(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,setImmediate){(function (){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.async = {})));
}(this, (function (exports) { 'use strict';

    /**
     * Creates a continuation function with some arguments already applied.
     *
     * Useful as a shorthand when combined with other control flow functions. Any
     * arguments passed to the returned function are added to the arguments
     * originally passed to apply.
     *
     * @name apply
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {Function} fn - The function you want to eventually apply all
     * arguments to. Invokes with (arguments...).
     * @param {...*} arguments... - Any number of arguments to automatically apply
     * when the continuation is called.
     * @returns {Function} the partially-applied function
     * @example
     *
     * // using apply
     * async.parallel([
     *     async.apply(fs.writeFile, 'testfile1', 'test1'),
     *     async.apply(fs.writeFile, 'testfile2', 'test2')
     * ]);
     *
     *
     * // the same process without using apply
     * async.parallel([
     *     function(callback) {
     *         fs.writeFile('testfile1', 'test1', callback);
     *     },
     *     function(callback) {
     *         fs.writeFile('testfile2', 'test2', callback);
     *     }
     * ]);
     *
     * // It's possible to pass any number of additional arguments when calling the
     * // continuation:
     *
     * node> var fn = async.apply(sys.puts, 'one');
     * node> fn('two', 'three');
     * one
     * two
     * three
     */
    function apply(fn, ...args) {
        return (...callArgs) => fn(...args,...callArgs);
    }

    function initialParams (fn) {
        return function (...args/*, callback*/) {
            var callback = args.pop();
            return fn.call(this, args, callback);
        };
    }

    /* istanbul ignore file */

    var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
    var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

    function fallback(fn) {
        setTimeout(fn, 0);
    }

    function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
    }

    var _defer;

    if (hasQueueMicrotask) {
        _defer = queueMicrotask;
    } else if (hasSetImmediate) {
        _defer = setImmediate;
    } else if (hasNextTick) {
        _defer = process.nextTick;
    } else {
        _defer = fallback;
    }

    var setImmediate$1 = wrap(_defer);

    /**
     * Take a sync function and make it async, passing its return value to a
     * callback. This is useful for plugging sync functions into a waterfall,
     * series, or other async functions. Any arguments passed to the generated
     * function will be passed to the wrapped function (except for the final
     * callback argument). Errors thrown will be passed to the callback.
     *
     * If the function passed to `asyncify` returns a Promise, that promises's
     * resolved/rejected state will be used to call the callback, rather than simply
     * the synchronous return value.
     *
     * This also means you can asyncify ES2017 `async` functions.
     *
     * @name asyncify
     * @static
     * @memberOf module:Utils
     * @method
     * @alias wrapSync
     * @category Util
     * @param {Function} func - The synchronous function, or Promise-returning
     * function to convert to an {@link AsyncFunction}.
     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
     * invoked with `(args..., callback)`.
     * @example
     *
     * // passing a regular synchronous function
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(JSON.parse),
     *     function (data, next) {
     *         // data is the result of parsing the text.
     *         // If there was a parsing error, it would have been caught.
     *     }
     * ], callback);
     *
     * // passing a function returning a promise
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(function (contents) {
     *         return db.model.create(contents);
     *     }),
     *     function (model, next) {
     *         // `model` is the instantiated model object.
     *         // If there was an error, this function would be skipped.
     *     }
     * ], callback);
     *
     * // es2017 example, though `asyncify` is not needed if your JS environment
     * // supports async functions out of the box
     * var q = async.queue(async.asyncify(async function(file) {
     *     var intermediateStep = await processFile(file);
     *     return await somePromise(intermediateStep)
     * }));
     *
     * q.push(files);
     */
    function asyncify(func) {
        if (isAsync(func)) {
            return function (...args/*, callback*/) {
                const callback = args.pop();
                const promise = func.apply(this, args);
                return handlePromise(promise, callback)
            }
        }

        return initialParams(function (args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (result && typeof result.then === 'function') {
                return handlePromise(result, callback)
            } else {
                callback(null, result);
            }
        });
    }

    function handlePromise(promise, callback) {
        return promise.then(value => {
            invokeCallback(callback, null, value);
        }, err => {
            invokeCallback(callback, err && err.message ? err : new Error(err));
        });
    }

    function invokeCallback(callback, error, value) {
        try {
            callback(error, value);
        } catch (err) {
            setImmediate$1(e => { throw e }, err);
        }
    }

    function isAsync(fn) {
        return fn[Symbol.toStringTag] === 'AsyncFunction';
    }

    function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === 'AsyncGenerator';
    }

    function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === 'function';
    }

    function wrapAsync(asyncFn) {
        if (typeof asyncFn !== 'function') throw new Error('expected a function')
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }

    // conditionally promisify a function.
    // only return a promise if a callback is omitted
    function awaitify (asyncFn, arity = asyncFn.length) {
        if (!arity) throw new Error('arity is undefined')
        function awaitable (...args) {
            if (typeof args[arity - 1] === 'function') {
                return asyncFn.apply(this, args)
            }

            return new Promise((resolve, reject) => {
                args[arity - 1] = (err, ...cbArgs) => {
                    if (err) return reject(err)
                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
                };
                asyncFn.apply(this, args);
            })
        }

        return awaitable
    }

    function applyEach (eachfn) {
        return function applyEach(fns, ...callArgs) {
            const go = awaitify(function (callback) {
                var that = this;
                return eachfn(fns, (fn, cb) => {
                    wrapAsync(fn).apply(that, callArgs.concat(cb));
                }, callback);
            });
            return go;
        };
    }

    function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);

        return eachfn(arr, (value, _, iterCb) => {
            var index = counter++;
            _iteratee(value, (err, v) => {
                results[index] = v;
                iterCb(err);
            });
        }, err => {
            callback(err, results);
        });
    }

    function isArrayLike(value) {
        return value &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            value.length % 1 === 0;
    }

    // A temporary value used to identify if the loop should be broken.
    // See #1064, #1293
    const breakLoop = {};

    function once(fn) {
        function wrapper (...args) {
            if (fn === null) return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper
    }

    function getIterator (coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }

    function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
            return ++i < len ? {value: coll[i], key: i} : null;
        }
    }

    function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
            var item = iterator.next();
            if (item.done)
                return null;
            i++;
            return {value: item.value, key: i};
        }
    }

    function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
            var key = okeys[++i];
            return i < len ? {value: obj[key], key} : null;
        };
    }

    function createIterator(coll) {
        if (isArrayLike(coll)) {
            return createArrayIterator(coll);
        }

        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }

    function onlyOnce(fn) {
        return function (...args) {
            if (fn === null) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        };
    }

    // for async generators
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;

        function replenish() {
            //console.log('replenish')
            if (running >= limit || awaiting || done) return
            //console.log('replenish awaiting')
            awaiting = true;
            generator.next().then(({value, done: iterDone}) => {
                //console.log('got value', value)
                if (canceled || done) return
                awaiting = false;
                if (iterDone) {
                    done = true;
                    if (running <= 0) {
                        //console.log('done nextCb')
                        callback(null);
                    }
                    return;
                }
                running++;
                iteratee(value, idx, iterateeCallback);
                idx++;
                replenish();
            }).catch(handleError);
        }

        function iterateeCallback(err, result) {
            //console.log('iterateeCallback')
            running -= 1;
            if (canceled) return
            if (err) return handleError(err)

            if (err === false) {
                done = true;
                canceled = true;
                return
            }

            if (result === breakLoop || (done && running <= 0)) {
                done = true;
                //console.log('done iterCb')
                return callback(null);
            }
            replenish();
        }

        function handleError(err) {
            if (canceled) return
            awaiting = false;
            done = true;
            callback(err);
        }

        replenish();
    }

    var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
            callback = once(callback);
            if (limit <= 0) {
                throw new RangeError('concurrency limit cannot be less than 1')
            }
            if (!obj) {
                return callback(null);
            }
            if (isAsyncGenerator(obj)) {
                return asyncEachOfLimit(obj, limit, iteratee, callback)
            }
            if (isAsyncIterable(obj)) {
                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
            }
            var nextElem = createIterator(obj);
            var done = false;
            var canceled = false;
            var running = 0;
            var looping = false;

            function iterateeCallback(err, value) {
                if (canceled) return
                running -= 1;
                if (err) {
                    done = true;
                    callback(err);
                }
                else if (err === false) {
                    done = true;
                    canceled = true;
                }
                else if (value === breakLoop || (done && running <= 0)) {
                    done = true;
                    return callback(null);
                }
                else if (!looping) {
                    replenish();
                }
            }

            function replenish () {
                looping = true;
                while (running < limit && !done) {
                    var elem = nextElem();
                    if (elem === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
                looping = false;
            }

            replenish();
        };
    };

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name eachOfLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`. The `key` is the item's key, or index in the case of an
     * array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }

    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);

    // eachOf implementation optimized for array-likes
    function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index = 0,
            completed = 0,
            {length} = coll,
            canceled = false;
        if (length === 0) {
            callback(null);
        }

        function iteratorCallback(err, value) {
            if (err === false) {
                canceled = true;
            }
            if (canceled === true) return
            if (err) {
                callback(err);
            } else if ((++completed === length) || value === breakLoop) {
                callback(null);
            }
        }

        for (; index < length; index++) {
            iteratee(coll[index], index, onlyOnce(iteratorCallback));
        }
    }

    // a generic version of eachOf which can handle array, object, and iterator cases.
    function eachOfGeneric (coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
    }

    /**
     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
     * to the iteratee.
     *
     * @name eachOf
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEachOf
     * @category Collection
     * @see [async.each]{@link module:Collections.each}
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each
     * item in `coll`.
     * The `key` is the item's key, or index in the case of an array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dev.json is a file containing a valid json object config for dev environment
     * // dev.json is a file containing a valid json object config for test environment
     * // prod.json is a file containing a valid json object config for prod environment
     * // invalid.json is a file with a malformed json object
     *
     * let configs = {}; //global variable
     * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
     * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
     *
     * // asynchronous function that reads a json file and parses the contents as json object
     * function parseFile(file, key, callback) {
     *     fs.readFile(file, "utf8", function(err, data) {
     *         if (err) return calback(err);
     *         try {
     *             configs[key] = JSON.parse(data);
     *         } catch (e) {
     *             return callback(e);
     *         }
     *         callback();
     *     });
     * }
     *
     * // Using callbacks
     * async.forEachOf(validConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *         // JSON parse error exception
     *     } else {
     *         console.log(configs);
     *     }
     * });
     *
     * // Using Promises
     * async.forEachOf(validConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     *     // configs is now a map of JSON data, e.g.
     *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     * }).catch( err => {
     *     console.error(err);
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     * }).catch( err => {
     *     console.error(err);
     *     // JSON parse error exception
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.forEachOf(validConfigFileMap, parseFile);
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * //Error handing
     * async () => {
     *     try {
     *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
     *         console.log(configs);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // JSON parse error exception
     *     }
     * }
     *
     */
    function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }

    var eachOf$1 = awaitify(eachOf, 3);

    /**
     * Produces a new collection of values by mapping each value in `coll` through
     * the `iteratee` function. The `iteratee` is called with an item from `coll`
     * and a callback for when it has finished processing. Each of these callback
     * takes 2 arguments: an `error`, and the transformed item from `coll`. If
     * `iteratee` passes an error to its callback, the main `callback` (for the
     * `map` function) is immediately called with the error.
     *
     * Note, that since this function applies the `iteratee` to each item in
     * parallel, there is no guarantee that the `iteratee` functions will complete
     * in order. However, the results array will be in the same order as the
     * original `coll`.
     *
     * If `map` is passed an Object, the results will be an Array.  The results
     * will roughly be in the order of the original Objects' keys (but this can
     * vary across JavaScript engines).
     *
     * @name map
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an Array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.map(fileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(results);
     *     }
     * });
     *
     * // Using Promises
     * async.map(fileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now an array of the file size in bytes for each file, e.g.
     *     // [ 1000, 2000, 3000]
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.map(fileList, getFileSizeInBytes);
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.map(withMissingFileList, getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function map (coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback)
    }
    var map$1 = awaitify(map, 3);

    /**
     * Applies the provided arguments to each function in the array, calling
     * `callback` after all functions have completed. If you only provide the first
     * argument, `fns`, then it will return a function which lets you pass in the
     * arguments as if it were a single function call. If more arguments are
     * provided, `callback` is required while `args` is still optional. The results
     * for each of the applied async functions are passed to the final callback
     * as an array.
     *
     * @name applyEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
     * to all call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - Returns a function that takes no args other than
     * an optional callback, that is the result of applying the `args` to each
     * of the functions.
     * @example
     *
     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
     *
     * appliedFn((err, results) => {
     *     // results[0] is the results for `enableSearch`
     *     // results[1] is the results for `updateSchema`
     * });
     *
     * // partial application example:
     * async.each(
     *     buckets,
     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
     *     callback
     * );
     */
    var applyEach$1 = applyEach(map$1);

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
     *
     * @name eachOfSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback)
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);

    /**
     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
     *
     * @name mapSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapSeries (coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
    }
    var mapSeries$1 = awaitify(mapSeries, 3);

    /**
     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
     *
     * @name applyEachSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.applyEach]{@link module:ControlFlow.applyEach}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
     * call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - A function, that when called, is the result of
     * appling the `args` to the list of functions.  It takes no args, other than
     * a callback.
     */
    var applyEachSeries = applyEach(mapSeries$1);

    const PROMISE_SYMBOL = Symbol('promiseCallback');

    function promiseCallback () {
        let resolve, reject;
        function callback (err, ...args) {
            if (err) return reject(err)
            resolve(args.length > 1 ? args : args[0]);
        }

        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
            resolve = res,
            reject = rej;
        });

        return callback
    }

    /**
     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
     * their requirements. Each function can optionally depend on other functions
     * being completed first, and each function is run as soon as its requirements
     * are satisfied.
     *
     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
     * will stop. Further tasks will not execute (so any other functions depending
     * on it will not run), and the main `callback` is immediately called with the
     * error.
     *
     * {@link AsyncFunction}s also receive an object containing the results of functions which
     * have completed so far as the first argument, if they have dependencies. If a
     * task function has no dependencies, it will only be passed a callback.
     *
     * @name auto
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Object} tasks - An object. Each of its properties is either a
     * function or an array of requirements, with the {@link AsyncFunction} itself the last item
     * in the array. The object's key of a property serves as the name of the task
     * defined by that property, i.e. can be used when specifying requirements for
     * other tasks. The function receives one or two arguments:
     * * a `results` object, containing the results of the previously executed
     *   functions, only passed if the task has any dependencies,
     * * a `callback(err, result)` function, which must be called when finished,
     *   passing an `error` (which can be `null`) and the result of the function's
     *   execution.
     * @param {number} [concurrency=Infinity] - An optional `integer` for
     * determining the maximum number of tasks that can be run in parallel. By
     * default, as many as possible.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback. Results are always returned; however, if an
     * error occurs, no further `tasks` will be performed, and the results object
     * will only contain partial results. Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     * @example
     *
     * //Using Callbacks
     * async.auto({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }, function(err, results) {
     *     if (err) {
     *         console.log('err = ', err);
     *     }
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * });
     *
     * //Using Promises
     * async.auto({
     *     get_data: function(callback) {
     *         console.log('in get_data');
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         console.log('in make_folder');
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }).then(results => {
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * }).catch(err => {
     *     console.log('err = ', err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.auto({
     *             get_data: function(callback) {
     *                 // async code to get some data
     *                 callback(null, 'data', 'converted to array');
     *             },
     *             make_folder: function(callback) {
     *                 // async code to create a directory to store a file in
     *                 // this is run at the same time as getting the data
     *                 callback(null, 'folder');
     *             },
     *             write_file: ['get_data', 'make_folder', function(results, callback) {
     *                 // once there is some data and the directory exists,
     *                 // write the data to a file in the directory
     *                 callback(null, 'filename');
     *             }],
     *             email_link: ['write_file', function(results, callback) {
     *                 // once the file is written let's email a link to it...
     *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *             }]
     *         });
     *         console.log('results = ', results);
     *         // results = {
     *         //     get_data: ['data', 'converted to array']
     *         //     make_folder; 'folder',
     *         //     write_file: 'filename'
     *         //     email_link: { file: 'filename', email: 'user@example.com' }
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== 'number') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = numTasks;
        }

        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;

        var listeners = Object.create(null);

        var readyTasks = [];

        // for cycle detection:
        var readyToCheck = []; // tasks that have been identified as reachable
        // without the possibility of returning to an ancestor task
        var uncheckedDependencies = {};

        Object.keys(tasks).forEach(key => {
            var task = tasks[key];
            if (!Array.isArray(task)) {
                // no dependencies
                enqueueTask(key, [task]);
                readyToCheck.push(key);
                return;
            }

            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
                enqueueTask(key, task);
                readyToCheck.push(key);
                return;
            }
            uncheckedDependencies[key] = remainingDependencies;

            dependencies.forEach(dependencyName => {
                if (!tasks[dependencyName]) {
                    throw new Error('async.auto task `' + key +
                        '` has a non-existent dependency `' +
                        dependencyName + '` in ' +
                        dependencies.join(', '));
                }
                addListener(dependencyName, () => {
                    remainingDependencies--;
                    if (remainingDependencies === 0) {
                        enqueueTask(key, task);
                    }
                });
            });
        });

        checkForDeadlocks();
        processQueue();

        function enqueueTask(key, task) {
            readyTasks.push(() => runTask(key, task));
        }

        function processQueue() {
            if (canceled) return
            if (readyTasks.length === 0 && runningTasks === 0) {
                return callback(null, results);
            }
            while(readyTasks.length && runningTasks < concurrency) {
                var run = readyTasks.shift();
                run();
            }

        }

        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
                taskListeners = listeners[taskName] = [];
            }

            taskListeners.push(fn);
        }

        function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            taskListeners.forEach(fn => fn());
            processQueue();
        }


        function runTask(key, task) {
            if (hasError) return;

            var taskCallback = onlyOnce((err, ...result) => {
                runningTasks--;
                if (err === false) {
                    canceled = true;
                    return
                }
                if (result.length < 2) {
                    [result] = result;
                }
                if (err) {
                    var safeResults = {};
                    Object.keys(results).forEach(rkey => {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[key] = result;
                    hasError = true;
                    listeners = Object.create(null);
                    if (canceled) return
                    callback(err, safeResults);
                } else {
                    results[key] = result;
                    taskComplete(key);
                }
            });

            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
                taskFn(results, taskCallback);
            } else {
                taskFn(taskCallback);
            }
        }

        function checkForDeadlocks() {
            // Kahn's algorithm
            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
                currentTask = readyToCheck.pop();
                counter++;
                getDependents(currentTask).forEach(dependent => {
                    if (--uncheckedDependencies[dependent] === 0) {
                        readyToCheck.push(dependent);
                    }
                });
            }

            if (counter !== numTasks) {
                throw new Error(
                    'async.auto cannot execute tasks due to a recursive dependency'
                );
            }
        }

        function getDependents(taskName) {
            var result = [];
            Object.keys(tasks).forEach(key => {
                const task = tasks[key];
                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                    result.push(key);
                }
            });
            return result;
        }

        return callback[PROMISE_SYMBOL]
    }

    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

    function parseParams(func) {
        const src = func.toString().replace(STRIP_COMMENTS, '');
        let match = src.match(FN_ARGS);
        if (!match) {
            match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
        let [, args] = match;
        return args
            .replace(/\s/g, '')
            .split(FN_ARG_SPLIT)
            .map((arg) => arg.replace(FN_ARG, '').trim());
    }

    /**
     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
     * tasks are specified as parameters to the function, after the usual callback
     * parameter, with the parameter names matching the names of the tasks it
     * depends on. This can provide even more readable task graphs which can be
     * easier to maintain.
     *
     * If a final callback is specified, the task results are similarly injected,
     * specified as named parameters after the initial error parameter.
     *
     * The autoInject function is purely syntactic sugar and its semantics are
     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
     *
     * @name autoInject
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.auto]{@link module:ControlFlow.auto}
     * @category Control Flow
     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
     * the form 'func([dependencies...], callback). The object's key of a property
     * serves as the name of the task defined by that property, i.e. can be used
     * when specifying requirements for other tasks.
     * * The `callback` parameter is a `callback(err, result)` which must be called
     *   when finished, passing an `error` (which can be `null`) and the result of
     *   the function's execution. The remaining parameters name other tasks on
     *   which the task is dependent, and the results from those tasks are the
     *   arguments of those parameters.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback, and a `results` object with any completed
     * task results, similar to `auto`.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * //  The example from `auto` can be rewritten as follows:
     * async.autoInject({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: function(get_data, make_folder, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     },
     *     email_link: function(write_file, callback) {
     *         // once the file is written let's email a link to it...
     *         // write_file contains the filename returned by write_file.
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     *
     * // If you are using a JS minifier that mangles parameter names, `autoInject`
     * // will not work with plain functions, since the parameter names will be
     * // collapsed to a single letter identifier.  To work around this, you can
     * // explicitly specify the names of the parameters your task function needs
     * // in an array, similar to Angular.js dependency injection.
     *
     * // This still has an advantage over plain `auto`, since the results a task
     * // depends on are still spread into arguments.
     * async.autoInject({
     *     //...
     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(write_file, callback) {
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }]
     *     //...
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     */
    function autoInject(tasks, callback) {
        var newTasks = {};

        Object.keys(tasks).forEach(key => {
            var taskFn = tasks[key];
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps =
                (!fnIsAsync && taskFn.length === 1) ||
                (fnIsAsync && taskFn.length === 0);

            if (Array.isArray(taskFn)) {
                params = [...taskFn];
                taskFn = params.pop();

                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
                // no dependencies, use the function as-is
                newTasks[key] = taskFn;
            } else {
                params = parseParams(taskFn);
                if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                    throw new Error("autoInject task functions require explicit parameters.");
                }

                // remove callback param
                if (!fnIsAsync) params.pop();

                newTasks[key] = params.concat(newTask);
            }

            function newTask(results, taskCb) {
                var newArgs = params.map(name => results[name]);
                newArgs.push(taskCb);
                wrapAsync(taskFn)(...newArgs);
            }
        });

        return auto(newTasks, callback);
    }

    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
    // used for queues. This implementation assumes that the node provided by the user can be modified
    // to adjust the next and last properties. We implement only the minimal functionality
    // for queue support.
    class DLL {
        constructor() {
            this.head = this.tail = null;
            this.length = 0;
        }

        removeLink(node) {
            if (node.prev) node.prev.next = node.next;
            else this.head = node.next;
            if (node.next) node.next.prev = node.prev;
            else this.tail = node.prev;

            node.prev = node.next = null;
            this.length -= 1;
            return node;
        }

        empty () {
            while(this.head) this.shift();
            return this;
        }

        insertAfter(node, newNode) {
            newNode.prev = node;
            newNode.next = node.next;
            if (node.next) node.next.prev = newNode;
            else this.tail = newNode;
            node.next = newNode;
            this.length += 1;
        }

        insertBefore(node, newNode) {
            newNode.prev = node.prev;
            newNode.next = node;
            if (node.prev) node.prev.next = newNode;
            else this.head = newNode;
            node.prev = newNode;
            this.length += 1;
        }

        unshift(node) {
            if (this.head) this.insertBefore(this.head, node);
            else setInitial(this, node);
        }

        push(node) {
            if (this.tail) this.insertAfter(this.tail, node);
            else setInitial(this, node);
        }

        shift() {
            return this.head && this.removeLink(this.head);
        }

        pop() {
            return this.tail && this.removeLink(this.tail);
        }

        toArray() {
            return [...this]
        }

        *[Symbol.iterator] () {
            var cur = this.head;
            while (cur) {
                yield cur.data;
                cur = cur.next;
            }
        }

        remove (testFn) {
            var curr = this.head;
            while(curr) {
                var {next} = curr;
                if (testFn(curr)) {
                    this.removeLink(curr);
                }
                curr = next;
            }
            return this;
        }
    }

    function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
    }

    function queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new RangeError('Concurrency must not be zero');
        }

        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
            error: [],
            drain: [],
            saturated: [],
            unsaturated: [],
            empty: []
        };

        function on (event, handler) {
            events[event].push(handler);
        }

        function once (event, handler) {
            const handleAndRemove = (...args) => {
                off(event, handleAndRemove);
                handler(...args);
            };
            events[event].push(handleAndRemove);
        }

        function off (event, handler) {
            if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
            if (!handler) return events[event] = []
            events[event] = events[event].filter(ev => ev !== handler);
        }

        function trigger (event, ...args) {
            events[event].forEach(handler => handler(...args));
        }

        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
            if (callback != null && typeof callback !== 'function') {
                throw new Error('task callback must be a function');
            }
            q.started = true;

            var res, rej;
            function promiseCallback (err, ...args) {
                // we don't care about the error, let the global error handler
                // deal with it
                if (err) return rejectOnError ? rej(err) : res()
                if (args.length <= 1) return res(args[0])
                res(args);
            }

            var item = {
                data,
                callback: rejectOnError ?
                    promiseCallback :
                    (callback || promiseCallback)
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }

            if (!processingScheduled) {
                processingScheduled = true;
                setImmediate$1(() => {
                    processingScheduled = false;
                    q.process();
                });
            }

            if (rejectOnError || !callback) {
                return new Promise((resolve, reject) => {
                    res = resolve;
                    rej = reject;
                })
            }
        }

        function _createCB(tasks) {
            return function (err, ...args) {
                numRunning -= 1;

                for (var i = 0, l = tasks.length; i < l; i++) {
                    var task = tasks[i];

                    var index = workersList.indexOf(task);
                    if (index === 0) {
                        workersList.shift();
                    } else if (index > 0) {
                        workersList.splice(index, 1);
                    }

                    task.callback(err, ...args);

                    if (err != null) {
                        trigger('error', err, task.data);
                    }
                }

                if (numRunning <= (q.concurrency - q.buffer) ) {
                    trigger('unsaturated');
                }

                if (q.idle()) {
                    trigger('drain');
                }
                q.process();
            };
        }

        function _maybeDrain(data) {
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                setImmediate$1(() => trigger('drain'));
                return true
            }
            return false
        }

        const eventMethod = (name) => (handler) => {
            if (!handler) {
                return new Promise((resolve, reject) => {
                    once(name, (err, data) => {
                        if (err) return reject(err)
                        resolve(data);
                    });
                })
            }
            off(name);
            on(name, handler);

        };

        var isProcessing = false;
        var q = {
            _tasks: new DLL(),
            *[Symbol.iterator] () {
                yield* q._tasks[Symbol.iterator]();
            },
            concurrency,
            payload,
            buffer: concurrency / 4,
            started: false,
            paused: false,
            push (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, false, callback))
                }
                return _insert(data, false, false, callback);
            },
            pushAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, true, callback))
                }
                return _insert(data, false, true, callback);
            },
            kill () {
                off();
                q._tasks.empty();
            },
            unshift (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, false, callback))
                }
                return _insert(data, true, false, callback);
            },
            unshiftAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, true, callback))
                }
                return _insert(data, true, true, callback);
            },
            remove (testFn) {
                q._tasks.remove(testFn);
            },
            process () {
                // Avoid trying to start too many processing operations. This can occur
                // when callbacks resolve synchronously (#1267).
                if (isProcessing) {
                    return;
                }
                isProcessing = true;
                while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                    var tasks = [], data = [];
                    var l = q._tasks.length;
                    if (q.payload) l = Math.min(l, q.payload);
                    for (var i = 0; i < l; i++) {
                        var node = q._tasks.shift();
                        tasks.push(node);
                        workersList.push(node);
                        data.push(node.data);
                    }

                    numRunning += 1;

                    if (q._tasks.length === 0) {
                        trigger('empty');
                    }

                    if (numRunning === q.concurrency) {
                        trigger('saturated');
                    }

                    var cb = onlyOnce(_createCB(tasks));
                    _worker(data, cb);
                }
                isProcessing = false;
            },
            length () {
                return q._tasks.length;
            },
            running () {
                return numRunning;
            },
            workersList () {
                return workersList;
            },
            idle() {
                return q._tasks.length + numRunning === 0;
            },
            pause () {
                q.paused = true;
            },
            resume () {
                if (q.paused === false) { return; }
                q.paused = false;
                setImmediate$1(q.process);
            }
        };
        // define these as fixed properties, so people get useful errors when updating
        Object.defineProperties(q, {
            saturated: {
                writable: false,
                value: eventMethod('saturated')
            },
            unsaturated: {
                writable: false,
                value: eventMethod('unsaturated')
            },
            empty: {
                writable: false,
                value: eventMethod('empty')
            },
            drain: {
                writable: false,
                value: eventMethod('drain')
            },
            error: {
                writable: false,
                value: eventMethod('error')
            },
        });
        return q;
    }

    /**
     * Creates a `cargo` object with the specified payload. Tasks added to the
     * cargo will be processed altogether (up to the `payload` limit). If the
     * `worker` is in progress, the task is queued until it becomes available. Once
     * the `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, cargo passes an array of tasks to a single worker, repeating
     * when the worker is finished.
     *
     * @name cargo
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargo and inner queue.
     * @example
     *
     * // create a cargo object with payload 2
     * var cargo = async.cargo(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2);
     *
     * // add some items
     * cargo.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargo.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * await cargo.push({name: 'baz'});
     * console.log('finished processing baz');
     */
    function cargo(worker, payload) {
        return queue(worker, 1, payload);
    }

    /**
     * Creates a `cargoQueue` object with the specified payload. Tasks added to the
     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
     * If the all `workers` are in progress, the task is queued until one becomes available. Once
     * a `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
     * the cargoQueue passes an array of tasks to multiple parallel workers.
     *
     * @name cargoQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @see [async.cargo]{@link module:ControlFLow.cargo}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargoQueue and inner queue.
     * @example
     *
     * // create a cargoQueue object with payload 2 and concurrency 2
     * var cargoQueue = async.cargoQueue(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2, 2);
     *
     * // add some items
     * cargoQueue.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargoQueue.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * cargoQueue.push({name: 'baz'}, function(err) {
     *     console.log('finished processing baz');
     * });
     * cargoQueue.push({name: 'boo'}, function(err) {
     *     console.log('finished processing boo');
     * });
     */
    function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
    }

    /**
     * Reduces `coll` into a single value using an async `iteratee` to return each
     * successive step. `memo` is the initial state of the reduction. This function
     * only operates in series.
     *
     * For performance reasons, it may make sense to split a call to this function
     * into a parallel map, and then use the normal `Array.prototype.reduce` on the
     * results. This function is for situations where each step in the reduction
     * needs to be async; if you can get the data before reducing it, then it's
     * probably a good idea to do so.
     *
     * @name reduce
     * @static
     * @memberOf module:Collections
     * @method
     * @alias inject
     * @alias foldl
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];
     *
     * // asynchronous function that computes the file size in bytes
     * // file size is added to the memoized value, then returned
     * function getFileSizeInBytes(memo, file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, memo + stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.reduce(fileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // 6000
     *     // which is the sum of the file sizes of the three files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
            _iteratee(memo, x, (err, v) => {
                memo = v;
                iterCb(err);
            });
        }, err => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);

    /**
     * Version of the compose function that is more natural to read. Each function
     * consumes the return value of the previous function. It is the equivalent of
     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name seq
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.compose]{@link module:ControlFlow.compose}
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} a function that composes the `functions` in order
     * @example
     *
     * // Requires lodash (or underscore), express3 and dresende's orm2.
     * // Part of an app, that fetches cats of the logged user.
     * // This example uses `seq` function to avoid overnesting and error
     * // handling clutter.
     * app.get('/cats', function(request, response) {
     *     var User = request.models.User;
     *     async.seq(
     *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
     *         function(user, fn) {
     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
     *         }
     *     )(req.session.user_id, function (err, cats) {
     *         if (err) {
     *             console.error(err);
     *             response.json({ status: 'error', message: err.message });
     *         } else {
     *             response.json({ status: 'ok', message: 'Cats found', data: cats });
     *         }
     *     });
     * });
     */
    function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function (...args) {
            var that = this;

            var cb = args[args.length - 1];
            if (typeof cb == 'function') {
                args.pop();
            } else {
                cb = promiseCallback();
            }

            reduce$1(_functions, args, (newargs, fn, iterCb) => {
                fn.apply(that, newargs.concat((err, ...nextargs) => {
                    iterCb(err, nextargs);
                }));
            },
            (err, results) => cb(err, ...results));

            return cb[PROMISE_SYMBOL]
        };
    }

    /**
     * Creates a function which is a composition of the passed asynchronous
     * functions. Each function consumes the return value of the function that
     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
     *
     * If the last argument to the composed function is not a function, a promise
     * is returned when you call it.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name compose
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} an asynchronous function that is the composed
     * asynchronous `functions`
     * @example
     *
     * function add1(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n + 1);
     *     }, 10);
     * }
     *
     * function mul3(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n * 3);
     *     }, 10);
     * }
     *
     * var add1mul3 = async.compose(mul3, add1);
     * add1mul3(4, function (err, result) {
     *     // result now equals 15
     * });
     */
    function compose(...args) {
        return seq(...args.reverse());
    }

    /**
     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
     *
     * @name mapLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapLimit (coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)
    }
    var mapLimit$1 = awaitify(mapLimit, 4);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
     *
     * @name concatLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapLimit
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, ...args) => {
                if (err) return iterCb(err);
                return iterCb(err, args);
            });
        }, (err, mapResults) => {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    result = result.concat(...mapResults[i]);
                }
            }

            return callback(err, result);
        });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);

    /**
     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
     * the concatenated list. The `iteratee`s are called in parallel, and the
     * results are concatenated as they return. The results array will be returned in
     * the original order of `coll` passed to the `iteratee` function.
     *
     * @name concat
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @alias flatMap
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * let directoryList = ['dir1','dir2','dir3'];
     * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];
     *
     * // Using callbacks
     * async.concat(directoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *    }
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *        // [ Error: ENOENT: no such file or directory ]
     *        // since dir4 does not exist
     *    } else {
     *        console.log(results);
     *    }
     * });
     *
     * // Using Promises
     * async.concat(directoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     * }).catch(err => {
     *      console.log(err);
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     * }).catch(err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4 does not exist
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.concat(directoryList, fs.readdir);
     *         console.log(results);
     *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *     } catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.concat(withMissingDirectoryList, fs.readdir);
     *         console.log(results);
     *     } catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4 does not exist
     *     }
     * }
     *
     */
    function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback)
    }
    var concat$1 = awaitify(concat, 3);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
     *
     * @name concatSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapSeries
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
     * The iteratee should complete with an array an array of results.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback)
    }
    var concatSeries$1 = awaitify(concatSeries, 3);

    /**
     * Returns a function that when called, calls-back with the values provided.
     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
     * [`auto`]{@link module:ControlFlow.auto}.
     *
     * @name constant
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {...*} arguments... - Any number of arguments to automatically invoke
     * callback with.
     * @returns {AsyncFunction} Returns a function that when invoked, automatically
     * invokes the callback with the previous given arguments.
     * @example
     *
     * async.waterfall([
     *     async.constant(42),
     *     function (value, next) {
     *         // value === 42
     *     },
     *     //...
     * ], callback);
     *
     * async.waterfall([
     *     async.constant(filename, "utf8"),
     *     fs.readFile,
     *     function (fileData, next) {
     *         //...
     *     }
     *     //...
     * ], callback);
     *
     * async.auto({
     *     hostname: async.constant("https://server.net/"),
     *     port: findFreePort,
     *     launchServer: ["hostname", "port", function (options, cb) {
     *         startServer(options, cb);
     *     }],
     *     //...
     * }, callback);
     */
    function constant(...args) {
        return function (...ignoredArgs/*, callback*/) {
            var callback = ignoredArgs.pop();
            return callback(null, ...args);
        };
    }

    function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
            var testPassed = false;
            var testResult;
            const iteratee = wrapAsync(_iteratee);
            eachfn(arr, (value, _, callback) => {
                iteratee(value, (err, result) => {
                    if (err || err === false) return callback(err);

                    if (check(result) && !testResult) {
                        testPassed = true;
                        testResult = getResult(true, value);
                        return callback(null, breakLoop);
                    }
                    callback();
                });
            }, err => {
                if (err) return cb(err);
                cb(null, testPassed ? testResult : getResult(false));
            });
        };
    }

    /**
     * Returns the first value in `coll` that passes an async truth test. The
     * `iteratee` is applied in parallel, meaning the first iteratee to return
     * `true` will fire the detect `callback` with that result. That means the
     * result might not be the first item in the original `coll` (in terms of order)
     * that passes the test.

     * If order within the original `coll` is important, then look at
     * [`detectSeries`]{@link module:Collections.detectSeries}.
     *
     * @name detect
     * @static
     * @memberOf module:Collections
     * @method
     * @alias find
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // dir1/file1.txt
     *        // result now equals the first file in the list that exists
     *    }
     *);
     *
     * // Using Promises
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)
     * .then(result => {
     *     console.log(result);
     *     // dir1/file1.txt
     *     // result now equals the first file in the list that exists
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);
     *         console.log(result);
     *         // dir1/file1.txt
     *         // result now equals the file in the list that exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function detect(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
    }
    var detect$1 = awaitify(detect, 3);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name detectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findLimit
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns a Promise if no callback is passed
     */
    function detectLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var detectLimit$1 = awaitify(detectLimit, 4);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
     *
     * @name detectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findSeries
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns a Promise if no callback is passed
     */
    function detectSeries(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)
    }

    var detectSeries$1 = awaitify(detectSeries, 3);

    function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
            /* istanbul ignore else */
            if (typeof console === 'object') {
                /* istanbul ignore else */
                if (err) {
                    /* istanbul ignore else */
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) { /* istanbul ignore else */
                    resultArgs.forEach(x => console[name](x));
                }
            }
        })
    }

    /**
     * Logs the result of an [`async` function]{@link AsyncFunction} to the
     * `console` using `console.dir` to display the properties of the resulting object.
     * Only works in Node.js or in browsers that support `console.dir` and
     * `console.error` (such as FF and Chrome).
     * If multiple arguments are returned from the async function,
     * `console.dir` is called on each argument in order.
     *
     * @name dir
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, {hello: name});
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.dir(hello, 'world');
     * {hello: 'world'}
     */
    var dir = consoleFunc('dir');

    /**
     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
     * the order of operations, the arguments `test` and `iteratee` are switched.
     *
     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
     *
     * @name doWhilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - A function which is called each time `test`
     * passes. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`.
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped.
     * `callback` will be passed an error and any arguments passed to the final
     * `iteratee`'s callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;

        function next(err, ...args) {
            if (err) return callback(err);
            if (err === false) return;
            results = args;
            _test(...args, check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return check(null, true);
    }

    var doWhilst$1 = awaitify(doWhilst, 3);

    /**
     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
     * argument ordering differs from `until`.
     *
     * @name doUntil
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
            const cb = args.pop();
            _test(...args, (err, truth) => cb (err, !truth));
        }, callback);
    }

    function _withoutIndex(iteratee) {
        return (value, index, callback) => iteratee(value, callback);
    }

    /**
     * Applies the function `iteratee` to each item in `coll`, in parallel.
     * The `iteratee` is called with an item from the list, and a callback for when
     * it has finished. If the `iteratee` passes an error to its `callback`, the
     * main `callback` (for the `each` function) is immediately called with the
     * error.
     *
     * Note, that since this function applies `iteratee` to each item in parallel,
     * there is no guarantee that the iteratee functions will complete in order.
     *
     * @name each
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEach
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to
     * each item in `coll`. Invoked with (item, callback).
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOf`.
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
     * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
     *
     * // asynchronous function that deletes a file
     * const deleteFile = function(file, callback) {
     *     fs.unlink(file, callback);
     * };
     *
     * // Using callbacks
     * async.each(fileList, deleteFile, function(err) {
     *     if( err ) {
     *         console.log(err);
     *     } else {
     *         console.log('All files have been deleted successfully');
     *     }
     * });
     *
     * // Error Handling
     * async.each(withMissingFileList, deleteFile, function(err){
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using Promises
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         await async.each(files, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         await async.each(withMissingFileList, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4/file2.txt does not exist
     *         // dir1/file1.txt could have been deleted
     *     }
     * }
     *
     */
    function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }

    var each = awaitify(eachLimit, 3);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
     *
     * @name eachLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfLimit`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$2 = awaitify(eachLimit$1, 4);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
     *
     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
     * in series and therefore the iteratee functions will complete in order.

     * @name eachSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfSeries`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback)
    }
    var eachSeries$1 = awaitify(eachSeries, 3);

    /**
     * Wrap an async function and ensure it calls its callback on a later tick of
     * the event loop.  If the function already calls its callback on a next tick,
     * no extra deferral is added. This is useful for preventing stack overflows
     * (`RangeError: Maximum call stack size exceeded`) and generally keeping
     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
     * contained. ES2017 `async` functions are returned as-is -- they are immune
     * to Zalgo's corrupting influences, as they always resolve on a later tick.
     *
     * @name ensureAsync
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - an async function, one that expects a node-style
     * callback as its last argument.
     * @returns {AsyncFunction} Returns a wrapped function with the exact same call
     * signature as the function passed in.
     * @example
     *
     * function sometimesAsync(arg, callback) {
     *     if (cache[arg]) {
     *         return callback(null, cache[arg]); // this would be synchronous!!
     *     } else {
     *         doSomeIO(arg, callback); // this IO would be asynchronous
     *     }
     * }
     *
     * // this has a risk of stack overflows if many results are cached in a row
     * async.mapSeries(args, sometimesAsync, done);
     *
     * // this will defer sometimesAsync's callback if necessary,
     * // preventing stack overflows
     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
     */
    function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function (...args/*, callback*/) {
            var callback = args.pop();
            var sync = true;
            args.push((...innerArgs) => {
                if (sync) {
                    setImmediate$1(() => callback(...innerArgs));
                } else {
                    callback(...innerArgs);
                }
            });
            fn.apply(this, args);
            sync = false;
        };
    }

    /**
     * Returns `true` if every element in `coll` satisfies an async test. If any
     * iteratee call returns `false`, the main `callback` is immediately called.
     *
     * @name every
     * @static
     * @memberOf module:Collections
     * @method
     * @alias all
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.every(fileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * });
     *
     * async.every(withMissingFileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * });
     *
     * // Using Promises
     * async.every(fileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.every(withMissingFileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.every(fileList, fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.every(withMissingFileList, fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since NOT every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function every(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
    }
    var every$1 = awaitify(every, 3);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
     *
     * @name everyLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everyLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var everyLimit$1 = awaitify(everyLimit, 4);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
     *
     * @name everySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in series.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everySeries(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var everySeries$1 = awaitify(everySeries, 3);

    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                truthValues[index] = !!v;
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
                if (truthValues[i]) results.push(arr[i]);
            }
            callback(null, results);
        });
    }

    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                if (err) return iterCb(err);
                if (v) {
                    results.push({index, value: x});
                }
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            callback(null, results
                .sort((a, b) => a.index - b.index)
                .map(v => v.value));
        });
    }

    function _filter(eachfn, coll, iteratee, callback) {
        var filter = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter(eachfn, coll, wrapAsync(iteratee), callback);
    }

    /**
     * Returns a new array of all the values in `coll` which pass an async truth
     * test. This operation is performed in parallel, but the results array will be
     * in the same order as the original.
     *
     * @name filter
     * @static
     * @memberOf module:Collections
     * @method
     * @alias select
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.filter(files, fileExists, function(err, results) {
     *    if(err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *        // results is now an array of the existing files
     *    }
     * });
     *
     * // Using Promises
     * async.filter(files, fileExists)
     * .then(results => {
     *     console.log(results);
     *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *     // results is now an array of the existing files
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.filter(files, fileExists);
     *         console.log(results);
     *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *         // results is now an array of the existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function filter (coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback)
    }
    var filter$1 = awaitify(filter, 3);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name filterLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     */
    function filterLimit (coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback)
    }
    var filterLimit$1 = awaitify(filterLimit, 4);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
     *
     * @name filterSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results)
     * @returns {Promise} a promise, if no callback provided
     */
    function filterSeries (coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback)
    }
    var filterSeries$1 = awaitify(filterSeries, 3);

    /**
     * Calls the asynchronous function `fn` with a callback parameter that allows it
     * to call itself again, in series, indefinitely.

     * If an error is passed to the callback then `errback` is called with the
     * error, and execution stops, otherwise it will never be called.
     *
     * @name forever
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} fn - an async function to call repeatedly.
     * Invoked with (next).
     * @param {Function} [errback] - when `fn` passes an error to it's callback,
     * this function will be called, and execution stops. Invoked with (err).
     * @returns {Promise} a promise that rejects if an error occurs and an errback
     * is not passed
     * @example
     *
     * async.forever(
     *     function(next) {
     *         // next is suitable for passing to things that need a callback(err [, whatever]);
     *         // it will result in this function being called again.
     *     },
     *     function(err) {
     *         // if next is called with a value in its first parameter, it will appear
     *         // in here as 'err', and execution will stop.
     *     }
     * );
     */
    function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));

        function next(err) {
            if (err) return done(err);
            if (err === false) return;
            task(next);
        }
        return next();
    }
    var forever$1 = awaitify(forever, 2);

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
     *
     * @name groupByLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, key) => {
                if (err) return iterCb(err);
                return iterCb(err, {key, val});
            });
        }, (err, mapResults) => {
            var result = {};
            // from MDN, handle object having an `hasOwnProperty` prop
            var {hasOwnProperty} = Object.prototype;

            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    var {key} = mapResults[i];
                    var {val} = mapResults[i];

                    if (hasOwnProperty.call(result, key)) {
                        result[key].push(val);
                    } else {
                        result[key] = [val];
                    }
                }
            }

            return callback(err, result);
        });
    }

    var groupByLimit$1 = awaitify(groupByLimit, 4);

    /**
     * Returns a new object, where each value corresponds to an array of items, from
     * `coll`, that returned the corresponding key. That is, the keys of the object
     * correspond to the values passed to the `iteratee` callback.
     *
     * Note: Since this function applies the `iteratee` to each item in parallel,
     * there is no guarantee that the `iteratee` functions will complete in order.
     * However, the values for each key in the `result` will be in the same order as
     * the original `coll`. For Objects, the values will roughly be in the order of
     * the original Objects' keys (but this can vary across JavaScript engines).
     *
     * @name groupBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const files = ['dir1/file1.txt','dir2','dir4']
     *
     * // asynchronous function that detects file type as none, file, or directory
     * function detectFile(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(null, 'none');
     *         }
     *         callback(null, stat.isDirectory() ? 'directory' : 'file');
     *     });
     * }
     *
     * //Using callbacks
     * async.groupBy(files, detectFile, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *	       console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     * });
     *
     * // Using Promises
     * async.groupBy(files, detectFile)
     * .then( result => {
     *     console.log(result);
     *     // {
     *     //     file: [ 'dir1/file1.txt' ],
     *     //     none: [ 'dir4' ],
     *     //     directory: [ 'dir2']
     *     // }
     *     // result is object containing the files grouped by type
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.groupBy(files, detectFile);
     *         console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function groupBy (coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback)
    }

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
     *
     * @name groupBySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whose
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupBySeries (coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback)
    }

    /**
     * Logs the result of an `async` function to the `console`. Only works in
     * Node.js or in browsers that support `console.log` and `console.error` (such
     * as FF and Chrome). If multiple arguments are returned from the async
     * function, `console.log` is called on each argument in order.
     *
     * @name log
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, 'hello ' + name);
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.log(hello, 'world');
     * 'hello world'
     */
    var log = consoleFunc('log');

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name mapValuesLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
            _iteratee(val, key, (err, result) => {
                if (err) return next(err);
                newObj[key] = result;
                next(err);
            });
        }, err => callback(err, newObj));
    }

    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);

    /**
     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
     *
     * Produces a new Object by mapping each value of `obj` through the `iteratee`
     * function. The `iteratee` is called each `value` and `key` from `obj` and a
     * callback for when it has finished processing. Each of these callbacks takes
     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
     * passes an error to its callback, the main `callback` (for the `mapValues`
     * function) is immediately called with the error.
     *
     * Note, the order of the keys in the result is not guaranteed.  The keys will
     * be roughly in the order they complete, (but this is very engine-specific)
     *
     * @name mapValues
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file3.txt'
     * };
     *
     * const withMissingFileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file4.txt'
     * };
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, key, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     * });
     *
     * // Error handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.mapValues(fileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // result is now a map of file size in bytes for each file, e.g.
     *     // {
     *     //     f1: 1000,
     *     //     f2: 2000,
     *     //     f3: 3000
     *     // }
     * }).catch (err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch (err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.mapValues(fileMap, getFileSizeInBytes);
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback)
    }

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
     *
     * @name mapValuesSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback)
    }

    /**
     * Caches the results of an async function. When creating a hash to store
     * function results against, the callback is omitted from the hash and an
     * optional hash function can be used.
     *
     * **Note: if the async function errs, the result will not be cached and
     * subsequent calls will call the wrapped function.**
     *
     * If no hash function is specified, the first argument is used as a hash key,
     * which may work reasonably if it is a string or a data type that converts to a
     * distinct string. Note that objects and arrays will not behave reasonably.
     * Neither will cases where the other arguments are significant. In such cases,
     * specify your own hash function.
     *
     * The cache of results is exposed as the `memo` property of the function
     * returned by `memoize`.
     *
     * @name memoize
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function to proxy and cache results from.
     * @param {Function} hasher - An optional function for generating a custom hash
     * for storing results. It has all the arguments applied to it apart from the
     * callback, and must be synchronous.
     * @returns {AsyncFunction} a memoized version of `fn`
     * @example
     *
     * var slow_fn = function(name, callback) {
     *     // do something
     *     callback(null, result);
     * };
     * var fn = async.memoize(slow_fn);
     *
     * // fn can now be used as if it were slow_fn
     * fn('some name', function() {
     *     // callback
     * });
     */
    function memoize(fn, hasher = v => v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
            var key = hasher(...args);
            if (key in memo) {
                setImmediate$1(() => callback(null, ...memo[key]));
            } else if (key in queues) {
                queues[key].push(callback);
            } else {
                queues[key] = [callback];
                _fn(...args, (err, ...resultArgs) => {
                    // #1465 don't memoize if an error occurred
                    if (!err) {
                        memo[key] = resultArgs;
                    }
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i](err, ...resultArgs);
                    }
                });
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    }

    /**
     * Calls `callback` on a later loop around the event loop. In Node.js this just
     * calls `process.nextTick`.  In the browser it will use `setImmediate` if
     * available, otherwise `setTimeout(callback, 0)`, which means other higher
     * priority events may precede the execution of `callback`.
     *
     * This is used internally for browser-compatibility purposes.
     *
     * @name nextTick
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.setImmediate]{@link module:Utils.setImmediate}
     * @category Util
     * @param {Function} callback - The function to call on a later loop around
     * the event loop. Invoked with (args...).
     * @param {...*} args... - any number of additional arguments to pass to the
     * callback on the next tick.
     * @example
     *
     * var call_order = [];
     * async.nextTick(function() {
     *     call_order.push('two');
     *     // call_order now equals ['one','two']
     * });
     * call_order.push('one');
     *
     * async.setImmediate(function (a, b, c) {
     *     // a, b, and c equal 1, 2, and 3
     * }, 1, 2, 3);
     */
    var _defer$1;

    if (hasNextTick) {
        _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
    } else {
        _defer$1 = fallback;
    }

    var nextTick = wrap(_defer$1);

    var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};

        eachfn(tasks, (task, key, taskCb) => {
            wrapAsync(task)((err, ...result) => {
                if (result.length < 2) {
                    [result] = result;
                }
                results[key] = result;
                taskCb(err);
            });
        }, err => callback(err, results));
    }, 3);

    /**
     * Run the `tasks` collection of functions in parallel, without waiting until
     * the previous function has completed. If any of the functions pass an error to
     * its callback, the main `callback` is immediately called with the value of the
     * error. Once the `tasks` have completed, the results are passed to the final
     * `callback` as an array.
     *
     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
     * parallel execution of code.  If your tasks do not use any timers or perform
     * any I/O, they will actually be executed in series.  Any synchronous setup
     * sections for each task will happen one after the other.  JavaScript remains
     * single-threaded.
     *
     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
     * execution of other tasks when a task fails.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     * results from {@link async.parallel}.
     *
     * @name parallel
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     *
     * //Using Callbacks
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.parallel([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two'] even though
     *         // the second function had a shorter timeout.
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
    }

    /**
     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name parallelLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.parallel]{@link module:ControlFlow.parallel}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     */
    function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
    }

    /**
     * A queue of tasks for the worker function to complete.
     * @typedef {Iterable} QueueObject
     * @memberOf module:ControlFlow
     * @property {Function} length - a function returning the number of items
     * waiting to be processed. Invoke with `queue.length()`.
     * @property {boolean} started - a boolean indicating whether or not any
     * items have been pushed and processed by the queue.
     * @property {Function} running - a function returning the number of items
     * currently being processed. Invoke with `queue.running()`.
     * @property {Function} workersList - a function returning the array of items
     * currently being processed. Invoke with `queue.workersList()`.
     * @property {Function} idle - a function returning false if there are items
     * waiting or being processed, or true if not. Invoke with `queue.idle()`.
     * @property {number} concurrency - an integer for determining how many `worker`
     * functions should be run in parallel. This property can be changed after a
     * `queue` is created to alter the concurrency on-the-fly.
     * @property {number} payload - an integer that specifies how many items are
     * passed to the worker function at a time. only applies if this is a
     * [cargo]{@link module:ControlFlow.cargo} object
     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
     * once the `worker` has finished processing the task. Instead of a single task,
     * a `tasks` array can be submitted. The respective callback is used for every
     * task in the list. Invoke with `queue.push(task, [callback])`,
     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
     * Invoke with `queue.unshift(task, [callback])`.
     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
     * a promise that rejects if an error occurs.
     * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
     * a promise that rejects if an error occurs.
     * @property {Function} remove - remove items from the queue that match a test
     * function.  The test function will be passed an object with a `data` property,
     * and a `priority` property, if this is a
     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
     * `function ({data, priority}) {}` and returns a Boolean.
     * @property {Function} saturated - a function that sets a callback that is
     * called when the number of running workers hits the `concurrency` limit, and
     * further tasks will be queued.  If the callback is omitted, `q.saturated()`
     * returns a promise for the next occurrence.
     * @property {Function} unsaturated - a function that sets a callback that is
     * called when the number of running workers is less than the `concurrency` &
     * `buffer` limits, and further tasks will not be queued. If the callback is
     * omitted, `q.unsaturated()` returns a promise for the next occurrence.
     * @property {number} buffer - A minimum threshold buffer in order to say that
     * the `queue` is `unsaturated`.
     * @property {Function} empty - a function that sets a callback that is called
     * when the last item from the `queue` is given to a `worker`. If the callback
     * is omitted, `q.empty()` returns a promise for the next occurrence.
     * @property {Function} drain - a function that sets a callback that is called
     * when the last item from the `queue` has returned from the `worker`. If the
     * callback is omitted, `q.drain()` returns a promise for the next occurrence.
     * @property {Function} error - a function that sets a callback that is called
     * when a task errors. Has the signature `function(error, task)`. If the
     * callback is omitted, `error()` returns a promise that rejects on the next
     * error.
     * @property {boolean} paused - a boolean for determining whether the queue is
     * in a paused state.
     * @property {Function} pause - a function that pauses the processing of tasks
     * until `resume()` is called. Invoke with `queue.pause()`.
     * @property {Function} resume - a function that resumes the processing of
     * queued tasks when the queue is paused. Invoke with `queue.resume()`.
     * @property {Function} kill - a function that removes the `drain` callback and
     * empties remaining tasks from the queue forcing it to go idle. No more tasks
     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
     *
     * @example
     * const q = async.queue(worker, 2)
     * q.push(item1)
     * q.push(item2)
     * q.push(item3)
     * // queues are iterable, spread into an array to inspect
     * const items = [...q] // [item1, item2, item3]
     * // or use for of
     * for (let item of q) {
     *     console.log(item)
     * }
     *
     * q.drain(() => {
     *     console.log('all done')
     * })
     * // or
     * await q.drain()
     */

    /**
     * Creates a `queue` object with the specified `concurrency`. Tasks added to the
     * `queue` are processed in parallel (up to the `concurrency` limit). If all
     * `worker`s are in progress, the task is queued until one becomes available.
     * Once a `worker` completes a `task`, that `task`'s callback is called.
     *
     * @name queue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`. Invoked with (task, callback).
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
     * attached as certain properties to listen for specific events during the
     * lifecycle of the queue.
     * @example
     *
     * // create a queue object with concurrency 2
     * var q = async.queue(function(task, callback) {
     *     console.log('hello ' + task.name);
     *     callback();
     * }, 2);
     *
     * // assign a callback
     * q.drain(function() {
     *     console.log('all items have been processed');
     * });
     * // or await the end
     * await q.drain()
     *
     * // assign an error callback
     * q.error(function(err, task) {
     *     console.error('task experienced an error');
     * });
     *
     * // add some items to the queue
     * q.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * // callback is optional
     * q.push({name: 'bar'});
     *
     * // add some items to the queue (batch-wise)
     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
     *     console.log('finished processing item');
     * });
     *
     * // add some items to the front of the queue
     * q.unshift({name: 'bar'}, function (err) {
     *     console.log('finished processing bar');
     * });
     */
    function queue$1 (worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
            _worker(items[0], cb);
        }, concurrency, 1);
    }

    // Binary min-heap implementation used for priority queue.
    // Implementation is stable, i.e. push time is considered for equal priorities
    class Heap {
        constructor() {
            this.heap = [];
            this.pushCount = Number.MIN_SAFE_INTEGER;
        }

        get length() {
            return this.heap.length;
        }

        empty () {
            this.heap = [];
            return this;
        }

        percUp(index) {
            let p;

            while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
                let t = this.heap[index];
                this.heap[index] = this.heap[p];
                this.heap[p] = t;

                index = p;
            }
        }

        percDown(index) {
            let l;

            while ((l=leftChi(index)) < this.heap.length) {
                if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                    l = l+1;
                }

                if (smaller(this.heap[index], this.heap[l])) {
                    break;
                }

                let t = this.heap[index];
                this.heap[index] = this.heap[l];
                this.heap[l] = t;

                index = l;
            }
        }

        push(node) {
            node.pushCount = ++this.pushCount;
            this.heap.push(node);
            this.percUp(this.heap.length-1);
        }

        unshift(node) {
            return this.heap.push(node);
        }

        shift() {
            let [top] = this.heap;

            this.heap[0] = this.heap[this.heap.length-1];
            this.heap.pop();
            this.percDown(0);

            return top;
        }

        toArray() {
            return [...this];
        }

        *[Symbol.iterator] () {
            for (let i = 0; i < this.heap.length; i++) {
                yield this.heap[i].data;
            }
        }

        remove (testFn) {
            let j = 0;
            for (let i = 0; i < this.heap.length; i++) {
                if (!testFn(this.heap[i])) {
                    this.heap[j] = this.heap[i];
                    j++;
                }
            }

            this.heap.splice(j);

            for (let i = parent(this.heap.length-1); i >= 0; i--) {
                this.percDown(i);
            }

            return this;
        }
    }

    function leftChi(i) {
        return (i<<1)+1;
    }

    function parent(i) {
        return ((i+1)>>1)-1;
    }

    function smaller(x, y) {
        if (x.priority !== y.priority) {
            return x.priority < y.priority;
        }
        else {
            return x.pushCount < y.pushCount;
        }
    }

    /**
     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
     * completed in ascending priority order.
     *
     * @name priorityQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`.
     * Invoked with (task, callback).
     * @param {number} concurrency - An `integer` for determining how many `worker`
     * functions should be run in parallel.  If omitted, the concurrency defaults to
     * `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
     * differences between `queue` and `priorityQueue` objects:
     * * `push(task, priority, [callback])` - `priority` should be a number. If an
     *   array of `tasks` is given, all tasks will be assigned the same priority.
     * * The `unshift` method was removed.
     */
    function priorityQueue(worker, concurrency) {
        // Start with a normal queue
        var q = queue$1(worker, concurrency);
        var processingScheduled = false;

        q._tasks = new Heap();

        // Override push to accept second parameter representing priority
        q.push = function(data, priority = 0, callback = () => {}) {
            if (typeof callback !== 'function') {
                throw new Error('task callback must be a function');
            }
            q.started = true;
            if (!Array.isArray(data)) {
                data = [data];
            }
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return setImmediate$1(() => q.drain());
            }

            for (var i = 0, l = data.length; i < l; i++) {
                var item = {
                    data: data[i],
                    priority,
                    callback
                };

                q._tasks.push(item);
            }

            if (!processingScheduled) {
                processingScheduled = true;
                setImmediate$1(() => {
                    processingScheduled = false;
                    q.process();
                });
            }
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    }

    /**
     * Runs the `tasks` array of functions in parallel, without waiting until the
     * previous function has completed. Once any of the `tasks` complete or pass an
     * error to its callback, the main `callback` is immediately called. It's
     * equivalent to `Promise.race()`.
     *
     * @name race
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
     * to run. Each function can complete with an optional `result` value.
     * @param {Function} callback - A callback to run once any of the functions have
     * completed. This function gets an error or result from the first function that
     * completed. Invoked with (err, result).
     * @returns undefined
     * @example
     *
     * async.race([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ],
     * // main callback
     * function(err, result) {
     *     // the result will be equal to 'two' as it finishes earlier
     * });
     */
    function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
        }
    }

    var race$1 = awaitify(race, 2);

    /**
     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
     *
     * @name reduceRight
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reduce]{@link module:Collections.reduce}
     * @alias foldr
     * @category Collection
     * @param {Array} array - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function reduceRight (array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
    }

    /**
     * Wraps the async function in another function that always completes with a
     * result object, even when it errors.
     *
     * The result object has either the property `error` or `value`.
     *
     * @name reflect
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function you want to wrap
     * @returns {Function} - A function that always passes null to it's callback as
     * the error. The second argument to the callback will be an `object` with
     * either an `error` or a `value` property.
     * @example
     *
     * async.parallel([
     *     async.reflect(function(callback) {
     *         // do some stuff ...
     *         callback(null, 'one');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff but error ...
     *         callback('bad stuff happened');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff ...
     *         callback(null, 'two');
     *     })
     * ],
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = 'bad stuff happened'
     *     // results[2].value = 'two'
     * });
     */
    function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
            args.push((error, ...cbArgs) => {
                let retVal = {};
                if (error) {
                    retVal.error = error;
                }
                if (cbArgs.length > 0){
                    var value = cbArgs;
                    if (cbArgs.length <= 1) {
                        [value] = cbArgs;
                    }
                    retVal.value = value;
                }
                reflectCallback(null, retVal);
            });

            return _fn.apply(this, args);
        });
    }

    /**
     * A helper function that wraps an array or an object of functions with `reflect`.
     *
     * @name reflectAll
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.reflect]{@link module:Utils.reflect}
     * @category Util
     * @param {Array|Object|Iterable} tasks - The collection of
     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
     * @returns {Array} Returns an array of async functions, each wrapped in
     * `async.reflect`
     * @example
     *
     * let tasks = [
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         // do some more stuff but error ...
     *         callback(new Error('bad stuff happened'));
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ];
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = Error('bad stuff happened')
     *     // results[2].value = 'two'
     * });
     *
     * // an example using an object instead of an array
     * let tasks = {
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         callback('two');
     *     },
     *     three: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'three');
     *         }, 100);
     *     }
     * };
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results.one.value = 'one'
     *     // results.two.error = 'two'
     *     // results.three.value = 'three'
     * });
     */
    function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
            results = tasks.map(reflect);
        } else {
            results = {};
            Object.keys(tasks).forEach(key => {
                results[key] = reflect.call(this, tasks[key]);
            });
        }
        return results;
    }

    function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
            iteratee(value, (err, v) => {
                cb(err, !v);
            });
        }, callback);
    }

    /**
     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
     *
     * @name reject
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.reject(fileList, fileExists, function(err, results) {
     *    // [ 'dir3/file6.txt' ]
     *    // results now equals an array of the non-existing files
     * });
     *
     * // Using Promises
     * async.reject(fileList, fileExists)
     * .then( results => {
     *     console.log(results);
     *     // [ 'dir3/file6.txt' ]
     *     // results now equals an array of the non-existing files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.reject(fileList, fileExists);
     *         console.log(results);
     *         // [ 'dir3/file6.txt' ]
     *         // results now equals an array of the non-existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function reject$1 (coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback)
    }
    var reject$2 = awaitify(reject$1, 3);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name rejectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectLimit (coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback)
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
     *
     * @name rejectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectSeries (coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback)
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);

    function constant$1(value) {
        return function () {
            return value;
        }
    }

    /**
     * Attempts to get a successful response from `task` no more than `times` times
     * before returning an error. If the task is successful, the `callback` will be
     * passed the result of the successful task. If all attempts fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name retry
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @see [async.retryable]{@link module:ControlFlow.retryable}
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
     * object with `times` and `interval` or a number.
     * * `times` - The number of attempts to make before giving up.  The default
     *   is `5`.
     * * `interval` - The time to wait between retries, in milliseconds.  The
     *   default is `0`. The interval may also be specified as a function of the
     *   retry count (see example).
     * * `errorFilter` - An optional synchronous function that is invoked on
     *   erroneous result. If it returns `true` the retry attempts will continue;
     *   if the function returns `false` the retry flow is aborted with the current
     *   attempt's error and result being returned to the final callback.
     *   Invoked with (err).
     * * If `opts` is a number, the number specifies the number of times to retry,
     *   with the default interval of `0`.
     * @param {AsyncFunction} task - An async function to retry.
     * Invoked with (callback).
     * @param {Function} [callback] - An optional callback which is called when the
     * task has succeeded, or after the final failed attempt. It receives the `err`
     * and `result` arguments of the last attempt at completing the `task`. Invoked
     * with (err, results).
     * @returns {Promise} a promise if no callback provided
     *
     * @example
     *
     * // The `retry` function can be used as a stand-alone control flow by passing
     * // a callback, as shown below:
     *
     * // try calling apiMethod 3 times
     * async.retry(3, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 3 times, waiting 200 ms between each retry
     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 10 times with exponential backoff
     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
     * async.retry({
     *   times: 10,
     *   interval: function(retryCount) {
     *     return 50 * Math.pow(2, retryCount);
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod the default 5 times no delay between each retry
     * async.retry(apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod only when error condition satisfies, all other
     * // errors will abort the retry control flow and return to final callback
     * async.retry({
     *   errorFilter: function(err) {
     *     return err.message === 'Temporary error'; // only retry on a specific error
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // to retry individual methods that are not as reliable within other
     * // control flow functions, use the `retryable` wrapper:
     * async.auto({
     *     users: api.getUsers.bind(api),
     *     payments: async.retryable(3, api.getPayments.bind(api))
     * }, function(err, results) {
     *     // do something with the results
     * });
     *
     */
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;

    function retry(opts, task, callback) {
        var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
        };

        if (arguments.length < 3 && typeof opts === 'function') {
            callback = task || promiseCallback();
            task = opts;
        } else {
            parseTimes(options, opts);
            callback = callback || promiseCallback();
        }

        if (typeof task !== 'function') {
            throw new Error("Invalid arguments for async.retry");
        }

        var _task = wrapAsync(task);

        var attempt = 1;
        function retryAttempt() {
            _task((err, ...args) => {
                if (err === false) return
                if (err && attempt++ < options.times &&
                    (typeof options.errorFilter != 'function' ||
                        options.errorFilter(err))) {
                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
                } else {
                    callback(err, ...args);
                }
            });
        }

        retryAttempt();
        return callback[PROMISE_SYMBOL]
    }

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    /**
     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
     * wraps a task and makes it retryable, rather than immediately calling it
     * with retries.
     *
     * @name retryable
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.retry]{@link module:ControlFlow.retry}
     * @category Control Flow
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
     * options, exactly the same as from `retry`, except for a `opts.arity` that
     * is the arity of the `task` function, defaulting to `task.length`
     * @param {AsyncFunction} task - the asynchronous function to wrap.
     * This function will be passed any arguments passed to the returned wrapper.
     * Invoked with (...args, callback).
     * @returns {AsyncFunction} The wrapped function, which when invoked, will
     * retry on an error, based on the parameters specified in `opts`.
     * This function will accept the same parameters as `task`.
     * @example
     *
     * async.auto({
     *     dep1: async.retryable(3, getFromFlakyService),
     *     process: ["dep1", async.retryable(3, function (results, cb) {
     *         maybeProcessData(results.dep1, cb);
     *     })]
     * }, callback);
     */
    function retryable (opts, task) {
        if (!task) {
            task = opts;
            opts = null;
        }
        let arity = (opts && opts.arity) || task.length;
        if (isAsync(task)) {
            arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
            if (args.length < arity - 1 || callback == null) {
                args.push(callback);
                callback = promiseCallback();
            }
            function taskFn(cb) {
                _task(...args, cb);
            }

            if (opts) retry(opts, taskFn, callback);
            else retry(taskFn, callback);

            return callback[PROMISE_SYMBOL]
        });
    }

    /**
     * Run the functions in the `tasks` collection in series, each one running once
     * the previous function has completed. If any functions in the series pass an
     * error to its callback, no more functions are run, and `callback` is
     * immediately called with the value of the error. Otherwise, `callback`
     * receives an array of results when `tasks` have completed.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function, and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     *  results from {@link async.series}.
     *
     * **Note** that while many implementations preserve the order of object
     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
     * explicitly states that
     *
     * > The mechanics and order of enumerating the properties is not specified.
     *
     * So if you rely on the order in which your series of functions are executed,
     * and want this to work on all platforms, consider using an array.
     *
     * @name series
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
     * [async functions]{@link AsyncFunction} to run in series.
     * Each function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This function gets a results array (or object)
     * containing all the result arguments passed to the `task` callbacks. Invoked
     * with (err, result).
     * @return {Promise} a promise, if no callback is passed
     * @example
     *
     * //Using Callbacks
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * });
     *
     * // an example using objects instead of arrays
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.series([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
    }

    /**
     * Returns `true` if at least one element in the `coll` satisfies an async test.
     * If any iteratee call returns `true`, the main `callback` is immediately
     * called.
     *
     * @name some
     * @static
     * @memberOf module:Collections
     * @method
     * @alias any
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // true
     *        // result is true since some file in the list exists
     *    }
     *);
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // false
     *        // result is false since none of the files exists
     *    }
     *);
     *
     * // Using Promises
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since some file in the list exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since none of the files exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since some file in the list exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since none of the files exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function some(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
    }
    var some$1 = awaitify(some, 3);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
     *
     * @name someLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anyLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var someLimit$1 = awaitify(someLimit, 4);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
     *
     * @name someSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anySeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in series.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var someSeries$1 = awaitify(someSeries, 3);

    /**
     * Sorts a list by the results of running each `coll` value through an async
     * `iteratee`.
     *
     * @name sortBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a value to use as the sort criteria as
     * its `result`.
     * Invoked with (item, callback).
     * @param {Function} callback - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is the items
     * from the original `coll` sorted by the values returned by the `iteratee`
     * calls. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback passed
     * @example
     *
     * // bigfile.txt is a file that is 251100 bytes in size
     * // mediumfile.txt is a file that is 11000 bytes in size
     * // smallfile.txt is a file that is 121 bytes in size
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // By modifying the callback parameter the
     * // sorting order can be influenced:
     *
     * // ascending order
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) return callback(getFileSizeErr);
     *         callback(null, fileSize);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // descending order
     * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) {
     *             return callback(getFileSizeErr);
     *         }
     *         callback(null, fileSize * -1);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']
     *         }
     *     }
     * );
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *             // [ Error: ENOENT: no such file or directory ]
     *         } else {
     *             console.log(results);
     *         }
     *     }
     * );
     *
     * // Using Promises
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now the original array of files sorted by
     *     // file size (ascending by default), e.g.
     *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *         // results is now the original array of files sorted by
     *         // file size (ascending by default), e.g.
     *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * // Error handling
     * async () => {
     *     try {
     *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function sortBy (coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
            _iteratee(x, (err, criteria) => {
                if (err) return iterCb(err);
                iterCb(err, {value: x, criteria});
            });
        }, (err, results) => {
            if (err) return callback(err);
            callback(null, results.sort(comparator).map(v => v.value));
        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    }
    var sortBy$1 = awaitify(sortBy, 3);

    /**
     * Sets a time limit on an asynchronous function. If the function does not call
     * its callback within the specified milliseconds, it will be called with a
     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
     *
     * @name timeout
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} asyncFn - The async function to limit in time.
     * @param {number} milliseconds - The specified time limit.
     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
     * to timeout Error for more information..
     * @returns {AsyncFunction} Returns a wrapped function that can be used with any
     * of the control flow functions.
     * Invoke this function with the same parameters as you would `asyncFunc`.
     * @example
     *
     * function myFunction(foo, callback) {
     *     doAsyncTask(foo, function(err, data) {
     *         // handle errors
     *         if (err) return callback(err);
     *
     *         // do some stuff ...
     *
     *         // return processed data
     *         return callback(null, data);
     *     });
     * }
     *
     * var wrapped = async.timeout(myFunction, 1000);
     *
     * // call `wrapped` as you would `myFunction`
     * wrapped({ bar: 'bar' }, function(err, data) {
     *     // if `myFunction` takes < 1000 ms to execute, `err`
     *     // and `data` will have their expected values
     *
     *     // else `err` will be an Error with the code 'ETIMEDOUT'
     * });
     */
    function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);

        return initialParams((args, callback) => {
            var timedOut = false;
            var timer;

            function timeoutCallback() {
                var name = asyncFn.name || 'anonymous';
                var error  = new Error('Callback function "' + name + '" timed out.');
                error.code = 'ETIMEDOUT';
                if (info) {
                    error.info = info;
                }
                timedOut = true;
                callback(error);
            }

            args.push((...cbArgs) => {
                if (!timedOut) {
                    callback(...cbArgs);
                    clearTimeout(timer);
                }
            });

            // setup timer and call original function
            timer = setTimeout(timeoutCallback, milliseconds);
            fn(...args);
        });
    }

    function range(size) {
        var result = Array(size);
        while (size--) {
            result[size] = size;
        }
        return result;
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name timesLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} count - The number of times to run the function.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see [async.map]{@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
    }

    /**
     * Calls the `iteratee` function `n` times, and accumulates results in the same
     * manner you would use with [map]{@link module:Collections.map}.
     *
     * @name times
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     * @example
     *
     * // Pretend this is some complicated async factory
     * var createUser = function(id, callback) {
     *     callback(null, {
     *         id: 'user' + id
     *     });
     * };
     *
     * // generate 5 users
     * async.times(5, function(n, next) {
     *     createUser(n, function(err, user) {
     *         next(err, user);
     *     });
     * }, function(err, users) {
     *     // we should now have 5 users
     * });
     */
    function times (n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback)
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
     *
     * @name timesSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesSeries (n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback)
    }

    /**
     * A relative of `reduce`.  Takes an Object or Array, and iterates over each
     * element in parallel, each step potentially mutating an `accumulator` value.
     * The type of the accumulator defaults to the type of collection passed in.
     *
     * @name transform
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} [accumulator] - The initial state of the transform.  If omitted,
     * it will default to an empty Object or Array, depending on the type of `coll`
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * collection that potentially modifies the accumulator.
     * Invoked with (accumulator, item, key, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the transformed accumulator.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileList, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileList, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let result = await async.transform(fileList, transformFileSize);
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileMap, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileMap, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.transform(fileMap, transformFileSize);
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function transform (coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === 'function') {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);

        eachOf$1(coll, (v, k, cb) => {
            _iteratee(accumulator, v, k, cb);
        }, err => callback(err, accumulator));
        return callback[PROMISE_SYMBOL]
    }

    /**
     * It runs each task in series but stops whenever any of the functions were
     * successful. If one of the tasks were successful, the `callback` will be
     * passed the result of the successful task. If all tasks fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name tryEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
     * run, each function is passed a `callback(err, result)` it must call on
     * completion with an error `err` (which can be `null`) and an optional `result`
     * value.
     * @param {Function} [callback] - An optional callback which is called when one
     * of the tasks has succeeded, or all have failed. It receives the `err` and
     * `result` arguments of the last attempt at completing the `task`. Invoked with
     * (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     * async.tryEach([
     *     function getDataFromFirstWebsite(callback) {
     *         // Try getting the data from the first website
     *         callback(err, data);
     *     },
     *     function getDataFromSecondWebsite(callback) {
     *         // First website failed,
     *         // Try getting the data from the backup website
     *         callback(err, data);
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     Now do something with the data.
     * });
     *
     */
    function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
            wrapAsync(task)((err, ...args) => {
                if (err === false) return taskCb(err);

                if (args.length < 2) {
                    [result] = args;
                } else {
                    result = args;
                }
                error = err;
                taskCb(err ? null : {});
            });
        }, () => callback(error, result));
    }

    var tryEach$1 = awaitify(tryEach);

    /**
     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
     * unmemoized form. Handy for testing.
     *
     * @name unmemoize
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.memoize]{@link module:Utils.memoize}
     * @category Util
     * @param {AsyncFunction} fn - the memoized function
     * @returns {AsyncFunction} a function that calls the original unmemoized function
     */
    function unmemoize(fn) {
        return (...args) => {
            return (fn.unmemoized || fn)(...args);
        };
    }

    /**
     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs.
     *
     * @name whilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with ().
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` passes. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * var count = 0;
     * async.whilst(
     *     function test(cb) { cb(null, count < 5); },
     *     function iter(callback) {
     *         count++;
     *         setTimeout(function() {
     *             callback(null, count);
     *         }, 1000);
     *     },
     *     function (err, n) {
     *         // 5 seconds have passed, n = 5
     *     }
     * );
     */
    function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];

        function next(err, ...rest) {
            if (err) return callback(err);
            results = rest;
            if (err === false) return;
            _test(check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);

    /**
     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs. `callback` will be passed an error and any
     * arguments passed to the final `iteratee`'s callback.
     *
     * The inverse of [whilst]{@link module:ControlFlow.whilst}.
     *
     * @name until
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with (callback).
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     * const results = []
     * let finished = false
     * async.until(function test(cb) {
     *     cb(null, finished)
     * }, function iter(next) {
     *     fetchPage(url, (err, body) => {
     *         if (err) return next(err)
     *         results = results.concat(body.objects)
     *         finished = !!body.next
     *         next(err)
     *     })
     * }, function done (err) {
     *     // all pages have been fetched
     * })
     */
    function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
    }

    /**
     * Runs the `tasks` array of functions in series, each passing their results to
     * the next in the array. However, if any of the `tasks` pass an error to their
     * own callback, the next function is not executed, and the main `callback` is
     * immediately called with the error.
     *
     * @name waterfall
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
     * to run.
     * Each function should complete with any number of `result` values.
     * The `result` values will be passed as arguments, in order, to the next task.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This will be passed the results of the last task's
     * callback. Invoked with (err, [results]).
     * @returns undefined
     * @example
     *
     * async.waterfall([
     *     function(callback) {
     *         callback(null, 'one', 'two');
     *     },
     *     function(arg1, arg2, callback) {
     *         // arg1 now equals 'one' and arg2 now equals 'two'
     *         callback(null, 'three');
     *     },
     *     function(arg1, callback) {
     *         // arg1 now equals 'three'
     *         callback(null, 'done');
     *     }
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     *
     * // Or, with named functions:
     * async.waterfall([
     *     myFirstFunction,
     *     mySecondFunction,
     *     myLastFunction,
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     * function myFirstFunction(callback) {
     *     callback(null, 'one', 'two');
     * }
     * function mySecondFunction(arg1, arg2, callback) {
     *     // arg1 now equals 'one' and arg2 now equals 'two'
     *     callback(null, 'three');
     * }
     * function myLastFunction(arg1, callback) {
     *     // arg1 now equals 'three'
     *     callback(null, 'done');
     * }
     */
    function waterfall (tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
        if (!tasks.length) return callback();
        var taskIndex = 0;

        function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            task(...args, onlyOnce(next));
        }

        function next(err, ...args) {
            if (err === false) return
            if (err || taskIndex === tasks.length) {
                return callback(err, ...args);
            }
            nextTask(args);
        }

        nextTask([]);
    }

    var waterfall$1 = awaitify(waterfall);

    /**
     * An "async function" in the context of Async is an asynchronous function with
     * a variable number of parameters, with the final parameter being a callback.
     * (`function (arg1, arg2, ..., callback) {}`)
     * The final callback is of the form `callback(err, results...)`, which must be
     * called once the function is completed.  The callback should be called with a
     * Error as its first argument to signal that an error occurred.
     * Otherwise, if no error occurred, it should be called with `null` as the first
     * argument, and any additional `result` arguments that may apply, to signal
     * successful completion.
     * The callback must be called exactly once, ideally on a later tick of the
     * JavaScript event loop.
     *
     * This type of function is also referred to as a "Node-style async function",
     * or a "continuation passing-style function" (CPS). Most of the methods of this
     * library are themselves CPS/Node-style async functions, or functions that
     * return CPS/Node-style async functions.
     *
     * Wherever we accept a Node-style async function, we also directly accept an
     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
     * In this case, the `async` function will not be passed a final callback
     * argument, and any thrown error will be used as the `err` argument of the
     * implicit callback, and the return value will be used as the `result` value.
     * (i.e. a `rejected` of the returned Promise becomes the `err` callback
     * argument, and a `resolved` value becomes the `result`.)
     *
     * Note, due to JavaScript limitations, we can only detect native `async`
     * functions and not transpilied implementations.
     * Your environment must have `async`/`await` support for this to work.
     * (e.g. Node > v7.6, or a recent version of a modern browser).
     * If you are using `async` functions through a transpiler (e.g. Babel), you
     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
     * because the `async function` will be compiled to an ordinary function that
     * returns a promise.
     *
     * @typedef {Function} AsyncFunction
     * @static
     */

    var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,

        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
    };

    exports.default = index;
    exports.apply = apply;
    exports.applyEach = applyEach$1;
    exports.applyEachSeries = applyEachSeries;
    exports.asyncify = asyncify;
    exports.auto = auto;
    exports.autoInject = autoInject;
    exports.cargo = cargo;
    exports.cargoQueue = cargo$1;
    exports.compose = compose;
    exports.concat = concat$1;
    exports.concatLimit = concatLimit$1;
    exports.concatSeries = concatSeries$1;
    exports.constant = constant;
    exports.detect = detect$1;
    exports.detectLimit = detectLimit$1;
    exports.detectSeries = detectSeries$1;
    exports.dir = dir;
    exports.doUntil = doUntil;
    exports.doWhilst = doWhilst$1;
    exports.each = each;
    exports.eachLimit = eachLimit$2;
    exports.eachOf = eachOf$1;
    exports.eachOfLimit = eachOfLimit$2;
    exports.eachOfSeries = eachOfSeries$1;
    exports.eachSeries = eachSeries$1;
    exports.ensureAsync = ensureAsync;
    exports.every = every$1;
    exports.everyLimit = everyLimit$1;
    exports.everySeries = everySeries$1;
    exports.filter = filter$1;
    exports.filterLimit = filterLimit$1;
    exports.filterSeries = filterSeries$1;
    exports.forever = forever$1;
    exports.groupBy = groupBy;
    exports.groupByLimit = groupByLimit$1;
    exports.groupBySeries = groupBySeries;
    exports.log = log;
    exports.map = map$1;
    exports.mapLimit = mapLimit$1;
    exports.mapSeries = mapSeries$1;
    exports.mapValues = mapValues;
    exports.mapValuesLimit = mapValuesLimit$1;
    exports.mapValuesSeries = mapValuesSeries;
    exports.memoize = memoize;
    exports.nextTick = nextTick;
    exports.parallel = parallel;
    exports.parallelLimit = parallelLimit;
    exports.priorityQueue = priorityQueue;
    exports.queue = queue$1;
    exports.race = race$1;
    exports.reduce = reduce$1;
    exports.reduceRight = reduceRight;
    exports.reflect = reflect;
    exports.reflectAll = reflectAll;
    exports.reject = reject$2;
    exports.rejectLimit = rejectLimit$1;
    exports.rejectSeries = rejectSeries$1;
    exports.retry = retry;
    exports.retryable = retryable;
    exports.seq = seq;
    exports.series = series;
    exports.setImmediate = setImmediate$1;
    exports.some = some$1;
    exports.someLimit = someLimit$1;
    exports.someSeries = someSeries$1;
    exports.sortBy = sortBy$1;
    exports.timeout = timeout;
    exports.times = times;
    exports.timesLimit = timesLimit;
    exports.timesSeries = timesSeries;
    exports.transform = transform;
    exports.tryEach = tryEach$1;
    exports.unmemoize = unmemoize;
    exports.until = until;
    exports.waterfall = waterfall$1;
    exports.whilst = whilst$1;
    exports.all = every$1;
    exports.allLimit = everyLimit$1;
    exports.allSeries = everySeries$1;
    exports.any = some$1;
    exports.anyLimit = someLimit$1;
    exports.anySeries = someSeries$1;
    exports.find = detect$1;
    exports.findLimit = detectLimit$1;
    exports.findSeries = detectSeries$1;
    exports.flatMap = concat$1;
    exports.flatMapLimit = concatLimit$1;
    exports.flatMapSeries = concatSeries$1;
    exports.forEach = each;
    exports.forEachSeries = eachSeries$1;
    exports.forEachLimit = eachLimit$2;
    exports.forEachOf = eachOf$1;
    exports.forEachOfSeries = eachOfSeries$1;
    exports.forEachOfLimit = eachOfLimit$2;
    exports.inject = reduce$1;
    exports.foldl = reduce$1;
    exports.foldr = reduceRight;
    exports.select = filter$1;
    exports.selectLimit = filterLimit$1;
    exports.selectSeries = filterSeries$1;
    exports.wrapSync = asyncify;
    exports.during = whilst$1;
    exports.doDuring = doWhilst$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":6,"timers":10}],2:[function(require,module,exports){
var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    }
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    }
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
    }

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    }


    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    }
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
    }

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    }

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    }

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    }
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
    }

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
    }

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
    }

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
    }

    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
    }

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
    }

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I :
                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
                    v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
    }

    BigInteger.prototype.bitLength = function () {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    }
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < top) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function (text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
        }
        for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
                return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
                        .map(Array.prototype.valueOf, [1, 0])
                    ),
                    isNegative: false
                };

            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
                .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };

            return {
                value: Array.apply(null, Array(n.toJSNumber()))
                    .map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
    }

    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
        }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
    }

    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x))
                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += (new Array(exp + 1)).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if (typeof define === "function" && define.amd) {
    define( function () {
        return bigInt;
    });
}

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();

},{}],5:[function(require,module,exports){
exports.WeakMap = WeakMap
exports.WeakSet = WeakSet
exports.Set = Set

function isObject (value) {
  return typeof value === 'object' && value != null &&
    !(value instanceof Boolean) &&
    !(value instanceof Date) &&
    !(value instanceof Number) &&
    !(value instanceof RegExp) &&
    !(value instanceof String)
}

function decycle (object) {
  var seen = new exports.WeakSet()
  var paths = new exports.WeakMap()
  
  return function replacer (key, value) {
    if (key !== '$ref' && isObject(value)) {
      if (seen.has(value)) {
        return {$ref: toPointer(paths.get(value))}
      } else {
        paths.set(value, (paths.get(this)||[]).concat([key]))
        seen.add(value)
      }
    }

    return value
  }

  function toPointer (parts) {
    return '#'+parts.map(function(part) {
      return part.toString().replace(/~/g, '~0').replace(/\//g, '~1')
    }).join('/')
  }
}

function retrocycle () {
  var parents = new exports.WeakMap()
  var refs = new exports.Set()

  return function reviver (key, value) {
    if (key === '$ref') {
      refs.add(this)
    } else
    if (isObject(value)) {
      var isRoot = key === '' && Object.keys(this).length === 1
      if (isRoot) {
        refs.forEach(dereference, this)
      } else {
        parents.set(value, this)
      }
    }

    return value
  }

  function dereference (ref) {
    var parts = ref.$ref.slice(1).split('/')
    var key, parent, value = this
    for (var i=0; i<parts.length; i++) {
      key = parts[i].replace(/~1/g, '/').replace(/~0/g, '~')
      value = value[key]
    }
    parent = parents.get(ref)
    parent[key] = value
  }

}

function augment (JSON) {
  return Object.defineProperties(JSON, {
    decycle: {value: decycle},
    retrocycle: {value: retrocycle}
  })
}

exports.decycle = decycle
exports.retrocycle = retrocycle
exports.extend = augment
},{}],6:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
// Copyright (C) 2013 [Jeff Mesnil](http://jmesnil.net/)
//
//   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0
//
// The library can be used in node.js app to connect to STOMP brokers over TCP 
// or Web sockets.

// Root of the `stompjs module`

var Stomp = require('./lib/stomp.js');
var StompNode = require('./lib/stomp-node.js');

module.exports = Stomp.Stomp;
module.exports.overTCP = StompNode.overTCP;
module.exports.overWS = StompNode.overWS;
},{"./lib/stomp-node.js":8,"./lib/stomp.js":9}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2013 [Jeff Mesnil](http://jmesnil.net/)
 */

(function() {
  var Stomp, net, overTCP, overWS, wrapTCP, wrapWS;

  Stomp = require('./stomp');

  net = require('net');

  Stomp.Stomp.setInterval = function(interval, f) {
    return setInterval(f, interval);
  };

  Stomp.Stomp.clearInterval = function(id) {
    return clearInterval(id);
  };

  wrapTCP = function(port, host) {
    var socket, ws;
    socket = null;
    ws = {
      url: 'tcp:// ' + host + ':' + port,
      send: function(d) {
        return socket.write(d);
      },
      close: function() {
        return socket.end();
      }
    };
    socket = net.connect(port, host, function(e) {
      return ws.onopen();
    });
    socket.on('error', function(e) {
      return typeof ws.onclose === "function" ? ws.onclose(e) : void 0;
    });
    socket.on('close', function(e) {
      return typeof ws.onclose === "function" ? ws.onclose(e) : void 0;
    });
    socket.on('data', function(data) {
      var event;
      event = {
        'data': data.toString()
      };
      return ws.onmessage(event);
    });
    return ws;
  };

  wrapWS = function(url) {
    var WebSocketClient, connection, socket, ws;
    WebSocketClient = require('websocket').client;
    connection = null;
    ws = {
      url: url,
      send: function(d) {
        return connection.sendUTF(d);
      },
      close: function() {
        return connection.close();
      }
    };
    socket = new WebSocketClient();
    socket.on('connect', function(conn) {
      connection = conn;
      ws.onopen();
      connection.on('error', function(error) {
        return typeof ws.onclose === "function" ? ws.onclose(error) : void 0;
      });
      connection.on('close', function() {
        return typeof ws.onclose === "function" ? ws.onclose() : void 0;
      });
      return connection.on('message', function(message) {
        var event;
        if (message.type === 'utf8') {
          event = {
            'data': message.utf8Data
          };
          return ws.onmessage(event);
        }
      });
    });
    socket.connect(url);
    return ws;
  };

  overTCP = function(host, port) {
    var socket;
    socket = wrapTCP(port, host);
    return Stomp.Stomp.over(socket);
  };

  overWS = function(url) {
    var socket;
    socket = wrapWS(url);
    return Stomp.Stomp.over(socket);
  };

  exports.overTCP = overTCP;

  exports.overWS = overWS;

}).call(this);

},{"./stomp":9,"net":3,"websocket":26}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = (function() {
    var unmarshallSingle;

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers['content-length'] === false ? true : false;
      if (skipContentLength) {
        delete this.headers['content-length'];
      }
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body && !skipContentLength) {
        lines.push("content-length:" + (Frame.sizeOfUTF8(this.body)));
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame.sizeOfUTF8 = function(s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {
    var now;

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
    }

    Client.prototype.debug = function(message) {
      var _ref;
      return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
    };

    now = function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf;
      }
    };

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      while (true) {
        if (out.length > this.maxWebSocketFrameSize) {
          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
          out = out.substring(this.maxWebSocketFrameSize);
          if (typeof this.debug === "function") {
            this.debug("remaining = " + out.length);
          }
        } else {
          return this.ws.send(out);
        }
      }
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            _this.ws.send(Byte.LF);
            return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
          };
        })(this));
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            var delta;
            delta = now() - _this.serverActivity;
            if (delta > ttl * 2) {
              if (typeof _this.debug === "function") {
                _this.debug("did not receive server activity for the last " + delta + "ms");
              }
              return _this.ws.close();
            }
          };
        })(this));
      }
    };

    Client.prototype._parseConnect = function() {
      var args, connectCallback, errorCallback, headers;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          headers = args[0], connectCallback = args[1];
          break;
        case 3:
          if (args[1] instanceof Function) {
            headers = args[0], connectCallback = args[1], errorCallback = args[2];
          } else {
            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
          }
          break;
        case 4:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
          break;
        default:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function() {
      var args, errorCallback, headers, out;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      out = this._parseConnect.apply(this, args);
      headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = (function(_this) {
        return function(evt) {
          var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;
          data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              c = arr[_i];
              _results.push(String.fromCharCode(c));
            }
            return _results;
          })()).join('')) : evt.data;
          _this.serverActivity = now();
          if (data === Byte.LF) {
            if (typeof _this.debug === "function") {
              _this.debug("<<< PONG");
            }
            return;
          }
          if (typeof _this.debug === "function") {
            _this.debug("<<< " + data);
          }
          _ref = Frame.unmarshall(data);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            frame = _ref[_i];
            switch (frame.command) {
              case "CONNECTED":
                if (typeof _this.debug === "function") {
                  _this.debug("connected to server " + frame.headers.server);
                }
                _this.connected = true;
                _this._setupHeartbeat(frame.headers);
                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                break;
              case "MESSAGE":
                subscription = frame.headers.subscription;
                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                if (onreceive) {
                  client = _this;
                  messageID = frame.headers["message-id"];
                  frame.ack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.ack(messageID, subscription, headers);
                  };
                  frame.nack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.nack(messageID, subscription, headers);
                  };
                  _results.push(onreceive(frame));
                } else {
                  _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                }
                break;
              case "RECEIPT":
                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                break;
              case "ERROR":
                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                break;
              default:
                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
            }
          }
          return _results;
        };
      })(this);
      this.ws.onclose = (function(_this) {
        return function() {
          var msg;
          msg = "Whoops! Lost connection to " + _this.ws.url;
          if (typeof _this.debug === "function") {
            _this.debug(msg);
          }
          _this._cleanUp();
          return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
        };
      })(this);
      return this.ws.onopen = (function(_this) {
        return function() {
          if (typeof _this.debug === "function") {
            _this.debug('Web Socket Opened...');
          }
          headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
          headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
          return _this._transmit("CONNECT", headers);
        };
      })(this);
    };

    Client.prototype.disconnect = function(disconnectCallback, headers) {
      if (headers == null) {
        headers = {};
      }
      this._transmit("DISCONNECT", headers);
      this.ws.onclose = null;
      this.ws.close();
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.connected = false;
      if (this.pinger) {
        Stomp.clearInterval(this.pinger);
      }
      if (this.ponger) {
        return Stomp.clearInterval(this.ponger);
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      var client;
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      client = this;
      return {
        id: headers.id,
        unsubscribe: function() {
          return client.unsubscribe(headers.id);
        }
      };
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      var client, txid;
      txid = transaction || "tx-" + this.counter++;
      this._transmit("BEGIN", {
        transaction: txid
      });
      client = this;
      return {
        id: txid,
        commit: function() {
          return client.commit(txid);
        },
        abort: function() {
          return client.abort(txid);
        }
      };
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;

  })();

  Stomp = {
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return '1.1,1.0';
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Stomp = Stomp;
  }

  if (typeof window !== "undefined" && window !== null) {
    Stomp.setInterval = function(interval, f) {
      return window.setInterval(f, interval);
    };
    Stomp.clearInterval = function(id) {
      return window.clearInterval(id);
    };
    window.Stomp = Stomp;
  } else if (!exports) {
    self.Stomp = Stomp;
  }

}).call(this);

},{}],10:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":6,"timers":10}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":13,"./parse.js":14,"./stringify.js":18,"./v1.js":19,"./v3.js":20,"./v4.js":22,"./v5.js":23,"./validate.js":24,"./version.js":25}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":24}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":24}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":16,"./stringify.js":18}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":12,"./v35.js":21}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":14,"./stringify.js":18}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":16,"./stringify.js":18}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":17,"./v35.js":21}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":15}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":24}],26:[function(require,module,exports){
var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = require('es5-ext/global');
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = require('./version');


/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
module.exports = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : websocket_version
};

},{"./version":27,"es5-ext/global":4}],27:[function(require,module,exports){
module.exports = require('../package.json').version;

},{"../package.json":28}],28:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "websocket@1.0.34",
      "/opt/bamboo/bamboo-agent-home/xml-data/build-dir/NWEBRTC-NW2210-JOB1/nativewebrtc/vidyoclient"
    ]
  ],
  "_from": "websocket@1.0.34",
  "_id": "websocket@1.0.34",
  "_inBundle": false,
  "_integrity": "sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==",
  "_location": "/websocket",
  "_optional": true,
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "websocket@1.0.34",
    "name": "websocket",
    "escapedName": "websocket",
    "rawSpec": "1.0.34",
    "saveSpec": null,
    "fetchSpec": "1.0.34"
  },
  "_requiredBy": [
    "/stompjs"
  ],
  "_resolved": "https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz",
  "_spec": "1.0.34",
  "_where": "/opt/bamboo/bamboo-agent-home/xml-data/build-dir/NWEBRTC-NW2210-JOB1/nativewebrtc/vidyoclient",
  "author": {
    "name": "Brian McKelvey",
    "email": "theturtle32@gmail.com",
    "url": "https://github.com/theturtle32"
  },
  "browser": "lib/browser.js",
  "bugs": {
    "url": "https://github.com/theturtle32/WebSocket-Node/issues"
  },
  "config": {
    "verbose": false
  },
  "contributors": [
    {
      "name": "Iaki Baz Castillo",
      "email": "ibc@aliax.net",
      "url": "http://dev.sipdoc.net"
    }
  ],
  "dependencies": {
    "bufferutil": "^4.0.1",
    "debug": "^2.2.0",
    "es5-ext": "^0.10.50",
    "typedarray-to-buffer": "^3.1.5",
    "utf-8-validate": "^5.0.2",
    "yaeti": "^0.0.6"
  },
  "description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
  "devDependencies": {
    "buffer-equal": "^1.0.0",
    "gulp": "^4.0.2",
    "gulp-jshint": "^2.0.4",
    "jshint": "^2.0.0",
    "jshint-stylish": "^2.2.1",
    "tape": "^4.9.1"
  },
  "directories": {
    "lib": "./lib"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "homepage": "https://github.com/theturtle32/WebSocket-Node",
  "keywords": [
    "websocket",
    "websockets",
    "socket",
    "networking",
    "comet",
    "push",
    "RFC-6455",
    "realtime",
    "server",
    "client"
  ],
  "license": "Apache-2.0",
  "main": "index",
  "name": "websocket",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/theturtle32/WebSocket-Node.git"
  },
  "scripts": {
    "gulp": "gulp",
    "test": "tape test/unit/*.js"
  },
  "version": "1.0.34"
}

},{}],29:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {

});

emitter.on('somenamespace*', function (eventName, payloads) {

});

Please note that callbacks triggered by wildcard registered events also get
the event name as the first argument.
*/

module.exports = WildEmitter;

function WildEmitter() { }

WildEmitter.mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;

    prototype.isWildEmitter= true;

    // Listen on the given `event` with `fn`. Store a group name if present.
    prototype.on = function (event, groupName, fn) {
        this.callbacks = this.callbacks || {};
        var hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        func._groupName = group;
        (this.callbacks[event] = this.callbacks[event] || []).push(func);
        return this;
    };

    // Adds an `event` listener that will be invoked a single
    // time then automatically removed.
    prototype.once = function (event, groupName, fn) {
        var self = this,
            hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        function on() {
            self.off(event, on);
            func.apply(this, arguments);
        }
        this.on(event, group, on);
        return this;
    };

    // Unbinds an entire group
    prototype.releaseGroup = function (groupName) {
        this.callbacks = this.callbacks || {};
        var item, i, len, handlers;
        for (item in this.callbacks) {
            handlers = this.callbacks[item];
            for (i = 0, len = handlers.length; i < len; i++) {
                if (handlers[i]._groupName === groupName) {
                    //console.log('removing');
                    // remove it and shorten the array we're looping through
                    handlers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        return this;
    };

    // Remove the given callback for `event` or all
    // registered callbacks.
    prototype.off = function (event, fn) {
        this.callbacks = this.callbacks || {};
        var callbacks = this.callbacks[event],
            i;

        if (!callbacks) return this;

        // remove all handlers
        if (arguments.length === 1) {
            delete this.callbacks[event];
            return this;
        }

        // remove specific handler
        i = callbacks.indexOf(fn);
        if (i !== -1) {
            callbacks.splice(i, 1);
            if (callbacks.length === 0) {
                delete this.callbacks[event];
            }
        }
        return this;
    };

    /// Emit `event` with the given args.
    // also calls any `*` handlers
    prototype.emit = function (event) {
        this.callbacks = this.callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this.callbacks[event],
            specialCallbacks = this.getWildcardCallbacks(event),
            i,
            len,
            item,
            listeners;

        if (callbacks) {
            listeners = callbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, args);
            }
        }

        if (specialCallbacks) {
            len = specialCallbacks.length;
            listeners = specialCallbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, [event].concat(args));
            }
        }

        return this;
    };

    // Helper for for finding special wildcard event handlers that match the event
    prototype.getWildcardCallbacks = function (eventName) {
        this.callbacks = this.callbacks || {};
        var item,
            split,
            result = [];

        for (item in this.callbacks) {
            split = item.split('*');
            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
                result = result.concat(this.callbacks[item]);
            }
        }
        return result;
    };

};

WildEmitter.mixin(WildEmitter);

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimplifiedVidyoCore = exports.TrackType = exports.MediaTrackType = void 0;
const TrackMetaDataProvider_1 = require("./controllers/StreamController/TrackMetaDataProvider");
Object.defineProperty(exports, "MediaTrackType", { enumerable: true, get: function () { return TrackMetaDataProvider_1.MediaTrackType; } });
const LocalStreamController_1 = require("./controllers/StreamController/LocalStreamController");
Object.defineProperty(exports, "TrackType", { enumerable: true, get: function () { return LocalStreamController_1.TrackType; } });
const Participant_1 = require("./models/Participant");
class SimplifiedVidyoCore {
    constructor(_vidyoCore) {
        this._vidyoCore = _vidyoCore;
    }
    get AdvancedSettings() { return this._vidyoCore.Controllers.AdvancedSettingsController; }
    get LocalStreamController() { return this._vidyoCore.Controllers.LocalStreamController; }
    get RemoteStreamController() { return this._vidyoCore.Controllers.RemoteStreamController; }
    get TransmittedStreamController() { return this._vidyoCore.Controllers.TransmittedStreamController; }
    get Log() { return this._vidyoCore.Controllers.LogController; }
    GetLocalStreamMediaProperties(trackId) {
        return this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaProperties(trackId);
    }
    UpdateTransmitedStreamTracksMap(trackIdsBySsrc) {
        this._vidyoCore.Controllers.TransmittedStreamController.UpdateTracksSrrcs(trackIdsBySsrc);
    }
    GetRemoteParticipants() {
        return this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote });
    }
}
exports.SimplifiedVidyoCore = SimplifiedVidyoCore;

},{"./controllers/StreamController/LocalStreamController":56,"./controllers/StreamController/TrackMetaDataProvider":59,"./models/Participant":94}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoDiagnostics = exports.VidyoCore = void 0;
const RendererFactory = require("../render/RendererFactory");
const AdvancedSettingsController_1 = require("./controllers/AdvancedSettingsController");
const BaseController_1 = require("./controllers/BaseController");
const CallStateController_1 = require("./controllers/CallStateController");
const ConferenceController_1 = require("./controllers/ConferenceController/ConferenceController");
const ConnectionController_1 = require("./controllers/ConnectionController");
const EventDispatcher_1 = require("./events/EventDispatcher");
const DeviceController_1 = require("./controllers/DeviceController");
const EndPoint_1 = require("../vidyo_simple_api/EndPoint");
const LocalStreamController_1 = require("./controllers/StreamController/LocalStreamController");
const LogController_1 = require("./controllers/LogController/LogController");
const ParticipantController_1 = require("./controllers/ParticipantController");
const PersistedSettingsController_1 = require("./controllers/PersistedSettingsController");
const RemoteStreamController_1 = require("./controllers/StreamController/RemoteStreamController");
const RendererController_1 = require("./controllers/RendererController");
const RoomController_1 = require("./controllers/RoomController");
const SimplifiedVidyoCore_1 = require("./SimplifiedVidyoCore");
const StatisticsController_1 = require("./controllers/StatisticsController");
const TransmittedStreamController_1 = require("./controllers/StreamController/TransmittedStreamController");
const AnalyticsController_1 = require("./controllers/AnalyticsController/AnalyticsController");
const User_1 = require("../vidyo_simple_api/User");
const UserController_1 = require("./controllers/UserController");
const ObjectUtils_1 = require("./utils/ObjectUtils");
const MicrophoneEnergyLevelController_1 = require("./controllers/MicrophoneEnergyLevelController");
const RendererTypes_1 = require("./models/RendererTypes");
const Permission_1 = require("../vidyo_simple_api/Permission");
const PermissionController_1 = require("./controllers/PermissionController");
const MessageController_1 = require("./controllers/MessageController");
const ResourcesManager_1 = require("./controllers/ResourceManager/ResourcesManager");
const HunterProvider_1 = require("./hunter/HunterProvider");
const ModerationController_1 = require("./controllers/ModerationController");
class VidyoCore {
    constructor() {
        this.Controllers = (0, BaseController_1.CreateControllers)(this, {
            AdvancedSettingsController: AdvancedSettingsController_1.AdvancedSettingsController,
            CallStateController: CallStateController_1.CallStateController,
            ConferenceController: ConferenceController_1.ConferenceController,
            ConnectionController: ConnectionController_1.ConnectionController,
            DeviceController: DeviceController_1.DeviceController,
            LocalStreamController: LocalStreamController_1.LocalStreamController,
            MessageController: MessageController_1.MessageController,
            MicrophoneEnergyLevelController: MicrophoneEnergyLevelController_1.MicrophoneEnergyLevelController,
            LogController: LogController_1.LogController,
            ParticipantController: ParticipantController_1.ParticipantController,
            PermissionController: PermissionController_1.PermissionController,
            PersistedSettingsController: PersistedSettingsController_1.PersistedSettingsController,
            RendererController: RendererController_1.RendererController,
            ResourcesManager: ResourcesManager_1.ResourcesManager,
            RoomController: RoomController_1.RoomController,
            StatisticsController: StatisticsController_1.StatisticsController,
            RemoteStreamController: RemoteStreamController_1.RemoteStreamController,
            TransmittedStreamController: TransmittedStreamController_1.TransmittedStreamController,
            UserController: UserController_1.UserController,
            ModerationController: ModerationController_1.ModerationController,
            AnalyticsController: AnalyticsController_1.AnalyticsController
        });
        this.Diagnostics = new VidyoDiagnostics();
        this.EventDispatcher = (0, EventDispatcher_1.CreateEventDispatcher)();
        this.HunterProvider = new HunterProvider_1.HunterProvider(this.EventDispatcher, new SimplifiedVidyoCore_1.SimplifiedVidyoCore(this), this.Controllers.LogController);
        window['vidyoCore' + Math.floor(Math.random() * 10)] = this;
    }
    CreateEndpoint(viewId, viewStyle, remoteParticipants, consoleLogFilter, fileLogFilter, fileLogName) {
        this.Controllers.LogController.SetLogLevelSDK(consoleLogFilter);
        this.Controllers.AdvancedSettingsController.ParticipantLimit = remoteParticipants;
        this._renderer = RendererFactory.CreateRenderer(viewId, viewStyle, this);
        const isRenderModeComposite = this.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite;
        this.Controllers.ResourcesManager.DynamicShowState = isRenderModeComposite;
        if (isRenderModeComposite) {
            this.Controllers.DeviceController.StartDeviceDetection();
        }
        return new EndPoint_1.EndPoint(this);
    }
    CreatePermission() {
        return new Permission_1.Permission(this);
    }
    CreateUser(endPoint) {
        return new User_1.User(this);
    }
    Disable() {
        return this.Controllers.ConnectionController.Disable()
            .then(() => { this.Controllers.MicrophoneEnergyLevelController.Disable(); })
            .then(() => { this.Controllers.MessageController.Disable(); })
            .then(() => { this.Controllers.StatisticsController.Disable(); })
            .then(() => { this.Controllers.LocalStreamController.Disable(); })
            .then(() => { this.Controllers.RemoteStreamController.Disable(); })
            .then(() => { this.Controllers.TransmittedStreamController.Disable(); })
            .then(() => { this.Controllers.ResourcesManager.Disable(); })
            .then(() => { if (this._renderer) {
            this._renderer.Destroy();
        } })
            .then(() => { this.Controllers.DeviceController.Disable(); })
            .then(() => { this.Controllers.CallStateController.Disable(); })
            .then(() => { this.Controllers.ConferenceController.Disable(); })
            .then(() => { this.Controllers.RoomController.Disable(); })
            .then(() => { this.Controllers.ParticipantController.Disable(); })
            .then(() => { this.Controllers.PermissionController.Disable(); })
            .then(() => { this.Controllers.UserController.Disable(); })
            .then(() => { this.Controllers.RendererController.Disable(); })
            .then(() => { this.Controllers.PersistedSettingsController.Disable(); })
            .then(() => { this.Controllers.AdvancedSettingsController.Disable(); })
            .then(() => { this.Controllers.LogController.Disable(); })
            .then(() => { this.Controllers.ModerationController.Disable(); })
            .then(() => {
            this.EventDispatcher.releaseAll();
            return Promise.resolve(true);
        })
            .catch((err) => {
            throw (err ? err : new Error('Failed to Disable VidyoCore'));
        });
    }
    Initialize() {
        const controllers = Object.values(this.Controllers);
        return Promise.all(controllers.map((controller) => {
            return controller.Initialize().catch((reason) => {
                throw (new Error('Failed to initialize controller ' + controller.constructor.name + ' (' + reason + ')'));
            });
        })).then(() => {
            return Promise.resolve(true);
        });
    }
    ReassignRenderer(viewId, viewStyle) {
        if (this._renderer && !!this._renderer['Destroy']) {
            this._renderer.Destroy();
        }
        this._renderer = RendererFactory.CreateRenderer(viewId, viewStyle, this);
        return Promise.resolve(true);
    }
}
exports.VidyoCore = VidyoCore;
VidyoCore.Version = '0.0.0.1';
class VidyoDiagnostics {
    LayoutParameters() {
        let container = document.querySelector('.vidyo-rendering-container');
        if (!container) {
            throw (new Error('Failed to find .vidyo-rendering-container'));
        }
        let allVideos = container.querySelectorAll('video');
        let videoWidths = ObjectUtils_1.default.MapObject(allVideos, (v) => v.videoWidth).filter((w) => w > 0);
        let sumOfVideoWidths = videoWidths.reduce((a, b) => a + b);
        let videoHeights = ObjectUtils_1.default.MapObject(allVideos, (v) => v.videoHeight).filter((h) => h > 0);
        let sumOfVideoHeights = videoHeights.reduce((a, b) => a + b);
        let threshold = (sumOfVideoWidths / sumOfVideoHeights) / (container.clientWidth / container.clientHeight);
        return `${allVideos.length} videos, ${container.clientWidth} x ${container.clientHeight} container,
        average video is ${sumOfVideoWidths / videoWidths.length} x ${sumOfVideoHeights / videoHeights.length}
        (threshold === ${threshold})`;
    }
}
exports.VidyoDiagnostics = VidyoDiagnostics;

},{"../render/RendererFactory":176,"../vidyo_simple_api/EndPoint":185,"../vidyo_simple_api/Permission":189,"../vidyo_simple_api/User":191,"./SimplifiedVidyoCore":30,"./controllers/AdvancedSettingsController":32,"./controllers/AnalyticsController/AnalyticsController":33,"./controllers/BaseController":35,"./controllers/CallStateController":36,"./controllers/ConferenceController/ConferenceController":37,"./controllers/ConnectionController":42,"./controllers/DeviceController":43,"./controllers/LogController/LogController":44,"./controllers/MessageController":46,"./controllers/MicrophoneEnergyLevelController":47,"./controllers/ModerationController":48,"./controllers/ParticipantController":49,"./controllers/PermissionController":50,"./controllers/PersistedSettingsController":51,"./controllers/RendererController":52,"./controllers/ResourceManager/ResourcesManager":53,"./controllers/RoomController":54,"./controllers/StatisticsController":55,"./controllers/StreamController/LocalStreamController":56,"./controllers/StreamController/RemoteStreamController":57,"./controllers/StreamController/TransmittedStreamController":60,"./controllers/UserController":61,"./events/EventDispatcher":68,"./hunter/HunterProvider":83,"./models/RendererTypes":96,"./utils/ObjectUtils":153}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdvancedSettingsController = void 0;
const AdvancedSettingsEvents = require("../events/AdvancedSettingsEvents");
const BaseController_1 = require("./BaseController");
const AutoPropertyHelper_1 = require("../utils/AutoPropertyHelper");
const Constants = require("../utils/Constants");
const LogEvents_1 = require("../events/LogEvents");
const OperatingSystemInfoProvider_1 = require("../utils/OperatingSystemInfoProvider");
const EventDispatcher_1 = require("../events/EventDispatcher");
const AnalyticsEvents = require("../events/AnalyticsEvents");
function AdvancedSettingsTemplate(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.DisableAudioEnergyMonitor = false;
            this.DisableDynamicAudioSources = false;
            this.DisableStats = false;
            this.DynamicAudioSources = Constants.NumberOfSelectedAudioSources;
            this.EnableAudioOnlyMode = false;
            this.EnableAutoReconnect = true;
            this.EnableCompositorFixedParticipants = true;
            this.EnableFixedEncoderBitRate = false;
            this.EnableFixedSimulcastRunnels = false;
            this.EnableScreenShareSimulcast = false;
            this.EnableSimpleAPILogging = false;
            this.EnableTransportCc = true;
            this.EnableVideoSimulcast = true;
            this.EnableVidyoConnectorAPILogging = false;
            this.ExtDataType = undefined;
            this.ExtData = undefined;
            this.LoggerURL = undefined;
            this.MaxReconnectAttempts = 3;
            this.OnAnalyticsEventSent = null;
            this.ReconnectBackoff = 5;
            this.PinnedParticipantDisplayCropped = false;
            this.ShowStatisticsOverlay = false;
            this.StatisticsRefreshInterval = Constants.StatisticsRefreshInterval;
            this.CameraContentHint = Constants.VideoMediaTrackContentHints.motion;
            this.WindowShareContentHint = Constants.VideoMediaTrackContentHints.detail;
        }
    };
}
const eventsByPropertyName = {
    DisableAudioEnergyMonitor: AdvancedSettingsEvents.Events.DisableAudioEnergyMonitorChanged,
    DisableDynamicAudioSources: AdvancedSettingsEvents.Events.DisableDynamicAudioSourcesChanged,
    DisableStats: AdvancedSettingsEvents.Events.DisableStatsChanged,
    DynamicAudioSources: AdvancedSettingsEvents.Events.DynamicAudioSourcesChanged,
    EnableAudioOnlyMode: AdvancedSettingsEvents.Events.EnableAudioOnlyModeChanged,
    EnableAutoReconnect: AdvancedSettingsEvents.Events.EnableAutoReconnectChanged,
    EnableCompositorFixedParticipants: AdvancedSettingsEvents.Events.EnableCompositorFixedParticipantsChanged,
    EnableFixedEncoderBitRate: AdvancedSettingsEvents.Events.EnableFixedEncoderBitRateChanged,
    EnableFixedSimulcastRunnels: AdvancedSettingsEvents.Events.EnableFixedSimulcastRunnelsChanged,
    EnableScreenShareSimulcast: AdvancedSettingsEvents.Events.EnableScreenShareSimulcastChanged,
    EnableSimpleAPILogging: AdvancedSettingsEvents.Events.EnableSimpleAPILoggingChanged,
    EnableTransportCc: AdvancedSettingsEvents.Events.EnableTransportCcChanged,
    EnableVideoSimulcast: AdvancedSettingsEvents.Events.EnableVideoSimulcastChanged,
    EnableVidyoConnectorAPILogging: AdvancedSettingsEvents.Events.EnableVidyoConnectorAPILoggingChanged,
    ExtData: AdvancedSettingsEvents.Events.ExtDataChanged,
    ExtDataType: AdvancedSettingsEvents.Events.ExtDataTypeChanged,
    LoggerURL: AdvancedSettingsEvents.Events.LoggerURLChanged,
    MaxReconnectAttempts: AdvancedSettingsEvents.Events.MaxReconnectAttemptsChanged,
    ParticipantLimit: AdvancedSettingsEvents.Events.ParticipantLimitChanged,
    OnAnalyticsEventSent: AdvancedSettingsEvents.Events.OnAnalyticsEventSentChanged,
    ReconnectBackoff: AdvancedSettingsEvents.Events.ReconnectBackoffChanged,
    PinnedParticipantDisplayCropped: AdvancedSettingsEvents.Events.PinnedParticipantDisplayCroppedChanged,
    ShowLogCategory: AdvancedSettingsEvents.Events.LogCategoryChanged,
    ShowStatisticsOverlay: AdvancedSettingsEvents.Events.ShowStatisticsOverlayChanged,
    StatisticsRefreshInterval: AdvancedSettingsEvents.Events.StatisticsRefreshIntervalChanged,
    CameraContentHint: AdvancedSettingsEvents.Events.CameraContentHintChanged,
    WindowShareContentHint: AdvancedSettingsEvents.Events.WindowShareContentHintChanged
};
const validatorFunctionsByPropertyName = {
    EnableFixedSimulcastRunnels: (value) => {
        return value === false || value === 1 || value === 2 || value === 3;
    },
    ParticipantLimit: (value) => {
        const upperLimit = 1000;
        return typeof value === 'number' && !isNaN(value) && value >= 0 && value < upperLimit;
    },
    EnableFixedEncoderBitRate: (value) => {
        const minimum = 50000;
        const maximum = 10000000;
        return value === false || (typeof value === 'number' && !isNaN(value) && value >= minimum && value <= maximum);
    },
    DynamicAudioSources: (value) => {
        return (value >= 1) && (value <= 5);
    },
    MaxReconnectAttempts: (value) => {
        const minimum = 1;
        const maximum = 4;
        return (value >= minimum) && (value <= maximum);
    },
    OnAnalyticsEventSent: (value) => {
        return value === null || typeof value === 'function';
    },
    ReconnectBackoff: (value) => {
        const minimum = 2;
        const maximum = 20;
        return (value >= minimum) && (value <= maximum);
    },
    StatisticsRefreshInterval: (value) => {
        const minimum = 1000;
        return value >= minimum;
    },
    CameraContentHint: (value) => Object.values(Constants.VideoMediaTrackContentHints).includes(value),
    WindowShareContentHint: (value) => Object.values(Constants.VideoMediaTrackContentHints).includes(value)
};
class AdvancedSettingsController extends AdvancedSettingsTemplate(BaseController_1.BaseController) {
    constructor() {
        super(...arguments);
        this.Silent = false;
        this._onAnalyticsEventSent = (payload) => {
            if (typeof this.OnAnalyticsEventSent === 'function') {
                this.OnAnalyticsEventSent(payload);
            }
        };
    }
    Disable() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.AdvancedSettingsListeners);
        return super.Disable();
    }
    Initialize() {
        let TemplateClass = AdvancedSettingsTemplate(Object);
        let template = new TemplateClass();
        let levels = {};
        Object.keys(LogEvents_1.VidyoLogLevel).filter(x => Number.isNaN(parseInt(x))).forEach((e) => levels[e] = LogEvents_1.VidyoLogLevel[e]);
        Object.defineProperty(this, 'ShowLogCategory', {
            get: () => {
                return {
                    logLevel: levels,
                    logCategory: Object.keys(LogEvents_1.VidyoLogCategory),
                    activeLogs: this._vidyoCore.Controllers.LogController.GetLogLevelSDK()
                };
            },
            set: (val) => {
                this._vidyoCore.EventDispatcher.emit(eventsByPropertyName.ShowLogCategory, this._vidyoCore.Controllers.LogController.GetLogLevelSDK());
            }
        });
        const RestrictedParticipantLimit = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsWindows()
            && navigator.hardwareConcurrency <= Constants.WindowsMinHardwareConcurency;
        const MobileParticipantLimit = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice();
        let _participantLimit = RestrictedParticipantLimit ?
            Constants.RestrictedParticipantLimit : Constants.ParticipantLimit;
        _participantLimit = MobileParticipantLimit ? Constants.MobileParticipantLimit : _participantLimit;
        Object.defineProperty(this, 'ParticipantLimit', {
            get: () => {
                return _participantLimit;
            },
            set: (value) => {
                let validator = validatorFunctionsByPropertyName['ParticipantLimit'] || (() => true);
                let isValid = validator(value);
                if (isValid === true) {
                    let newValue = RestrictedParticipantLimit ? Math.min(value, Constants.RestrictedParticipantLimit) : value;
                    newValue = MobileParticipantLimit ? Math.min(newValue, Constants.MobileParticipantLimit) : newValue;
                    let didChange = _participantLimit !== newValue;
                    _participantLimit = newValue;
                    if (didChange && eventsByPropertyName['ParticipantLimit']) {
                        this._vidyoCore.EventDispatcher.emit(eventsByPropertyName['ParticipantLimit'], newValue);
                    }
                    if (RestrictedParticipantLimit && value > Constants.RestrictedParticipantLimit) {
                        this._vidyoCore.Controllers.LogController.LogWarning(() => `Your computer has slow performance.` +
                            `It is recommended not to use ParticipantLimit more then "${Constants.RestrictedParticipantLimit}"`);
                    }
                    if (MobileParticipantLimit && value > Constants.MobileParticipantLimit) {
                        this._vidyoCore.Controllers.LogController.LogWarning(() => `It is recommended not to use ParticipantLimit more then "${Constants.MobileParticipantLimit}" on mobile devices`);
                    }
                }
            }
        });
        (0, AutoPropertyHelper_1.CreateAutoProperties)(AdvancedSettingsTemplate, this, (propertyName) => {
            let _value = template[propertyName];
            return {
                get: () => _value,
                set: (value) => {
                    let validator = validatorFunctionsByPropertyName[propertyName] || (() => true);
                    let isValid = validator(value);
                    if (isValid === true) {
                        let didChange = _value !== value;
                        _value = value;
                        if (didChange && eventsByPropertyName[propertyName]) {
                            this._vidyoCore.EventDispatcher.emit(eventsByPropertyName[propertyName], value);
                        }
                        if (propertyName === 'EnableFixedSimulcastRunnels') {
                            this._vidyoCore.Controllers.LogController.LogWarning(() => `Forcing number of simulcast runnels to ${value} is for testing purpose only.
                 This assumes client under test has enough bandwidth and CPU processing cycles`);
                        }
                    }
                    else {
                        if (!this.Silent) {
                            this._vidyoCore.Controllers.LogController.LogWarning(() => `Cannot assign "${value}" to AdvancedSettings.${propertyName}.${typeof isValid === 'boolean' ? '' : isValid}`);
                        }
                    }
                }
            };
        });
        this._registerEventListeners();
        return super.Initialize();
    }
    _registerEventListeners() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.AdvancedSettingsListeners);
        this._vidyoCore.EventDispatcher.on(AnalyticsEvents.Events.AnalyticsEventSent, EventDispatcher_1.AdvancedSettingsListeners, this._onAnalyticsEventSent);
    }
}
exports.AdvancedSettingsController = AdvancedSettingsController;

},{"../events/AdvancedSettingsEvents":62,"../events/AnalyticsEvents":63,"../events/EventDispatcher":68,"../events/LogEvents":69,"../utils/AutoPropertyHelper":136,"../utils/Constants":138,"../utils/OperatingSystemInfoProvider":154,"./BaseController":35}],33:[function(require,module,exports){
"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsController = exports.AnalyticServiceType = exports.AnalyticsEventTable = exports.EventAction = exports.EventCategory = void 0;
const Constants_1 = require("../../utils/Constants");
const LocalStorageProvider_1 = require("../../utils/LocalStorageProvider");
const BaseController_1 = require("../BaseController");
const GoogleAnalytics_1 = require("./GoogleAnalytics");
const UUID = require("uuid");
var EventCategory;
(function (EventCategory) {
    EventCategory["General"] = "General";
    EventCategory["Renderer"] = "Renderer";
    EventCategory["Conference"] = "Conference";
})(EventCategory = exports.EventCategory || (exports.EventCategory = {}));
var EventAction;
(function (EventAction) {
    EventAction["DeviceInfo"] = "DeviceInfo";
    EventAction["EnableAudioOnlyMode"] = "EnableAudioOnlyMode";
    EventAction["DisableAudioOnlyMode"] = "DisableAudioOnlyMode";
    EventAction["EnableAutoReconnect"] = "EnableAutoReconnect";
    EventAction["DisableAutoReconnect"] = "DisableAutoReconnect";
    EventAction["EnableScreenShareSimulcast"] = "EnableScreenShareSimulcast";
    EventAction["DisableScreenShareSimulcast"] = "DisableScreenShareSimulcast";
    EventAction["EnableVideoSimulcast"] = "EnableVideoSimulcast";
    EventAction["DisableVideoSimulcast"] = "DisableVideoSimulcast";
    EventAction["EnableFixedSimulcastRunnels"] = "EnableFixedSimulcastRunnels";
    EventAction["DisableFixedSimulcastRunnels"] = "DisableFixedSimulcastRunnels";
    EventAction["CreateView"] = "CreateView";
    EventAction["EnableCompositorFixedParticipants"] = "EnableCompositorFixedParticipants";
    EventAction["DisableCompositorFixedParticipants"] = "DisableCompositorFixedParticipants";
    EventAction["ParticipantLimit"] = "ParticipantLimit";
    EventAction["Join"] = "Join";
    EventAction["UserType"] = "UserType";
    EventAction["Reconnect"] = "Reconnect";
    EventAction["Failed"] = "Failed";
    EventAction["End"] = "End";
})(EventAction = exports.EventAction || (exports.EventAction = {}));
class AnalyticsEventTable {
    constructor() {
        this[_a] = {
            [EventAction.DeviceInfo]: true,
            [EventAction.EnableAudioOnlyMode]: true,
            [EventAction.DisableAudioOnlyMode]: true,
            [EventAction.EnableAutoReconnect]: true,
            [EventAction.DisableAutoReconnect]: true,
            [EventAction.EnableScreenShareSimulcast]: true,
            [EventAction.DisableScreenShareSimulcast]: true,
            [EventAction.EnableVideoSimulcast]: true,
            [EventAction.DisableVideoSimulcast]: true,
            [EventAction.EnableFixedSimulcastRunnels]: true,
            [EventAction.DisableFixedSimulcastRunnels]: true
        };
        this[_b] = {
            [EventAction.CreateView]: true,
            [EventAction.EnableCompositorFixedParticipants]: true,
            [EventAction.DisableCompositorFixedParticipants]: true,
            [EventAction.ParticipantLimit]: true
        };
        this[_c] = {
            [EventAction.Join]: true,
            [EventAction.UserType]: true,
            [EventAction.Reconnect]: true,
            [EventAction.Failed]: true,
            [EventAction.End]: true
        };
    }
    fromJson(json) {
        try {
            const settings = JSON.parse(json);
            for (let eventCategory in settings) {
                for (let eventAction in settings[eventCategory]) {
                    if (this.hasOwnProperty(eventCategory) && this[eventCategory].hasOwnProperty(eventAction)) {
                        this[eventCategory][eventAction] = settings[eventCategory][eventAction];
                    }
                }
            }
        }
        catch (err) {
            console.error(err);
        }
    }
    toJson() {
        return JSON.stringify(this);
    }
}
exports.AnalyticsEventTable = AnalyticsEventTable;
_a = EventCategory.General, _b = EventCategory.Renderer, _c = EventCategory.Conference;
var AnalyticServiceType;
(function (AnalyticServiceType) {
    AnalyticServiceType["VIDYO_COREANALYTICSSERVICETYPE_Google"] = "VIDYO_COREANALYTICSSERVICETYPE_Google";
})(AnalyticServiceType = exports.AnalyticServiceType || (exports.AnalyticServiceType = {}));
class AnalyticsController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._googleAnalytics = new GoogleAnalytics_1.default(this._vidyoCore);
    }
    Initialize() {
        const serviceType = AnalyticServiceType.VIDYO_COREANALYTICSSERVICETYPE_Google;
        const serverUrl = Constants_1.GoogleAnalyticsBaseURL;
        const trackingID = Constants_1.GoogleAnalyticsTrackingID;
        return this.Start(serviceType, serverUrl, trackingID).then(() => {
            return super.Initialize();
        });
    }
    Disable() {
        return this.Stop().then(() => {
            return super.Disable();
        });
    }
    ControlEventAction(eventCategory, eventAction, enable) {
        return this._googleAnalytics.ControlEventAction(eventCategory, eventAction, enable);
    }
    GetAnalyticsEventTable() {
        return this._googleAnalytics.GetAnalyticsEventTable();
    }
    Start(serviceType, serverUrl, trackingID) {
        if (serviceType === AnalyticServiceType.VIDYO_COREANALYTICSSERVICETYPE_Google) {
            const gaClientIdStored = LocalStorageProvider_1.LocalStorageProvider.Get(Constants_1.GoogleAnalyticsLocalStorageCIDKey);
            const gaClientId = gaClientIdStored || UUID.v4();
            return this._googleAnalytics.Start(serverUrl, trackingID, gaClientId).then((result) => {
                if (result && !gaClientIdStored) {
                    LocalStorageProvider_1.LocalStorageProvider.Set(Constants_1.GoogleAnalyticsLocalStorageCIDKey, gaClientId);
                }
                return result;
            });
        }
        return Promise.resolve(false);
    }
    Stop() {
        return this._googleAnalytics.Stop();
    }
}
exports.AnalyticsController = AnalyticsController;

},{"../../utils/Constants":138,"../../utils/LocalStorageProvider":146,"../BaseController":35,"./GoogleAnalytics":34,"uuid":11}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AdvancedSettingsEvents = require("../../events/AdvancedSettingsEvents");
const AnalyticsEvents = require("../../events/AnalyticsEvents");
const ConferenceEvents = require("../../events/ConferenceEvents");
const ConnectionEvents = require("../../events/ConnectionEvents");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const GoogleAnalytics_1 = require("../../utils/GoogleAnalytics");
const LocalStorageProvider_1 = require("../../utils/LocalStorageProvider");
const Constants_1 = require("../../utils/Constants");
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
const AnalyticsController_1 = require("./AnalyticsController");
class GoogleAnalytics {
    constructor(_vidyoCore) {
        this._vidyoCore = _vidyoCore;
        this._eventTable = new AnalyticsController_1.AnalyticsEventTable();
        this._enableTrackingEvent = false;
        this._onAnalyticsEventSentChanged = (callback) => {
            this._enableTrackingEvent = typeof callback === 'function';
        };
        this._onEnableAudioOnlyModeChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.EnableAudioOnlyMode);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DisableAudioOnlyMode);
            }
        };
        this._onEnableAutoReconnectChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.EnableAutoReconnect);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DisableAutoReconnect);
            }
        };
        this._onEnableScreenShareSimulcastChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.EnableScreenShareSimulcast);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DisableScreenShareSimulcast);
            }
        };
        this._onEnableVideoSimulcastChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.EnableVideoSimulcast);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DisableVideoSimulcast);
            }
        };
        this._onEnableFixedSimulcastRunnelsChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.EnableFixedSimulcastRunnels);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DisableFixedSimulcastRunnels);
            }
        };
        this._onCreateView = () => {
            const renderMode = this._vidyoCore.Controllers.RendererController.RenderMode;
            const participantLimit = this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit;
            const enableFixedParticipants = this._vidyoCore.Controllers.AdvancedSettingsController.EnableCompositorFixedParticipants;
            this._sendEvent(AnalyticsController_1.EventCategory.Renderer, AnalyticsController_1.EventAction.CreateView, renderMode);
            this._onEnableCompositorFixedParticipantsChanged(enableFixedParticipants);
            this._onParticipantLimitChanged(participantLimit);
        };
        this._onEnableCompositorFixedParticipantsChanged = (isEnabled) => {
            if (isEnabled) {
                this._sendEvent(AnalyticsController_1.EventCategory.Renderer, AnalyticsController_1.EventAction.EnableCompositorFixedParticipants);
            }
            else {
                this._sendEvent(AnalyticsController_1.EventCategory.Renderer, AnalyticsController_1.EventAction.DisableCompositorFixedParticipants);
            }
        };
        this._onParticipantLimitChanged = (participantLimit) => {
            const eventLabel = `${participantLimit}`;
            this._sendEvent(AnalyticsController_1.EventCategory.Renderer, AnalyticsController_1.EventAction.ParticipantLimit, eventLabel);
        };
        this._onConferenceJoined = () => {
            this._sendEvent(AnalyticsController_1.EventCategory.Conference, AnalyticsController_1.EventAction.Join);
            this._sendEvent(AnalyticsController_1.EventCategory.Conference, AnalyticsController_1.EventAction.UserType, 'Guest');
        };
        this._onReconnecting = () => {
            const eventLabel = 'Reconnect requests';
            this._sendEvent(AnalyticsController_1.EventCategory.Conference, AnalyticsController_1.EventAction.Reconnect, eventLabel);
        };
        this._onConferenceFailed = (payload) => {
            const eventLabel = payload.msg || 'Unknown error';
            this._sendEvent(AnalyticsController_1.EventCategory.Conference, AnalyticsController_1.EventAction.Failed, eventLabel);
        };
        this._onDisconnected = (payload) => {
            const eventLabel = payload.msg || 'Unknown error';
            this._sendEvent(AnalyticsController_1.EventCategory.Conference, AnalyticsController_1.EventAction.End, eventLabel);
        };
        if (LocalStorageProvider_1.LocalStorageProvider.Get(Constants_1.GoogleAnalyticsEventTableKey)) {
            this._eventTable.fromJson(LocalStorageProvider_1.LocalStorageProvider.Get(Constants_1.GoogleAnalyticsEventTableKey));
        }
    }
    Start(serverUrl = Constants_1.GoogleAnalyticsBaseURL, trackingID = Constants_1.GoogleAnalyticsTrackingID, clientId) {
        if (GoogleAnalytics_1.GoogleAnalyticsProvider.isDisabled) {
            this._vidyoCore.Controllers.LogController.LogDebug(() => 'Google Analytics disabled');
            return Promise.resolve(false);
        }
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.GoogleAnalyticsListeners);
        this._trackingID = trackingID;
        this._clientId = clientId;
        if (serverUrl) {
            GoogleAnalytics_1.GoogleAnalyticsProvider.baseURL = serverUrl;
        }
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.OnAnalyticsEventSentChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onAnalyticsEventSentChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableAudioOnlyModeChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableAudioOnlyModeChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableAutoReconnectChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableAutoReconnectChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableScreenShareSimulcastChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableScreenShareSimulcastChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableVideoSimulcastChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableVideoSimulcastChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableFixedSimulcastRunnelsChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableFixedSimulcastRunnelsChanged);
        this._vidyoCore.EventDispatcher.on(AnalyticsEvents.Events.CreateView, EventDispatcher_1.GoogleAnalyticsListeners, this._onCreateView);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableCompositorFixedParticipantsChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onEnableCompositorFixedParticipantsChanged);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ParticipantLimitChanged, EventDispatcher_1.GoogleAnalyticsListeners, this._onParticipantLimitChanged);
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.ConferenceJoined, EventDispatcher_1.GoogleAnalyticsListeners, this._onConferenceJoined);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.ConferenceFailed, EventDispatcher_1.GoogleAnalyticsListeners, this._onConferenceFailed);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnecting, EventDispatcher_1.GoogleAnalyticsListeners, this._onReconnecting);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnected, EventDispatcher_1.GoogleAnalyticsListeners, this._onDisconnected);
        this._start();
        this._vidyoCore.Controllers.LogController.LogDebug(() => 'Google Analytics started');
        return Promise.resolve(true);
    }
    Stop() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.GoogleAnalyticsListeners);
        this._vidyoCore.Controllers.LogController.LogDebug(() => 'Google Analytics stoped');
        return Promise.resolve(true);
    }
    ControlEventAction(eventCategory, eventAction, enable) {
        if (this._eventTable[eventCategory].hasOwnProperty(eventAction)) {
            this._eventTable[eventCategory][eventAction] = enable;
            LocalStorageProvider_1.LocalStorageProvider.Set(Constants_1.GoogleAnalyticsEventTableKey, this._eventTable.toJson());
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    GetAnalyticsEventTable() {
        return this._eventTable;
    }
    _sendEvent(eventCategory, eventAction, eventLabel) {
        const emitTrackingEvent = (status) => {
            if (this._enableTrackingEvent) {
                this._vidyoCore.EventDispatcher.emit(AnalyticsEvents.Events.AnalyticsEventSent, {
                    serviceType: AnalyticsController_1.AnalyticServiceType.VIDYO_COREANALYTICSSERVICETYPE_Google,
                    category: eventCategory,
                    action: eventAction,
                    label: eventLabel,
                    status
                });
            }
        };
        if (this._eventTable[eventCategory]?.[eventAction]) {
            const eventString = [eventCategory, eventAction, eventLabel].filter((text) => text).join('::');
            this._vidyoCore.Controllers.LogController.LogDebug(() => `Sending event ${eventString}`);
            return GoogleAnalytics_1.GoogleAnalyticsProvider.SendEvent({
                trackingID: this._trackingID,
                clientId: this._clientId,
                eventCategory,
                eventAction,
                eventLabel
            }).then((status) => {
                emitTrackingEvent(status);
                return status;
            });
        }
        emitTrackingEvent(false);
        this._vidyoCore.Controllers.LogController.LogDebug(() => `Sending event ${eventCategory}::${eventAction} is not allowed`);
        return Promise.resolve(false);
    }
    _start() {
        const osInfo = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.GetOSInfo();
        const browserName = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.BrowserName;
        const browserVersion = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.BrowserVersion;
        const deviceInfo = `${osInfo.OSName} ${osInfo.OSVersion}, ${browserName} ${browserVersion}`;
        const advancedSettings = this._vidyoCore.Controllers.AdvancedSettingsController;
        this._sendEvent(AnalyticsController_1.EventCategory.General, AnalyticsController_1.EventAction.DeviceInfo, deviceInfo);
        this._onEnableAudioOnlyModeChanged(advancedSettings.EnableAudioOnlyMode);
        this._onEnableAutoReconnectChanged(advancedSettings.EnableAutoReconnect);
        this._onEnableFixedSimulcastRunnelsChanged(advancedSettings.EnableFixedSimulcastRunnels);
        this._onEnableScreenShareSimulcastChanged(advancedSettings.EnableScreenShareSimulcast);
        this._onEnableVideoSimulcastChanged(advancedSettings.EnableVideoSimulcast);
    }
}
exports.default = GoogleAnalytics;

},{"../../events/AdvancedSettingsEvents":62,"../../events/AnalyticsEvents":63,"../../events/ConferenceEvents":65,"../../events/ConnectionEvents":66,"../../events/EventDispatcher":68,"../../utils/Constants":138,"../../utils/GoogleAnalytics":144,"../../utils/LocalStorageProvider":146,"../../utils/OperatingSystemInfoProvider":154,"./AnalyticsController":33}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateControllers = exports.BaseController = void 0;
class BaseController {
    constructor(vidyoCore) {
        this._vidyoCore = vidyoCore;
    }
    Disable() {
        return Promise.resolve(true);
    }
    Initialize() {
        return Promise.resolve(undefined);
    }
}
exports.BaseController = BaseController;
function CreateControllers(vidyoCore, controllers) {
    let result = {};
    Object.keys(controllers).forEach(((key) => result[key] =
        new controllers[key](vidyoCore)));
    return result;
}
exports.CreateControllers = CreateControllers;

},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStateController = exports.MediaState = exports.BaseMediaState = void 0;
const CallStateEvents = require("../events/CallStateEvents");
const ConferenceEvents = require("../events/ConferenceEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const BaseController_1 = require("./BaseController");
const EventDispatcher_1 = require("../events/EventDispatcher");
class BaseMediaState {
    constructor() {
        this._name = '<no name>';
    }
    EnableMedia() { return this; }
    StartTransmitting() { return this; }
    StopTransmitting() { return this; }
    toString() {
        return `MediaState.${this._name}`;
    }
}
exports.BaseMediaState = BaseMediaState;
class MediaStateOff extends BaseMediaState {
    constructor() {
        super(...arguments);
        this._name = 'Off';
    }
    EnableMedia() { return exports.MediaState.PreviewOnly; }
    get ShouldRenderMedia() { return false; }
    get ShouldTransmitMedia() { return false; }
}
class MediaStatePreviewOnly extends BaseMediaState {
    constructor() {
        super(...arguments);
        this._name = 'PreviewOnly';
    }
    StartTransmitting() { return exports.MediaState.Transmitting; }
    get ShouldRenderMedia() { return true; }
    get ShouldTransmitMedia() { return false; }
}
class MediaStateTransmitting extends BaseMediaState {
    constructor() {
        super(...arguments);
        this._name = 'Transmitting';
    }
    StopTransmitting() { return exports.MediaState.PreviewOnly; }
    get ShouldRenderMedia() { return true; }
    get ShouldTransmitMedia() { return true; }
}
exports.MediaState = {
    Off: new MediaStateOff(),
    PreviewOnly: new MediaStatePreviewOnly(),
    Transmitting: new MediaStateTransmitting()
};
class CallStateController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._mediaState = exports.MediaState.Off;
    }
    Disable() {
        return super.Disable();
    }
    EnableMedia() { this._transition(this._mediaState.EnableMedia()); }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.CallStateControllerListeners);
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.ConferenceJoined, EventDispatcher_1.CallStateControllerListeners, () => this._startTransmitting());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.CallStateControllerListeners, () => this._stopTransmitting());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnecting, EventDispatcher_1.CallStateControllerListeners, () => this._stopTransmitting());
        return super.Initialize();
    }
    get MediaState() { return this._mediaState; }
    _startTransmitting() { this._transition(this._mediaState.StartTransmitting()); }
    _stopTransmitting() { this._transition(this._mediaState.StopTransmitting()); }
    _transition(nextState) {
        if (nextState !== this._mediaState) {
            this._vidyoCore.EventDispatcher.emit(CallStateEvents.Events.MediaStateTransition, nextState);
            this._mediaState = nextState;
        }
    }
}
exports.CallStateController = CallStateController;

},{"../events/CallStateEvents":64,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/EventDispatcher":68,"./BaseController":35}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConferenceController = void 0;
const CmcpParameters = require("../../models/ConferenceCommandParameters");
const ConferenceEvents = require("../../events/ConferenceEvents");
const ConnectionEvents = require("../../events/ConnectionEvents");
const StatisticsEvents = require("../../events/StatisticsEvents");
const RenderEvents = require("../../events/RenderEvents");
const Constants = require("../../utils/Constants");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const ConferenceDialog_1 = require("./ConferenceDialog");
const ConferenceCommandParameters_1 = require("../../models/ConferenceCommandParameters");
const ConferenceDialogIdentity_1 = require("../../models/ConferenceDialogIdentity");
const Constants_1 = require("../../utils/Constants");
const Source_1 = require("../../models/Source");
const Participant_1 = require("../../models/Participant");
const RendererTypes_1 = require("../../models/RendererTypes");
const SubscriptionDialog_1 = require("./SubscriptionDialog");
const BaseController_1 = require("../BaseController");
const VidyoSimple_1 = require("../../../vidyo_simple_api/VidyoSimple");
const StreamEvents = require("../../events/StreamEvents");
const ConnectionEvents_1 = require("../../events/ConnectionEvents");
const Dialog_1 = require("./Dialog");
const ResourcesManagerEvents = require("../../events/ResourcesManagerEvents");
const NotEqual_1 = require("../../utils/NotEqual");
const ObjectUtils_1 = require("../../utils/ObjectUtils");
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
class ConferenceController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._selfViewPolicy = Constants.DefaultSelfViewPolicy;
        this._staticSources = [];
        this._lastShow = { dynamicShow: null, ssrcMap: {} };
        this._currentDynamicSources = [];
    }
    get ActiveStaticSources() {
        return this._staticSources.filter(val => val.active).map(val => val.ssrc);
    }
    get SelfViewPolicy() {
        return this._selfViewPolicy;
    }
    ActivateParticipantSource(participant, sourceId) {
        this._changeParticipantSourceState(participant, sourceId, true);
    }
    DeactivateParticipantSource(participant, sourceId) {
        this._changeParticipantSourceState(participant, sourceId, false);
    }
    Disable() {
        return super.Disable();
    }
    Initialize() {
        this._nextLocalDialogId = 0;
        this._dialogIdentity = new ConferenceDialogIdentity_1.DialogIdentity();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ConferenceControllerListeners);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaConf, EventDispatcher_1.ConferenceControllerListeners, (payload) => this._onMediaConf(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.JingleAccepted, EventDispatcher_1.ConferenceControllerListeners, (payload) => this._onJingleAccepted(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaSessionStarted, EventDispatcher_1.ConferenceControllerListeners, () => this._onMediaSessionStarted());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.ConferenceControllerListeners, () => this._onDisconnecting());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnecting, EventDispatcher_1.ConferenceControllerListeners, () => this._onReconnecting());
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.VideoResolutionChanged, EventDispatcher_1.ConferenceControllerListeners, () => this._onVideoResolutionChanged());
        this._vidyoCore.EventDispatcher.on(ResourcesManagerEvents.Events.MaxRemoteSourcesChanged, EventDispatcher_1.ConferenceControllerListeners, () => this.UpdateSourcesState());
        this._vidyoCore.Controllers.ParticipantController.ResetParticipantList();
        return Promise.resolve(undefined);
    }
    ShowSource(participantId, ssrc, params) {
        this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.ActivateRemoteSource, { ssrc, participantId });
        this._sendShowSourceCMD(participantId, ssrc, params);
    }
    ShowSourceAuto(participantId, ssrc, params) {
        this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.ActivateRemoteSource, { ssrc, participantId });
        this._sendShowSourceAutoCMD(ssrc, params);
    }
    HideSource(ssrc) {
        this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.DeactivateRemoteSource, { ssrc });
        this._sendHideSourceCMD(ssrc);
    }
    StartConferenceDialog(conferenceJoinData) {
        const ConferenceDialogGroupListeners = 'ConferenceDialogGroupListeners';
        let identity = this._dialogIdentity.Clone(this._generateLocalDialogId());
        this.ConferenceDialog = new ConferenceDialog_1.ConferenceDialog(this._vidyoCore.EventDispatcher, identity.ToObject(), this._vidyoCore.HunterProvider);
        this.ConferenceDialog.Join(conferenceJoinData);
        this._vidyoCore.EventDispatcher.releaseGroup(ConferenceDialogGroupListeners);
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.Reply.Scoped(identity.LocalId), ConferenceDialogGroupListeners, (payload) => {
            if (payload.result !== CmcpParameters.CMCPResultCodes.LMI_CMCPRESULTCODE_OK) {
                this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ConferenceFailed);
            }
        });
    }
    StartParticipantSubscriptionDialog(subscribeData) {
        subscribeData.package = 'participant';
        this.ParticipantDialog = this.StartSubscriptionDialog(subscribeData);
        this.ParticipantDialog.OnNotifyParticipant((notification) => {
            this._onParticipantNotifyMessage(notification);
        });
    }
    StartReceiveBandwidthSubscriptionDialog(subscribeData) {
        subscribeData.package = 'receivebw';
        this.ReceiveBandwidthDialog = this.StartSubscriptionDialog(subscribeData);
        this.ReceiveBandwidthDialog.OnNotifyReceiveBandwidth((notification) => {
            this._onReceiveBandwidthNotifyMessage(notification);
        });
    }
    StartSelectedParticipantSubscriptionDialog(subscribeData) {
        subscribeData.package = 'selectedparticipant';
        this.SelectedParticipantDialog = this.StartSubscriptionDialog(subscribeData);
        this.SelectedParticipantDialog.OnNotifySelectedParticipant((notification) => {
            this._onSelectedParticipantNotifyMessage(notification);
        });
    }
    StartSubscriptionDialog(subscribeData) {
        let identity = this._dialogIdentity.Clone(this._generateLocalDialogId());
        let dialog = new SubscriptionDialog_1.SubscriptionDialog(this._vidyoCore.EventDispatcher, identity.ToObject(), this._vidyoCore.HunterProvider);
        dialog.Subscribe(subscribeData);
        return dialog;
    }
    UpdatePinnedParticipants() {
        const participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants();
        participants.forEach((participant) => {
            if (participant.HasVideoSource()) {
                const ssrc = participant.GetVideoSources()[0].Ssrc[0];
                if (participant.IsPinned) {
                    if (this._staticSources.findIndex((val) => ssrc === val.ssrc) === -1) {
                        this._staticSources.unshift({ ssrc, active: false, participantId: participant.Id });
                    }
                }
                else {
                    if (this._staticSources.findIndex((val) => ssrc === val.ssrc) !== -1) {
                        this._sendHideSourceCMD(ssrc);
                        this._staticSources = this._staticSources.filter((val) => ssrc !== val.ssrc);
                    }
                }
            }
        });
        this.UpdateSourcesState();
        this.SendDynamicShow();
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    UpdateSourcesState() {
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
            const maxRemoteSourcesLimit = this._vidyoCore.Controllers.ResourcesManager.CurrentSourcesLimit;
            this._staticSources.forEach((val, index) => {
                const active = index < maxRemoteSourcesLimit;
                if (val.active !== active) {
                    val.active = active;
                    if (active) {
                        this.ShowSource(val.participantId, val.ssrc);
                    }
                    else {
                        this._sendHideSourceCMD(val.ssrc);
                    }
                }
            });
        }
    }
    GetRequestedShowData(ssrc) {
        if (this._lastShow.ssrcMap[ssrc]) {
            return this._lastShow.ssrcMap[ssrc];
        }
        return null;
    }
    _addParticipant(participantData) {
        const id = participantData.participantUri;
        const origin = id === this._vidyoCore.Controllers.RoomController.RoomUserResourceId() ?
            Participant_1.ParticipantOrigin.Local :
            Participant_1.ParticipantOrigin.Remote;
        this._vidyoCore.Controllers.ParticipantController.CreateParticipant(id, origin, participantData.displayText);
    }
    _onReconnecting() {
        this._lastShow = { dynamicShow: null, ssrcMap: {} };
        this._staticSources = [];
        this._currentDynamicSources = [];
        this._nextLocalDialogId = 0;
        this._dialogIdentity = new ConferenceDialogIdentity_1.DialogIdentity();
        this.ConferenceDialog = undefined;
    }
    _sendHideSourceCMD(ssrc) {
        if (this.ConferenceDialog) {
            this.ConferenceDialog.Show({
                sourceId: +ssrc,
                state: CmcpParameters.SourceState.Off
            });
        }
    }
    _sendShowSourceCMD(participantId, ssrc, params) {
        if (this.ConferenceDialog) {
            this.ConferenceDialog.Show({
                sourceId: +ssrc,
                state: CmcpParameters.SourceState.On,
                params
            });
        }
    }
    _sendShowSourceAutoCMD(ssrc, params) {
        if (this.ConferenceDialog) {
            this.ConferenceDialog.Show({
                sourceId: +ssrc,
                state: CmcpParameters.SourceState.Auto,
                params
            });
        }
    }
    _updateParticipantDuration(participantData) {
        const id = participantData.participantUri;
        const duration = Number(participantData.duration);
        const IsRecording = (duration & 2) === 2;
        const IsHidden = (duration & 4) === 4;
        const IsSelectable = (duration & 8) !== 8;
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(id);
        if (participant) {
            this._vidyoCore.Controllers.ParticipantController.UpdateParticipants([{
                    participantId: id,
                    update: { IsHidden, IsRecording, IsSelectable },
                }]);
        }
    }
    _addSource(participantData, sourceData) {
        const id = participantData.participantUri;
        let paused = false;
        if (sourceData.properties && Array.isArray(sourceData.properties)) {
            const pausedProperty = sourceData.properties.find((val) => val.name === 'paused');
            if (pausedProperty) {
                paused = pausedProperty.value === 'true';
            }
        }
        let source = new Source_1.Source(sourceData.ssrcMap.ssrc.map(function (e) { return e.toString(); }), sourceData.name, sourceData.type, paused);
        if (sourceData.rc && sourceData.rc.id) {
            source.RemoteControlId = sourceData.rc.id;
            if (sourceData.rc.parameters) {
                const rcProps = sourceData.rc.parameters
                    .filter((property) => property.mode === 'nudge')
                    .map((property) => property.id);
                source.HasZoom = rcProps.includes('zoom');
                source.HasPanAndTilt = rcProps.includes('pan') && rcProps.includes('tilt');
            }
        }
        if (sourceData.dyn) {
            source.Dynamic = sourceData.dyn === 'true';
            const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(id);
            if (participant && participant.IsRemote && source.Type === Source_1.SourceMediaType.Audio && !source.Dynamic) {
                this.ShowSource(participant.Id, source.Ssrc[0]);
            }
        }
        if (Source_1.SourceSignalType[sourceData.signal]) {
            source.Signal = Source_1.SourceSignalType[sourceData.signal];
        }
        this._vidyoCore.Controllers.ParticipantController.UpdateParticipantSource(id, source);
        return source;
    }
    _changeParticipantSourceState(participant, sourceId, state) {
        if (participant && participant.IsRemote) {
            this._vidyoCore.Controllers.ParticipantController.UpdateParticipants([{ participantId: participant.Id, update: { Active: true } }]);
            const view = this._vidyoCore.Controllers.RendererController.GetViewBySsrc(sourceId);
            if (participant.HasSource(sourceId)) {
                let height = Constants.DefaultLocalStreamHeight;
                let width = Constants.DefaultLocalStreamWidth;
                if (view && view.position) {
                    height = view.position.height;
                    width = view.position.width;
                }
                this._setSourceProperties({
                    enable: state,
                    framesPerSec: Constants_1.DefaultLocalStreamFrameRate,
                    height,
                    participantId: participant.Id,
                    sourceId,
                    width
                });
            }
        }
    }
    _checkSourcesChanged(participantData) {
        let participant = this._vidyoCore.Controllers.ParticipantController
            .TryGetParticipant(participantData.participantUri);
        if (participant) {
            let sourcesToRemove = [];
            let sources = participant.Sources.filter((participantSource) => {
                if (participantData.sources &&
                    participantData.sources.some((source) => source.idStr === participantSource.Ssrc[0])) {
                    return true;
                }
                sourcesToRemove.push({
                    ssrc: participantSource.Ssrc[0],
                    participantId: participant.Id,
                    type: participantSource.Type
                });
                return false;
            });
            participant.UpdateSources(sources);
            this._removeParticipantSources(sourcesToRemove);
        }
    }
    _ensureIdIsFinalized(action, identity) {
        if (!identity.IsFinalized()) {
            let message = `ConferenceController: Cannot ${action} without a complete DialogIdentity object.
DialogIdentity: ${JSON.stringify(identity, null, 1).replace(/["\n]/g, '')}`;
            throw new Error(message);
        }
    }
    _generateLocalDialogId() {
        this._nextLocalDialogId += 1;
        return this._nextLocalDialogId;
    }
    _isNewSource(participantData, newSource) {
        let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantData.participantUri);
        if (participant) {
            return !participant.HasSource(newSource.idStr);
        }
        else {
            return true;
        }
    }
    _onDisconnecting() {
        this._lastShow = { dynamicShow: null, ssrcMap: {} };
        this._staticSources = [];
        this._currentDynamicSources = [];
        this._nextLocalDialogId = 0;
        this._dialogIdentity = new ConferenceDialogIdentity_1.DialogIdentity();
        this.ConferenceDialog = undefined;
    }
    _onJingleAccepted(payload) {
        this._dialogIdentity.Session = payload.sid;
    }
    _onMediaConf(payload) {
        this._dialogIdentity.Conference = payload.id;
        this._dialogIdentity.Reflector = payload.reflector;
    }
    _onMediaSessionStarted() {
        let params = {
            displayText: this._vidyoCore.Controllers.UserController.UserDisplayName(),
            gm: this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite ? ConferenceCommandParameters_1.GhostMode.Gen : ConferenceCommandParameters_1.GhostMode.NoGen
        };
        this._vidyoCore.Controllers.ConferenceController.StartConferenceDialog(params);
        if (this.ConferenceDialog) {
            this.ConferenceDialog.PromiseToOpen.then(() => {
                const subscriptionDuration = { duration: Constants_1.SubscriptionDialogDuration };
                this._vidyoCore.Controllers.ConferenceController.StartParticipantSubscriptionDialog(subscriptionDuration);
                this._sendFirstDynamicShow();
                this._vidyoCore.Controllers.ConferenceController.StartSelectedParticipantSubscriptionDialog(subscriptionDuration);
                this._vidyoCore.Controllers.ConferenceController.StartReceiveBandwidthSubscriptionDialog({
                    duration: Constants_1.SubscriptionDialogDuration
                });
            });
        }
    }
    _onParticipantNotifyMessage(notification) {
        if (CmcpParameters.IsSourceNotification(notification)) {
            notification.notify.event.participantPackageContent.participants.forEach((participantData) => {
                this._processOnSourceNotification(participantData);
            });
        }
        else if (CmcpParameters.IsLeaveNotification(notification)) {
            notification.notify.event.participantPackageContent.participants.forEach((participant) => {
                this._participantLeave(participant);
            });
        }
        this._updateDynamicSources();
    }
    _onReceiveBandwidthNotifyMessage(notification) {
        this._vidyoCore.Controllers.LogController.LogInfo(() => `Receive bandwidth: ${notification.receiveBw}`);
        let payload = { receiveBw: notification.receiveBw };
        this._vidyoCore.EventDispatcher.emit(StatisticsEvents.Events.ReceiveBandwidthUpdated, payload);
    }
    _onSelectedParticipantNotifyMessage(notification) {
        const selectedParticipantsIds = {};
        if (notification.notify.event.selectedParticipantPackageContent
            && notification.notify.event.selectedParticipantPackageContent.selectedParticipants) {
            notification.notify.event.selectedParticipantPackageContent.selectedParticipants.forEach((selectedParticipant) => {
                selectedParticipantsIds[selectedParticipant.id] = selectedParticipant.generation;
            });
        }
        let participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants();
        let policy = this._vidyoCore.Controllers.ResourcesManager.SelfViewPolicy;
        let selectedCount = 0;
        if (participants.length) {
            let changes = [];
            let i = 0;
            const numberOfSelectedParticipants = Object.keys(selectedParticipantsIds).length;
            let generationNumber = numberOfSelectedParticipants;
            participants.forEach((participant) => {
                if (selectedParticipantsIds.hasOwnProperty(participant.Id)) {
                    participant.Generation = selectedParticipantsIds[participant.Id];
                    if (participant.IsRemote || policy === CmcpParameters.SelfViewPolicy.ShowSelf) {
                        selectedCount++;
                    }
                }
                else {
                    participant.Generation = generationNumber++;
                }
            });
            if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
                participants = participants.sort((p1, p2) => p1.Generation - p2.Generation);
                const dynamicSourcesLimit = this._getDynamicSourcesLimit();
                const audioCount = this._vidyoCore.Controllers.ResourcesManager.AudioCount;
                const count = Math.min(selectedCount, dynamicSourcesLimit);
                participants.forEach((participant) => {
                    let Active = false;
                    if (i < count) {
                        switch (policy) {
                            case CmcpParameters.SelfViewPolicy.HideSelf:
                                Active = participant.IsRemote;
                                break;
                            case CmcpParameters.SelfViewPolicy.ShowSelf:
                                Active = true;
                                break;
                            case CmcpParameters.SelfViewPolicy.ShowSelfIfNoOther:
                                Active = participant.IsRemote;
                                break;
                            default:
                                Active = false;
                                this._vidyoCore.Controllers.LogController.LogError(() => 'WRONG users\'s ACTIVE setting!');
                        }
                        if (Active) {
                            i++;
                        }
                    }
                    participant.Active = Active;
                });
                const notRemoteNotActive = (participant) => !(participant.IsRemote && participant.Active);
                const selfViewOnlyParticipant = policy === CmcpParameters.SelfViewPolicy.ShowSelfIfNoOther;
                if (selfViewOnlyParticipant && participants.every(notRemoteNotActive)) {
                    const localParticipant = participants.filter((participant) => participant.IsLocal)[0];
                    if (localParticipant) {
                        localParticipant.Active = true;
                    }
                }
            }
            this._vidyoCore.Controllers.ParticipantController.UpdateParticipants([]);
            this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.SelectedParticipantsChanged, { participants });
            this._updateDynamicSources();
            if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
                this.SendDynamicShow();
            }
        }
    }
    _onSourceNotification(participantData, sourceData) {
        if (this._isNewSource(participantData, sourceData)) {
            const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantData.participantUri);
            if (!participant) {
                return;
            }
            let source = this._addSource(participantData, sourceData);
            if (!participant.IsLocal
                && source.Type === Source_1.SourceMediaType.Application) {
                this._staticSources.unshift({ ssrc: source.Ssrc[0], active: false, participantId: participant.Id });
                if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
                    this.UpdateSourcesState();
                }
            }
            this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.SourceDetected, {
                ssrc: source.Ssrc[0],
                name: sourceData.name,
                origin: participant.Origin,
                participantId: participantData.participantUri,
                participantName: participantData.displayText,
                type: source.Type
            });
            this._vidyoCore.Controllers.ParticipantController
                .AddParticipantDevice(participantData.participantUri, source.Ssrc[0], sourceData.name, source.Type, source.Paused);
        }
        else {
            this._updateSource(participantData, sourceData);
        }
    }
    _onVideoResolutionChanged() {
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
            this.SendDynamicShow();
            const participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote });
            participants.forEach((participant) => {
                const staticSources = participant.GetApplicationSources();
                if (participant.IsPinned && participant.HasVideoSource()) {
                    staticSources.push(participant.GetVideoSources()[0]);
                }
                staticSources.forEach((appSource) => {
                    const stream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantStreamBySsrc(participant.Id, appSource.Ssrc[0]);
                    if (stream && this._vidyoCore.Controllers.RendererController.VideoResolutions.Has(stream.Id)) {
                        const videoResolution = this._vidyoCore.Controllers.RendererController.VideoResolutions.Get(stream.Id);
                        const sourceId = appSource.Ssrc[0];
                        const show = {
                            sourceId,
                            state: CmcpParameters.SourceState.On,
                            params: {
                                windowSize: { height: videoResolution.ContainerResolution.Height, width: videoResolution.ContainerResolution.Width }
                            }
                        };
                        let staticSrc = this._staticSources.find(s => s.ssrc === sourceId);
                        if (this.ConferenceDialog && staticSrc && staticSrc.active) {
                            this._lastShow.ssrcMap[sourceId] = show.params;
                            this.ConferenceDialog.Show(show);
                        }
                    }
                });
            });
        }
    }
    _participantLeave(participantData) {
        let participant = this._vidyoCore.Controllers.ParticipantController
            .TryGetParticipant(participantData.participantUri);
        if (participant) {
            const sourcesToRemove = participant.Sources.map((source) => ({
                participantId: participant.Id,
                ssrc: source.Ssrc[0],
                type: source.Type
            }));
            this._removeParticipantSources(sourcesToRemove);
        }
        this._vidyoCore.Controllers.ParticipantController.RemoveParticipant(participantData.participantUri);
    }
    _processOnSourceNotification(participantData) {
        if (participantData.event === 'join') {
            this._addParticipant(participantData);
        }
        this._updateParticipantDuration(participantData);
        if (participantData.event === 'update' || participantData.event === 'join') {
            if (participantData.sources) {
                participantData.sources.forEach((sourceData) => {
                    this._onSourceNotification(participantData, sourceData);
                });
            }
            this._checkSourcesChanged(participantData);
        }
    }
    _removeParticipantSources(sourcesToRemove) {
        this._staticSources = this._staticSources.filter((val) => {
            return !sourcesToRemove.find((payload) => +payload.ssrc === +val.ssrc);
        });
        sourcesToRemove.forEach((toRemovePayload) => {
            delete this._lastShow.ssrcMap[toRemovePayload.ssrc];
            this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.SourceRemoved, toRemovePayload);
            this._vidyoCore.Controllers.ParticipantController
                .RemoveParticipantDevice(toRemovePayload.participantId, toRemovePayload.ssrc, toRemovePayload.type);
        });
    }
    _sendFirstDynamicShow() {
        const browserVersion = parseFloat(OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.BrowserVersion);
        let lateVideoSetup = ((OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIOS() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIPadOS()) && browserVersion < 14.0);
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite && !lateVideoSetup) {
            this.SendDynamicShow();
        }
        else {
            if (this.ConferenceDialog && this.ConferenceDialog.State() === Dialog_1.States.Open) {
                let showSelected = {
                    audio: {
                        count: Constants.NumberOfSelectedAudioSources,
                        policy: CmcpParameters.AudioPolicy.LoudestSpeaker
                    }
                };
                this._vidyoCore.HunterProvider.ConferenceShowSelected(this.ConferenceDialog.Identity(), showSelected);
            }
        }
    }
    _setSourceProperties(options) {
        if (options.enable) {
            const params = {
                windowSize: { height: options.height, width: options.width },
                framesPerSec: options.framesPerSec
            };
            this.ShowSource(options.participantId, options.sourceId, params);
        }
        else {
            this.HideSource(options.sourceId);
        }
    }
    _updateSource(participantData, sourceData) {
        const id = participantData.participantUri;
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(id);
        if (participant && participant.IsRemote) {
            let paused = false;
            if (sourceData.properties && Array.isArray(sourceData.properties)) {
                const pausedProperty = sourceData.properties.find((val) => val.name === 'paused');
                if (pausedProperty) {
                    paused = pausedProperty.value === 'true';
                }
            }
            const source = participant.GetSourceBySSrc(sourceData.id.toString());
            if (source && source.Type === Source_1.SourceMediaType.Audio && source.Paused !== paused) {
                if (Source_1.SourceSignalType[sourceData.signal]) {
                    source.Signal = Source_1.SourceSignalType[sourceData.signal];
                }
                source.Paused = paused;
                const microphone = participant.GetDevice(source.Ssrc[0]);
                if (microphone) {
                    this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteMicrophoneStateUpdated, {
                        microphone,
                        participant,
                        state: paused ? VidyoSimple_1.VidyoDeviceState.Paused : VidyoSimple_1.VidyoDeviceState.Resumed
                    });
                }
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TracksChanged, participant.Id);
            }
        }
    }
    SendDynamicShow() {
        const dynamicSourcesLimit = this._getDynamicSourcesLimit();
        const { dynamicShowPayload, ssrcMap } = this._buildDynamicShowPayload(dynamicSourcesLimit);
        this._updateDynamicSources();
        if (this.ConferenceDialog &&
            this.ConferenceDialog.State() === Dialog_1.States.Open &&
            this._needSendDynamicShow(dynamicShowPayload)) {
            this._lastShow.dynamicShow = dynamicShowPayload;
            Object.assign(this._lastShow.ssrcMap, ssrcMap);
            return this._vidyoCore.HunterProvider
                .ConferenceShowSelected(this.ConferenceDialog.Identity(), dynamicShowPayload)
                .then((data) => {
                setTimeout(() => this._vidyoCore.Controllers.ParticipantController.UpdateParticipants([]), 0);
                return data;
            });
        }
        return Promise.resolve(false);
    }
    _buildDynamicShowPayload(sourcesLimit) {
        let videoGenerations = [];
        const ssrcMap = {};
        let i;
        let participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote, IsPinned: false });
        participants = participants.sort((p1, p2) => p1.Generation - p2.Generation);
        const countOfActiveParticipants = sourcesLimit;
        const videoResolutions = this._vidyoCore.Controllers.RendererController.VideoResolutions;
        const sourcesOnCount = Math.min(participants.length, sourcesLimit);
        for (i = 0; i < sourcesOnCount; i++) {
            let width = Constants.DefaultLocalStreamWidth;
            let height = Constants.DefaultLocalStreamHeight;
            if (participants[i]) {
                let resolution = videoResolutions.GetVideoByParticipantId(participants[i].Id);
                if (resolution) {
                    width = resolution.ContainerResolution.Width;
                    height = resolution.ContainerResolution.Height;
                }
            }
            let framesPerSec = 30;
            const videoGeneration = {
                id: i,
                state: CmcpParameters.SourceState.On,
                params: {
                    windowSize: { width, height }
                }
            };
            const videoSrc = participants[i]?.GetVideoSources()?.[0];
            if (videoSrc) {
                ssrcMap[videoSrc.Ssrc[0]] = videoGeneration.params;
            }
            videoGenerations.push(videoGeneration);
        }
        if (this._lastShow.dynamicShow) {
            this._lastShow.dynamicShow.video.generation
                .filter(g => (g.state === CmcpParameters.SourceState.On && g.id >= sourcesOnCount))
                .map((g) => {
                videoGenerations.push({
                    id: g.id,
                    state: CmcpParameters.SourceState.Off
                });
            });
        }
        else {
            let numberOfOffsToSend = Math.max(0, countOfActiveParticipants - participants.length);
            for (let j = 0; j < numberOfOffsToSend; j++) {
                videoGenerations.push({
                    id: i + j,
                    state: CmcpParameters.SourceState.Off
                });
            }
        }
        participants.forEach((participant, index) => {
            if (index >= countOfActiveParticipants) {
                participant.Active = false;
            }
            else if (participant.HasVideoSource() && !participant.Active) {
                participant.Active = true;
            }
        });
        let showSelected = {
            audio: {
                count: this._vidyoCore.Controllers.ResourcesManager.AudioCount,
                policy: CmcpParameters.AudioPolicy.LoudestSpeaker
            },
            video: {
                policy: this.SelfViewPolicy,
                dynamicViewPolicy: CmcpParameters.ViewPolicy.ShowIfNotStaticallyViewed,
                generation: videoGenerations
            },
        };
        return { dynamicShowPayload: showSelected, ssrcMap };
    }
    _getDynamicSourcesLimit() {
        const controllers = this._vidyoCore.Controllers;
        return Math.max(0, controllers.ResourcesManager.CurrentDynamicSourcesLimit - controllers.ParticipantController.PinnedParticipantsCount);
    }
    _needSendDynamicShow(dynamicShowPayload) {
        if (!this._lastShow.dynamicShow) {
            return true;
        }
        if (this._lastShow.dynamicShow.video?.generation?.length !== dynamicShowPayload.video?.generation?.length) {
            return true;
        }
        let needSend = false;
        const Threshold = 0.4;
        dynamicShowPayload.video?.generation.forEach((gen, i) => {
            if (gen.state !== this._lastShow.dynamicShow.video?.generation[i]?.state) {
                needSend = true;
            }
            if ((0, NotEqual_1.NotEqual)(gen.params?.windowSize?.width, this._lastShow.dynamicShow.video?.generation[i]?.params?.windowSize?.width, Threshold) ||
                (0, NotEqual_1.NotEqual)(gen.params?.windowSize?.height, this._lastShow.dynamicShow.video?.generation[i]?.params?.windowSize?.height, Threshold)) {
                needSend = true;
            }
        });
        return needSend;
    }
    _updateDynamicSources() {
        const limit = this._getDynamicSourcesLimit();
        const ssrcToParticipantMap = {};
        const newDynamicSources = [];
        let remoteParticipants = this._vidyoCore.Controllers.ParticipantController
            .GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote })
            .sort((p1, p2) => p1.Generation - p2.Generation);
        if (!this._vidyoCore.Controllers.ResourcesManager.DynamicAudioSourcesDisabled) {
            const dynamicAudioSources = remoteParticipants
                .map((p) => p.GetDynamicAudioSources()
                .map((s) => {
                ssrcToParticipantMap[s.Ssrc[0]] = p.Id;
                return s.Ssrc[0];
            }))
                .flat();
            newDynamicSources.push(...dynamicAudioSources);
        }
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
            const dynamicVideoSources = remoteParticipants
                .map((p) => p.GetVideoSources().map((s) => {
                ssrcToParticipantMap[s.Ssrc[0]] = p.Id;
                return s.Ssrc[0];
            }))
                .flat();
            dynamicVideoSources.length = Math.min(dynamicVideoSources.length, limit + 10);
            newDynamicSources.push(...dynamicVideoSources);
        }
        ObjectUtils_1.default.Difference(this._currentDynamicSources, newDynamicSources).forEach((ssrc) => {
            this._vidyoCore.EventDispatcher.emit(ConferenceEvents.Events.DeactivateRemoteSource, { ssrc });
        });
        ObjectUtils_1.default.Difference(newDynamicSources, this._currentDynamicSources).forEach((ssrc) => {
            this._vidyoCore.EventDispatcher
                .emit(ConferenceEvents.Events.ActivateRemoteSource, { ssrc, participantId: ssrcToParticipantMap[ssrc] });
        });
        this._currentDynamicSources = [...newDynamicSources];
    }
}
exports.ConferenceController = ConferenceController;

},{"../../../vidyo_simple_api/VidyoSimple":192,"../../events/ConferenceEvents":65,"../../events/ConnectionEvents":66,"../../events/EventDispatcher":68,"../../events/RenderEvents":75,"../../events/ResourcesManagerEvents":76,"../../events/StatisticsEvents":78,"../../events/StreamEvents":79,"../../models/ConferenceCommandParameters":91,"../../models/ConferenceDialogIdentity":92,"../../models/Participant":94,"../../models/RendererTypes":96,"../../models/Source":98,"../../utils/Constants":138,"../../utils/NotEqual":151,"../../utils/ObjectUtils":153,"../../utils/OperatingSystemInfoProvider":154,"../BaseController":35,"./ConferenceDialog":38,"./Dialog":39,"./SubscriptionDialog":41}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConferenceDialog = void 0;
const ConferenceEvents = require("../../events/ConferenceEvents");
const DialogBaseState_1 = require("./DialogBaseState");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const Dialog_1 = require("./Dialog");
let AllStates;
class ConferenceDialog extends Dialog_1.Dialog {
    Join(conferenceJoinData) {
        return this._handleStateResult(this._state().Join(this._context, conferenceJoinData));
    }
    Leave(conferenceLeaveData) {
        return this._handleStateResult(this._state().Leave(this._context, conferenceLeaveData));
    }
    Show(conferenceShowData) {
        return this._handleStateResult(this._state().Show(this._context, conferenceShowData));
    }
    ShowSelected(conferenceShowSelectedData) {
        return this._handleStateResult(this._state().ShowSelected(this._context, conferenceShowSelectedData));
    }
    State() { return this._state().Name; }
    Update(conferenceState) {
        return this._handleStateResult(this._state().Update(this._context, conferenceState));
    }
    _initialize() {
        this._transitionTo(AllStates.Closed);
        this._eventDispatcher.on(ConferenceEvents.Events.ConferenceRejected.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, (payload) => {
            void payload;
            this._transitionTo(this._state().AfterReject());
        });
        this._eventDispatcher.on(ConferenceEvents.Events.ConferenceAccepted.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, (payload) => {
            this._transitionTo(this._state().AfterAccept(this._context, payload));
            this._eventDispatcher.emit(ConferenceEvents.Events.ConferenceJoined);
        });
    }
    _handleStateResult(stateResult) {
        this._transitionTo(stateResult.nextState);
        return stateResult.returnValue;
    }
    _state() {
        return this._readonlyState;
    }
    _transitionTo(state) {
        let lastState = this._readonlyState && this._readonlyState.Name;
        this._readonlyState = state;
        this._handleImportantStateTransitions(lastState, state.Name);
    }
}
exports.ConferenceDialog = ConferenceDialog;
class State extends DialogBaseState_1.BaseState {
    constructor() {
        super(...arguments);
        this._dialogName = 'ConferenceDialog';
    }
    AfterAccept(context, payload) {
        return this;
    }
    AfterReject() {
        return this;
    }
    Join(context, conferenceJoinData) {
        return this._invalidAction('join');
    }
    Leave(context, conferenceLeaveData) {
        return this._invalidAction('leave');
    }
    Show(context, conferenceShowData) {
        return this._invalidAction('show');
    }
    ShowSelected(context, conferenceShowSelectedData) {
        return this._invalidAction('show selected');
    }
    Update(context, conferenceState) {
        return this._invalidAction('update');
    }
}
class ClosedState extends State {
    constructor() {
        super(...arguments);
        this.Name = Dialog_1.States.Closed;
    }
    Join(context, commandParameter) {
        return {
            nextState: AllStates.Pending,
            returnValue: context.Commands.ConferenceJoin(context.Identity, commandParameter)
        };
    }
}
class PendingState extends State {
    constructor() {
        super(...arguments);
        this.Name = Dialog_1.States.Pending;
    }
    AfterAccept(context, payload) {
        if (payload && payload.dialogId) {
            context.Identity.RemoteId = payload.dialogId.local;
        }
        return AllStates.Open;
    }
    AfterReject() {
        return AllStates.Terminated;
    }
}
class OpenState extends State {
    constructor() {
        super(...arguments);
        this.Name = Dialog_1.States.Open;
    }
    Leave(context, commandParameter) {
        return {
            nextState: AllStates.Terminated,
            returnValue: context.Commands.ConferenceLeave(context.Identity, commandParameter)
        };
    }
    Show(context, commandParameter) {
        return {
            nextState: this,
            returnValue: context.Commands.ConferenceShow(context.Identity, commandParameter)
        };
    }
    ShowSelected(context, commandParameter) {
        return {
            nextState: this,
            returnValue: context.Commands.ConferenceShowSelected(context.Identity, commandParameter)
        };
    }
    Update(context, commandParameter) {
        return {
            nextState: this,
            returnValue: context.Commands.ConferenceUpdate(context.Identity, commandParameter)
        };
    }
}
class TerminatedState extends State {
    constructor() {
        super(...arguments);
        this.Name = Dialog_1.States.Terminated;
    }
}
AllStates = {
    Closed: new ClosedState(),
    Pending: new PendingState(),
    Open: new OpenState(),
    Terminated: new TerminatedState()
};

},{"../../events/ConferenceEvents":65,"../../events/EventDispatcher":68,"./Dialog":39,"./DialogBaseState":40}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogContext = exports.Dialog = exports.States = void 0;
var States;
(function (States) {
    States["Closed"] = "Closed";
    States["Open"] = "Open";
    States["Pending"] = "Pending";
    States["Terminated"] = "Terminated";
})(States = exports.States || (exports.States = {}));
class Dialog {
    constructor(eventDispatcher, identity, hunterProvider) {
        this._id = identity.LocalId;
        this._eventDispatcher = eventDispatcher;
        this._context = new DialogContext(identity, hunterProvider);
        this.PromiseToOpen = new Promise((resolve, reject) => {
            this._isOpen = resolve;
            this._cannotOpen = reject;
        });
        this._initialize();
    }
    Identity() {
        return this._context.Identity;
    }
    _handleImportantStateTransitions(oldState, newState) {
        if (newState === States.Open) {
            this._isOpen();
        }
        if (newState === States.Terminated && oldState === States.Pending) {
            this._cannotOpen();
        }
    }
    _initialize() { }
}
exports.Dialog = Dialog;
class DialogContext {
    constructor(Identity, Commands) {
        this.Identity = Identity;
        this.Commands = Commands;
    }
}
exports.DialogContext = DialogContext;

},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseState = void 0;
class BaseState {
    constructor() {
        this._dialogName = '<this._dialogName is not defined>';
    }
    _invalidAction(actionName) {
        throw new Error(`CmcpStateError: cannot ${actionName} when ${this._dialogName} is in the '${this.Name}' state`);
    }
}
exports.BaseState = BaseState;

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionDialog = void 0;
const Dialog_1 = require("./Dialog");
const DialogBaseState_1 = require("./DialogBaseState");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const ConferenceEvents = require("../../events/ConferenceEvents");
let AllStates;
class SubscriptionDialog extends Dialog_1.Dialog {
    OnNotifyParticipant(callback) {
        this._eventDispatcher.on(ConferenceEvents.Events.NotifyParticipant.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, callback);
    }
    OnNotifyReceiveBandwidth(callback) {
        this._eventDispatcher.on(ConferenceEvents.Events.NotifyReceiveBandwidth.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, callback);
    }
    OnNotifySelectedParticipant(callback) {
        this._eventDispatcher.on(ConferenceEvents.Events.NotifySelectedParticipant.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, callback);
    }
    State() { return this._state().Name; }
    Subscribe(subscribeData) {
        let subscribe = this._state().Subscribe(this._context, subscribeData);
        this._transitionTo(subscribe.nextState);
        return subscribe.returnValue;
    }
    Unsubscribe(unsubscribeData) {
        let unsubscribe = this._state().Unsubscribe(this._context, unsubscribeData);
        this._transitionTo(unsubscribe.nextState);
        return unsubscribe.returnValue;
    }
    _initialize() {
        this._transitionTo(AllStates.Closed);
        this._eventDispatcher.on(ConferenceEvents.Events.Reply.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, (payload) => {
            this._transitionTo(this._state().AfterSubscribeAck(this._context, payload));
        });
        this._eventDispatcher.on(ConferenceEvents.Events.SubscribeTimeout.Scoped(this._id), EventDispatcher_1.ConnectionControllerListeners, () => {
            this._transitionTo(this._state().AfterSubscribeTimeout());
        });
    }
    _state() {
        return this._readonlyState;
    }
    _transitionTo(state) {
        let lastState = this._readonlyState && this._readonlyState.Name;
        this._readonlyState = state;
        this._handleImportantStateTransitions(lastState, state.Name);
    }
}
exports.SubscriptionDialog = SubscriptionDialog;
class State extends DialogBaseState_1.BaseState {
    constructor() {
        super(...arguments);
        this._dialogName = 'SubscriptionDialog';
    }
    AfterSubscribeAck(context, payload) {
        return this;
    }
    AfterSubscribeTimeout() {
        return this;
    }
    Subscribe(context, subscribeData) {
        return this._invalidAction('subscribe');
    }
    Unsubscribe(context, unsubscribeData) {
        return this._invalidAction('unsubscribe');
    }
}
class ClosedState extends State {
    constructor() {
        super(...arguments);
        this.Name = 'Closed';
    }
    Subscribe(context, subscribeData) {
        let returnValue = context.Commands.Subscribe(context.Identity, subscribeData);
        return {
            nextState: AllStates.Pending,
            returnValue
        };
    }
}
class PendingState extends State {
    constructor() {
        super(...arguments);
        this.Name = 'Pending';
    }
    AfterSubscribeAck(context, payload) {
        if (payload && payload.dialogId) {
            context.Identity.RemoteId = payload.dialogId.remote;
        }
        return AllStates.Open;
    }
    AfterSubscribeTimeout() {
        return AllStates.Terminated;
    }
}
class OpenState extends State {
    constructor() {
        super(...arguments);
        this.Name = 'Open';
    }
    Unsubscribe(context, unsubscribeData) {
        return {
            nextState: AllStates.Terminated,
            returnValue: context.Commands.Unsubscribe(context.Identity, unsubscribeData)
        };
    }
}
class TerminatedState extends State {
    constructor() {
        super(...arguments);
        this.Name = 'Terminated';
    }
}
AllStates = {
    Closed: new ClosedState(),
    Pending: new PendingState(),
    Open: new OpenState(),
    Terminated: new TerminatedState()
};

},{"../../events/ConferenceEvents":65,"../../events/EventDispatcher":68,"./Dialog":39,"./DialogBaseState":40}],42:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionController = void 0;
const AdvancedSettingsEvents = require("../events/AdvancedSettingsEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const StreamEvents = require("../events/StreamEvents");
const Constants = require("../utils/Constants");
const TokenUtils = require("../utils/TokenUtils");
const BaseController_1 = require("./BaseController");
const EventDispatcher_1 = require("../events/EventDispatcher");
const ObjectUtils_1 = require("../utils/ObjectUtils");
const LocationProvider_1 = require("../utils/LocationProvider");
const ConnectionEvents_1 = require("../events/ConnectionEvents");
const OperatingSystemInfoProvider_1 = require("../utils/OperatingSystemInfoProvider");
const VidyoConnector_1 = require("../../vidyo_connector_api/VidyoConnector");
const ReconnectUtils_1 = require("../utils/ReconnectUtils");
const FiniteStateMachine_1 = require("../utils/FiniteStateMachine");
const RendererTypes_1 = require("../models/RendererTypes");
const LogEvents_1 = require("../events/LogEvents");
const ConferenceEvents = require("../events/ConferenceEvents");
const Decorators_1 = require("../utils/Decorators");
class ConnectionController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._disconnectingPromise = null;
        this._reconnectOptions = null;
        this._reflectorsPoolName = null;
    }
    set ReflectorsPoolName(poolName) {
        this._reflectorsPoolName = poolName;
    }
    get ReflectorsPoolName() {
        return this._reflectorsPoolName;
    }
    get HasReflectorsPoolName() {
        return !!this._reflectorsPoolName;
    }
    get ReconnectOptions() {
        return ObjectUtils_1.default.Copy(this._reconnectOptions);
    }
    AddStream(stream) {
        return this._vidyoCore.HunterProvider.AddStream(stream);
    }
    Connect() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ConnectionControllerListeners);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Connected, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onConnected(payload));
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.ConferenceJoined, EventDispatcher_1.ConnectionControllerListeners, () => this._onConferenceJoined());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.ConferenceFailed, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onConferenceFailed(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaConf, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onMediaConf(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.JingleSourceView, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onJingleSourceView(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaSessionFailed, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onMediaSessionFailed(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaSessionEnded, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onMediaSessionEnded(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.SignallingDisconnected, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onSignallingDisconnected(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.SignallingError, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onSignallingDisconnected(payload));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.MediaFailed, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onMediaSessionFailed(ConnectionEvents_1.ConnectionEventsInfo[payload.reason]));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.AuthenticationError, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onSignallingDisconnected(payload));
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableAutoReconnectChanged, EventDispatcher_1.ConnectionControllerListeners, (payload) => this._onEnableAutoReconnectChanged(payload));
        this._vidyoCore.HunterProvider.Connect();
    }
    CreateConnection(options) {
        return Promise.resolve(true);
    }
    CreateHunterConnection(options) {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsBrowserVersionNotSupported()) {
            return Promise.reject(VidyoConnector_1.VidyoConnectorFailReason.BrowserVersionNotSupported);
        }
        const enableScreenShareSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast;
        const enableVideoSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast;
        const defaultOptions = {
            displayName: 'anonymous',
            enableScreenShareSimulcast,
            enableVideoSimulcast,
            host: options.host,
            roomKey: options.roomKey,
            port: Constants.DefaultPort,
            locationTag: this._reflectorsPoolName,
            roomPin: options.roomPin,
            extData: this._vidyoCore.Controllers.AdvancedSettingsController.ExtData,
            extDataType: this._vidyoCore.Controllers.AdvancedSettingsController.ExtDataType,
            secure: true
        };
        options = ObjectUtils_1.default.Merge(defaultOptions, options);
        if (options.credentials && options.credentials.token) {
            options.credentials.password = options.credentials.password || options.credentials.token;
            options.credentials.username = options.credentials.username || TokenUtils.DecodeUserName(options.credentials.token);
        }
        if (options.displayName) {
            if (options.displayName.length > Constants.MaxDisplayNameLength) {
                return Promise.reject(VidyoConnector_1.VidyoConnectorFailReason.InvalidDisplayNameLength);
            }
            this._vidyoCore.Controllers.UserController.SetUserDisplayName(options.displayName);
        }
        this.Session = this._vidyoCore.HunterProvider.CreateClient(options);
        const resourceControllerState = this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite;
        this._vidyoCore.Controllers.ResourcesManager.DynamicShowState = resourceControllerState;
        this._vidyoCore.Controllers.StatisticsController
            .SetClientConnectionStats(options.host, options.port, options.serviceType);
        this._reconnectOptions = options;
        return Promise.resolve(true);
    }
    Disable() {
        return this.Disconnect(ConnectionEvents_1.ConnectionEventsInfo.Disconnecting).then(() => {
            return super.Disable();
        });
    }
    Disconnect(payload) {
        this._reconnectEnable(false);
        this._reconnectOptions = null;
        if (!this._disconnectingPromise) {
            this._vidyoCore.Controllers.ResourcesManager.Stop();
            this._vidyoCore.Controllers.LogController.LogInfo(() => `ConnectionController: Disconnecting - "${payload.msg}"`);
            this._vidyoCore.Controllers.StatisticsController.LogCallSummary();
            this._disconnectingPromise = this._vidyoCore.Controllers.RoomController.LeaveAll()
                .then(() => this._disconnect(payload))
                .catch((err) => {
                const message = 'ConnectionController::__disconnect error during disconnection';
                this._vidyoCore.Controllers.LogController.LogError(err, LogEvents_1.VidyoLogCategory.VidyoClient, message);
                this._disconnect(payload);
                return Promise.resolve();
            });
        }
        return this._disconnectingPromise;
    }
    Initialize() {
        LocationProvider_1.LocationProvider.Initialize();
        window.addEventListener('unload', () => {
            try {
                this.Disconnect(ConnectionEvents_1.ConnectionEventsInfo.Disconnecting);
            }
            catch (e) { }
        });
        this._initReconnectStateMachine();
        return Promise.resolve(undefined);
    }
    Reflector() {
        return this._reflector;
    }
    RemoveStream(stream) {
        return this._vidyoCore.HunterProvider.RemoveStream(stream);
    }
    SendClientStats(stats) {
        this._vidyoCore.HunterProvider.SendClientStats(this._reflector, stats);
    }
    StartMediaExchange() {
        const startEnableMediaTime = new Date();
        return Promise.resolve().then(() => {
            this._vidyoCore.HunterProvider.MediaStart({
                jid: this._vidyoCore.Controllers.RoomController.RoomJid(),
                start: {}
            });
            const enableMediaLatency = new Date().getTime() - startEnableMediaTime.getTime();
            this._vidyoCore.Controllers.StatisticsController.EndpointStatistic.MediaEnableTimeConsumedMs = enableMediaLatency;
            console.log("Start media exchange", enableMediaLatency);
        });
    }
    _disconnect(payload) {
        try {
            this._vidyoCore.HunterProvider.Disconnect();
        }
        catch (err) {
            this._vidyoCore.Controllers.LogController.LogError(err, LogEvents_1.VidyoLogCategory.VidyoClient, 'ConnectionController::__disconnect error during disconnection');
        }
        try {
            this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ConnectionControllerListeners);
        }
        catch (err) {
            this._vidyoCore.Controllers.LogController.LogError(err, LogEvents_1.VidyoLogCategory.VidyoClient, 'ConnectionController::__disconnect error during disconnection');
        }
        this._vidyoCore.Controllers.LogController.LogInfo(() => 'ConnectionController: Disconnected.');
        if (payload.code === ConnectionEvents_1.ConnectionEventsInfo.Disconnecting.code) {
            payload = ConnectionEvents_1.ConnectionEventsInfo.Disconnected;
        }
        this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.Disconnecting);
        this._vidyoCore.EventDispatcher.emitAsync(ConnectionEvents.Events.Disconnected, payload);
        this._disconnectingPromise = null;
    }
    _initReconnectStateMachine() {
        const { AdvancedSettingsController, LogController, RoomController } = this._vidyoCore.Controllers;
        let lastReconnectReason = null;
        let reconnectTimeout = null;
        let reconnectAttempt = 0;
        const state = ReconnectUtils_1.ReconnectState.Idle;
        this._reconnectStateMachine = new FiniteStateMachine_1.FiniteStateMachine(state, LogController, (context) => {
            const reset = () => {
                clearTimeout(reconnectTimeout);
                lastReconnectReason = null;
                reconnectAttempt = 0;
            };
            const onConferenceLost = () => {
                LogController.LogInfo(() => 'AutoReconnect: conference lost');
                this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.ConferenceLost, {
                    lastReason: lastReconnectReason.reasonCode
                });
                this.Disconnect(lastReconnectReason);
                reset();
            };
            return {
                [ReconnectUtils_1.ReconnectState.Idle]: {
                    VIDYO_RECONNECTACTION_Connect: (lastReason) => {
                        LogController.LogInfo(() => 'AutoReconnect: disconnecting');
                        this.Disconnect(lastReason);
                    },
                    VIDYO_RECONNECTACTION_Disable: () => {
                        LogController.LogInfo(() => 'AutoReconnect already disabled');
                    },
                    VIDYO_RECONNECTACTION_Enable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        reset();
                    }
                },
                [ReconnectUtils_1.ReconnectState.Pending]: {
                    VIDYO_RECONNECTACTION_Connect: (lastReason) => {
                        context.State = ReconnectUtils_1.ReconnectState.Connecting;
                        clearTimeout(reconnectTimeout);
                        const reconnectBackoff = AdvancedSettingsController.ReconnectBackoff;
                        const attemptTimeout = reconnectBackoff * Math.pow(2, reconnectAttempt);
                        lastReconnectReason = lastReason;
                        reconnectAttempt++;
                        if (reconnectAttempt > AdvancedSettingsController.MaxReconnectAttempts) {
                            LogController.LogInfo(() => 'AutoReconnect: max number of attempts reached');
                            return context.dispatch(ReconnectUtils_1.ReconnectAction.Disable);
                        }
                        this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.Reconnecting, {
                            attempt: reconnectAttempt,
                            attemptTimeout: attemptTimeout,
                            lastReason: lastReason.reasonCode
                        });
                        LogController.LogInfo(() => `AutoReconnect: attempt ${reconnectAttempt} will start in ${attemptTimeout} seconds`);
                        reconnectTimeout = setTimeout(() => {
                            LogController.LogInfo(() => 'AutoReconnect starting');
                            try {
                                this._vidyoCore.HunterProvider.Disconnect();
                                this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ConnectionControllerListeners);
                                this.CreateHunterConnection(this._reconnectOptions).then(() => {
                                    this.Connect();
                                });
                            }
                            catch (err) {
                                LogController.LogError(err, LogEvents_1.VidyoLogCategory.VidyoClient);
                                context.dispatch(ReconnectUtils_1.ReconnectAction.Reject);
                            }
                        }, attemptTimeout * 1000);
                    },
                    VIDYO_RECONNECTACTION_Disable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Idle;
                        if (lastReconnectReason) {
                            onConferenceLost();
                        }
                    }
                },
                [ReconnectUtils_1.ReconnectState.Connecting]: {
                    VIDYO_RECONNECTACTION_Connect: (lastReason) => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReason);
                    },
                    VIDYO_RECONNECTACTION_CreateRoom: () => {
                        context.State = ReconnectUtils_1.ReconnectState.RoomCreating;
                        RoomController.CreateRoom({
                            token: this._reconnectOptions.roomKey,
                            resourceId: this._reconnectOptions.host
                        }).then(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.EnterRoom);
                        }).catch(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.Reject);
                        });
                    },
                    VIDYO_RECONNECTACTION_Disable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Idle;
                        onConferenceLost();
                    },
                    VIDYO_RECONNECTACTION_Reject: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReconnectReason);
                    }
                },
                [ReconnectUtils_1.ReconnectState.RoomCreating]: {
                    VIDYO_RECONNECTACTION_Disable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Idle;
                        onConferenceLost();
                    },
                    VIDYO_RECONNECTACTION_Connect: (lastReason) => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReason);
                    },
                    VIDYO_RECONNECTACTION_EnterRoom: () => {
                        context.State = ReconnectUtils_1.ReconnectState.RoomEntering;
                        RoomController.Enter(RoomController.CoreRoom).then(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.StartMedia);
                        }).catch(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.Reject);
                        });
                    },
                    VIDYO_RECONNECTACTION_Reject: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReconnectReason);
                    }
                },
                [ReconnectUtils_1.ReconnectState.RoomEntering]: {
                    VIDYO_RECONNECTACTION_Disable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Idle;
                        onConferenceLost();
                    },
                    VIDYO_RECONNECTACTION_StartMedia: () => {
                        context.State = ReconnectUtils_1.ReconnectState.MediaStarting;
                        this.StartMediaExchange().catch(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.Reject);
                        });
                    },
                    VIDYO_RECONNECTACTION_Reject: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        RoomController.LeaveAll().finally(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReconnectReason);
                        });
                    }
                },
                [ReconnectUtils_1.ReconnectState.MediaStarting]: {
                    VIDYO_RECONNECTACTION_Connect: () => {
                        context.dispatch(ReconnectUtils_1.ReconnectAction.Reject);
                    },
                    VIDYO_RECONNECTACTION_Disable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Idle;
                        LogController.LogInfo(() => 'AutoReconnect complete successfully');
                        reset();
                    },
                    VIDYO_RECONNECTACTION_Enable: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.Reconnected);
                        LogController.LogInfo(() => 'AutoReconnect complete successfully');
                        reset();
                    },
                    VIDYO_RECONNECTACTION_Reject: () => {
                        context.State = ReconnectUtils_1.ReconnectState.Pending;
                        RoomController.LeaveAll().finally(() => {
                            context.dispatch(ReconnectUtils_1.ReconnectAction.Connect, lastReconnectReason);
                        });
                    }
                }
            };
        });
    }
    _isReconnectRequired(payload) {
        return ReconnectUtils_1.AutoReconnectStartReasons.includes(payload.reasonCode)
            && this._vidyoCore.Controllers.AdvancedSettingsController.EnableAutoReconnect;
    }
    _onConferenceFailed(payload) {
        if (this._isReconnectRequired(payload)) {
            return this._reconnectStart(payload);
        }
        this.Disconnect(payload);
    }
    _onConferenceJoined() {
        this._reconnectEnable(this._vidyoCore.Controllers.AdvancedSettingsController.EnableAutoReconnect);
        this._vidyoCore.Controllers.ResourcesManager.Start();
    }
    _onConnected(payload) {
        if (this._reconnectStateMachine.State === ReconnectUtils_1.ReconnectState.Connecting) {
            this._reconnectContinue();
        }
    }
    _onEnableAutoReconnectChanged(isEnabled) {
        if (isEnabled) {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'AutoReconnect is enabled by advanced settings');
        }
        else {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'AutoReconnect is disabled by advanced settings');
        }
        this._reconnectEnable(isEnabled);
    }
    _onJingleSourceView(payload) {
        payload.sources.forEach((source) => {
            this._vidyoCore.Controllers.TransmittedStreamController.SetLocalSource(source);
        });
    }
    _onMediaConf(payload) {
        this._reflector = payload.reflector;
        this._vidyoCore.Controllers.RoomController.SetConference(payload.id, payload.displayName);
        payload.properties.forEach((prop) => {
            if (prop.name === "maxSendBandwith") {
                this._vidyoCore.Controllers.LocalStreamController.SetMaxSendBitRate(+prop.value);
                this._vidyoCore.Controllers.LogController.LogInfo(() => `Set maxSendBandwith ${prop.value} accroding to portal setting`);
            }
            else if (prop.name === "maxRecvBandwith") {
                this._vidyoCore.Controllers.TransmittedStreamController.MaxReceiveBandwidth = +prop.value;
                this._vidyoCore.Controllers.LogController.LogInfo(() => `Set maxRecvBandwith ${prop.value} accroding to portal setting`);
            }
        });
    }
    _onMediaSessionEnded(payload) {
        this.Disconnect(payload);
    }
    _onMediaSessionFailed(payload) {
        this.Disconnect(payload);
    }
    _onSignallingDisconnected(payload) {
        if (this._isReconnectRequired(payload)) {
            return this._reconnectStart(payload);
        }
        this.Disconnect(payload);
    }
    _onSignallingError(payload) {
        this.Disconnect(payload);
    }
    _reconnectContinue() {
        this._reconnectStateMachine.dispatch(ReconnectUtils_1.ReconnectAction.CreateRoom);
    }
    _reconnectEnable(isEnabled) {
        if (isEnabled) {
            this._reconnectStateMachine.dispatch(ReconnectUtils_1.ReconnectAction.Enable);
        }
        else {
            this._reconnectStateMachine.dispatch(ReconnectUtils_1.ReconnectAction.Disable);
        }
    }
    _reconnectStart(payload) {
        this._reconnectStateMachine.dispatch(ReconnectUtils_1.ReconnectAction.Connect, payload);
    }
}
__decorate([
    Decorators_1.notImplemented
], ConnectionController.prototype, "CreateConnection", null);
exports.ConnectionController = ConnectionController;

},{"../../vidyo_connector_api/VidyoConnector":181,"../events/AdvancedSettingsEvents":62,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/EventDispatcher":68,"../events/LogEvents":69,"../events/StreamEvents":79,"../models/RendererTypes":96,"../utils/Constants":138,"../utils/Decorators":139,"../utils/FiniteStateMachine":143,"../utils/LocationProvider":147,"../utils/ObjectUtils":153,"../utils/OperatingSystemInfoProvider":154,"../utils/ReconnectUtils":159,"../utils/TokenUtils":167,"./BaseController":35}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceController = void 0;
const ConferenceEvents = require("../events/ConferenceEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const DeviceEvents = require("../events/DeviceEvents");
const RoomEvents = require("../events/RoomEvents");
const Camera_1 = require("../models/device/Camera");
const EventDispatcher_1 = require("../events/EventDispatcher");
const BaseController_1 = require("./BaseController");
const DeviceList_1 = require("../models/device/DeviceList");
const DeviceSelection_1 = require("../models/device/DeviceSelection");
const OperatingSystemInfoProvider_1 = require("../utils/OperatingSystemInfoProvider");
const MediaDevicesProvider_1 = require("../utils/MediaDevicesProvider");
const Microphone_1 = require("../models/device/Microphone");
const Speaker_1 = require("../models/device/Speaker");
const Permission_1 = require("../models/Permission");
const RenderEvents = require("../events/RenderEvents");
const PermissionEvents = require("../events/PermissionEvents");
const VidyoSimple_1 = require("../../vidyo_simple_api/VidyoSimple");
const Constants_1 = require("../utils/Constants");
const TimingProvider_1 = require("../utils/TimingProvider");
const UserMediaProvider_1 = require("../utils/UserMediaProvider");
const Devices_1 = require("../../vidyo_simple_api/Devices");
const Camera_2 = require("../models/device/Camera");
class DeviceController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._deviceDetectionIntervalID = null;
        this._deviceDetectionStarted = false;
        this._deviceSelection = new DeviceSelection_1.DeviceSelection();
        this._localSpeakerSourceState = new Map();
        this._localWindowSharePreviewLabel = 'Self View';
        this._monitorSharePreviewLabel = 'Self View';
        this._systemDefaultMicrophoneSafari = null;
    }
    get DefaultMicrophone() {
        return this._deviceList.Microphones.GetDefaultDevice();
    }
    get RemoteSpeaker() {
        return this._remoteSpeaker;
    }
    AddToRemoteSpeaker(localMicrophoneId, remoteSpeakerId) {
        const localMicrophone = this._deviceList.Microphones.Find(localMicrophoneId);
        if (localMicrophone && this._remoteSpeaker.Id === remoteSpeakerId) {
            return this._vidyoCore.Controllers.LocalStreamController.AddMicrophone(localMicrophone).then(() => {
                return true;
            });
        }
        return Promise.resolve(false);
    }
    AddRemoteMicrophoneToLocalSpeaker(id, mode) {
        if (this._localSpeakerSourceState.get(id) === mode) {
            return Promise.resolve(true);
        }
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const showStatic = mode === Devices_1.VidyoRemoteMicrophoneMode.VIDYO_REMOTEMICROPHONEMODE_Static;
            if (showStatic) {
                this._vidyoCore.Controllers.ConferenceController.ShowSource(participant.Id, id);
            }
            else {
                this._vidyoCore.Controllers.ConferenceController.ShowSourceAuto(participant.Id, id);
            }
            this._vidyoCore.Controllers.LogController.LogInfo(`Remote microphone "${id}" added to selected speaker`);
            this._localSpeakerSourceState.set(id, mode);
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    AllowRemoteCameraControl(cameraId, allow) {
        return this.IsLocalCameraControllable(cameraId);
    }
    ClearLocalCameras() {
        this._deviceList.Cameras.All().forEach((camera) => {
            this._deviceList.Cameras.Remove(camera.Id);
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraRemoved, { camera });
        });
        this._deviceSelection.SelectCamera(undefined);
    }
    ClearLocalMicrophones() {
        this._deviceList.Microphones.All().forEach((microphone) => {
            this._deviceList.Microphones.Remove(microphone.Id);
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneRemoved, { microphone });
        });
        this._deviceSelection.SelectMicrophone(undefined);
    }
    ClearLocalSpeakers() {
        this._deviceList.Speakers.All().forEach((speaker) => {
            this._deviceList.Speakers.Remove(speaker.Id);
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerRemoved, { speaker });
        });
        this._deviceSelection.SelectSpeaker(undefined);
    }
    ControlRemoteCameraCapture(id) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const source = participant.GetSourceBySSrc(id);
            if (source && source.RemoteControlId && participant.FullJID) {
                return Promise.resolve(true);
            }
        }
        return Promise.resolve(false);
    }
    ControlRemoteCameraPTZNudge(id, options) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const camera = participant.GetDevice(id);
            if (camera && participant.FullJID) {
                const [controllableCamera] = participant.GetCameraTableItems();
                if (controllableCamera) {
                    if (!controllableCamera.ControlCapabilities.panTiltHasNudge
                        && !controllableCamera.ControlCapabilities.zoomHasNudge) {
                        this._vidyoCore.Controllers.LogController.LogInfo(() => `Camera "${controllableCamera.Name}" doesn't support nudge commands`);
                        return Promise.resolve(false);
                    }
                    for (let key in options) {
                        const feccMsgOptions = {
                            to: participant.FullJID,
                            fecc: {
                                cameraId: controllableCamera.Id,
                                command: Camera_2.FeccCommand.Nudge
                            }
                        };
                        if (controllableCamera.ControlCapabilities.hasVisca) {
                            feccMsgOptions.fecc.command = Camera_2.FeccCommand.Start;
                            feccMsgOptions.fecc.timeout = Constants_1.FeccMoveDurationMs;
                        }
                        switch (key) {
                            case 'pan':
                                if (!controllableCamera.ControlCapabilities.panTiltHasNudge) {
                                    this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Pan nudge capability`);
                                }
                                if (options.pan < 0) {
                                    feccMsgOptions.fecc.pan = Camera_2.FeccPanControl.Left;
                                }
                                else if (options.pan > 0) {
                                    feccMsgOptions.fecc.pan = Camera_2.FeccPanControl.Right;
                                }
                                break;
                            case 'tilt':
                                if (!controllableCamera.ControlCapabilities.panTiltHasNudge) {
                                    this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Tilt nudge capability`);
                                }
                                if (options.tilt < 0) {
                                    feccMsgOptions.fecc.tilt = Camera_2.FeccTiltControl.Down;
                                }
                                else if (options.tilt > 0) {
                                    feccMsgOptions.fecc.tilt = Camera_2.FeccTiltControl.Up;
                                }
                                break;
                            case 'zoom':
                                if (!controllableCamera.ControlCapabilities.zoomHasNudge) {
                                    this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Zoom nudge capability`);
                                }
                                if (options.zoom < 0) {
                                    feccMsgOptions.fecc.zoom = Camera_2.FeccZoomControl.Out;
                                }
                                else if (options.zoom > 0) {
                                    feccMsgOptions.fecc.zoom = Camera_2.FeccZoomControl.In;
                                }
                                break;
                            default:
                                this._vidyoCore.Controllers.LogController.LogError(() => `Incorrect nudge option: ${key}`);
                                return Promise.resolve(false);
                        }
                        this._vidyoCore.Controllers.MessageController.SendFeccMessage(feccMsgOptions);
                    }
                    return Promise.resolve(true);
                }
            }
        }
        return Promise.resolve(false);
    }
    ControlRemoteCameraPTZStart(id, options) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const camera = participant.GetDevice(id);
            if (camera && participant.FullJID) {
                const [controllableCamera] = participant.GetCameraTableItems();
                if (controllableCamera) {
                    if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove
                        && !controllableCamera.ControlCapabilities.zoomHasContinuousMove) {
                        this._vidyoCore.Controllers.LogController.LogInfo(() => `Camera "${controllableCamera.Name}" doesn't support move commands`);
                        return Promise.resolve(false);
                    }
                    const feccMsgOptions = {
                        to: participant.FullJID,
                        fecc: {
                            cameraId: controllableCamera.Id,
                            command: Camera_2.FeccCommand.Start
                        }
                    };
                    if (options.timeout >= 1000000) {
                        feccMsgOptions.fecc.timeout = options.timeout / 1000000;
                    }
                    else {
                        this._vidyoCore.Controllers.LogController.LogError(() => `Incorrect move timeout: ${options.timeout} - cannot be less then 1ms`);
                        return Promise.resolve(false);
                    }
                    switch (options.direction) {
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_PanLeft:
                            if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Pan move capability`);
                            }
                            feccMsgOptions.fecc.pan = Camera_2.FeccPanControl.Left;
                            break;
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_PanRight:
                            if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Pan move capability`);
                            }
                            feccMsgOptions.fecc.pan = Camera_2.FeccPanControl.Right;
                            break;
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_TiltDown:
                            if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Tilt move capability`);
                            }
                            feccMsgOptions.fecc.tilt = Camera_2.FeccTiltControl.Down;
                            break;
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_TiltUp:
                            if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Tilt move capability`);
                            }
                            feccMsgOptions.fecc.tilt = Camera_2.FeccTiltControl.Up;
                            break;
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_ZoomIn:
                            if (!controllableCamera.ControlCapabilities.zoomHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Zoom move capability`);
                            }
                            feccMsgOptions.fecc.zoom = Camera_2.FeccZoomControl.In;
                            break;
                        case Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_ZoomOut:
                            if (!controllableCamera.ControlCapabilities.zoomHasContinuousMove) {
                                this._vidyoCore.Controllers.LogController.LogWarning(() => `Camera "${controllableCamera.Name}" doesn't provide Zoom move capability`);
                            }
                            feccMsgOptions.fecc.zoom = Camera_2.FeccZoomControl.Out;
                            break;
                        default:
                            this._vidyoCore.Controllers.LogController.LogError(() => `Incorrect move direction: ${options.direction}`);
                            return Promise.resolve(false);
                    }
                    this._vidyoCore.Controllers.MessageController.SendFeccMessage(feccMsgOptions);
                    return Promise.resolve(true);
                }
            }
        }
        return Promise.resolve(false);
    }
    ControlRemoteCameraPTZStop(id) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const camera = participant.GetDevice(id);
            if (camera && participant.FullJID) {
                const [controllableCamera] = participant.GetCameraTableItems();
                if (controllableCamera) {
                    if (!controllableCamera.ControlCapabilities.panTiltHasContinuousMove
                        && !controllableCamera.ControlCapabilities.zoomHasContinuousMove) {
                        this._vidyoCore.Controllers.LogController.LogInfo(() => `Camera "${controllableCamera.Name}" doesn't support move commands`);
                        return Promise.resolve(false);
                    }
                    const feccMsgOptions = {
                        to: participant.FullJID,
                        fecc: {
                            cameraId: controllableCamera.Id,
                            command: Camera_2.FeccCommand.Stop
                        }
                    };
                    this._vidyoCore.Controllers.MessageController.SendFeccMessage(feccMsgOptions);
                    return Promise.resolve(true);
                }
            }
        }
        return Promise.resolve(false);
    }
    CycleCamera() {
        this._checkPreconditions();
        let camera;
        if (this._deviceSelection.Camera.Device) {
            camera = this._deviceList.Cameras.Next(this._deviceSelection.Camera.Device.Id);
        }
        else {
            camera = this._deviceList.Cameras.GetFirstDevice();
        }
        if (camera) {
            this._selectCamera(camera);
        }
    }
    CycleMicrophone() {
        this._checkPreconditions();
        let microphone;
        if (this._deviceSelection.Microphone.Device) {
            microphone = this._deviceList.Microphones.Next(this._deviceSelection.Microphone.Device.Id);
        }
        else {
            microphone = this._deviceList.Microphones.GetFirstDevice();
        }
        if (microphone) {
            this._selectMicrophone(microphone);
        }
    }
    CycleSpeaker() {
        this._checkPreconditions();
        let speaker;
        if (this._deviceSelection.Speaker.Device) {
            speaker = this._deviceList.Speakers.Next(this._deviceSelection.Speaker.Device.Id);
        }
        else {
            speaker = this._deviceList.Speakers.GetFirstDevice();
        }
        if (speaker) {
            this._selectSpeaker(speaker);
        }
    }
    Disable() {
        this.ClearLocalCameras();
        this.ClearLocalMicrophones();
        this.ClearLocalSpeakers();
        return super.Disable();
    }
    get DevicesAreBeingDetected() {
        return this._deviceDetectionStarted;
    }
    GetAudioMuteState() {
        const isMicrophoneHardMuted = this._vidyoCore.Controllers.ModerationController.IsMicrophoneHardMuted;
        return isMicrophoneHardMuted || this._deviceSelection.Microphone.Muted;
    }
    GetCameraControlCapabilities(id) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
        if (participant) {
            const camera = participant.GetDevice(id);
            if (camera) {
                const [controllableTable] = participant.GetCameraTableItems();
                if (controllableTable) {
                    return Promise.resolve(controllableTable.ControlCapabilities);
                }
                return Promise.resolve(camera.ControlCapabilities);
            }
        }
    }
    GetCameraList() {
        return this._deviceList.Cameras.All();
    }
    GetMicrophoneList() {
        return this._deviceList.Microphones.All();
    }
    GetMicrophoneMediaProperties(microphoneId) {
        const microphone = microphoneId ? this._deviceList.Microphones.Find(microphoneId) : this._deviceSelection.Microphone.Device;
        if (microphone) {
            return {
                isDynamic: microphone.SignalType === Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Voice,
                signalType: microphone.SignalType
            };
        }
    }
    GetPreviewLabel(cameraId) {
        let previewLabel = '';
        const camera = this._deviceList.Cameras.Find(cameraId);
        if (camera) {
            previewLabel = camera.PreviewLabel;
        }
        return previewLabel;
    }
    GetRemoteMicrophoneSignalType(microphoneId) {
        const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(microphoneId);
        if (participant) {
            const microphone = participant.Devices[microphoneId];
            if (microphone) {
                return microphone.SignalType;
            }
        }
    }
    GetSelectedDevices() {
        return this._deviceSelection.Simplified;
    }
    GetWindowSharePreviewLabel() {
        return this._localWindowSharePreviewLabel;
    }
    GetMonitorSharePreviewLabel() {
        return this._monitorSharePreviewLabel;
    }
    GetSpeakerList() {
        return this._deviceList.Speakers.All();
    }
    GetSpeakerMuteState() {
        return this._deviceSelection.Speaker.Muted;
    }
    GetVideoMuteState() {
        const isCameraHardMuted = this._vidyoCore.Controllers.ModerationController.IsCameraHardMuted;
        return isCameraHardMuted || !this._deviceSelection.Camera.Enabled;
    }
    Initialize() {
        this._deviceList = {
            Cameras: new DeviceList_1.DeviceList(Camera_1.Camera),
            Microphones: new DeviceList_1.DeviceList(Microphone_1.Microphone),
            Speakers: new DeviceList_1.DeviceList(Speaker_1.Speaker)
        };
        this._mediaDevices = MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.DeviceControllerListeners);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.DeviceControllerListeners, () => this._onDisconnecting());
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.SourceRemoved, EventDispatcher_1.DeviceControllerListeners, (payload) => this._onSourceRemoved(payload));
        this._vidyoCore.EventDispatcher.on(RoomEvents.Events.Entered, EventDispatcher_1.DeviceControllerListeners, (payload) => this._onRoomEntered(payload));
        this._vidyoCore.EventDispatcher.on(RoomEvents.Events.Left, EventDispatcher_1.DeviceControllerListeners, () => this._onRoomLeft());
        return Promise.resolve(undefined);
    }
    IsCameraSelected() {
        return !!this._deviceSelection.Camera.Device;
    }
    IsDefaultCamera(camera) {
        let defCamera = this._deviceList.Cameras.GetDefaultDevice();
        return !!defCamera && !!camera && defCamera.Id === camera.Id && defCamera.Name === camera.Name;
    }
    IsDefaultMicrophone(microphone) {
        let defMicrophone = this._deviceList.Microphones.GetDefaultDevice();
        return !!defMicrophone && !!microphone && defMicrophone.Id === microphone.Id && defMicrophone.Name === microphone.Name;
    }
    IsDefaultSpeaker(speaker) {
        let defSpeaker = this._deviceList.Speakers.GetDefaultDevice();
        return !!defSpeaker && !!speaker && defSpeaker.Id === speaker.Id && defSpeaker.Name === speaker.Name;
    }
    IsLocalCameraControllable(id) {
        return Promise.resolve(false);
    }
    IsMicrophoneSelected() {
        return !!this._deviceSelection.Microphone.Device;
    }
    IsRemoteCameraControllable(id) {
        return this.GetCameraControlCapabilities(id).then((controlCapabilities) => {
            return Object.values(controlCapabilities).some((control) => control);
        });
    }
    IsSpeakerSelected() {
        return !!this._deviceSelection.Speaker.Device;
    }
    RemoteCameraHasPanAndTilt(id) {
        return this.GetCameraControlCapabilities(id).then((controlCapabilities) => {
            if (controlCapabilities) {
                return controlCapabilities.panTiltHasContinuousMove
                    || controlCapabilities.panTiltHasNudge;
            }
            return false;
        });
    }
    RemoteCameraHasZoom(id) {
        return this.GetCameraControlCapabilities(id).then((controlCapabilities) => {
            if (controlCapabilities) {
                return controlCapabilities.zoomHasContinuousMove
                    || controlCapabilities.zoomHasNudge;
            }
            return false;
        });
    }
    RemoveFromRemoteSpeaker(localMicrophoneId, remoteSpeakerId) {
        const localMicrophone = this._deviceList.Microphones.Find(localMicrophoneId);
        if (localMicrophone && this._remoteSpeaker.Id === remoteSpeakerId) {
            return this._vidyoCore.Controllers.LocalStreamController.RemoveMicrophone(localMicrophone).then(() => {
                this._handleMicrophoneUpdate(localMicrophone);
                return true;
            });
        }
        return Promise.resolve(false);
    }
    RemoveRemoteMicrophoneFromLocalSpeaker(id) {
        if (!this._localSpeakerSourceState.has(id)) {
            return Promise.resolve(false);
        }
        this._vidyoCore.Controllers.ConferenceController.HideSource(id);
        this._localSpeakerSourceState.delete(id);
        return Promise.resolve(true);
    }
    SelectAudioContentShareDevice(microphone) {
        this._checkPreconditions();
        let microphoneDevice;
        if (microphone) {
            microphoneDevice = this._deviceList.Microphones.Find(microphone.Id) || undefined;
        }
        this._deviceSelection.SelectAudioContentShare(microphoneDevice);
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.AudioContentDeviceChanged);
    }
    SelectCamera(camera) {
        this._checkPreconditions();
        this._selectCamera(camera);
    }
    SelectDefaultCamera() {
        this._checkPreconditions();
        let camera = this._deviceList.Cameras.GetDefaultDevice();
        if (!camera) {
            camera = this._deviceList.Cameras.GetFirstDevice();
        }
        if (!camera) {
            this._deviceSelection.Camera.Device = null;
        }
        else if (!this._checkDeviceId(camera)) {
            this._selectCamera(camera);
        }
    }
    SelectDefaultMicrophone() {
        this._checkPreconditions();
        let microphone = this._deviceList.Microphones.GetDefaultDevice();
        if (!microphone) {
            microphone = this._deviceList.Microphones.GetFirstDevice();
        }
        if (!microphone) {
            this._deviceSelection.Microphone.Device = null;
        }
        else if (!this._checkDeviceId(microphone)) {
            this._selectMicrophone(microphone);
        }
    }
    SelectDefaultSpeaker() {
        this._checkPreconditions();
        let speaker = this._deviceList.Speakers.GetDefaultDevice();
        if (!speaker) {
            speaker = this._deviceList.Speakers.GetFirstDevice();
        }
        if (!speaker) {
            this._deviceSelection.Camera.Device = null;
        }
        else if (!this._checkDeviceId(speaker)) {
            this._selectSpeaker(speaker);
        }
    }
    SelectMicrophone(microphone) {
        this._checkPreconditions();
        this._selectMicrophone(microphone);
    }
    SelectMonitor(share) {
        if (share) {
            return this._vidyoCore.Controllers.LocalStreamController.StartMonitorShare();
        }
        else {
            this._vidyoCore.Controllers.LocalStreamController.StopMonitorShare();
            return Promise.resolve(true);
        }
    }
    SelectPreviousCamera() {
        let cameraId = this._vidyoCore.Controllers.PersistedSettingsController.SelectedCamera;
        if (cameraId) {
            let camera = this._deviceList.Cameras.Find(cameraId);
            if (camera) {
                this.SelectCamera(camera);
            }
        }
    }
    SelectPreviousMicrophone() {
        let microphoneId = this._vidyoCore.Controllers.PersistedSettingsController.SelectedMicrophone;
        if (microphoneId) {
            let microphone = this._deviceList.Microphones.Find(microphoneId);
            if (microphone) {
                this.SelectMicrophone(microphone);
            }
        }
    }
    SelectPreviousSpeaker() {
        let speakerId = this._vidyoCore.Controllers.PersistedSettingsController.SelectedSpeaker;
        if (speakerId) {
            let speaker = this._deviceList.Speakers.Find(speakerId);
            if (speaker) {
                this.SelectSpeaker(speaker);
            }
        }
    }
    SelectSpeaker(speaker) {
        this._checkPreconditions();
        this._selectSpeaker(speaker);
    }
    SelectVideoContentShareDevice(camera) {
        this._checkPreconditions();
        if (camera) {
            const cameraDevice = this._deviceList.Cameras.Find(camera?.Id) || undefined;
            if (cameraDevice) {
                this._deviceSelection.SelectVideoContentShare(cameraDevice);
                return this._vidyoCore.Controllers.LocalStreamController.StartVideoContentShare();
            }
            return Promise.resolve(false);
        }
        this._deviceSelection.SelectVideoContentShare(undefined);
        this._vidyoCore.Controllers.LocalStreamController.StopVideoContentShare();
        return Promise.resolve(true);
    }
    SelectWindowShare(share) {
        if (share) {
            return this._vidyoCore.Controllers.LocalStreamController.StartWindowShare();
        }
        else {
            this._vidyoCore.Controllers.LocalStreamController.StopWindowShare();
            return Promise.resolve(true);
        }
    }
    SetAspectRatioConstraint(cameraId, aspectRatioWidth, aspectRatioHeight) {
        const camera = this._deviceList.Cameras.Find(cameraId);
        if (camera) {
            camera.AspectRatioConstraints = {
                width: aspectRatioWidth,
                height: aspectRatioHeight
            };
            if (this._isCameraInUse(camera)) {
                this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraConstraintChanged);
            }
        }
    }
    SetAudioMuteState(mute) {
        if (mute === this._deviceSelection.Microphone.Muted) {
            return Promise.resolve(false);
        }
        if (!mute && this._vidyoCore.Controllers.ModerationController.IsMicrophoneHardMuted) {
            return Promise.resolve(false);
        }
        this._deviceSelection.Microphone.Muted = mute;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneMuteStateChanged);
        if (this._deviceSelection.Microphone.Device) {
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneStateUpdated, {
                microphone: this._deviceSelection.Microphone.Device,
                state: mute ? VidyoSimple_1.VidyoDeviceState.Stopped : VidyoSimple_1.VidyoDeviceState.Started
            });
        }
        return Promise.resolve(true);
    }
    SetDefaultCamera(camera) {
        if (camera == null) {
            this._deviceSelection.Camera.Device = null;
        }
        this._deviceList.Cameras.SetDefaultDevice(camera);
    }
    SetDefaultMicrophone(microphone) {
        if (microphone == null) {
            this._deviceSelection.Microphone.Device = null;
        }
        this._deviceList.Microphones.SetDefaultDevice(microphone);
    }
    SetDefaultSpeaker(speaker) {
        if (speaker == null) {
            this._deviceSelection.Speaker.Device = null;
        }
        this._deviceList.Speakers.SetDefaultDevice(speaker);
    }
    SetMaxConstraint(constraints, cameraId) {
        const camera = this._deviceList.Cameras.Find(cameraId);
        if (camera) {
            const newMaxConastraints = {
                height: constraints.height,
                width: constraints.width,
            };
            if (constraints.frameInterval) {
                newMaxConastraints.frameRate = constraints.frameInterval;
            }
            camera.MaxConstraints = newMaxConastraints;
            if (this._isCameraInUse(camera)) {
                this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraConstraintChanged);
            }
        }
    }
    SetMicrophoneSignalType(microphoneId, signalType) {
        const microphone = this._deviceList.Microphones.Find(microphoneId);
        if (microphone && Devices_1.VidyoDeviceAudioSignalType[signalType]) {
            if (microphone.SignalType !== Devices_1.VidyoDeviceAudioSignalType[signalType]) {
                microphone.SignalType = Devices_1.VidyoDeviceAudioSignalType[signalType];
                this._handleMicrophoneUpdate(microphone);
            }
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    SetPreviewLabel(previewLabel, cameraId) {
        const camera = this._deviceList.Cameras.Find(cameraId);
        if (camera) {
            camera.PreviewLabel = previewLabel;
            const selectedCamera = this._deviceSelection.Camera.Device;
            if (selectedCamera && selectedCamera.Id === camera.Id) {
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateLocalViewLabel);
            }
        }
    }
    SetWindowSharePreviewLabel(previewLabel) {
        this._localWindowSharePreviewLabel = previewLabel;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateWindowShareViewLabel);
    }
    SetMonitorSharePreviewLabel(previewLabel) {
        this._monitorSharePreviewLabel = previewLabel;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateMonitorShareViewLabel);
    }
    SetSpeakerMuteState(mute) {
        if (mute === this._deviceSelection.Speaker.Muted) {
            return;
        }
        this._deviceSelection.Speaker.Muted = mute;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerSettingsChanged, this._deviceSelection.Speaker);
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.SpeakerPrivacyChanged, mute);
        if (this._deviceSelection.Speaker.Device) {
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerStateUpdated, {
                speaker: this._deviceSelection.Speaker.Device,
                state: mute ? VidyoSimple_1.VidyoDeviceState.Stopped : VidyoSimple_1.VidyoDeviceState.Started
            });
        }
    }
    SetVideoMuteState(mute) {
        if (mute === this._deviceSelection.Camera.Muted) {
            return Promise.resolve(false);
        }
        if (!mute && this._vidyoCore.Controllers.ModerationController.IsCameraHardMuted) {
            return Promise.resolve(false);
        }
        this._deviceSelection.Camera.Muted = mute;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraSettingsChanged, this._deviceSelection.Camera);
        if (this._deviceSelection.Camera.Device) {
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraStateUpdated, {
                camera: this._deviceSelection.Camera.Device,
                state: mute ? VidyoSimple_1.VidyoDeviceState.Stopped : VidyoSimple_1.VidyoDeviceState.Started
            });
        }
        return Promise.resolve(true);
    }
    SetVideoSuspendedState(suspended) {
        if (this._deviceSelection.Camera.Muted) {
            return;
        }
        if (this._deviceSelection.Camera.Device) {
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraStateUpdated, {
                camera: this._deviceSelection.Camera.Device,
                state: suspended ? VidyoSimple_1.VidyoDeviceState.Suspended : VidyoSimple_1.VidyoDeviceState.Unsuspended
            });
        }
    }
    ShowCameraControl(id, show) {
        return this.IsRemoteCameraControllable(id).then((result) => {
            if (result) {
                const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(id);
                if (participant) {
                    return this._vidyoCore.Controllers.RendererController.ShowCameraControl(participant.Id, show);
                }
            }
            return result;
        });
    }
    StartDeviceDetection() {
        if (!this._deviceDetectionPromise) {
            this._deviceDetectionStarted = true;
            let promise = Promise.resolve();
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                promise = this._initDeviceListForFirefox();
            }
            else {
                promise = this._identifyDeviceListChanges();
            }
            if ('ondevicechange' in this._mediaDevices) {
                this._mediaDevices.ondevicechange = () => {
                    this._identifyDeviceListChanges();
                };
            }
            else {
                this._vidyoCore.Controllers.LogController
                    .LogInfo(() => `ondevicechange not found in MediaDevices. Start polling with ${Constants_1.DeviceDetectionDalay}ms delay`);
                this._deviceDetectionIntervalID = TimingProvider_1.TimingProvider.Interval(Constants_1.DeviceDetectionDalay, () => {
                    this._identifyDeviceListChanges();
                });
            }
            this._deviceDetectionPromise = promise.then(() => {
                return true;
            });
            this._vidyoCore.EventDispatcher.on(PermissionEvents.Events.PermissionUpdated, ({ permission, granted }) => {
                if ((permission === Permission_1.PermissionType.camera || permission === Permission_1.PermissionType.microphone) && granted) {
                    this._identifyDeviceListChanges();
                }
            });
        }
        return this._deviceDetectionPromise;
    }
    _checkDeviceId(device) {
        return !!this._deviceSelection[device.Type].Device && this._deviceSelection[device.Type].Device.Id === device.Id;
    }
    _checkPreconditions() {
        if (!this._deviceDetectionStarted) {
            throw new Error('This method does nothing unless StartDeviceDetection is called first');
        }
    }
    _identifyDeviceListChanges() {
        return this._mediaDevices.enumerateDevices().then((devices) => {
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
                devices.sort((a, b) => a.deviceId === UserMediaProvider_1.UserMediaProvider.DefaultCameraDeviceId ? 1 : -1);
            }
            this._deviceList.Cameras.All().forEach((camera) => {
                if (!devices.some((device) => device.kind === 'videoinput' &&
                    device.deviceId === camera.Id && device.label === camera.Name)) {
                    this._onCameraRemoved(camera);
                    this._deviceList.Cameras.Remove(camera.Id);
                    this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraUnplugged, { camera });
                }
            });
            this._deviceList.Microphones.All().forEach((microphone) => {
                if (!devices.some((device) => device.kind === 'audioinput' &&
                    device.deviceId === microphone.Id && device.label === microphone.Name)) {
                    if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && microphone.Id === 'default') {
                        return;
                    }
                    this._onMicrophoneRemoved(microphone);
                    this._deviceList.Microphones.Remove(microphone.Id);
                    if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsAndroid() && this.DefaultMicrophone === false) {
                        this._deviceList.Microphones.All().forEach((mic) => {
                            if (!mic.Name.toLowerCase().includes('earpiece')) {
                                this._deviceList.Microphones.SetDefaultDevice(mic);
                            }
                        });
                    }
                    this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneUnplugged, { microphone });
                }
            });
            this._deviceList.Speakers.All().forEach((speaker) => {
                if (!devices.some((device) => device.kind === 'audiooutput' &&
                    device.deviceId === speaker.Id && device.label === speaker.Name)) {
                    if ((OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) && speaker.Id === 'default') {
                        return;
                    }
                    this._deviceList.Speakers.Remove(speaker.Id);
                    this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerUnplugged, { speaker });
                }
            });
            if (!this._deviceList.Speakers.All().length) {
                this._vidyoCore.Controllers.LogController.LogDebug(() => 'Reset speaker selection due to no devices in the speaker list');
                this._deviceSelection.SelectSpeaker(undefined);
            }
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
                const systemDefaultMicrophone = devices.find((d) => d.kind === 'audioinput') || null;
                if (systemDefaultMicrophone?.deviceId) {
                    if (this._systemDefaultMicrophoneSafari &&
                        this._systemDefaultMicrophoneSafari.deviceId !== systemDefaultMicrophone.deviceId) {
                        const microphone = this._deviceList.Microphones.Find('default');
                        if (microphone) {
                            this._onMicrophoneRemoved(microphone);
                            this._deviceList.Microphones.Remove(microphone.Id);
                            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneUnplugged, { microphone });
                        }
                    }
                    const microphone = this._deviceList.Microphones.Add(`Default - ${systemDefaultMicrophone.label}`, 'default');
                    if (microphone) {
                        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneAdded, { microphone });
                    }
                }
                this._systemDefaultMicrophoneSafari = systemDefaultMicrophone;
            }
            let needFakeDefaultSpeaker = !this._deviceList.Speakers.Find('default');
            devices.forEach((device) => {
                if (!device.deviceId || !device.label) {
                    return;
                }
                switch (device.kind) {
                    case 'videoinput':
                        let camera = this._deviceList.Cameras.Add(device.label, device.deviceId);
                        if (camera) {
                            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraAdded, { camera });
                        }
                        break;
                    case 'audioinput':
                        let microphone = this._deviceList.Microphones.Add(device.label, device.deviceId);
                        if (microphone) {
                            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneAdded, { microphone });
                        }
                        break;
                    case 'audiooutput':
                        let speaker = this._deviceList.Speakers.Add(device.label, device.deviceId);
                        if (speaker) {
                            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerAdded, { speaker });
                        }
                        needFakeDefaultSpeaker = false;
                        break;
                    default:
                        break;
                }
            });
            if (needFakeDefaultSpeaker) {
                const speaker = this._deviceList.Speakers.Add('Default', 'default');
                if (speaker) {
                    this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerAdded, { speaker });
                }
            }
        });
    }
    _initDeviceListForFirefox() {
        return this._mediaDevices.enumerateDevices().then((devices) => {
            const constraints = {
                audio: false,
                video: false
            };
            devices.forEach((device) => {
                if (UserMediaProvider_1.UserMediaProvider.Constraints.audio && device.kind === 'audioinput') {
                    constraints.audio = true;
                }
                if (UserMediaProvider_1.UserMediaProvider.Constraints.video && device.kind === 'videoinput') {
                    constraints.video = true;
                }
            });
            return this._mediaDevices.getUserMedia(constraints);
        }).then((stream) => {
            return this._identifyDeviceListChanges().then(() => {
                stream.getTracks().forEach((track) => track.stop());
            });
        }).catch(() => {
            return this._identifyDeviceListChanges();
        });
    }
    _isCameraInUse(camera) {
        const selectedCamera = this._deviceSelection.Camera.Device;
        const selectedVideoContent = this._deviceSelection.VideoContent.Device;
        return (selectedCamera && selectedCamera.Id === camera.Id) || (selectedVideoContent && selectedVideoContent.Id === camera.Id);
    }
    _handleMicrophoneUpdate(microphone) {
        if (microphone.Id === this._deviceSelection.Microphone.Device?.Id) {
            this._vidyoCore.Controllers.LocalStreamController.StartOrStopAudio();
        }
        if (microphone.Id === this._deviceSelection.AudioContent.Device?.Id) {
            this._vidyoCore.Controllers.LocalStreamController.StartOrStopAudioContentShare();
        }
    }
    _onDisconnecting() {
        this._localSpeakerSourceState.clear();
    }
    _onCameraRemoved(camera) {
        let selectetedCamera = this._deviceSelection.Simplified.VideoContent;
        if (typeof selectetedCamera !== 'boolean') {
            if (camera.Id === selectetedCamera.Id) {
                this._deviceSelection.SelectVideoContentShare(undefined);
            }
        }
    }
    _onMicrophoneRemoved(microphone) {
        let selectetedMicrophone = this._deviceSelection.Simplified.AudioContent;
        if (typeof selectetedMicrophone !== 'boolean') {
            if (microphone.Id === selectetedMicrophone.Id) {
                this._deviceSelection.SelectAudioContentShare(undefined);
            }
        }
        if (this._vidyoCore.Controllers.LocalStreamController.IsMicrophoneAddedToRemoteSpeaker(microphone)) {
            this._vidyoCore.Controllers.LocalStreamController.RemoveMicrophone(microphone);
        }
    }
    _onRoomEntered(payload) {
        const speakerId = payload.roomId.toString();
        const spekerName = `RemoteSpeaker_${speakerId}`;
        this._remoteSpeaker = new Speaker_1.Speaker(spekerName, speakerId);
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.RemoteSpeakerAdded, {
            speaker: this._remoteSpeaker
        });
    }
    _onRoomLeft() {
        this._deviceList.Microphones.All().forEach((microphone) => {
            if (this._vidyoCore.Controllers.LocalStreamController.IsMicrophoneAddedToRemoteSpeaker(microphone)) {
                this._vidyoCore.Controllers.LocalStreamController.RemoveMicrophone(microphone).then(() => {
                    this._handleMicrophoneUpdate(microphone);
                });
            }
        });
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.RemoteSpeakerRemoved, {
            speaker: this._remoteSpeaker
        });
        this._remoteSpeaker = null;
    }
    _onSourceRemoved({ ssrc }) {
        if (this._localSpeakerSourceState.has(ssrc)) {
            this._localSpeakerSourceState.delete(ssrc);
        }
    }
    _selectCamera(camera) {
        let cameraDevice;
        if (camera) {
            cameraDevice = this._deviceList.Cameras.Find(camera.Id) || undefined;
        }
        this._deviceSelection.SelectCamera(cameraDevice);
        this._vidyoCore.Controllers.LocalStreamController.SetCameraBWRestrictionState(false);
        this._vidyoCore.Controllers.PersistedSettingsController.SelectedCamera = cameraDevice ? cameraDevice.Id : null;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraSettingsChanged, this._deviceSelection.Camera);
        const payload = cameraDevice ? { camera: cameraDevice } : undefined;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.CameraSelected, payload);
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateLocalViewLabel);
    }
    _selectMicrophone(microphone) {
        const prevDevice = this._deviceSelection.Microphone.Device;
        this._deviceSelection.SelectMicrophone(microphone);
        this._vidyoCore.Controllers.PersistedSettingsController.SelectedMicrophone = microphone ? microphone.Id : null;
        if (prevDevice !== microphone) {
            this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneChanged);
        }
        let microphoneDevice;
        if (microphone) {
            microphoneDevice = this._deviceList.Microphones.Find(microphone.Id) || undefined;
        }
        const payload = microphoneDevice ? { microphone: microphoneDevice } : undefined;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.MicrophoneSelected, payload);
    }
    _selectSpeaker(speaker) {
        this._vidyoCore.Controllers.PersistedSettingsController.SelectedSpeaker = speaker ? speaker.Id : null;
        if (speaker) {
            this._deviceSelection.SelectSpeaker(speaker);
        }
        let speakerDevice;
        if (speaker) {
            speakerDevice = this._deviceList.Speakers.Find(speaker.Id) || undefined;
        }
        const payload = speakerDevice ? { speaker: speakerDevice } : undefined;
        this._vidyoCore.EventDispatcher.emit(DeviceEvents.Events.SpeakerSelected, payload);
    }
}
exports.DeviceController = DeviceController;

},{"../../vidyo_simple_api/Devices":184,"../../vidyo_simple_api/VidyoSimple":192,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/DeviceEvents":67,"../events/EventDispatcher":68,"../events/PermissionEvents":74,"../events/RenderEvents":75,"../events/RoomEvents":77,"../models/Permission":95,"../models/device/Camera":101,"../models/device/DeviceList":103,"../models/device/DeviceSelection":104,"../models/device/Microphone":105,"../models/device/Speaker":106,"../utils/Constants":138,"../utils/MediaDevicesProvider":148,"../utils/OperatingSystemInfoProvider":154,"../utils/TimingProvider":166,"../utils/UserMediaProvider":168,"./BaseController":35}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogRecord = exports.LogController = void 0;
const BaseController_1 = require("../BaseController");
const LogEvents_1 = require("../../events/LogEvents");
const Constants_1 = require("../../utils/Constants");
const VidyoInsightsProvider_1 = require("../../utils/VidyoInsightsProvider");
const AdvancedSettingsEvents_1 = require("../../events/AdvancedSettingsEvents");
const json_decycle_1 = require("json-decycle");
const VidyoDebugger_1 = require("../../utils/VidyoDebugger");
const EventListFactory_1 = require("../../utils/EventListFactory");
const Constants_2 = require("../../utils/Constants");
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
const StringUtils_1 = require("../../utils/StringUtils");
const LogLevelParser_1 = require("./LogLevelParser");
class LogController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._logLevelFilterSDK = {};
        this._logLevelFilterApp = {};
        this._logLevelFilterDebug = {};
        this._logRecords = [];
        this._vidyoInsightsProvider = null;
        this._vidyoInsightsPushInterval = null;
        this._vidyoInsightsHandle = null;
        this._visibilityListener = () => {
            if (document.visibilityState === 'hidden' && this._vidyoInsightsProvider) {
                const logString = '*** Tab became inactive ***';
                const logRecord = this._getLogRecord(LogEvents_1.LogEventDebug, LogEvents_1.VidyoLogCategory.VidyoClient, LogEvents_1.VidyoLogLevel.debug, logString);
                this._pushToVidyoInsights([...this._logRecords, logRecord], true).then(() => {
                    if (this._logRecords.length) {
                        this._logRecords = [];
                    }
                });
            }
        };
    }
    Disable() {
        this._unregisterVisibilityListener();
        return super.Disable();
    }
    DisableDebug() {
        this.SetLogLevelDebug('');
    }
    EnableDebug(logFilter) {
        this.SetLogLevelDebug(logFilter);
        return Promise.resolve(true);
    }
    Initialize() {
        VidyoDebugger_1.VidyoDebugger.Initialize(this._vidyoCore);
        this._registerVisibilityListener();
        return Promise.resolve(undefined);
    }
    IsLevelAndCategoryEnabled(level, category) {
        if (this._logLevelFilterSDK && this._logLevelFilterSDK[category] && (this._logLevelFilterSDK[category] & level) !== 0) {
            return true;
        }
        if ((this._logLevelFilterApp[category] & level) !== 0) {
            return true;
        }
        if ((this._logLevelFilterDebug[category] & level) !== 0) {
            true;
        }
        return false;
    }
    LogFatal(error, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.fatal, error, vidyoLogCategory, logEventName);
    }
    LogError(error, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.error, error, vidyoLogCategory, logEventName);
    }
    LogWarning(warning, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.warning, warning, vidyoLogCategory, logEventName);
    }
    LogInfo(info, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.info, info, vidyoLogCategory, logEventName);
    }
    LogDebug(verbose, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.debug, verbose, vidyoLogCategory, logEventName);
    }
    LogReceived(receivedInfo, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.received, receivedInfo, vidyoLogCategory, logEventName);
    }
    LogSent(sentInfo, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.sent, sentInfo, vidyoLogCategory, logEventName);
    }
    LogEnter(enterInfo, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.enter, enterInfo, vidyoLogCategory, logEventName);
    }
    LogLeave(leaveInfo, vidyoLogCategory, logEventName) {
        this._log(LogEvents_1.VidyoLogLevel.leave, leaveInfo, vidyoLogCategory, logEventName);
    }
    SetLogLevelSDK(logLevel) {
        LogLevelParser_1.LogLevelParser.ParseLogLevelFilter(logLevel, this._logLevelFilterSDK);
        this._vidyoCore.EventDispatcher.emit(AdvancedSettingsEvents_1.Events.LogCategoryChanged, this.GetLogLevelSDK());
    }
    GetLogLevelSDK() {
        return this._logLevelFilterSDK;
    }
    SetLogLevelApp(logLevel) {
        LogLevelParser_1.LogLevelParser.ParseLogLevelFilter(logLevel, this._logLevelFilterApp);
    }
    SetLogLevelDebug(logLevel) {
        LogLevelParser_1.LogLevelParser.ParseLogLevelFilter(logLevel, this._logLevelFilterDebug);
    }
    SetPushOptions(options) {
        if (options.enabled) {
            if (!StringUtils_1.default.isValidURL(options.pushURL)) {
                this.LogError('Invalid push URL');
                return Promise.resolve(false);
            }
            if (!options.pushURL.match(/http(s)?:\/\//)) {
                options.pushURL = 'https://' + options.pushURL;
            }
            this._vidyoInsightsPushInterval = Constants_1.LogsPushIntervalDefault;
            if (typeof options.pushInterval === 'number') {
                if (options.pushInterval === 0) {
                    this.LogInfo(() => 'Enable real-time logging to remote server');
                }
                else if (options.pushInterval < Constants_1.LogsPushIntervalMin) {
                    this.LogWarning(() => `Push interval cannot be less than ${Constants_1.LogsPushIntervalMin}ms. The minimum acceptable value applied`);
                    options.pushInterval = Constants_1.LogsPushIntervalMin;
                }
                else if (options.pushInterval > Constants_1.LogsPushIntervalMax) {
                    this.LogWarning(() => `Push interval cannot be more than ${Constants_1.LogsPushIntervalMax}ms. The maximun acceptable value applied`);
                    options.pushInterval = Constants_1.LogsPushIntervalMax;
                }
                this._vidyoInsightsPushInterval = options.pushInterval;
            }
            this._startSendingToVidyoInsights(options);
        }
        else {
            this._stopSendingToVidyoInsights();
        }
        return Promise.resolve(true);
    }
    UpdateEndpointId(endpointId) {
        this._endpointId = endpointId;
    }
    UpdateUserId(userId) {
        this._userId = userId;
    }
    _getLogRecord(logEvent, logCategory, logLevel, payload, traceInfo = this._parseStackTrace(3), logEventName) {
        const spacing = 2;
        const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload, (0, json_decycle_1.decycle)(), spacing);
        return new LogRecord(logCategory, Date.now(), traceInfo.fileName, traceInfo.functionName, LogEvents_1.VidyoLogLevel[logLevel], traceInfo.lineNumber, payloadString, logEventName || logEvent.toString(), 'Execute Main Thread', this._endpointId);
    }
    _log(logLevel, payloadData, logCategory = LogEvents_1.VidyoLogCategory.VidyoClient, logEventName) {
        if (this._logLevelFilterSDK && this._logLevelFilterSDK[logCategory] && (this._logLevelFilterSDK[logCategory] & logLevel) !== 0) {
            let logEventSDK = LogEvents_1.LogEventsSDK[LogEvents_1.VidyoLogLevel[logLevel]];
            if (!logEventSDK) {
                logEventSDK = new EventListFactory_1.EventDescriptor(LogEvents_1.VidyoLogLevel[LogEvents_1.VidyoLogLevel.error]);
            }
            this._logEvent(logEventSDK, logCategory, logLevel, payloadData, logEventName);
        }
        if ((this._logLevelFilterApp[logCategory] & logLevel) !== 0) {
            this._logEvent(LogEvents_1.LogEventApp, logCategory, logLevel, payloadData, logEventName);
        }
        if ((this._logLevelFilterDebug[logCategory] & logLevel) !== 0) {
            this._logEvent(LogEvents_1.LogEventDebug, logCategory, logLevel, payloadData, logEventName);
        }
    }
    _logEvent(logEvent, logCategory, logLevel, payloadData, logEventName) {
        const traceInfo = this._parseStackTrace();
        const spacing = 2;
        let payload = payloadData;
        if (typeof payloadData === 'function') {
            payload = payloadData();
        }
        if (payload instanceof Error) {
            payload = {
                name: payload.name,
                message: payload.message
            };
        }
        else if (window['OverconstrainedError'] && payload instanceof OverconstrainedError) {
            payload = {
                name: payload.name,
                message: payload.message,
                constraint: payload.constraint
            };
        }
        let payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload, (0, json_decycle_1.decycle)(), spacing);
        const logRecord = new LogRecord(logCategory, Date.now(), traceInfo.fileName, traceInfo.functionName, LogEvents_1.VidyoLogLevel[logLevel], traceInfo.lineNumber, payloadString, logEventName || logEvent.toString(), 'Execute Main Thread', this._endpointId);
        if (this._vidyoInsightsProvider) {
            if (this._vidyoInsightsPushInterval > 0) {
                this._logRecords.push(logRecord);
            }
            else {
                this._pushToVidyoInsights([...this._logRecords, logRecord]).then(() => {
                    if (this._logRecords.length) {
                        this._logRecords = [];
                    }
                }).catch((err) => {
                    console.error(err);
                });
            }
        }
        else {
            this._vidyoCore.EventDispatcher.emit(logEvent, logRecord);
        }
    }
    _parseStackTrace(callerDescriptionIdx = 5) {
        let functionName = 'anonymous function';
        let fileName = 'unknown fileName';
        let lineNumber = '0';
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsChrome()) {
            let error = new Error();
            try {
                if (error.stack) {
                    let callerStack = error.stack.split('\n');
                    if (callerStack && callerStack.length > callerDescriptionIdx) {
                        let callerDescription = callerStack[callerDescriptionIdx].split(' (');
                        let fileInfoDescriptionIdx = 0;
                        if (callerDescription.length > 1) {
                            functionName = callerDescription[0].split('at ')[1];
                            fileInfoDescriptionIdx = 1;
                        }
                        let fileInfoDescription = callerDescription[fileInfoDescriptionIdx].split('/');
                        let fileDescription = fileInfoDescription[fileInfoDescription.length - 1].split(':');
                        fileName = fileDescription[0];
                        lineNumber = fileDescription[1];
                    }
                }
            }
            catch (e) {
            }
        }
        return new LoggerTraceInfo(fileName, functionName, parseInt(lineNumber, Constants_2.BaseTenRadix));
    }
    _unregisterVisibilityListener() {
        document.removeEventListener('visibilitychange', this._visibilityListener);
    }
    _registerVisibilityListener() {
        document.addEventListener('visibilitychange', this._visibilityListener);
    }
    _pushToVidyoInsights(logRecords, keepAlive) {
        if (this._vidyoInsightsProvider && logRecords.length) {
            const stream = {
                EventType: 'WebRTCClientLogs'
            };
            const localParticipant = this._vidyoCore.Controllers.ParticipantController.GetLocalParticipant();
            if (localParticipant && localParticipant.Id) {
                stream.ClientParticipantId = localParticipant.Id;
            }
            if (this._vidyoCore.Controllers.ConnectionController.Reflector()) {
                stream.ClientRouterName = this._vidyoCore.Controllers.ConnectionController.Reflector();
            }
            if (this._vidyoCore.Controllers.RoomController.GetConference()) {
                stream.ClientConferenceId = this._vidyoCore.Controllers.RoomController.GetConference();
            }
            if (this._endpointId) {
                stream.ClientEndpointId = this._endpointId;
            }
            if (this._userId) {
                stream.ClientUserId = this._userId;
            }
            return this._vidyoInsightsProvider.push(stream, logRecords, keepAlive);
        }
        return Promise.resolve(false);
    }
    _startSendingToVidyoInsights(options) {
        this._vidyoInsightsProvider = new VidyoInsightsProvider_1.VidyoInsightsProvider(options.pushURL, options.trackingID);
        this.LogDebug(() => '*** Push logs started ***');
        if (this._vidyoInsightsPushInterval > 0) {
            const pushNext = () => {
                clearTimeout(this._vidyoInsightsHandle);
                if (this._vidyoInsightsProvider) {
                    this._pushToVidyoInsights([...this._logRecords]).then(() => {
                        this._logRecords = [];
                    }).finally(() => {
                        this._vidyoInsightsHandle = window.setTimeout(() => {
                            pushNext();
                        }, this._vidyoInsightsPushInterval);
                    });
                }
            };
            pushNext();
        }
    }
    _stopSendingToVidyoInsights() {
        clearTimeout(this._vidyoInsightsHandle);
        const logString = '*** Push logs stopped ***';
        const logRecord = this._getLogRecord(LogEvents_1.LogEventDebug, LogEvents_1.VidyoLogCategory.VidyoClient, LogEvents_1.VidyoLogLevel.debug, logString);
        this._pushToVidyoInsights([logRecord]).catch(console.error);
        this._logRecords.forEach((logRecord) => {
            this._vidyoCore.EventDispatcher.emit(new EventListFactory_1.EventDescriptor(logRecord.name), logRecord);
        });
        this._vidyoInsightsPushInterval = null;
        this._vidyoInsightsProvider = null;
        this._vidyoInsightsHandle = null;
        this._logRecords = [];
    }
}
exports.LogController = LogController;
class LoggerTraceInfo {
    constructor(fileName, functionName, lineNumber) {
        this.fileName = fileName;
        this.functionName = functionName;
        this.lineNumber = lineNumber;
    }
}
class LogRecord {
    constructor(categoryName, eventTime, file, functionName, level, line, message, name, threadName, endpointId) {
        this.categoryName = categoryName;
        this.eventTime = eventTime;
        this.file = file;
        this.functionName = functionName;
        this.level = level;
        this.line = line;
        this.message = message;
        this.name = name;
        this.threadName = threadName;
        this.endpointId = endpointId;
    }
    static toLogString(logRecord) {
        return StringUtils_1.default.toStringDate(new Date(logRecord.eventTime), true) + ': ' + logRecord.level.toUpperCase() + ': '
            + logRecord.categoryName + ': ' + logRecord.threadName + ': ' + logRecord.file + ':' + logRecord.line + ': '
            + logRecord.functionName + ': ' + logRecord.message;
    }
}
exports.LogRecord = LogRecord;

},{"../../events/AdvancedSettingsEvents":62,"../../events/LogEvents":69,"../../utils/Constants":138,"../../utils/EventListFactory":142,"../../utils/OperatingSystemInfoProvider":154,"../../utils/StringUtils":164,"../../utils/VidyoDebugger":170,"../../utils/VidyoInsightsProvider":171,"../BaseController":35,"./LogLevelParser":45,"json-decycle":5}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevelParser = void 0;
const LogEvents_1 = require("../../events/LogEvents");
class LogLevelParser {
    static ParseLogLevelFilter(logLevel, logLevelFilter) {
        logLevel = logLevel.replace('@*', '');
        let allSettings = logLevel.split(' ');
        let globalAbsoluteSettings = [];
        for (let gs of allSettings) {
            if (gs.match(/(^[^\+\-\!\=])([^@]+)$/g)) {
                globalAbsoluteSettings.push(gs);
            }
        }
        LogLevelParser._setLogLevelItems(logLevelFilter, globalAbsoluteSettings);
        let globalModifiersSettings = [];
        for (let gs of allSettings) {
            if (gs.match(/(^[\+\-\!\=])([^@]+)$/g)) {
                globalModifiersSettings.push(gs);
            }
        }
        LogLevelParser._setLogLevelItems(logLevelFilter, globalModifiersSettings);
        let categoryAbsoluteSettings = [];
        for (let gs of allSettings) {
            if (gs.match(/(^[^\+\-\!\=])(.+[@].+)$/g)) {
                categoryAbsoluteSettings.push(gs);
            }
        }
        LogLevelParser._setLogLevelItems(logLevelFilter, categoryAbsoluteSettings);
        let categoryModifiersSettings = [];
        for (let gs of allSettings) {
            if (gs.match(/(^[\+\-\!\=])(.+[@].+)$/g)) {
                categoryModifiersSettings.push(gs);
            }
        }
        LogLevelParser._setLogLevelItems(logLevelFilter, categoryModifiersSettings);
    }
    static _setLogLevelItems(logLevelFilter, logLevelItems) {
        for (let logLevelItem of logLevelItems) {
            let logLevelAndCategory = logLevelItem.match(/[^\+\-\!\=][a-z][^@]+/g);
            if (logLevelAndCategory === null || logLevelAndCategory.length < 1) {
                return false;
            }
            let logLevel = logLevelAndCategory[0];
            let logCategory = logLevelAndCategory[1];
            let _logModifiers = logLevelItem.match(/^[\+\-\!\=]+/g);
            let logModifiers = _logModifiers ? _logModifiers[0] : null;
            if (!LogLevelParser._checkLogLevel(logLevel)) {
                console.error('LogLevelParser Error: ' + logLevel);
                return false;
            }
            if (!LogLevelParser._checkLogCategory(logCategory)) {
                console.error('LogCategory Error: ' + logCategory);
                return false;
            }
            if (!LogLevelParser._checkLogModifiers(logModifiers)) {
                console.error('LogModifiers Error: ' + logModifiers);
                return false;
            }
            if (logLevel.toLowerCase() === 'all') {
                LogLevelParser._setLogLevelALL(logLevelFilter, logModifiers, logCategory);
            }
            else {
                LogLevelParser._setLogLevel(logLevelFilter, logLevel, logModifiers, logCategory);
            }
        }
        return true;
    }
    static _checkLogLevel(logLevel) {
        if (!logLevel) {
            return false;
        }
        if (logLevel.toLowerCase() === 'all') {
            return true;
        }
        return !!LogEvents_1.VidyoLogLevel[logLevel];
    }
    static _checkLogCategory(logCategory) {
        if (!logCategory) {
            return true;
        }
        return !!LogEvents_1.VidyoLogCategory[logCategory];
    }
    static _checkLogModifiers(logModifiers) {
        if (!logModifiers) {
            return true;
        }
        if (logModifiers.match(/^(\+{2})|(\-{2})|(\!{2})|(\={2})|(\+\-)|(\-\+)|(\+\!)|(\!\+)|(\-\!)|(\!\-)$/g)) {
            return false;
        }
        return !!logModifiers.match(/^[\+\-\!\=]{1,2}$/g);
    }
    static _setLogLevelALL(logLevelFilter, modifier, category) {
        if (!category) {
            for (let vidyoLogCategory in LogEvents_1.VidyoLogCategory) {
                if (LogEvents_1.VidyoLogCategory.hasOwnProperty(vidyoLogCategory)) {
                    LogLevelParser._setLogLevelALL(logLevelFilter, modifier, LogEvents_1.VidyoLogCategory[vidyoLogCategory]);
                }
            }
            return;
        }
        if (modifier && modifier.match(/^(\-)|(\-\=)|(\=\-)|(\!\=)|(\=\!)$/g) !== null) {
            logLevelFilter[LogEvents_1.VidyoLogCategory[category]] = 0;
        }
        else {
            logLevelFilter[LogEvents_1.VidyoLogCategory[category]] =
                LogEvents_1.VidyoLogLevel.fatal | LogEvents_1.VidyoLogLevel.error | LogEvents_1.VidyoLogLevel.warning | LogEvents_1.VidyoLogLevel.info | LogEvents_1.VidyoLogLevel.debug |
                    LogEvents_1.VidyoLogLevel.sent | LogEvents_1.VidyoLogLevel.received |
                    LogEvents_1.VidyoLogLevel.enter | LogEvents_1.VidyoLogLevel.leave;
        }
    }
    static _setLogLevel(logLevelFilter, logLevelStr, modifier, categoryStr) {
        let logLevel = LogEvents_1.VidyoLogLevel[logLevelStr];
        let category = categoryStr ? LogEvents_1.VidyoLogCategory[categoryStr] : null;
        let logLevels = new Array();
        logLevels.push(logLevel);
        let exclusive = false;
        if (modifier) {
            exclusive = !!modifier.match(/[=]/g);
        }
        if (exclusive === false) {
            switch (logLevel) {
                case LogEvents_1.VidyoLogLevel.enter:
                    logLevels.push(LogEvents_1.VidyoLogLevel.leave);
                    break;
                case LogEvents_1.VidyoLogLevel.leave:
                    logLevels.push(LogEvents_1.VidyoLogLevel.enter);
                    break;
                case LogEvents_1.VidyoLogLevel.sent:
                    logLevels.push(LogEvents_1.VidyoLogLevel.received);
                    break;
                case LogEvents_1.VidyoLogLevel.received:
                    logLevels.push(LogEvents_1.VidyoLogLevel.sent);
                    break;
                case LogEvents_1.VidyoLogLevel.fatal:
                    break;
                case LogEvents_1.VidyoLogLevel.error:
                    logLevels.push(LogEvents_1.VidyoLogLevel.fatal);
                    break;
                case LogEvents_1.VidyoLogLevel.warning:
                    logLevels.push(LogEvents_1.VidyoLogLevel.error);
                    logLevels.push(LogEvents_1.VidyoLogLevel.fatal);
                    break;
                case LogEvents_1.VidyoLogLevel.info:
                    logLevels.push(LogEvents_1.VidyoLogLevel.warning);
                    logLevels.push(LogEvents_1.VidyoLogLevel.error);
                    logLevels.push(LogEvents_1.VidyoLogLevel.fatal);
                    break;
                case LogEvents_1.VidyoLogLevel.debug:
                    logLevels.push(LogEvents_1.VidyoLogLevel.info);
                    logLevels.push(LogEvents_1.VidyoLogLevel.warning);
                    logLevels.push(LogEvents_1.VidyoLogLevel.error);
                    logLevels.push(LogEvents_1.VidyoLogLevel.fatal);
                    break;
                default:
                    console.info("unsupported log level " + LogEvents_1.VidyoLogLevel[logLevel]);
                    break;
            }
        }
        for (let logLevelItem of logLevels) {
            LogLevelParser._setLogLevelItem(logLevelFilter, logLevelItem, modifier, category);
        }
    }
    static _setLogLevelItem(logLevelFilter, logLevel, modifier, category) {
        if (!category) {
            for (let vidyoLogCategory in LogEvents_1.VidyoLogCategory) {
                if (LogEvents_1.VidyoLogCategory.hasOwnProperty(vidyoLogCategory)) {
                    LogLevelParser._setLogLevelItem(logLevelFilter, logLevel, modifier, vidyoLogCategory);
                }
            }
            return;
        }
        let onOff = true;
        if (modifier) {
            onOff = !modifier.match(/[\-\!]/g);
        }
        if (onOff === true) {
            logLevelFilter[category] |= logLevel;
        }
        else {
            logLevelFilter[category] &= ~logLevel;
        }
    }
}
exports.LogLevelParser = LogLevelParser;

},{"../../events/LogEvents":69}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageController = exports.ChatStates = void 0;
const BaseController_1 = require("./BaseController");
const EventDispatcher_1 = require("../events/EventDispatcher");
const MessageEvents = require("../events/MessageEvents");
const Message_1 = require("../models/Message");
const RendererTypes_1 = require("../models/RendererTypes");
const ParticipantEvents = require("../events/ParticipantEvents");
const Participant_1 = require("../models/Participant");
var ChatStates;
(function (ChatStates) {
    ChatStates["active"] = "active";
    ChatStates["inactive"] = "inactive";
    ChatStates["gone"] = "gone";
    ChatStates["composing"] = "composing";
    ChatStates["paused"] = "paused";
})(ChatStates = exports.ChatStates || (exports.ChatStates = {}));
var ChatCommandTypes;
(function (ChatCommandTypes) {
    ChatCommandTypes["EnableFixedParticipantResolution"] = "EnableFixedParticipantResolution";
    ChatCommandTypes["DisableFixedParticipantResolution"] = "DisableFixedParticipantResolution";
})(ChatCommandTypes || (ChatCommandTypes = {}));
class MessageController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._messages = [];
        this._sendMessagesCounter = 0;
        this._msgClassWhiteListFilters = [];
    }
    AddMessageClass(msgClass) {
        if (!this._msgClassWhiteListFilters.includes(msgClass)) {
            this._msgClassWhiteListFilters.push(msgClass);
        }
    }
    Disable() {
        return super.Disable();
    }
    GetMessageById(id) {
        const message = this._messages.find((msg) => msg.id === id);
        return message;
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.MessageReceived, EventDispatcher_1.MessageControllerListeners, (payload) => this._onMessageReceived(payload));
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.MessageRead, EventDispatcher_1.MessageControllerListeners, (payload) => this._onMessageRead(payload));
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.MessageChatState, EventDispatcher_1.MessageControllerListeners, (payload) => this._onMessageChatState(payload));
        this._vidyoCore.EventDispatcher
            .on(ParticipantEvents.Events.ParticipantLeft, (payload) => {
            this._vidyoCore.Controllers.RendererController.VideoResolutions.RemoveFixedParticipantResolution(payload.participant.Id);
        });
        return Promise.resolve(undefined);
    }
    SendFeccMessage(options) {
        this._vidyoCore.HunterProvider.SendFeccMessage({ ...options, id: this._sendMessagesCounter++ });
    }
    SendMessage(message) {
        if (message.startsWith('VC::')) {
            this._handleChatCommand(message);
            return true;
        }
        else {
            return this._vidyoCore.HunterProvider.SendMessage({ message, id: this._sendMessagesCounter++ });
        }
    }
    SendPrivateMessage(participantUri, message) {
        return this._vidyoCore.HunterProvider.SendPrivateMessage({ participantUri, message, id: this._sendMessagesCounter++ });
    }
    SendMessageAcknowledged(messageId) {
        const message = this._messages.find((msg) => +msg.id === +messageId);
        if (message) {
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    SendMessageTypingIndication(typingIndication) {
        if (typingIndication in ChatStates) {
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    _handleChatCommand(message) {
        const command = message.split('::')[1];
        const commandParts = command.split(' ');
        const commandType = commandParts[0];
        switch (commandType) {
            case ChatCommandTypes.EnableFixedParticipantResolution:
                if (commandParts.length === 4) {
                    const participantId = commandParts[1];
                    const width = +commandParts[2];
                    const height = +commandParts[3];
                    this._vidyoCore.Controllers.RendererController.VideoResolutions
                        .AddFixedParticipantResolution(participantId, width, height);
                    if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
                        this._vidyoCore.Controllers.ConferenceController.SendDynamicShow();
                    }
                }
                break;
            case ChatCommandTypes.DisableFixedParticipantResolution:
                if (commandParts.length === 2) {
                    const participantId = commandParts[1];
                    this._vidyoCore.Controllers.RendererController.VideoResolutions.RemoveFixedParticipantResolution(participantId);
                    if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
                        this._vidyoCore.Controllers.ConferenceController.SendDynamicShow();
                    }
                }
                break;
            default:
                break;
        }
    }
    _onMessageChatState(payload) {
        let participant = null;
        if (payload.resource) {
            participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(payload.resource);
            if (participant) {
                this._vidyoCore.EventDispatcher.emit(MessageEvents.Events.OnMessageChatState, { participant, state: payload.chatState });
            }
        }
    }
    _onMessageRead(payload) {
        let participant = null;
        if (payload.resource) {
            participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(payload.resource);
            if (participant) {
                this._vidyoCore.EventDispatcher.emit(MessageEvents.Events.OnMessageRead, { participant, messageId: payload.id });
            }
        }
    }
    _onMessageReceived(payload) {
        let matchOne = false;
        if (payload.body.includes('SpecialMessage::')) {
            this._msgClassWhiteListFilters.forEach((msgClass) => {
                if (payload.body.includes(`msgClass:${msgClass};`)) {
                    matchOne = true;
                }
            });
            if (!matchOne) {
                return;
            }
        }
        let message = new Message_1.Message();
        message.body = payload.body;
        message.id = payload.id;
        message.timestamp = Date.now();
        let participant = null;
        if (payload.resource) {
            participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(payload.resource);
            if (participant && (participant.UserId || participant.IsLocal)) {
                message.userId = participant.IsRemote ? participant.UserId : Participant_1.LocalParticipantId;
                message.resource = payload.resource;
                message.senderType = Message_1.SenderType.user;
                if (payload.type === 'privatechat') {
                    message.type = Message_1.MessageType.privatechat;
                }
                else {
                    message.type = Message_1.MessageType.chat;
                }
            }
        }
        if (payload.subtype &&
            (payload.subtype === Message_1.MessageType.mediastart || payload.subtype === Message_1.MessageType.mediastop)) {
            message.userId = null;
            message.senderType = Message_1.SenderType.room;
            message.type = payload.subtype;
        }
        this._messages.push(message);
        if (participant && message.senderType === Message_1.SenderType.user) {
            if (participant.IsLocal) {
                this._vidyoCore.EventDispatcher.emit(MessageEvents.Events.OnMessageAcknowledged, { message });
            }
            else {
                this._vidyoCore.EventDispatcher.emit(MessageEvents.Events.OnMessage, { participant, message });
            }
        }
    }
}
exports.MessageController = MessageController;

},{"../events/EventDispatcher":68,"../events/MessageEvents":70,"../events/ParticipantEvents":73,"../models/Message":93,"../models/Participant":94,"../models/RendererTypes":96,"./BaseController":35}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MicrophoneEnergyLevelController = void 0;
const AdvancedSettingsEvents = require("../events/AdvancedSettingsEvents");
const MicrophoneEnergyEvents = require("../events/MicrophoneEnergyEvents");
const ParticipantEvents = require("../events/ParticipantEvents");
const StreamEvents = require("../events/StreamEvents");
const EventDispatcher_1 = require("../events/EventDispatcher");
const Participant_1 = require("../../vidyo_simple_api/Participant");
const Devices_1 = require("../../vidyo_simple_api/Devices");
const Origin_1 = require("../../vidyo_simple_api/Origin");
const Participant_2 = require("../models/Participant");
const BaseController_1 = require("./BaseController");
class MicrophoneEnergyLevelController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._fftSize = 256;
        this._minLgAudioLevel = -127;
        this._maxLgAudioLevel = 0;
        this._processPeriod = 1000;
        this._smoothingTimeConstant = 0.1;
        this._audioContext = null;
        this._fftBins = new Float32Array(this._fftSize);
        this._localSources = [];
        this._remoteSources = {};
        this._nextProcessTimeout = null;
        this._localOnEnergyCallback = null;
        this._remoteOnEnergyCallback = null;
        this._resumeAudioContext = () => {
            if (this._audioContext) {
                this._audioContext.resume();
            }
        };
    }
    Disable() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.MicrophoneEnergyLevelControllerListeners);
        this._stopProcessing();
        return super.Disable();
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.MicrophoneEnergyLevelControllerListeners);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.DisableAudioEnergyMonitorChanged, EventDispatcher_1.MicrophoneEnergyLevelControllerListeners, (payload) => this._onDisableAudioEnergyMonitorChanged(payload));
        this._startProcessing();
        return Promise.resolve();
    }
    GetRemoteStats(participantId, sourceId) {
        const remoteSource = this._remoteSources[participantId];
        if (remoteSource) {
            const sourceData = remoteSource.sources.find((source) => source.id === sourceId);
            if (sourceData) {
                return {
                    audioLevel: sourceData.audioLevel,
                    channelsCount: sourceData.analyser.channelCount,
                    sampleRate: sourceData.analyser.context.sampleRate,
                    sampleSize: sourceData.analyser.frequencyBinCount
                };
            }
        }
    }
    RegisterLocalMicrophoneEnergyListener(energyLevelInfo) {
        this._localOnEnergyCallback = energyLevelInfo;
        return Promise.resolve(true);
    }
    RegisterRemoteMicrophoneEnergyListener(energyLevelInfo) {
        this._remoteOnEnergyCallback = energyLevelInfo;
        return Promise.resolve(true);
    }
    UnregisterLocalMicrophoneEnergyListener() {
        this._localOnEnergyCallback = null;
        return Promise.resolve(true);
    }
    UnregisterRemoteMicrophoneEnergyListener() {
        this._remoteOnEnergyCallback = null;
        return Promise.resolve(true);
    }
    _calculateAudioLevel(analyser) {
        let maxEnergy = -Infinity;
        analyser.getFloatFrequencyData(this._fftBins);
        for (let i = 0; i < this._fftBins.length; i++) {
            if (this._fftBins[i] > maxEnergy && this._fftBins[i] < 0) {
                maxEnergy = this._fftBins[i];
            }
        }
        maxEnergy = Math.min(this._maxLgAudioLevel, maxEnergy);
        return Math.max(maxEnergy, this._minLgAudioLevel);
    }
    _createEnergyLevelSource(sourceId, track, vidyoMicrophone) {
        const result = {
            id: sourceId,
            audioLevel: this._minLgAudioLevel,
            analyser: null,
            vidyoMicrophone,
            sourceNode: null,
            stream: new MediaStream()
        };
        result.stream.addTrack(track.clone());
        result.sourceNode = this._audioContext.createMediaStreamSource(result.stream);
        result.analyser = this._audioContext.createAnalyser();
        result.analyser.smoothingTimeConstant = this._smoothingTimeConstant;
        result.analyser.fftSize = this._fftSize;
        result.sourceNode.connect(result.analyser);
        return result;
    }
    _disableEnergyLevelSource(sourceData) {
        sourceData.analyser.disconnect();
        sourceData.sourceNode.disconnect();
        sourceData.stream.getAudioTracks().forEach((track) => track.stop());
    }
    _getLocalMicrophone(deviceId) {
        const microphones = this._vidyoCore.Controllers.DeviceController.GetMicrophoneList();
        const coreMicrophone = microphones.find((microphone) => microphone.Id === deviceId);
        if (coreMicrophone) {
            return new Devices_1.Microphone(this._vidyoCore, coreMicrophone, Origin_1.Origin.Local);
        }
        return null;
    }
    _getParticipantMicrophone(participant, sourceId) {
        const coreMicrophone = participant.GetDevice(sourceId);
        if (coreMicrophone) {
            return new Devices_1.Microphone(this._vidyoCore, coreMicrophone, (0, Origin_1.FromCoreOrigin)(participant.Origin));
        }
        return null;
    }
    _handleLocalTracksChanged() {
        this._updateLocalParticipantAnaliser();
    }
    _handleRemoteTracksChanged(participantId) {
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
        if (participant) {
            this._updateRemoteParticipantAnalyser(participant);
        }
        else {
            this._handleStreamListChanged();
        }
    }
    _onDisableAudioEnergyMonitorChanged(disabled) {
        if (disabled) {
            this._stopProcessing();
        }
        else {
            this._startProcessing();
        }
    }
    _handleStreamListChanged() {
        const remoteParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_2.ParticipantOrigin.Remote });
        for (let participantId in this._remoteSources) {
            if (!remoteParticipants.some((p) => p.Id === participantId)) {
                this._removeRemoteParticipantAnaliser(participantId);
            }
        }
        for (let participant of remoteParticipants) {
            if (!this._remoteSources.hasOwnProperty(participant.Id)) {
                this._updateRemoteParticipantAnalyser(participant);
            }
        }
    }
    _handleTracksChanged(participantOrStreamId) {
        const localStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
        if (localStream?.Id === participantOrStreamId) {
            this._handleLocalTracksChanged();
        }
        else {
            this._handleRemoteTracksChanged(participantOrStreamId);
        }
    }
    _process() {
        this._processLocalSources();
        this._processRemoteSources();
        this._nextProcessTimeout = window.setTimeout(() => this._process(), this._processPeriod);
    }
    _processLocalSources() {
        this._localSources.forEach((sourceData) => {
            if (this._vidyoCore.Controllers.DeviceController.GetAudioMuteState()) {
                sourceData.audioLevel = this._minLgAudioLevel;
                return;
            }
            sourceData.audioLevel = this._calculateAudioLevel(sourceData.analyser);
            this._vidyoCore.EventDispatcher.emitAsync(MicrophoneEnergyEvents.Events.MicrophoneEnergyLevelUpdate, {
                audioLevel: sourceData.audioLevel,
                isLocal: true
            });
            if (this._localOnEnergyCallback) {
                this._localOnEnergyCallback.onEnergy(sourceData.vidyoMicrophone, sourceData.audioLevel);
            }
        });
    }
    _processRemoteSources() {
        const loudestSource = {
            participant: null,
            audioLevel: this._minLgAudioLevel
        };
        for (let participantId in this._remoteSources) {
            const participantState = this._remoteSources[participantId];
            participantState.sources.forEach((sourceData) => {
                if (participantState.participant.AudioMuted()) {
                    sourceData.audioLevel = this._minLgAudioLevel;
                    return;
                }
                sourceData.audioLevel = this._calculateAudioLevel(sourceData.analyser);
                this._vidyoCore.EventDispatcher.emitAsync(MicrophoneEnergyEvents.Events.MicrophoneEnergyLevelUpdate, {
                    audioLevel: sourceData.audioLevel,
                    isLocal: false,
                    participant: participantState.participant
                });
                if (this._remoteOnEnergyCallback) {
                    this._remoteOnEnergyCallback.onEnergy(sourceData.vidyoMicrophone, participantState.vidyoParticipant, sourceData.audioLevel);
                }
                if (sourceData.audioLevel > loudestSource.audioLevel) {
                    loudestSource.audioLevel = sourceData.audioLevel;
                    loudestSource.participant = participantState.participant;
                }
            });
        }
        if (this._loudestParticipant !== loudestSource.participant) {
            this._loudestParticipant = loudestSource.participant;
            if (this._loudestParticipant) {
                this._vidyoCore.EventDispatcher.emitAsync(ParticipantEvents.Events.LoudestParticipantChanged, {
                    participant: this._loudestParticipant
                });
            }
        }
    }
    _startProcessing() {
        if (this._vidyoCore.Controllers.AdvancedSettingsController.DisableAudioEnergyMonitor) {
            return;
        }
        this._stopProcessing();
        this._audioContext = new AudioContext();
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.TracksChanged, EventDispatcher_1.MicrophoneEnergyLevelStreamListeners, (streamId) => this._handleTracksChanged(streamId));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.StreamListChanged, EventDispatcher_1.MicrophoneEnergyLevelStreamListeners, () => this._handleStreamListChanged());
        const startProcessing = () => {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Microphones energy processing started');
            this._updateLocalParticipantAnaliser();
            this._handleStreamListChanged();
            this._process();
        };
        switch (this._audioContext.state) {
            case 'running':
                startProcessing();
                break;
            case 'suspended':
                this._audioContext.onstatechange = () => {
                    if (this._audioContext.state === 'suspended') {
                        return;
                    }
                    this._audioContext.onstatechange = null;
                    document.removeEventListener('click', this._resumeAudioContext);
                    if (this._audioContext.state === 'running') {
                        this._vidyoCore.Controllers.LogController.LogInfo(() => 'AudioContext is running');
                        startProcessing();
                    }
                    else {
                        this._stopProcessing();
                    }
                };
                document.addEventListener('click', this._resumeAudioContext);
                break;
            default:
                this._stopProcessing();
        }
    }
    _stopProcessing() {
        if (this._nextProcessTimeout) {
            clearTimeout(this._nextProcessTimeout);
            this._nextProcessTimeout = null;
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Energy level processing stopped');
        }
        document.removeEventListener('click', this._resumeAudioContext);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.MicrophoneEnergyLevelStreamListeners);
        Object.keys(this._remoteSources).forEach((participantId) => {
            this._removeRemoteParticipantAnaliser(participantId);
        });
        this._removeLocalParticipantAnaliser();
        if (this._audioContext) {
            this._audioContext.close();
            this._audioContext = null;
        }
    }
    _removeLocalParticipantAnaliser() {
        this._localSources.forEach((sourceData) => {
            this._disableEnergyLevelSource(sourceData);
        });
        this._localSources = [];
    }
    _removeRemoteParticipantAnaliser(participantId) {
        if (this._remoteSources[participantId]) {
            this._remoteSources[participantId].sources.forEach((sourceData) => {
                this._disableEnergyLevelSource(sourceData);
            });
            delete this._remoteSources[participantId];
        }
    }
    _updateLocalParticipantAnaliser() {
        this._removeLocalParticipantAnaliser();
        const roStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
        if (roStream) {
            this._localSources = roStream.GetMediaStream().getAudioTracks().map((track) => {
                const { deviceId } = track.getSettings();
                return this._createEnergyLevelSource(deviceId, track, this._getLocalMicrophone(deviceId));
            });
        }
    }
    _updateRemoteParticipantAnalyser(participant) {
        this._removeRemoteParticipantAnaliser(participant.Id);
        const roStream = this._vidyoCore.Controllers.RemoteStreamController.TryGetNetworkStream(participant.Id);
        if (roStream) {
            const sources = roStream.GetMediaStream().getAudioTracks().map((track) => {
                const ssrc = this._vidyoCore.Controllers.ConnectionController.Session.GetReceiverSsrcByTrackId(track.id);
                return this._createEnergyLevelSource(ssrc, track, this._getParticipantMicrophone(participant, ssrc));
            });
            this._remoteSources[participant.Id] = {
                vidyoParticipant: new Participant_1.Participant(participant),
                participant,
                sources
            };
        }
    }
}
exports.MicrophoneEnergyLevelController = MicrophoneEnergyLevelController;

},{"../../vidyo_simple_api/Devices":184,"../../vidyo_simple_api/Origin":187,"../../vidyo_simple_api/Participant":188,"../events/AdvancedSettingsEvents":62,"../events/EventDispatcher":68,"../events/MicrophoneEnergyEvents":71,"../events/ParticipantEvents":73,"../events/StreamEvents":79,"../models/Participant":94,"./BaseController":35}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModerationController = void 0;
const BaseController_1 = require("./BaseController");
const EventDispatcher_1 = require("../events/EventDispatcher");
const ParticipantEvents = require("../events/ParticipantEvents");
const ModerationEvents = require("../events/ModerationEvents");
const RoomEvents = require("../events/RoomEvents");
const Devices_1 = require("../../vidyo_simple_api/Devices");
const Room_1 = require("../../vidyo_simple_api/Room");
const Participant_1 = require("../../vidyo_simple_api/Participant");
const VidyoPortalGuestService_1 = require("../utils/VidyoPortalGuestService");
const ConnectionEvents = require("../events/ConnectionEvents");
const Constants_1 = require("../utils/Constants");
const TimingProvider_1 = require("../utils/TimingProvider");
class ModerationController extends BaseController_1.BaseController {
    constructor(vidyoCore) {
        super(vidyoCore);
        this._audioHardMute = false;
        this._videoHardMute = false;
        this._endpointHandRaised = false;
        this._roomAudioSoftMute = false;
        this._roomVideoSoftMute = false;
        this._lectureMode = false;
        this._presenterId = null;
        this._isSharingPermitted = true;
        this._roomConferenceMode = null;
        this._portalGuestService = null;
        this._roomStatePollingInterval = null;
    }
    Disable() {
        return super.Disable();
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ModerationControllerListeners);
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.EventServerModerationCommand, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onModerationCommand(payload));
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.LectureStatusUpdate, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onLectureStatusUpdate(payload));
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.UserStatusUpdate, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onUserStatusUpdate(payload));
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.EndpointStateUpdate, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onEndpointStateUpdate(payload));
        this._vidyoCore.EventDispatcher.on(RoomEvents.Events.StateUpdate, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onRoomStateUpdate(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Connected, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onConnected(payload));
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.ParticipantJoined, EventDispatcher_1.ModerationControllerListeners, (payload) => this._onParticipantJoined(payload));
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.EventServerConnected, EventDispatcher_1.ModerationControllerListeners, () => this._stopRoomStatePolling());
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.EventServerError, EventDispatcher_1.ModerationControllerListeners, () => this._startRoomStatePolling());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.ModerationControllerListeners, () => this._onDisconnecting());
        return super.Initialize();
    }
    get IsCameraHardMuted() {
        return this._videoHardMute;
    }
    get IsMicrophoneHardMuted() {
        return this._audioHardMute;
    }
    get IsLectureMode() {
        return this._lectureMode;
    }
    get IsLobbyEnabled() {
        return this._roomConferenceMode === Room_1.VidyoRoomConferenceMode.Lobby;
    }
    get IsSharingPermitted() {
        return this._isSharingPermitted;
    }
    RaiseHand() {
        if (this._portalGuestService) {
            return this._portalGuestService.RaiseHand();
        }
        return Promise.resolve(false);
    }
    UnraiseHand() {
        if (this._portalGuestService) {
            return this._portalGuestService.UnraiseHand();
        }
        return Promise.resolve(false);
    }
    _onConnected(payload) {
        const options = this._vidyoCore.Controllers.ConnectionController.ReconnectOptions;
        this._portalGuestService = new VidyoPortalGuestService_1.default(options.host, payload.guestId, payload.userName);
    }
    _onDisconnecting() {
        this._stopRoomStatePolling();
        this._portalGuestService = null;
        this._roomConferenceMode = null;
        this._endpointHandRaised = false;
        this._roomAudioSoftMute = false;
        this._roomVideoSoftMute = false;
        this._videoHardMute = false;
        this._audioHardMute = false;
        this._lectureMode = false;
        this._presenterId = null;
    }
    _onLectureStatusUpdate(payload) {
        this._lectureMode = payload.lecture;
        this._presenterId = payload.presenter;
        this._handleRoomConferenceModeChanged(this._lectureMode, !!payload.presenter);
        this._handleSharingPermissionChanged();
        if (typeof payload.muteAudio === 'boolean') {
            if (payload.muteAudio && !this._audioHardMute) {
                this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardMute);
            }
            else if (!payload.muteAudio && this._audioHardMute) {
                this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardUnmute);
            }
        }
        if (payload.presenter) {
            const participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants();
            const participant = participants.find((participant) => participant.Id.includes(payload.presenter));
            if (participant && participant.IsComplete) {
                this._vidyoCore.EventDispatcher.emitAsync(ModerationEvents.Events.PresenterChanged, {
                    participant
                });
            }
        }
        else {
            this._vidyoCore.EventDispatcher.emit(ModerationEvents.Events.PresenterChanged, {
                participant: null
            });
        }
    }
    _onParticipantJoined(payload) {
        if (this._presenterId && payload.participant.Id.includes(this._presenterId)) {
            this._vidyoCore.EventDispatcher.emitAsync(ModerationEvents.Events.PresenterChanged, {
                participant: payload.participant
            });
        }
    }
    _onUserStatusUpdate(payload) {
        this._handleRaiseHandResponse(payload.handApproved);
    }
    _onEndpointStateUpdate(payload) {
        if (payload.endpointAudio.hardMute && !this._audioHardMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardMute);
        }
        else if (!payload.endpointAudio.hardMute && this._audioHardMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardUnmute);
        }
        if (payload.endpointVideo.hardMute && !this._videoHardMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationCameraHardMute);
        }
        else if (!payload.endpointVideo.hardMute && this._videoHardMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationCameraHardUnmute);
        }
        if (!payload.handRaised && this._endpointHandRaised) {
            this._handleRaiseHandResponse(false);
        }
        this._endpointHandRaised = payload.handRaised;
    }
    _onRoomStateUpdate(payload) {
        this._lectureMode = payload.lectureMode;
        this._handleRoomConferenceModeChanged(this._lectureMode, payload.presenter, payload.waitingRoom);
        if (payload.roomAudio.softMute && !this._roomAudioSoftMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationMicrophoneSoftMute);
        }
        if (payload.roomVideo.softMute && !this._roomVideoSoftMute) {
            this._onModerationCommand(ModerationEvents.EventServerModerationMessage.ModerationCameraSoftMute);
        }
        this._roomAudioSoftMute = payload.roomAudio.softMute;
        this._roomVideoSoftMute = payload.roomVideo.softMute;
    }
    _onModerationCommand(payload) {
        let deviceType;
        let moderationType;
        let state;
        switch (payload) {
            case ModerationEvents.EventServerModerationMessage.ModerationCameraSoftMute:
                deviceType = Devices_1.VidyoDeviceType.LocalCamera;
                moderationType = Room_1.VidyoRoomModerationType.SoftMute;
                state = true;
                this._vidyoCore.Controllers.DeviceController.SetVideoMuteState(true);
                break;
            case ModerationEvents.EventServerModerationMessage.ModerationMicrophoneSoftMute:
                deviceType = Devices_1.VidyoDeviceType.LocalMicrophone;
                moderationType = Room_1.VidyoRoomModerationType.SoftMute;
                state = true;
                this._vidyoCore.Controllers.DeviceController.SetAudioMuteState(true);
                break;
            case ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardMute:
                this._audioHardMute = true;
                deviceType = Devices_1.VidyoDeviceType.LocalMicrophone;
                moderationType = Room_1.VidyoRoomModerationType.HardMute;
                state = true;
                this._vidyoCore.Controllers.DeviceController.SetAudioMuteState(true);
                break;
            case ModerationEvents.EventServerModerationMessage.ModerationCameraHardMute:
                this._videoHardMute = true;
                deviceType = Devices_1.VidyoDeviceType.LocalCamera;
                moderationType = Room_1.VidyoRoomModerationType.HardMute;
                state = true;
                this._vidyoCore.Controllers.DeviceController.SetVideoMuteState(true);
                break;
            case ModerationEvents.EventServerModerationMessage.ModerationMicrophoneHardUnmute:
                this._audioHardMute = false;
                deviceType = Devices_1.VidyoDeviceType.LocalMicrophone;
                moderationType = Room_1.VidyoRoomModerationType.HardMute;
                state = false;
                this._handleRaiseHandResponse(true);
                break;
            case ModerationEvents.EventServerModerationMessage.ModerationCameraHardUnmute:
                this._videoHardMute = false;
                deviceType = Devices_1.VidyoDeviceType.LocalCamera;
                moderationType = Room_1.VidyoRoomModerationType.HardMute;
                state = false;
                break;
            default:
                console.info("unsupported EventServerModerationMessage " + ModerationEvents.EventServerModerationMessage[payload]);
                break;
        }
        if (deviceType && moderationType) {
            this._vidyoCore.EventDispatcher.emit(ModerationEvents.Events.OnModerationCommandReceived, {
                deviceType,
                moderationType,
                state
            });
        }
    }
    _handleRaiseHandResponse(isApproved) {
        const handState = isApproved
            ? Participant_1.VidyoParticipantHandState.VIDYO_PARTICIPANTHANDSTATE_APPROVED
            : Participant_1.VidyoParticipantHandState.VIDYO_PARTICIPANTHANDSTATE_DISMISSED;
        this._vidyoCore.EventDispatcher.emit(ModerationEvents.Events.RaiseHandResponse, { handState });
    }
    _handleRoomConferenceModeChanged(lectureMode, designatedPresenter, waitingRoom = false) {
        let roomConferenceMode = Room_1.VidyoRoomConferenceMode.Group;
        if (lectureMode) {
            roomConferenceMode = designatedPresenter
                ? Room_1.VidyoRoomConferenceMode.Lecture
                : Room_1.VidyoRoomConferenceMode.Lobby;
        }
        if (this._roomConferenceMode !== roomConferenceMode) {
            this._roomConferenceMode = roomConferenceMode;
            this._vidyoCore.EventDispatcher.emit(ModerationEvents.Events.ConferenceModeChanged, {
                mode: roomConferenceMode
            });
            this._handleSharingPermissionChanged();
        }
    }
    _handleSharingPermissionChanged() {
        const localParticipant = this._vidyoCore.Controllers.ParticipantController.GetLocalParticipant();
        const isLocalPresenter = localParticipant && localParticipant.Id.includes(this._presenterId);
        const isSharingPermitted = !this._lectureMode || isLocalPresenter;
        if (isSharingPermitted !== this._isSharingPermitted) {
            this._isSharingPermitted = isSharingPermitted;
            this._vidyoCore.EventDispatcher.emit(ModerationEvents.Events.LocalSharePermissionChanged, {
                isPermitted: this._isSharingPermitted
            });
        }
    }
    _startRoomStatePolling() {
        clearInterval(this._roomStatePollingInterval);
        const RETRY_NUMBER_AFTER_FAIL = 3;
        let failedRequestCounter = 0;
        this._roomStatePollingInterval = TimingProvider_1.TimingProvider.Interval(Constants_1.RoomStatePollingIntervalMs, async () => {
            const res = await this._vidyoCore.HunterProvider.RequestConferenceState();
            if (!res) {
                if (++failedRequestCounter >= RETRY_NUMBER_AFTER_FAIL) {
                    this._stopRoomStatePolling();
                }
            }
            else {
                failedRequestCounter = 0;
            }
        });
    }
    _stopRoomStatePolling() {
        clearInterval(this._roomStatePollingInterval);
    }
}
exports.ModerationController = ModerationController;

},{"../../vidyo_simple_api/Devices":184,"../../vidyo_simple_api/Participant":188,"../../vidyo_simple_api/Room":190,"../events/ConnectionEvents":66,"../events/EventDispatcher":68,"../events/ModerationEvents":72,"../events/ParticipantEvents":73,"../events/RoomEvents":77,"../utils/Constants":138,"../utils/TimingProvider":166,"../utils/VidyoPortalGuestService":172,"./BaseController":35}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticipantController = void 0;
const ConferenceEvents = require("../events/ConferenceEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const ParticipantEvents = require("../events/ParticipantEvents");
const DeviceEvents = require("../events/DeviceEvents");
const Participant_1 = require("../models/Participant");
const BaseController_1 = require("./BaseController");
const Source_1 = require("../models/Source");
const EventDispatcher_1 = require("../events/EventDispatcher");
const ObjectUtils_1 = require("../utils/ObjectUtils");
const Microphone_1 = require("../models/device/Microphone");
const Camera_1 = require("../models/device/Camera");
const WindowShare_1 = require("../models/device/WindowShare");
const StreamEvents = require("../events/StreamEvents");
const Devices_1 = require("../../vidyo_simple_api/Devices");
class ParticipantController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._reportLocalParticipant = false;
    }
    get RemoteSharesCount() {
        return this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote })
            .reduce((count, participant) => {
            return count + participant.Sources.filter((source) => source.Type === Source_1.SourceMediaType.Application).length;
        }, 0);
    }
    AddParticipantDevice(participantId, ssrc, name, type, paused) {
        let participant = this._participants[participantId];
        if (participant) {
            switch (type) {
                case Source_1.SourceMediaType.Audio:
                    let microphone = new Microphone_1.Microphone(name, ssrc);
                    participant.AddDevice(ssrc, microphone);
                    if (participant.IsRemote) {
                        const source = participant.GetSourceBySSrc(ssrc);
                        if (source) {
                            microphone.SignalType = source.Signal === Source_1.SourceSignalType.unprocessed
                                ? Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed
                                : Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Voice;
                        }
                        participant.NotifyDevicesEvents(() => {
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteMicrophoneAdded, {
                                microphone,
                                participant
                            });
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteMicrophoneStateUpdated, {
                                microphone,
                                participant,
                                state: paused ? Devices_1.VidyoDeviceState.Paused : Devices_1.VidyoDeviceState.Resumed
                            });
                        });
                    }
                    break;
                case Source_1.SourceMediaType.Video:
                    let camera = new Camera_1.Camera(name, ssrc);
                    participant.AddDevice(ssrc, camera);
                    if (participant.IsRemote) {
                        participant.NotifyDevicesEvents(() => {
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteCameraAdded, {
                                camera,
                                participant
                            });
                        });
                    }
                    break;
                case Source_1.SourceMediaType.Application:
                    let windowShare = new WindowShare_1.WindowShare(name, ssrc);
                    participant.AddDevice(ssrc, windowShare);
                    if (participant.IsRemote) {
                        participant.NotifyDevicesEvents(() => {
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteWindowShareAdded, {
                                windowShare,
                                participant
                            });
                        });
                    }
                    break;
                default:
                    console.log("unsupported SourceMediaType " + type?.toString());
                    break;
            }
        }
    }
    CreateParticipant(id, origin, name, user_id, clientType) {
        let participant;
        let needJoinEvent = false;
        if (user_id) {
            user_id = user_id.replace(/(.*)_(.*)@.*/, '$1@$2');
        }
        if (!this._participants[id]) {
            participant = new Participant_1.Participant(id, origin, name, user_id);
            this._participants[id] = participant;
            needJoinEvent = participant.IsComplete;
        }
        else {
            participant = this._participants[id];
            if (user_id) {
                participant.UserId = user_id;
                needJoinEvent = participant.IsComplete;
            }
            if (name) {
                participant.Name = name;
                needJoinEvent = participant.IsComplete;
            }
        }
        if (clientType === "gateway" || clientType === "legacy") {
            participant.AppType = Participant_1.ParticipantAppType.Gateway;
        }
        else if (clientType === "recorder") {
            participant.AppType = Participant_1.ParticipantAppType.Recorder;
        }
        if (needJoinEvent && !participant.IsRecorder) {
            this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantsChanged);
            if (origin === Participant_1.ParticipantOrigin.Remote || (this._reportLocalParticipant && origin === Participant_1.ParticipantOrigin.Local)) {
                participant.NotifyJoinedEvent(() => {
                    this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantJoined, { participant: participant });
                });
            }
        }
        if (!participant.IsRecorder) {
            this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantAddedOrUpdated, participant.Id);
        }
        return participant;
    }
    Disable() {
        return super.Disable();
    }
    GetLocalParticipant() {
        let localParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Local });
        if (localParticipants && localParticipants.length > 0) {
            return localParticipants[0];
        }
    }
    GetParticipantBySsrc(ssrc) {
        for (let id in this._participants) {
            if (this._participants.hasOwnProperty(id)) {
                const participant = this._participants[id];
                if (participant.Sources.some((source) => source.Ssrc[0] === ssrc)) {
                    return participant;
                }
            }
        }
        return null;
    }
    GetParticipants(whereClause) {
        if (whereClause) {
            return ObjectUtils_1.default.Filter(this._participants, whereClause);
        }
        else {
            return this._participants ? Object.values(this._participants) : [];
        }
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ParticipantControllerListeners);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraListChanged, EventDispatcher_1.ParticipantControllerListeners, (payload) => this._onCameraListChanged(payload));
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraListRemoved, EventDispatcher_1.ParticipantControllerListeners, (payload) => this._onCameraListRemoved(payload));
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.SelectedParticipantsChanged, EventDispatcher_1.ParticipantControllerListeners, (payload) => this._onSelectedParticipantsChanged(payload));
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.SelectedParticipantUnavailable, EventDispatcher_1.ParticipantControllerListeners, (payload) => this._onSelectedParticipantsRemoved(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Available, EventDispatcher_1.ParticipantControllerListeners, (payload) => this._onParticipantAvailable(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.ParticipantControllerListeners, () => this._onDisconnecting());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnecting, EventDispatcher_1.ParticipantControllerListeners, () => this._onReconnecting());
        return Promise.resolve(undefined);
    }
    get PinnedParticipantsCount() {
        return Object.values(this._participants).filter((p) => p.IsPinned).length;
    }
    PinParticipant(participantId, pin) {
        Object.values(this._participants).forEach((participant) => {
            if (!pin || participantId !== participant.Id) {
                participant.IsControlled = false;
            }
            participant.IsPinned = false;
        });
        if (this._participants[participantId]) {
            this._participants[participantId].IsPinned = this._participants[participantId].HasVideoSource() && pin;
            this._vidyoCore.Controllers.ConferenceController.UpdatePinnedParticipants();
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    RemoveParticipant(id) {
        const participant = this._participants[id];
        if (participant) {
            this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantRemoved, participant.Id);
            if (!participant.IsRecorder) {
                if (participant.IsRemote || (this._reportLocalParticipant && participant.IsLocal)) {
                    this._vidyoCore.EventDispatcher.emitAsync(ParticipantEvents.Events.ParticipantLeft, { participant });
                    this._vidyoCore.EventDispatcher.emitAsync(ParticipantEvents.Events.ParticipantsChanged);
                }
                if (participant.IsRemote) {
                    participant.Sources.forEach((source) => {
                        this.RemoveParticipantDevice(participant.Id, source.Ssrc[0], source.Type);
                    });
                }
            }
        }
        delete this._participants[id];
    }
    RemoveParticipantDevice(participantId, ssrc, type) {
        const participant = this._participants[participantId];
        if (participant && participant) {
            const device = participant.GetDevice(ssrc);
            if (device) {
                if (participant.IsRemote) {
                    switch (type) {
                        case Source_1.SourceMediaType.Audio:
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteMicrophoneRemoved, {
                                microphone: device,
                                participant
                            });
                            break;
                        case Source_1.SourceMediaType.Video:
                            participant.IsPinned = false;
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteCameraRemoved, {
                                camera: device,
                                participant
                            });
                            break;
                        case Source_1.SourceMediaType.Application:
                            this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteWindowShareRemoved, {
                                windowShare: device,
                                participant
                            });
                            break;
                        default:
                            console.log("unsupported SourceMediaType " + type?.toString());
                            break;
                    }
                }
                participant.RemoveDevice(ssrc);
            }
        }
    }
    ReportLocalParticipant(payload) {
        this._reportLocalParticipant = payload.reportLocalParticipant;
    }
    ResetParticipantList() {
        this._participants = {};
    }
    TogglePinParticipant(participantId) {
        if (this._participants[participantId]) {
            this.PinParticipant(participantId, !this._participants[participantId].IsPinned);
        }
    }
    TryGetParticipant(id) {
        return this._participants[id];
    }
    UpdateParticipants(changes) {
        changes.forEach((change) => {
            let participant = this.TryGetParticipant(change.participantId);
            if (participant) {
                for (let key in change.update) {
                    if (change.update.hasOwnProperty(key)) {
                        participant[key] = change.update[key];
                    }
                }
            }
        });
        this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantsChanged);
    }
    UpdateParticipantSource(id, source) {
        let participant = this._participants[id];
        if (!participant) {
            return;
        }
        participant.Sources.push(source);
        this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantsChanged);
    }
    _onDisconnecting() {
        Object.keys(this._participants).forEach((participantId) => this.RemoveParticipant(participantId));
    }
    _onReconnecting() {
        Object.keys(this._participants).forEach((participantId) => this.RemoveParticipant(participantId));
    }
    _onParticipantAvailable(payload) {
        let id = payload.resource;
        const origin = id === this._vidyoCore.Controllers.RoomController.RoomUserResourceId()
            ? Participant_1.ParticipantOrigin.Local
            : Participant_1.ParticipantOrigin.Remote;
        const participant = this.CreateParticipant(id, origin, undefined, payload.jid, payload.clientType.toLowerCase());
        participant.FullJID = payload.fullJid;
    }
    _onCameraListChanged(payload) {
        const participant = this._participants[payload.participantUri];
        if (participant) {
            const camera = new Camera_1.Camera(payload.name, payload.id);
            camera.AltId = payload.altId;
            camera.ControlCapabilities = new Camera_1.CameraControlCapabilities(payload.control);
            this._vidyoCore.Controllers.LogController.LogDebug(() => `${participant.Id} updated camera "${camera.Name} (${camera.Id})"`);
            participant.CameraTableUpdate(camera);
        }
    }
    _onCameraListRemoved(payload) {
        Object.values(this._participants).forEach((participant) => {
            participant.GetCameraTableItems({ Id: payload.id, AltId: payload.altId }).forEach((camera) => {
                if (camera) {
                    this._vidyoCore.Controllers.LogController.LogDebug(() => `${participant.Id} removed camera "${camera.Name} (${camera.Id})"`);
                    participant.CameraTableRemove(camera.Id);
                }
            });
        });
    }
    _onSelectedParticipantsChanged(payload) {
        this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.DynamicParticipantChanged, {
            participants: payload.participants
        });
    }
    _onSelectedParticipantsRemoved(payload) {
        if (this._participants.hasOwnProperty(payload.id)) {
            this._participants[payload.id].Active = false;
            this._vidyoCore.EventDispatcher.emit(ParticipantEvents.Events.ParticipantsChanged);
        }
    }
}
exports.ParticipantController = ParticipantController;

},{"../../vidyo_simple_api/Devices":184,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/DeviceEvents":67,"../events/EventDispatcher":68,"../events/ParticipantEvents":73,"../events/StreamEvents":79,"../models/Participant":94,"../models/Source":98,"../models/device/Camera":101,"../models/device/Microphone":105,"../models/device/WindowShare":107,"../utils/ObjectUtils":153,"./BaseController":35}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionController = void 0;
const BaseController_1 = require("./BaseController");
const EventDispatcher_1 = require("../events/EventDispatcher");
const PermissionEvents = require("../../core/events/PermissionEvents");
const Permission_1 = require("../models/Permission");
const PermissionProvider_1 = require("../utils/PermissionProvider");
class PermissionController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._permissions = {};
    }
    Disable() {
        return super.Disable();
    }
    GetPermissions() {
        let data = {};
        for (let name in this._permissions) {
            if (name) {
                data[name] = this._permissions[name].granted;
            }
        }
        return data;
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.PermissionControllerListeners);
        this._vidyoCore.EventDispatcher.on(PermissionEvents.Events.PermissionListenerRegistered, EventDispatcher_1.PermissionControllerListeners, () => this._subscribePermissionsAll());
        this._vidyoCore.EventDispatcher.on(PermissionEvents.Events.PermissionListenerUnregistered, EventDispatcher_1.PermissionControllerListeners, () => this._unsubscribePermissionsAll());
        return Promise.resolve(undefined);
    }
    TrySubscribePermission(permissionType, _default) {
        let permission = this._getPermissionKeys(permissionType);
        return this._subscribePermission(permission).then(() => {
            return Promise.resolve(true);
        }).catch(() => {
            if (this._permissions[permissionType]) {
                this._unsubscribePermission(permissionType);
            }
            this._permissions[permissionType] = { granted: _default };
            this._notifyPermissionChanged(permissionType, this._permissions[permissionType].granted);
            return Promise.resolve(false);
        });
    }
    _getPermissionKeys(permissionType) {
        let permissionTypeEntries = Object.entries(Permission_1.PermissionType);
        if (permissionType) {
            let [key, value] = permissionTypeEntries.find((entry) => entry.includes(permissionType));
            return key;
        }
        return permissionTypeEntries.map((entry) => entry[0]);
    }
    _notifyPermissionChanged(permission, granted) {
        this._vidyoCore.EventDispatcher.emit(PermissionEvents.Events.PermissionUpdated, { granted, permission });
    }
    _onPermissionStatusChanged(event) {
        let permissionType = Permission_1.PermissionType[event.sender];
        if (permissionType) {
            switch (event.state) {
                case 'granted':
                    this._permissions[permissionType]['granted'] = true;
                    break;
                default:
                    this._permissions[permissionType]['granted'] = false;
                    break;
            }
            this._notifyPermissionChanged(permissionType, this._permissions[permissionType].granted);
        }
    }
    _subscribePermission(key) {
        return PermissionProvider_1.PermissionProvider.subscribe(key).then((permissionStatus) => {
            this._unsubscribePermission(Permission_1.PermissionType[key]);
            this._permissions[Permission_1.PermissionType[key]] = permissionStatus;
            this._permissions[Permission_1.PermissionType[key]].onchange = (event) => {
                let state = event.target.state;
                let sender = key;
                this._onPermissionStatusChanged({ sender, state });
            };
            this._onPermissionStatusChanged({ sender: key, state: permissionStatus.state });
            return Promise.resolve(true);
        }).catch((e) => {
            return Promise.reject(e);
        });
    }
    _subscribePermissionsAll() {
        let permissions = this._getPermissionKeys();
        for (let name of permissions) {
            this._subscribePermission(name).catch((e) => {
                if (this._permissions[Permission_1.PermissionType[name]]) {
                    this._notifyPermissionChanged(Permission_1.PermissionType[name], this._permissions[Permission_1.PermissionType[name]].granted);
                }
            });
        }
        return Promise.resolve(true);
    }
    _unsubscribePermission(permissionType) {
        if (this._permissions[permissionType]) {
            this._permissions[permissionType].onchange = null;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    _unsubscribePermissionsAll() {
        for (let permission in this._permissions) {
            if (permission) {
                this._unsubscribePermission(permission);
            }
        }
        return Promise.resolve(true);
    }
}
exports.PermissionController = PermissionController;

},{"../../core/events/PermissionEvents":74,"../events/EventDispatcher":68,"../models/Permission":95,"../utils/PermissionProvider":155,"./BaseController":35}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistedSettingsController = void 0;
const BaseController_1 = require("./BaseController");
const AutoPropertyHelper_1 = require("../utils/AutoPropertyHelper");
const LocalStorageProvider_1 = require("../utils/LocalStorageProvider");
function PersistedSettingsTemplate(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.SelectedCamera = '';
            this.SelectedMicrophone = '';
            this.SelectedSpeaker = '';
        }
    };
}
class PersistedSettingsController extends PersistedSettingsTemplate(BaseController_1.BaseController) {
    Disable() {
        return super.Disable();
    }
    Initialize() {
        (0, AutoPropertyHelper_1.CreateAutoProperties)(PersistedSettingsTemplate, this, (propertyName) => {
            const namespacedProperty = `VidyoCore::${propertyName}`;
            return {
                get: () => LocalStorageProvider_1.LocalStorageProvider.Get(namespacedProperty),
                set: (value) => LocalStorageProvider_1.LocalStorageProvider.Set(namespacedProperty, value)
            };
        });
        return Promise.resolve(undefined);
    }
}
exports.PersistedSettingsController = PersistedSettingsController;

},{"../utils/AutoPropertyHelper":136,"../utils/LocalStorageProvider":146,"./BaseController":35}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RendererController = void 0;
const StreamEvents = require("../events/StreamEvents");
const DeviceEvents = require("../events/DeviceEvents");
const ParticipantEvents = require("../events/ParticipantEvents");
const RenderEvents = require("../events/RenderEvents");
const StatisticsEvents = require("../events/StatisticsEvents");
const ModerationEvents = require("../events/ModerationEvents");
const Types = require("../models/RendererTypes");
const BaseController_1 = require("./BaseController");
const VideoResolution_1 = require("../models/VideoResolution");
const Collection_1 = require("../utils/Collection");
const GridLayout_1 = require("../models/renderer/GridLayout");
const TrackMetaDataProvider_1 = require("./StreamController/TrackMetaDataProvider");
const EventDispatcher_1 = require("../events/EventDispatcher");
const VideoPlaceholderTrack_1 = require("../utils/VideoPlaceholderTrack");
const ObjectUtils_1 = require("../utils/ObjectUtils");
const TimingProvider_1 = require("../utils/TimingProvider");
const Participant_1 = require("../models/Participant");
class RenderState {
    constructor() {
        this.ParticipantCount = 0;
        this.Resolutions = new VideoResolution_1.VideoResolutionSet();
        this.VideoPlaceholders = new Collection_1.Collection((id) => new Collection_1.DataWithId(id, new VideoPlaceholderTrack_1.VideoPlaceholderTrack()));
        this.Views = {};
    }
}
class RendererController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this.ApplicationGridLayout = new GridLayout_1.GridLayout(0, 0);
        this.DebounceTimeForResize = 1000;
        this.MaxNumberOfTracks = 9;
        this.MediaGridSplit = 'horizontal';
        this.VideoGridLayout = new GridLayout_1.GridLayout();
        this._previewOn = true;
        this._showLocalPreview = true;
        this._showLocalSharePreview = false;
        this._state = new RenderState();
    }
    get ShowLocalPreview() {
        return this._showLocalPreview;
    }
    set ShowLocalPreview(show) {
        this._showLocalPreview = show;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    get ShowLocalSharePreview() {
        return this._showLocalSharePreview;
    }
    get VideoResolutions() {
        return this._state.Resolutions;
    }
    get Views() {
        return this._state.Views;
    }
    AssignViewToCompositeRenderer(options) {
        let { viewId, viewStyle, remoteParticipants } = options;
        if (this._vidyoCore.Controllers.RendererController.RenderMode === Types.RenderMode.Custom) {
            this._vidyoCore.ReassignRenderer(viewId, viewStyle);
        }
        this.UpdateCompositeRenderer(viewId, viewStyle, remoteParticipants);
    }
    async AssignViewToLocalSource(options) {
        if (this._state.Views[options.viewId] && (this._state.Views[options.viewId].streamId || this._state.Views[options.viewId].sourceId)) {
            return Promise.reject(`View already used with another source`);
        }
        if (Object.values(this._state.Views).some(v => v.streamId === options.streamId)) {
            return Promise.reject(`Source already assigned to another view`);
        }
        let view = {
            allowZoom: options.allowZoom,
            displayCropped: options.displayCropped,
            isApplication: options.isApplication,
            isLocal: true,
            label: 'Self View',
            participantId: Participant_1.LocalParticipantId,
            streamId: options.streamId,
            sourceId: '',
            viewId: options.viewId
        };
        this._state.Views[options.viewId] = ObjectUtils_1.default.Merge({}, this._state.Views[options.viewId], view);
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
        return Promise.resolve(true);
    }
    async AssignViewToRemoteSource(options) {
        if (this._state.Views[options.viewId] && (this._state.Views[options.viewId].streamId || this._state.Views[options.viewId].sourceId)) {
            return Promise.reject(`View already used with another source`);
        }
        if (Object.values(this._state.Views).some(v => v.sourceId === options.sourceId)) {
            return Promise.reject(`Source already assigned to another view`);
        }
        return new Promise((resolve => {
            let waitingTimeout;
            const eventID = `options.sourceId${Math.random()}`;
            const assignComplete = () => {
                clearTimeout(waitingTimeout);
                this._vidyoCore.EventDispatcher.releaseGroup(eventID);
                resolve(true);
            };
            let participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(options.sourceId);
            if (participant && participant.IsRemote) {
                this._vidyoCore.EventDispatcher
                    .once(StreamEvents.Events.RemoteTrackAddedSsrc.Scoped(options.sourceId), eventID, () => assignComplete());
                waitingTimeout = setTimeout(() => assignComplete(), 500);
                let view = {
                    allowZoom: options.allowZoom,
                    displayCropped: options.displayCropped,
                    isApplication: options.isApplication,
                    isLocal: false,
                    label: participant.Name,
                    participantId: participant.Id,
                    sourceId: options.sourceId,
                    viewId: options.viewId
                };
                this._state.Views[options.viewId] = ObjectUtils_1.default.Merge({}, this._state.Views[options.viewId], view);
                this._vidyoCore.Controllers.ConferenceController.ActivateParticipantSource(participant, options.sourceId);
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
            }
            else {
                setTimeout(() => assignComplete(), 0);
            }
        }));
    }
    Disable() {
        return super.Disable();
    }
    GetViewBySsrc(ssrc) {
        const view = Object.values(this._state.Views).find((v) => v.sourceId === ssrc);
        return view;
    }
    HideView(options) {
        return new Promise((resolve) => {
            if (this._state.Views[options.viewId]) {
                let waitingTimeout;
                const eventID = `options.sourceId${Math.random()}`;
                const hideComplete = () => {
                    this._vidyoCore.EventDispatcher.releaseGroup(eventID);
                    clearTimeout(waitingTimeout);
                    resolve(true);
                };
                if (!this._state.Views[options.viewId].isLocal) {
                    const participantId = this._state.Views[options.viewId].participantId;
                    const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
                    if (participant) {
                        const sourceID = this._state.Views[options.viewId].sourceId;
                        this._vidyoCore.EventDispatcher
                            .once(StreamEvents.Events.RemoteTrackRemovedSsrc.Scoped(sourceID), eventID, () => hideComplete());
                        this._vidyoCore.Controllers.ConferenceController.DeactivateParticipantSource(participant, sourceID);
                    }
                    waitingTimeout = setTimeout(() => hideComplete(), 500);
                }
                else {
                    waitingTimeout = setTimeout(() => hideComplete(), 0);
                }
                delete this._state.Views[options.viewId];
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Hide, { viewId: options.viewId });
            }
            else {
                resolve(true);
            }
        });
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.RendererControllerListeners);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerSelected, EventDispatcher_1.RendererControllerListeners, (payload) => this._onSpeakerSelected(payload && payload.speaker || null));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.StreamListChanged, EventDispatcher_1.RendererControllerListeners, () => this._onStreamsChanged([]));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.TracksChanged, EventDispatcher_1.RendererControllerListeners, (streamId) => this._onStreamStateChanged(streamId));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.StreamEnableStateChanged, EventDispatcher_1.RendererControllerListeners, (streamId) => this._onStreamStateChanged(streamId));
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.ParticipantsChanged, EventDispatcher_1.RendererControllerListeners, () => { this._onParticipantsChanged(); });
        this._vidyoCore.EventDispatcher.on(StatisticsEvents.Events.Update, EventDispatcher_1.RendererControllerListeners, () => this._onStatisticsChanged());
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.ConferenceModeChanged, EventDispatcher_1.RendererControllerListeners, () => this._handleConferenceModeChanged());
        this._debouncedNotifyOfVideoResolutionChanged = TimingProvider_1.TimingProvider.Debounce(() => this._notifyOfVideoResolutionChanged(), this.DebounceTimeForResize);
        return Promise.resolve(undefined);
    }
    SetPreview(options) {
        this._previewOn = options.preview;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    SetShowLocalPreview(show) {
        this._showLocalPreview = show;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    ShowAudioMeters(options) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateAudioMeters, { viewId: options.viewId, showMeters: options.showMeters });
        return Promise.resolve(true);
    }
    ShowLocalShare(show) {
        this._showLocalSharePreview = show;
        let previewId = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream.Id;
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource, previewId);
    }
    ShowVideoTileControls(options) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateVideoTileControls, { viewId: options.viewId, showControls: options.showControls });
        return Promise.resolve(true);
    }
    ShowViewAt(options) {
        if (options.x || options.y) {
            this._vidyoCore.Controllers.LogController.LogDebug(() => 'X and Y parameters of ShowViewAt are not supported in browser');
        }
        const view = {
            viewId: options.viewId,
            position: {
                height: options.height,
                width: options.width
            }
        };
        this._state.Views[options.viewId] = ObjectUtils_1.default.Merge({}, this._state.Views[options.viewId], view);
        return Promise.resolve(true);
    }
    ShowViewLabel(options) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateViewLabel, { viewId: options.viewId, showLabel: options.showLabel });
        return Promise.resolve(true);
    }
    ShowCameraControl(participantId, show) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateCameraControl, { participantId, show });
        return Promise.resolve(true);
    }
    UpdateCompositeRenderer(viewId, viewStyle, remoteParticipants) {
        if (this.RenderMode === Types.RenderMode.Composite) {
            this._vidyoCore.Controllers.ResourcesManager.DynamicShowState = true;
            this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit = remoteParticipants;
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateCompositeRenderer, { viewId, viewStyle });
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.RecheckEachVideoSize);
            this._vidyoCore.Controllers.ConferenceController.UpdateSourcesState();
        }
    }
    UpdateRenderer() {
        let newNumberOfParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants().length;
        if (newNumberOfParticipants !== this._state.ParticipantCount) {
            this._state.ParticipantCount = newNumberOfParticipants;
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.RecheckEachVideoSize);
        }
    }
    UpdateVideoResolutions(videoContainer, videos) {
        let videoAspectRatioSum = 0;
        let videoAspectRatioCount = 0;
        let videoZeroSizeTracks = 0;
        let applicationAspectRatioSum = 0;
        let applicationAspectRatioCount = 0;
        let applicationZeroSizeTracks = 0;
        videos.forEach((video) => {
            let trackType = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantStream(video.Id)
                ? this._vidyoCore.Controllers.RemoteStreamController.GetTrackMediaType(video.Id)
                : this._vidyoCore.Controllers.LocalStreamController.GetStreamTrackMediaType(video.Id);
            if (trackType === TrackMetaDataProvider_1.MediaTrackType.Application || video.IsPinned) {
                if (video.Width > 0 && video.Height > 0) {
                    applicationAspectRatioSum += video.AspectRatio;
                    applicationAspectRatioCount += 1;
                }
                else {
                    applicationZeroSizeTracks += 1;
                }
            }
            else {
                if (video.Width > 0 && video.Height > 0) {
                    videoAspectRatioSum += video.AspectRatio;
                    videoAspectRatioCount += 1;
                }
                else {
                    videoZeroSizeTracks += 1;
                }
            }
            let oldResolution = this._state.Resolutions.Get(video.Id);
            if (oldResolution.AspectRatioRatioType !== video.AspectRatioRatioType) {
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.VideoCropSettingsChanged, video);
            }
        });
        let containerChanged = videos.some((resolution) => {
            let oldContainer = this._state.Resolutions.Get(resolution.Id).ContainerResolution;
            let newContainer = resolution.ContainerResolution;
            let change = oldContainer.Width !== newContainer.Width || oldContainer.Height !== newContainer.Height;
            return change;
        });
        this._state.Resolutions.UpdateVideoResolutions(videoContainer, videos);
        const applicationToVideoRatio = 0.8;
        let applicationGridCoefficient = 0;
        if (applicationAspectRatioCount > 0 && videoAspectRatioCount > 0) {
            applicationGridCoefficient = applicationToVideoRatio;
        }
        else if (applicationAspectRatioCount > 0 && videoAspectRatioCount <= 0) {
            applicationGridCoefficient = 1;
        }
        let videoGridCoefficient = 1 - applicationGridCoefficient;
        if (videoContainer.AspectRatio <= 1) {
            applicationGridCoefficient = 1 / applicationGridCoefficient;
            videoGridCoefficient = 1 / videoGridCoefficient;
            this.MediaGridSplit = 'vertical';
        }
        else {
            this.MediaGridSplit = 'horizontal';
        }
        const videoGridLayoutChanged = this.VideoGridLayout.Update(videoAspectRatioCount + videoZeroSizeTracks, videoContainer.AspectRatio * videoGridCoefficient, videoAspectRatioSum / videoAspectRatioCount, !!applicationGridCoefficient);
        const applicationGridChanged = this.ApplicationGridLayout.Update(applicationAspectRatioCount + applicationZeroSizeTracks, videoContainer.AspectRatio * applicationGridCoefficient, applicationAspectRatioSum / applicationAspectRatioCount);
        if (videoGridLayoutChanged || applicationGridChanged) {
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.GridLayoutChanged);
        }
        if (containerChanged && this._debouncedNotifyOfVideoResolutionChanged) {
            this._debouncedNotifyOfVideoResolutionChanged();
        }
    }
    _handleConferenceModeChanged() {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    _notifyOfVideoResolutionChanged() {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.VideoResolutionChanged);
    }
    _onParticipantsChanged() {
        this.UpdateRenderer();
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    _onSpeakerSelected(speaker) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.SpeakerSelected, { speakerId: speaker && speaker.Id || '' });
    }
    _onStatisticsChanged() {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.StatisticsUpdate);
    }
    _onStreamsChanged(ids) {
        this.UpdateRenderer();
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update, ids);
    }
    _onStreamStateChanged(streamId) {
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource, streamId);
        this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.Update);
    }
    _simplifyAspectRatio(ratio) {
        const maxRatio = 10;
        const threeQuarters = 0.75;
        const half = 0.5;
        const quarter = 0.25;
        if (ratio >= maxRatio) {
            return maxRatio.toString();
        }
        else if (ratio >= 1) {
            let ratioBreakpoint = Math.floor(ratio);
            return ratioBreakpoint.toString();
        }
        else if (ratio >= threeQuarters) {
            return '0.75';
        }
        else if (ratio >= half) {
            return '0.5';
        }
        else if (ratio >= quarter) {
            return '0.25';
        }
        else {
            return '0';
        }
    }
}
exports.RendererController = RendererController;

},{"../events/DeviceEvents":67,"../events/EventDispatcher":68,"../events/ModerationEvents":72,"../events/ParticipantEvents":73,"../events/RenderEvents":75,"../events/StatisticsEvents":78,"../events/StreamEvents":79,"../models/Participant":94,"../models/RendererTypes":96,"../models/VideoResolution":100,"../models/renderer/GridLayout":108,"../utils/Collection":137,"../utils/ObjectUtils":153,"../utils/TimingProvider":166,"../utils/VideoPlaceholderTrack":169,"./BaseController":35,"./StreamController/TrackMetaDataProvider":59}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourcesManager = void 0;
const BaseController_1 = require("../BaseController");
const Constants = require("../../utils/Constants");
const LogEvents_1 = require("../../events/LogEvents");
const ResourcesManagerEvents = require("../../events/ResourcesManagerEvents");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
const AdvancedSettingsEvents = require("../../events/AdvancedSettingsEvents");
const VideoResolution_1 = require("../../models/VideoResolution");
class ResourcesManager extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this.NumberOfDynamicOffsToSend = 5;
        this._adjustTimeoutsCounter = 0;
        this._currentSourcesLimit = 1;
        this._selfViewPolicy = Constants.DefaultSelfViewPolicy;
        this._stopReceiving = false;
        this._lastIncTimestamp = 0;
        this._lastDecTimestamp = 0;
    }
    get AudioCount() {
        return this._vidyoCore.Controllers.AdvancedSettingsController.DynamicAudioSources;
    }
    get SelfViewPolicy() {
        return this._selfViewPolicy;
    }
    get CurrentDynamicSourcesLimit() {
        let currentDynamicSourcesLimit = Math.max(this.CurrentSourcesLimit - this._vidyoCore.Controllers.ParticipantController.RemoteSharesCount, 0);
        currentDynamicSourcesLimit = Math.min(currentDynamicSourcesLimit, this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit);
        return currentDynamicSourcesLimit;
    }
    get CurrentSourcesLimit() {
        const core = this._vidyoCore;
        if (core.Controllers.AdvancedSettingsController.EnableCompositorFixedParticipants) {
            return core.Controllers.AdvancedSettingsController.ParticipantLimit + core.Controllers.ParticipantController.RemoteSharesCount;
        }
        else if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            return core.Controllers.AdvancedSettingsController.ParticipantLimit + core.Controllers.ParticipantController.RemoteSharesCount;
        }
        else {
            return this._currentSourcesLimit;
        }
    }
    get DynamicAudioSourcesDisabled() {
        return this._vidyoCore.Controllers.AdvancedSettingsController.DisableDynamicAudioSources;
    }
    set DynamicShowState(state) {
        this._isDynamicShowState = state;
    }
    AccumulateStatistics(stats) {
        if (stats.userStats && stats.userStats.length) {
            const userStats = stats.userStats[0];
            if (userStats.roomStats && userStats.roomStats.length) {
                const roomStats = userStats.roomStats[0];
                let availableStatistics = {
                    bandwidthReceiveObj: roomStats.availableDecodeBwPercent,
                    bandwidthSendObj: roomStats.availableEncodeBwPercent,
                    cpuDecodeObj: roomStats.availableDecodeCpuPercent,
                    cpuEncodeObj: roomStats.availableEncodeCpuPercent
                };
                this._onAvailableResourcesChanged(availableStatistics);
            }
        }
    }
    Disable() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ResourceManagerEventListeners);
        return super.Disable();
    }
    Initialize() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.ResourceManagerEventListeners);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.DisableDynamicAudioSourcesChanged, EventDispatcher_1.ResourceManagerEventListeners, () => this._onDisableDynamicAudioSourcesChanged());
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ParticipantLimitChanged, EventDispatcher_1.ResourceManagerEventListeners, (limit) => this._onParticipantLimitChanged(limit));
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableCompositorFixedParticipantsChanged, EventDispatcher_1.ResourceManagerEventListeners, () => this._onParticipantLimitChanged());
        return super.Initialize();
    }
    RegisterResourceManagerEventListener(resourceManagerCallbacks) {
        if (resourceManagerCallbacks.onMaxRemoteSourcesChanged) {
            this._vidyoCore.EventDispatcher.on(ResourcesManagerEvents.Events.MaxRemoteSourcesChanged, EventDispatcher_1.VidyoResourceManagerEventListeners, (payload) => {
                resourceManagerCallbacks.onMaxRemoteSourcesChanged(payload.maxRemoteSourcesObj);
            });
        }
        if (resourceManagerCallbacks.onAvailableResourcesChanged) {
            this._vidyoCore.EventDispatcher.on(ResourcesManagerEvents.Events.AvailableResourcesChanged, EventDispatcher_1.VidyoResourceManagerEventListeners, (payload) => {
                resourceManagerCallbacks.onAvailableResourcesChanged(payload.cpuEncodeObj, payload.cpuDecodeObj, payload.bandwidthSendObj, payload.bandwidthReceiveObj);
            });
        }
        return Promise.resolve(true);
    }
    Start() {
        if (!this._runningState) {
            this._runningState = true;
            this._currentSourcesLimit = Math.min(this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit, ResourcesManager.DEFAULT_START_SOURCES_LIMIT);
            this._adjustTimeoutsCounter = 0;
            this._lastIncTimestamp = this._lastDecTimestamp = 0;
            setTimeout(() => this._adjustSources(), this._getTimeoutForAdjust());
        }
    }
    Stop() {
        this._runningState = false;
    }
    UnregisterResourceManagerEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoResourceManagerEventListeners);
        return Promise.resolve(true);
    }
    _adjustSources() {
        if (this._runningState) {
            let limit = this._calculateNewLimit();
            this._onSourceLimitChanged(limit);
            const timeout = this._getTimeoutForAdjust();
            this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: next adjusting will be in ${timeout} ms`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            setTimeout(() => this._adjustSources(), timeout);
        }
    }
    _calculateNewLimit() {
        if (this._vidyoCore.Controllers.AdvancedSettingsController.EnableCompositorFixedParticipants) {
            return this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit +
                this._vidyoCore.Controllers.ParticipantController.RemoteSharesCount;
        }
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            return this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit +
                this._vidyoCore.Controllers.ParticipantController.RemoteSharesCount;
        }
        let limit = this._currentSourcesLimit;
        const receiveBitrateAvailable = this._vidyoCore.Controllers.StatisticsController.AvailableReceiveBitrate;
        const receiveBitrate = this._vidyoCore.Controllers.StatisticsController.CurrentReceiveBitrate;
        const AcceptablePacketLost = 40;
        const AcceptableGrowPacketLost = 20;
        const TERRIBLE_PACKETS_LOST = 70;
        const GOOD_PACKETS_LOST = 5;
        const codecName = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName() ?? VideoResolution_1.CodecName.VP8;
        const bandwidthPerTile = (0, VideoResolution_1.CalculateNominalSendBitrate)(1280, 720, VideoResolution_1.CodecName[codecName]);
        const tilesByBandwidth = Math.min(receiveBitrateAvailable > 0 ? Math.max(Math.floor(receiveBitrateAvailable / bandwidthPerTile), ResourcesManager.MIN_SOURCE_LIMIT) : 0, Constants.ParticipantLimit);
        this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager:
            ; Current limit = ${limit}
            ; Current active sources packet lost = ${this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost || 0}
            ; Available receive Bitrate = ${receiveBitrateAvailable} => up to ${tilesByBandwidth} tiles
            ; Actual receive bitrate = ${receiveBitrate}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
        if (this._adjustTimeoutsCounter < ResourcesManager.AGGRESSIVE_GROW_COUNT) {
            this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: aggressive growing process - ${this._adjustTimeoutsCounter} out of ${ResourcesManager.AGGRESSIVE_GROW_COUNT} attempts`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            if (tilesByBandwidth > 0) {
                if (limit < tilesByBandwidth) {
                    this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: increase limit by 1 due to bandwidth`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                }
                limit++;
            }
            else if (tilesByBandwidth <= 0 &&
                typeof this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost === 'number' &&
                this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost < AcceptableGrowPacketLost) {
                this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: increase limit by 1 due to packet lost`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                limit++;
            }
            return limit;
        }
        if (tilesByBandwidth > 0) {
            if (limit < tilesByBandwidth) {
                if (Date.now() - this._lastDecTimestamp > 60000) {
                    this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: increase limit from ${limit} to ${tilesByBandwidth} due to bandwidth`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                    limit++;
                    this._lastIncTimestamp = Date.now();
                }
                else {
                    this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager skipping tile number increment: decrement within last minute`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                }
            }
            else if (limit > tilesByBandwidth) {
                if (Date.now() - this._lastIncTimestamp > 60000) {
                    this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: reduce limit from ${limit} to ${tilesByBandwidth} due to bandwidth`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                    limit--;
                    this._lastDecTimestamp = Date.now();
                }
                else {
                    this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager skipping tile number decrement: increment within last minute`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                }
            }
            this._adjustTimeoutsCounter = Math.min(this._adjustTimeoutsCounter, ResourcesManager.SMOOTH_START_ADJUST_COUNT - 1);
        }
        else if (receiveBitrateAvailable <= 0 && this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost > AcceptablePacketLost) {
            this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: reduce limit by ${this._getDecreaseNumberForAdjust()} due to packet lost`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            limit = Math.max(ResourcesManager.MIN_SOURCE_LIMIT, limit - this._getDecreaseNumberForAdjust());
            if (this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost > TERRIBLE_PACKETS_LOST &&
                this._adjustTimeoutsCounter > ResourcesManager.SMOOTH_START_ADJUST_COUNT) {
                this._adjustTimeoutsCounter = Math.min(this._adjustTimeoutsCounter, ResourcesManager.SMOOTH_START_ADJUST_COUNT - 1);
            }
        }
        else if (receiveBitrateAvailable <= 0 && this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost < AcceptableGrowPacketLost) {
            this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: increase limit by 1 due to packet lost`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            limit++;
            if (this._vidyoCore.Controllers.StatisticsController.CombinedCurrentPacketLost < GOOD_PACKETS_LOST &&
                this._adjustTimeoutsCounter > ResourcesManager.SMOOTH_START_ADJUST_COUNT) {
                this._adjustTimeoutsCounter = Math.min(this._adjustTimeoutsCounter, ResourcesManager.SMOOTH_START_ADJUST_COUNT - 1);
            }
        }
        return limit;
    }
    _onDisableDynamicAudioSourcesChanged() {
        if (this._isDynamicShowState) {
            this._vidyoCore.Controllers.ConferenceController.SendDynamicShow();
        }
    }
    _onParticipantLimitChanged(limit = this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit) {
        if (limit === 0) {
            this._stopReceiving = true;
        }
        else {
            if (this._stopReceiving) {
                this._currentSourcesLimit = Math.min(this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit, ResourcesManager.DEFAULT_START_SOURCES_LIMIT);
            }
            this._stopReceiving = false;
        }
        if (this._isDynamicShowState) {
            this._vidyoCore.Controllers.ConferenceController.SendDynamicShow();
        }
    }
    _onSourceLimitChanged(limit) {
        let maxSourcesLimit = this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit;
        const newLimit = Math.min(limit, maxSourcesLimit);
        if (this._currentSourcesLimit !== newLimit) {
            this._currentSourcesLimit = newLimit;
            this._vidyoCore.Controllers.LogController.LogDebug(`ResourceManager: remote source limit now is - ${this._currentSourcesLimit}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            this._onMaxRemoteSourcesChanged({ maxRemoteSourcesObj: this.CurrentSourcesLimit });
            if (this._isDynamicShowState) {
                this._vidyoCore.Controllers.ConferenceController.SendDynamicShow();
            }
        }
    }
    _onAvailableResourcesChanged(availableResourcesChangedPayload) {
        this._vidyoCore.EventDispatcher.emit(ResourcesManagerEvents.Events.AvailableResourcesChanged, availableResourcesChangedPayload);
    }
    _onMaxRemoteSourcesChanged(maxRemoteSourcesChangedPayload) {
        this._vidyoCore.EventDispatcher.emit(ResourcesManagerEvents.Events.MaxRemoteSourcesChanged, maxRemoteSourcesChangedPayload);
    }
    _getDecreaseNumberForAdjust() {
        return this._adjustTimeoutsCounter < ResourcesManager.SMOOTH_START_ADJUST_COUNT ? 0 : 1;
    }
    _getTimeoutForAdjust() {
        if (this._adjustTimeoutsCounter++ < ResourcesManager.SMOOTH_START_ADJUST_COUNT) {
            return ResourcesManager.SMOOTH_START_ADJUST_TIMEOUT;
        }
        else {
            return ResourcesManager.ADJUST_TIMEOUT;
        }
    }
}
exports.ResourcesManager = ResourcesManager;
ResourcesManager.ADJUST_TIMEOUT = 15000;
ResourcesManager.MIN_SOURCE_LIMIT = 1;
ResourcesManager.SMOOTH_START_ADJUST_COUNT = 20;
ResourcesManager.AGGRESSIVE_GROW_COUNT = 4;
ResourcesManager.SMOOTH_START_ADJUST_TIMEOUT = 3000;
ResourcesManager.DEFAULT_START_SOURCES_LIMIT = 1;

},{"../../events/AdvancedSettingsEvents":62,"../../events/EventDispatcher":68,"../../events/LogEvents":69,"../../events/ResourcesManagerEvents":76,"../../models/VideoResolution":100,"../../utils/Constants":138,"../../utils/OperatingSystemInfoProvider":154,"../BaseController":35}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomController = exports.CreateRoomResults = void 0;
const Errors = require("../utils/Errors");
const BaseController_1 = require("./BaseController");
const RoomEvents_1 = require("../events/RoomEvents");
const Room_1 = require("../models/Room");
const Room_2 = require("../../vidyo_simple_api/Room");
const ConnectionEvents = require("../events/ConnectionEvents");
const ConnectionEvents_1 = require("../events/ConnectionEvents");
const VidyoConnector_1 = require("../../vidyo_connector_api/VidyoConnector");
const StreamEvents = require("../events/StreamEvents");
const StatisticsEvents = require("../events/StatisticsEvents");
const EventDispatcher_1 = require("../events/EventDispatcher");
var CreateRoomResults;
(function (CreateRoomResults) {
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_DUPLICATENAME"] = 0] = "VIDYO_USERROOMCREATERESULT_DUPLICATENAME";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_MISCLOCALERROR"] = 1] = "VIDYO_USERROOMCREATERESULT_MISCLOCALERROR";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_MISCREMOTEERROR"] = 2] = "VIDYO_USERROOMCREATERESULT_MISCREMOTEERROR";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_NORESPONSE"] = 3] = "VIDYO_USERROOMCREATERESULT_NORESPONSE";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_NOTFOUND"] = 4] = "VIDYO_USERROOMCREATERESULT_NOTFOUND";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_OK"] = 5] = "VIDYO_USERROOMCREATERESULT_OK";
    CreateRoomResults[CreateRoomResults["VIDYO_USERROOMCREATERESULT_UNAUTHORIZED"] = 6] = "VIDYO_USERROOMCREATERESULT_UNAUTHORIZED";
})(CreateRoomResults = exports.CreateRoomResults || (exports.CreateRoomResults = {}));
class RoomController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._handleUnprocessedAudioCodecUpdated = ({ codecName }) => {
            const isUnprocessAudioSupported = codecName?.toLowerCase().includes('opus');
            if (this._isUnprocessAudioSupported !== isUnprocessAudioSupported) {
                this._isUnprocessAudioSupported = isUnprocessAudioSupported;
                this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.UnprocessedAudioSupportChanged, {
                    supported: this._isUnprocessAudioSupported
                });
            }
        };
        this._handleUnprocessedAudioStateUpdated = ({ enabled }) => {
            if (this._isUnprocessAudioStarted !== enabled) {
                this._isUnprocessAudioStarted = enabled;
                this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.UnprocessedAudioStarted, {
                    started: this._isUnprocessAudioStarted
                });
            }
        };
    }
    ConferenceJoin(sid) {
        return Promise.resolve();
    }
    get CoreRoom() {
        return this._room;
    }
    CreateRoom(options) {
        return this._vidyoCore.HunterProvider.JoinRoom()
            .then((payload) => {
            this._room.Jid = payload.roomName;
            this._room.RoomId = payload.roomId;
            this._room.LocalUserId = this._vidyoCore.HunterProvider.Jid().resource;
            this._room.InRoom = true;
            this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.Created, {
                room: new Room_2.Room(this._vidyoCore, this._room),
                result: CreateRoomResults[CreateRoomResults.VIDYO_USERROOMCREATERESULT_OK],
                token: options.token
            });
        }).then(() => {
            return Promise.resolve(undefined);
        }).catch((error) => {
            if (error.name === Errors.NotValidClientError.Name) {
                return;
            }
            let result;
            switch (error.name) {
                case Errors.TimeOutError.Name:
                    result = CreateRoomResults[CreateRoomResults.VIDYO_USERROOMCREATERESULT_NORESPONSE];
                    break;
                case Errors.DuplicateNameError.Name:
                    result = CreateRoomResults[CreateRoomResults.VIDYO_USERROOMCREATERESULT_DUPLICATENAME];
                    break;
                default:
                    result = CreateRoomResults[CreateRoomResults.VIDYO_USERROOMCREATERESULT_MISCREMOTEERROR];
            }
            error.message = result;
            this._vidyoCore.Controllers.LogController.LogError(error);
            this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.Created, {
                room: new Room_2.Room(this._vidyoCore, this._room),
                result: result,
                token: options.token
            });
            this._vidyoCore.EventDispatcher.emit(ConnectionEvents.Events.SignallingError, new ConnectionEvents_1.VidyoEventInfo('SignallingError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, result, 'error'));
        });
    }
    Disable() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.RoomControllerListeners);
        return super.Disable();
    }
    Enter(room) {
        const startConnectingTime = new Date();
        if (room.InRoom) {
            const enterRoomLatency = new Date().getTime() - startConnectingTime.getTime();
            this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.Entered, { roomId: room.RoomId, roomJid: room.Jid });
            this._vidyoCore.Controllers.StatisticsController.EndpointStatistic.RoomEnterTimeConsumedMs = enterRoomLatency;
            return Promise.resolve(undefined);
        }
        else {
            return this._vidyoCore.HunterProvider.JoinRoom()
                .then((result) => {
                const enterRoomLatency = new Date().getTime() - startConnectingTime.getTime();
                this._vidyoCore.Controllers.StatisticsController.EndpointStatistic.RoomEnterTimeConsumedMs = enterRoomLatency;
                room.InRoom = true;
                this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.Entered, { roomId: room.RoomId, roomJid: room.Jid });
                return Promise.resolve(undefined);
            });
        }
    }
    GetConference() {
        return this._conference;
    }
    Initialize() {
        this._room = new Room_1.Room();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.RoomControllerListeners);
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.UnprocessedAudioStateUpdated, EventDispatcher_1.RoomControllerListeners, this._handleUnprocessedAudioStateUpdated);
        this._vidyoCore.EventDispatcher.on(StatisticsEvents.Events.UnprocessedAudioCodecUpdated, EventDispatcher_1.RoomControllerListeners, this._handleUnprocessedAudioCodecUpdated);
        return Promise.resolve(undefined);
    }
    Leave(room) {
        return this._vidyoCore.HunterProvider.LeaveRoom().then(() => {
            this._vidyoCore.EventDispatcher.emit(RoomEvents_1.Events.Left, { roomId: room.RoomId, roomJid: room.Jid });
        });
    }
    LeaveAll() {
        return this.Leave(this._room);
    }
    RoomJid() {
        return this._room.Jid;
    }
    RoomUserResourceId() {
        return this._room.LocalUserId;
    }
    SetConference(conference, displayName) {
        this._conference = conference;
        this._room.DisplayName = displayName;
    }
}
exports.RoomController = RoomController;

},{"../../vidyo_connector_api/VidyoConnector":181,"../../vidyo_simple_api/Room":190,"../events/ConnectionEvents":66,"../events/EventDispatcher":68,"../events/RoomEvents":77,"../events/StatisticsEvents":78,"../events/StreamEvents":79,"../models/Room":97,"../utils/Errors":141,"./BaseController":35}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatisticsController = void 0;
const ConferenceEvents = require("../events/ConferenceEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const StreamEvents = require("../events/StreamEvents");
const ParticipantsEvents = require("../events/ParticipantEvents");
const Constants = require("../utils/Constants");
const StatisticsEvents = require("../events/StatisticsEvents");
const BaseController_1 = require("./BaseController");
const Constants_1 = require("../utils/Constants");
const Statistics_1 = require("../models/statistics/Statistics");
const EventDispatcher_1 = require("../events/EventDispatcher");
const TimingProvider_1 = require("../utils/TimingProvider");
const Stats_1 = require("../../vidyo_simple_api/stats/Stats");
const OperatingSystemInfoProvider_1 = require("../utils/OperatingSystemInfoProvider");
const Source_1 = require("../models/Source");
const ObjectUtils_1 = require("../utils/ObjectUtils");
const StringUtils_1 = require("../utils/StringUtils");
const StatisticsExtension_1 = require("../utils/StatisticsExtension");
const SimplifiedVidyoCore_1 = require("../SimplifiedVidyoCore");
const RTCStatsReportHelper_1 = require("../utils/RTCStatsReportHelper");
const AdvancedSettingsEvents = require("../events/AdvancedSettingsEvents");
const LogEvents_1 = require("../events/LogEvents");
const Devices_1 = require("../../vidyo_simple_api/Devices");
class StatisticsController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this.EndpointStatistic = new Statistics_1.EndpointStatistics();
        this.RoomStatistics = new Statistics_1.RoomStatistics();
        this.UserStatistic = new Statistics_1.UserStatistics();
        this._bytesReceived = 0;
        this._bytesSent = 0;
        this._intervalRefreshHandle = null;
        this._intervalResourceManagerStatisticsMeasuring = null;
        this._intervalSendStatsHandle = null;
        this._maxPercent = 100;
        this._receiveBytesPrev = 0;
        this._roomJoinedTimestamp = 0;
        this._sendBytesPrev = 0;
        this._statsOn = false;
        this._timestampPrev = 0;
        this._inCall = false;
        this._availableOutgoingBandwidthCache = [];
        this.MAX_AOB_SAMPLE_NUMBER = 20;
    }
    Disable() {
        this._onDisconnected();
        return super.Disable();
    }
    get CombinedCurrentPacketLost() {
        let totalPacketLost = 0;
        let numberOfSources = 0;
        this.RoomStatistics.ParticipantStats
            .filter((participantStat) => participantStat.ParticipantIsActive && this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantStat.Id)?.IsRemote)
            .forEach((participantStat) => {
            if (participantStat.RemoteCameraStats.length > 0) {
                totalPacketLost += participantStat.RemoteCameraStats[0].CurrentPacketLost || 0;
                numberOfSources++;
            }
        });
        this.RoomStatistics.ParticipantStats
            .forEach((participantStat) => {
            if (participantStat.RemoteWindowShareStats.length > 0) {
                totalPacketLost += participantStat.RemoteWindowShareStats[0].CurrentPacketLost || 0;
                numberOfSources++;
            }
        });
        return numberOfSources == 0 ? 0 : totalPacketLost /= numberOfSources;
    }
    get CurrentReceiveBitrate() {
        return this.RoomStatistics.ReceiveBitRateTotal;
    }
    get AvailableReceiveBitrate() {
        return this.RoomStatistics.ReceiveBitRateAvailable;
    }
    GetCallStats() {
        const localParticipant = this._vidyoCore.Controllers.ParticipantController.GetLocalParticipant();
        const participantId = localParticipant ? localParticipant.Id : '';
        let stats = new Statistics_1.CallStatistics(participantId);
        stats.FillFromBandwidthSummaryStatistics(this.RoomStatistics.BandwidthVideo);
        stats.AvailableSendBandwidth.Value = this.RoomStatistics.SendBitRateAvailable;
        stats.AvailableRecieveBandwidth.Value = this.RoomStatistics.ReceiveBitRateAvailable;
        if (ObjectUtils_1.default.IsNotEmpty(this.EndpointStatistic.LocalMicrophoneStats)) {
            stats.FillFromLocalMicrophoneStatistics(this.EndpointStatistic.LocalMicrophoneStats[0]);
        }
        if (ObjectUtils_1.default.IsNotEmpty(this.EndpointStatistic.LocalCameraStats)) {
            stats.FillFromLocalVideoSourceStatistics(this.EndpointStatistic.LocalCameraStats[0]);
        }
        this.RoomStatistics.ParticipantStats.forEach((p) => {
            const remoteParticipant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(p.Id);
            let participantStats = stats.ParticipantStatistics.Get(p.Id);
            let shareStatistics = stats.ShareStatistics.Get(p.Id);
            participantStats.ParticipantIsActive = p.ParticipantIsActive;
            if (ObjectUtils_1.default.IsNotEmpty(p.RemoteMicrophoneStats)) {
                participantStats.FillFromRemoteMicrophoneStatistics(p.RemoteMicrophoneStats[0]);
            }
            if (ObjectUtils_1.default.IsNotEmpty(p.RemoteCameraStats)) {
                let cameraStats = p.RemoteCameraStats[0];
                participantStats.FillFromRemoteVideoSourceStatistics(cameraStats);
                const showParams = this._vidyoCore.Controllers.ConferenceController
                    .GetRequestedShowData(remoteParticipant?.GetVideoSources()?.[0]?.Ssrc[0]);
                if (showParams && showParams.windowSize) {
                    participantStats.VideoResolutionRequested.SetValues(showParams.windowSize.width, showParams.windowSize.height);
                }
            }
            if (ObjectUtils_1.default.IsNotEmpty(p.RemoteWindowShareStats)) {
                let shareStats = p.RemoteWindowShareStats[0];
                shareStatistics.FillFromRemoteVideoSourceStatistics(shareStats);
                const showParams = this._vidyoCore.Controllers.ConferenceController
                    .GetRequestedShowData(remoteParticipant?.GetApplicationSources()?.[0]?.Ssrc[0]);
                if (showParams && showParams.windowSize) {
                    shareStatistics.VideoResolutionRequested.SetValues(showParams.windowSize.width, showParams.windowSize.height);
                }
            }
            participantStats.AvailableRecieveBandwidth.Value = stats.AvailableRecieveBandwidth.Value;
            participantStats.AvailableSendBandwidth.Value = stats.AvailableSendBandwidth.Value;
            participantStats.SSRCs.Push(p.SSRCs);
        });
        return stats;
    }
    GetEndpointStatistics() {
        this._updateEndpointStatistics();
        return this.EndpointStatistic;
    }
    LogCallSummary() {
        let strToLog = '';
        this.EndpointStatistic.LocalCameraStats.forEach((localVideoSourceStatistics) => {
            strToLog += this._logCallQuality(localVideoSourceStatistics.Name, localVideoSourceStatistics);
        });
        this.EndpointStatistic.LocalWindowShareStats.forEach((localVideoSourceStatistics) => {
            strToLog += this._logCallQuality("Window Share", localVideoSourceStatistics);
        });
        this.EndpointStatistic.LocalMonitorStats.forEach((localVideoSourceStatistics) => {
            strToLog += this._logCallQuality("Monitor Share", localVideoSourceStatistics);
        });
        strToLog += this._logRemoteParticipantsDecoderStats();
        this._vidyoCore.Controllers.LogController.LogInfo(() => strToLog, LogEvents_1.VidyoLogCategory.VidyoClient);
    }
    GetLocalCameraCodecName() {
        let codecName;
        const localCameraStats = this.EndpointStatistic.LocalCameraStats
            .find((lcs) => lcs.TrackType === SimplifiedVidyoCore_1.TrackType.Camera);
        if (localCameraStats) {
            let mimeType = localCameraStats.CodecName;
            if (mimeType) {
                const CodecNameReg = /[^/]*$/.exec(mimeType);
                if (CodecNameReg && CodecNameReg.length) {
                    codecName = CodecNameReg[0];
                }
            }
        }
        return codecName;
    }
    GetLocalCameraResolution() {
        let width = 0;
        let height = 0;
        let frameRate = 0;
        const localCameraStats = this.EndpointStatistic.LocalCameraStats
            .find((lcs) => lcs.TrackType === SimplifiedVidyoCore_1.TrackType.Camera);
        if (localCameraStats) {
            width = localCameraStats.Width;
            height = localCameraStats.Height;
            frameRate = localCameraStats.VideoFrameRateSent;
        }
        return { width, height, frameRate };
    }
    GetUserStatistics() {
        return this.UserStatistic;
    }
    Initialize() {
        this._initStatistics();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.StatisticsControllerListeners);
        this._vidyoCore.EventDispatcher
            .on(ConferenceEvents.Events.ConferenceJoined, EventDispatcher_1.StatisticsControllerListeners, () => this._onConferenceJoined());
        this._vidyoCore.EventDispatcher
            .on(ConnectionEvents.Events.Disconnecting, EventDispatcher_1.StatisticsControllerListeners, () => this._onDisconnected());
        StatisticsExtension_1.StatisticsExtention.Initialize(this._vidyoCore);
        this._vidyoCore.EventDispatcher
            .on(ParticipantsEvents.Events.ParticipantAddedOrUpdated, EventDispatcher_1.StatisticsControllerListeners, (id) => this._onParticipantAddedOrUpdated(id));
        this._vidyoCore.EventDispatcher
            .on(ParticipantsEvents.Events.ParticipantRemoved, EventDispatcher_1.StatisticsControllerListeners, (id) => this._onParticipantRemoved(id));
        this._vidyoCore.EventDispatcher
            .on(ConferenceEvents.Events.SourceDetected, EventDispatcher_1.StatisticsControllerListeners, (data) => this._onParticipantSourceAdded(data));
        this._vidyoCore.EventDispatcher
            .on(ConferenceEvents.Events.SourceRemoved, EventDispatcher_1.StatisticsControllerListeners, (data) => this._onParticipantSourceRemoved(data));
        this._vidyoCore.EventDispatcher
            .on(StatisticsEvents.Events.ReceiveBandwidthUpdated, EventDispatcher_1.StatisticsControllerListeners, (data) => this._onReceiveBandwidthUpdated(data));
        this._vidyoCore.EventDispatcher
            .on(StreamEvents.Events.TransmittedStreamTracksSsrcUpdated, EventDispatcher_1.StatisticsControllerListeners, () => this._onLocalTracksSSRCsChanged());
        this._vidyoCore.EventDispatcher
            .on(AdvancedSettingsEvents.Events.StatisticsRefreshIntervalChanged, EventDispatcher_1.StatisticsControllerListeners, () => {
            if (this._inCall && !this._vidyoCore.Controllers.AdvancedSettingsController.DisableStats) {
                if (this._intervalRefreshHandle !== null) {
                    clearTimeout(this._intervalRefreshHandle);
                }
                this._setUpdateStatisticsCall();
            }
        });
        return Promise.resolve(undefined);
    }
    SetClientConnectionStats(host, port, serviceType) {
        this.UserStatistic.Host = host;
        this.UserStatistic.Port = port || 0;
        this.UserStatistic.ServiceType = serviceType || '';
        StatisticsExtension_1.StatisticsExtention.catchConnectTime();
    }
    _clearIntervals() {
        if (this._intervalRefreshHandle !== null) {
            clearTimeout(this._intervalRefreshHandle);
            this._intervalRefreshHandle = null;
        }
        if (this._intervalSendStatsHandle !== null) {
            TimingProvider_1.TimingProvider.ClearInterval(this._intervalSendStatsHandle);
            this._intervalSendStatsHandle = null;
            TimingProvider_1.TimingProvider.ClearInterval(this._intervalResourceManagerStatisticsMeasuring);
            this._intervalResourceManagerStatisticsMeasuring = null;
        }
    }
    _fillLocalCameraStatistics() {
        const selectedDevices = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices();
        const camera = selectedDevices.Camera;
        const localCameraStats = this.EndpointStatistic.LocalCameraStats
            .find((lcs) => lcs.TrackType === SimplifiedVidyoCore_1.TrackType.Camera);
        if (typeof camera !== 'boolean' && localCameraStats) {
            StatisticsExtension_1.StatisticsExtention.fillLocalCameraStatistics(localCameraStats, camera);
        }
    }
    _fillLocalMicrophoneStatistics() {
        const tracksSSRCs = this._vidyoCore.Controllers.TransmittedStreamController.GetTracksSSRCs();
        this.EndpointStatistic.LocalMicrophoneStats.forEach((localMicrophoneStats) => {
            const trackId = tracksSSRCs[localMicrophoneStats.Id];
            const settings = this._vidyoCore.Controllers.LocalStreamController.GetTransmittedTrackSettings(trackId);
            if (settings) {
                const microphoneList = this._vidyoCore.Controllers.DeviceController.GetMicrophoneList();
                const microphone = microphoneList.find((microphone) => microphone.Id === settings.deviceId);
                if (microphone) {
                    StatisticsExtension_1.StatisticsExtention.fillLocalMicrophoneStatistics(localMicrophoneStats, microphone);
                }
            }
        });
    }
    _fillLocalRendererStats() {
        let rendererViews = this._vidyoCore.Controllers.RendererController.Views;
        this.EndpointStatistic.LocalRendererStats.length = 0;
        Object.keys(rendererViews).forEach((key) => {
            let view = rendererViews[key];
            let localRendererStats = new Statistics_1.LocalRendererStatistics();
            localRendererStats.Id = view.viewId;
            localRendererStats.Width = view.position?.width || 0;
            localRendererStats.Height = view.position?.height || 0;
            this.EndpointStatistic.LocalRendererStats.push(localRendererStats);
        });
    }
    _fillLocalSpeakerStatistics() {
        let selectedDevices = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices();
        let localSpeakerStat = new Statistics_1.LocalSpeakerStatistics();
        let speaker = selectedDevices.Speaker;
        localSpeakerStat.Id = speaker.Id || '';
        localSpeakerStat.Name = speaker.Name || '';
        this.EndpointStatistic.LocalSpeakerStats.length = 0;
        this.EndpointStatistic.LocalSpeakerStats.push(localSpeakerStat);
    }
    _initStatistics() {
        this.TransportInformation = this.RoomStatistics.TransportInformation;
        this.UserStatistic.RoomStats = [this.RoomStatistics];
        this.EndpointStatistic.UserStats = [this.UserStatistic];
        let osInfo = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.GetOSInfo();
        this.EndpointStatistic.OsName = osInfo.OSName || '';
        this.EndpointStatistic.OsVersion = osInfo.OSVersion || '';
        this.EndpointStatistic.UserAgent = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.UserAgent;
    }
    _onConferenceJoined() {
        if (!this._vidyoCore.Controllers.AdvancedSettingsController.DisableStats) {
            this._roomJoinedTimestamp = Date.now();
            this.RoomStatistics.CallId = StringUtils_1.default.generateRandomString();
            this._clearIntervals();
            this._inCall = true;
            this._setUpdateStatisticsCall();
            this._intervalSendStatsHandle = TimingProvider_1.TimingProvider
                .Interval(Constants.SendClientStatisticsInterval, () => this._sendClientStatistic());
            this._intervalResourceManagerStatisticsMeasuring = TimingProvider_1.TimingProvider
                .Interval(Constants.ResourceManagerStatisticsMeasuringInterval, () => {
                this._vidyoCore.Controllers.ResourcesManager.AccumulateStatistics(new Stats_1.EndpointStats(this.EndpointStatistic));
            });
        }
    }
    _onDisconnected() {
        this._inCall = false;
        this.EndpointStatistic = new Statistics_1.EndpointStatistics();
        this.RoomStatistics = new Statistics_1.RoomStatistics();
        this.TransportInformation = [];
        this.UserStatistic = new Statistics_1.UserStatistics();
        this._initStatistics();
        StatisticsExtension_1.StatisticsExtention.Initialize(this._vidyoCore);
        this._clearIntervals();
    }
    _onLocalTracksSSRCsChanged() {
        const currentSSRCs = this._vidyoCore.Controllers.TransmittedStreamController.GetTracksSSRCs();
        this.EndpointStatistic.LocalCameraStats =
            this.EndpointStatistic.LocalCameraStats
                .filter((lcs) => currentSSRCs.hasOwnProperty(lcs.Id));
        this.EndpointStatistic.LocalWindowShareStats =
            this.EndpointStatistic.LocalWindowShareStats
                .filter((lcs) => currentSSRCs.hasOwnProperty(lcs.Id));
        this.EndpointStatistic.LocalMonitorStats =
            this.EndpointStatistic.LocalMonitorStats
                .filter((lcs) => currentSSRCs.hasOwnProperty(lcs.Id));
        this.EndpointStatistic.LocalMicrophoneStats =
            this.EndpointStatistic.LocalMicrophoneStats
                .filter((lcs) => currentSSRCs.hasOwnProperty(lcs.Id));
        const currentStatsIds = [
            ...this.EndpointStatistic.LocalCameraStats,
            ...this.EndpointStatistic.LocalMonitorStats,
            ...this.EndpointStatistic.LocalWindowShareStats,
            ...this.EndpointStatistic.LocalMicrophoneStats
        ].map((val) => val.Id);
        for (let currentSSRCsKey in currentSSRCs) {
            if (!currentStatsIds.includes(currentSSRCsKey)) {
                let trackId = currentSSRCs[currentSSRCsKey];
                const mediaProps = this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaProperties(trackId);
                switch (mediaProps.trackType) {
                    case SimplifiedVidyoCore_1.TrackType.Camera:
                        const localCameraStats = new Statistics_1.LocalVideoSourceStatistics();
                        const roVideoTrack = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream.GetVideoTracks()[0];
                        localCameraStats.Id = currentSSRCsKey;
                        localCameraStats.TrackType = SimplifiedVidyoCore_1.TrackType.Camera;
                        localCameraStats.FillFromTrack(roVideoTrack);
                        this.EndpointStatistic.LocalCameraStats.push(localCameraStats);
                        break;
                    case SimplifiedVidyoCore_1.TrackType.VideoContent:
                        const localVideoContentStats = new Statistics_1.LocalVideoSourceStatistics();
                        localVideoContentStats.Id = currentSSRCsKey;
                        localVideoContentStats.TrackType = SimplifiedVidyoCore_1.TrackType.VideoContent;
                        this.EndpointStatistic.LocalCameraStats.push(localVideoContentStats);
                        break;
                    case SimplifiedVidyoCore_1.TrackType.Microphone:
                    case SimplifiedVidyoCore_1.TrackType.AudioContent:
                        const localMicrophoneStats = new Statistics_1.LocalMicrophoneStatistics();
                        localMicrophoneStats.Id = currentSSRCsKey;
                        localMicrophoneStats.TrackType = mediaProps.trackType;
                        this.EndpointStatistic.LocalMicrophoneStats.push(localMicrophoneStats);
                        break;
                    case SimplifiedVidyoCore_1.TrackType.WindowShare:
                        const localWindowShareStats = new Statistics_1.LocalVideoSourceStatistics();
                        localWindowShareStats.Id = currentSSRCsKey;
                        localWindowShareStats.TrackType = SimplifiedVidyoCore_1.TrackType.WindowShare;
                        const roWindowShareTrack = this._vidyoCore.Controllers.LocalStreamController.WindowShareStream.GetVideoTracks()[0];
                        localWindowShareStats.FillFromTrack(roWindowShareTrack);
                        this.EndpointStatistic.LocalWindowShareStats.push(localWindowShareStats);
                        break;
                    case SimplifiedVidyoCore_1.TrackType.Monitor:
                        const localMonitorShareStats = new Statistics_1.LocalVideoSourceStatistics();
                        localMonitorShareStats.Id = currentSSRCsKey;
                        localMonitorShareStats.TrackType = SimplifiedVidyoCore_1.TrackType.Monitor;
                        const roMonitorTrack = this._vidyoCore.Controllers.LocalStreamController.MonitorShareStream.GetVideoTracks()[0];
                        localMonitorShareStats.FillFromTrack(roMonitorTrack);
                        this.EndpointStatistic.LocalMonitorStats.push(localMonitorShareStats);
                        break;
                    default:
                        console.log("unsupported TrackType");
                        break;
                }
            }
        }
    }
    _onParticipantAddedOrUpdated(id) {
        let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(id);
        if (participant) {
            let participantStatistic = this.RoomStatistics.ParticipantStats.find((ps) => ps.Id === id);
            if (!participantStatistic) {
                participantStatistic = new Statistics_1.ParticipantStatistic();
                participantStatistic.Id = id;
                this.RoomStatistics.ParticipantStats.push(participantStatistic);
            }
            participantStatistic.UserId = participant.UserId;
            participantStatistic.Name = participant.Name;
            participantStatistic.ParticipantIsActive = participant.IsLocal || participant.Active;
        }
    }
    _onParticipantRemoved(id) {
        this.RoomStatistics.ParticipantStats = this.RoomStatistics.ParticipantStats
            .filter((ps) => ps.Id !== id);
    }
    _onParticipantSourceAdded(data) {
        const participantStats = this.RoomStatistics.ParticipantStats
            .find((ps) => ps.Id === data.participantId);
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(data.participantId);
        if (participant && participant.IsRemote && participantStats) {
            participantStats.SSRCs.push(data.ssrc);
            switch (data.type) {
                case Source_1.SourceMediaType.Audio:
                    const remoteMicrophoneStatistics = new Statistics_1.RemoteMicrophoneStatistics();
                    remoteMicrophoneStatistics.Id = data.ssrc;
                    remoteMicrophoneStatistics.Name = data.name;
                    participantStats.RemoteMicrophoneStats.push(remoteMicrophoneStatistics);
                    break;
                case Source_1.SourceMediaType.Video:
                    const remoteCameraStatistics = new Statistics_1.RemoteVideoSourceStatistics();
                    remoteCameraStatistics.Id = data.ssrc;
                    remoteCameraStatistics.Name = data.name;
                    participantStats.RemoteCameraStats.push(remoteCameraStatistics);
                    break;
                case Source_1.SourceMediaType.Application:
                    const remoteWindowShareStatistics = new Statistics_1.RemoteVideoSourceStatistics();
                    remoteWindowShareStatistics.Id = data.ssrc;
                    remoteWindowShareStatistics.Name = data.name;
                    participantStats.RemoteWindowShareStats.push(remoteWindowShareStatistics);
                    break;
                default:
                    console.log("unsupported SourceMediaType");
                    break;
            }
        }
    }
    _onParticipantSourceRemoved(data) {
        const participantStats = this.RoomStatistics.ParticipantStats
            .find((ps) => ps.Id === data.participantId);
        if (participantStats) {
            participantStats.SSRCs = participantStats.SSRCs.filter((ssrc) => ssrc !== data.ssrc);
            switch (data.type) {
                case Source_1.SourceMediaType.Audio:
                    participantStats.RemoteMicrophoneStats = participantStats.RemoteMicrophoneStats
                        .filter((rms) => rms.Id !== data.ssrc);
                    break;
                case Source_1.SourceMediaType.Video:
                    participantStats.RemoteCameraStats = participantStats.RemoteCameraStats
                        .filter((rvs) => rvs.Id !== data.ssrc);
                    break;
                case Source_1.SourceMediaType.Application:
                    participantStats.RemoteWindowShareStats = participantStats.RemoteWindowShareStats
                        .filter((rvs) => rvs.Id !== data.ssrc);
                    break;
                default:
                    console.log("unsupported SourceMediaType");
                    break;
            }
        }
    }
    _onReceiveBandwidthUpdated(payload) {
        this._vidyoCore.Controllers.LogController.LogInfo(() => `Receive bandwidth: ${payload.receiveBw}`);
        this.RoomStatistics.ReceiveBitRateAvailable = payload.receiveBw;
    }
    _processAudioCodec(participant, remoteMicrophoneStatistics) {
        const microphone = participant.GetDevice(remoteMicrophoneStatistics.Id);
        const codecName = remoteMicrophoneStatistics?.CodecName;
        if (codecName && microphone?.SignalType === Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed) {
            this._vidyoCore.EventDispatcher.emit(StatisticsEvents.Events.UnprocessedAudioCodecUpdated, { codecName });
        }
    }
    _processTransportStatistic(stats) {
        const selectedCandidatePairs = RTCStatsReportHelper_1.default.GetSelectedCandidatePairs(stats);
        selectedCandidatePairs.forEach((candidatePairStats) => {
            let connectionInfo = new Statistics_1.MediaConnectionTransportInformation();
            connectionInfo.FillFromRTCStats(candidatePairStats, stats);
            let localCandidate = RTCStatsReportHelper_1.default.GetIceCandidateStats(stats, candidatePairStats.localCandidateId);
            if (localCandidate && localCandidate.protocol === 'tcp') {
                this.EndpointStatistic.BytesReceivedTcp += candidatePairStats.bytesReceived || 0;
                this.EndpointStatistic.BytesSentTcp += candidatePairStats.bytesSent || 0;
            }
            else {
                this.EndpointStatistic.BytesReceivedUdp += candidatePairStats.bytesReceived || 0;
                this.EndpointStatistic.BytesSentUdp += candidatePairStats.bytesSent || 0;
            }
            if (candidatePairStats.availableOutgoingBitrate > 0) {
                this._availableOutgoingBandwidthCache.push(candidatePairStats.availableOutgoingBitrate);
                if (this._availableOutgoingBandwidthCache.length > this.MAX_AOB_SAMPLE_NUMBER) {
                    this._availableOutgoingBandwidthCache.shift();
                }
            }
            this.RoomStatistics.SendBitRateAvailable = this._availableOutgoingBandwidthCache.length == 0 ?
                0 : this._availableOutgoingBandwidthCache.reduce((a, b) => (a + b)) / this._availableOutgoingBandwidthCache.length;
            if (this.RoomStatistics.SendBitRateAvailable === 0 && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                this.RoomStatistics.SendBitRateAvailable = 10000000;
            }
            if (this.RoomStatistics.SendBitRateAvailable > 0) {
                this._vidyoCore.Controllers.LocalStreamController.SetAvailableOutgoingBitRate(this.RoomStatistics.SendBitRateAvailable);
            }
            this._vidyoCore.Controllers.LogController.LogDebug(() => `AOB current ${candidatePairStats.availableOutgoingBitrate?.toLocaleString(undefined, { maximumFractionDigits: 0 })},
        average ${this.RoomStatistics.SendBitRateAvailable.toLocaleString(undefined, { maximumFractionDigits: 0 })}`);
            this._bytesSent += candidatePairStats.bytesSent || 0;
            this._bytesReceived += candidatePairStats.bytesReceived || 0;
            if (this.RoomStatistics.SendBitRateAvailable > 0) {
                this.RoomStatistics.AvailableEncodeBwPercent =
                    Math.round((this.RoomStatistics.SendBitRateTotal * this._maxPercent) / this.RoomStatistics.SendBitRateAvailable);
            }
            if (this.RoomStatistics.ReceiveBitRateAvailable > 0) {
                this.RoomStatistics.AvailableDecodeBwPercent =
                    Math.round((this.RoomStatistics.ReceiveBitRateTotal * this._maxPercent) / this.RoomStatistics.ReceiveBitRateAvailable);
            }
            this.TransportInformation.push(connectionInfo);
        });
    }
    _sendClientStatistic() {
        this._updateEndpointStatistics();
        let stats = new Stats_1.EndpointStats(this.EndpointStatistic);
        this._vidyoCore.Controllers.ConnectionController.SendClientStats(JSON.stringify(stats));
    }
    _setUpdateStatisticsCall() {
        if (this._inCall && !this._vidyoCore.Controllers.AdvancedSettingsController.DisableStats) {
            this._intervalRefreshHandle = setTimeout(() => this._updateStatistics(), this._vidyoCore.Controllers.AdvancedSettingsController.StatisticsRefreshInterval);
        }
    }
    _updateLocalTracksStats(stats) {
        this.EndpointStatistic.LocalMicrophoneStats.forEach((localMicrophoneStatistics) => {
            localMicrophoneStatistics.FillFromRTCStats(stats);
        });
        [...this.EndpointStatistic.LocalCameraStats,
            ...this.EndpointStatistic.LocalWindowShareStats,
            ...this.EndpointStatistic.LocalMonitorStats
        ].forEach((localVideoSourceStatistics) => {
            let oldCodecName = localVideoSourceStatistics.CodecName;
            localVideoSourceStatistics.FillFromRTCStats(stats);
            if (!localVideoSourceStatistics.CodecName && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                localVideoSourceStatistics.CodecName = 'VP8';
            }
            if (localVideoSourceStatistics.QualityLimitationReason && localVideoSourceStatistics.QualityLimitationReason !== 'none') {
                this._vidyoCore.Controllers.LogController
                    .LogDebug(() => `Local stream (type: '${localVideoSourceStatistics.TrackType}') quality is limited due to '${localVideoSourceStatistics.QualityLimitationReason}'
            ; resolution: ${localVideoSourceStatistics.Width} x ${localVideoSourceStatistics.Height}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            }
            let trackId = this._vidyoCore.Controllers.TransmittedStreamController.GetLocalTrackId(localVideoSourceStatistics.Id);
            if (trackId) {
                localVideoSourceStatistics.TargetBitRate = this._vidyoCore.Controllers.LocalStreamController.GetLocalStreamBandwidthByTrackId(trackId) || 0;
                if (oldCodecName != localVideoSourceStatistics.CodecName && localVideoSourceStatistics.CodecName != '') {
                    let SSRCs = this._vidyoCore.Controllers.TransmittedStreamController.GetTracksSSRCs();
                    Object.keys(SSRCs).forEach((ssrc) => {
                        if (trackId == this._vidyoCore.Controllers.TransmittedStreamController.GetLocalTrackId(ssrc)) {
                            this._vidyoCore.EventDispatcher.emit(StatisticsEvents.Events.CodecChanged, { ssrc: ssrc });
                        }
                    });
                }
            }
        });
        this.EndpointStatistic.LocalCameraStats.forEach((localCameraStatistics) => {
            localCameraStatistics.RemoteRendererStreams = this._vidyoCore.Controllers.TransmittedStreamController.VideoRids.map((id, i) => {
                const localTrack = this._vidyoCore.Controllers.LocalStreamController.GetTransmittedTrack(SimplifiedVidyoCore_1.TrackType.Camera);
                const remoteRendererStreamStats = new Statistics_1.RemoteRendererStreamStatistics(id, stats);
                remoteRendererStreamStats.LastWidth = localCameraStatistics.RemoteRendererStreams[i]?.Width;
                remoteRendererStreamStats.LastHeight = localCameraStatistics.RemoteRendererStreams[i]?.Height;
                remoteRendererStreamStats.CodecName = this.GetLocalCameraCodecName() || '';
                remoteRendererStreamStats.Name = localCameraStatistics.Name || '';
                if (localTrack) {
                    const requestedShowParameters = this._vidyoCore.Controllers.TransmittedStreamController.GetLocalSourceRequestedShowParameters(localTrack.id);
                    remoteRendererStreamStats.BitRateRequested = Number(requestedShowParameters.bandwidth);
                    remoteRendererStreamStats.FpsRequested = Number(requestedShowParameters.framerate);
                    remoteRendererStreamStats.WidthRequested = Number(requestedShowParameters.width);
                    remoteRendererStreamStats.HeightRequested = Number(requestedShowParameters.height);
                }
                return remoteRendererStreamStats;
            });
            const [highRunnelStats] = [...localCameraStatistics.RemoteRendererStreams]
                .filter((remoteRendererStreamStats) => {
                return remoteRendererStreamStats.Width && remoteRendererStreamStats.Height;
            })
                .sort((statsA, statsB) => {
                return statsB.Height - statsA.Height;
            });
            if (highRunnelStats) {
                localCameraStatistics.Width = highRunnelStats.Width;
                localCameraStatistics.Height = highRunnelStats.Height;
            }
        });
        this.RoomStatistics.BandwidthVideo.TargetEncoderBitRate = 0;
        this.RoomStatistics.BandwidthVideo.TotalTransmitBitRate = 0;
        this.RoomStatistics.BandwidthVideo.RetransmitBitRate = 0;
        [...this.EndpointStatistic.LocalCameraStats
        ].forEach((localVideoSourceStatistics) => {
            this.RoomStatistics.BandwidthVideo.TargetEncoderBitRate += localVideoSourceStatistics.TargetBitRate;
            this.RoomStatistics.BandwidthVideo.TotalTransmitBitRate += localVideoSourceStatistics.VideoBitRateSent;
            this.RoomStatistics.BandwidthVideo.RetransmitBitRate += localVideoSourceStatistics.VideoRetransimitBitRate;
        });
        this.RoomStatistics.BandwidthApp.TargetEncoderBitRate = 0;
        this.RoomStatistics.BandwidthApp.TotalTransmitBitRate = 0;
        this.RoomStatistics.BandwidthApp.RetransmitBitRate = 0;
        [...this.EndpointStatistic.LocalWindowShareStats,
            ...this.EndpointStatistic.LocalMonitorStats
        ].forEach((localVideoSourceStatistics) => {
            this.RoomStatistics.BandwidthApp.TargetEncoderBitRate += localVideoSourceStatistics.TargetBitRate;
            this.RoomStatistics.BandwidthApp.TotalTransmitBitRate += localVideoSourceStatistics.VideoBitRateSent;
            this.RoomStatistics.BandwidthApp.RetransmitBitRate += localVideoSourceStatistics.VideoRetransimitBitRate;
        });
    }
    _updateRemoteParticipantsStats(stats) {
        this.RoomStatistics.ParticipantStats.forEach((participantStatistic) => {
            const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantStatistic.Id);
            if (participant) {
                participantStatistic.Name = participant.Name;
                participantStatistic.ParticipantIsActive = participant.Active;
                if (participant.IsRemote) {
                    [...participantStatistic.RemoteWindowShareStats, ...participantStatistic.RemoteCameraStats]
                        .forEach((remoteVideoSourceStatistics) => {
                        remoteVideoSourceStatistics.FillFromRTCStats(stats);
                    });
                    participantStatistic.RemoteMicrophoneStats
                        .forEach((remoteMicrophoneStatistics) => {
                        const audioStats = this._vidyoCore.Controllers.MicrophoneEnergyLevelController
                            .GetRemoteStats(participant.Id, remoteMicrophoneStatistics.Id);
                        if (audioStats) {
                            remoteMicrophoneStatistics.FillFromAudioAnalyzerStats(audioStats);
                        }
                        remoteMicrophoneStatistics.FillFromRTCStats(stats);
                        this._processAudioCodec(participant, remoteMicrophoneStatistics);
                    });
                }
            }
        });
    }
    _updateEndpointStatistics() {
        this.EndpointStatistic.MaxBitRate =
            this._vidyoCore.Controllers.LocalStreamController.MaxBitrate || 0;
        this.EndpointStatistic.TimeStamp = StatisticsExtension_1.StatisticsExtention.getISODate(new Date());
        this.RoomStatistics.ReflectorId = this._vidyoCore.Controllers.ConnectionController.Reflector();
        this.RoomStatistics.ConferenceId = this._vidyoCore.Controllers.RoomController.GetConference();
        this.RoomStatistics.Id = this._vidyoCore.Controllers.RoomController.RoomJid();
        this._fillLocalCameraStatistics();
        this._fillLocalMicrophoneStatistics();
        this._fillLocalSpeakerStatistics();
        this._fillLocalRendererStats();
        StatisticsExtension_1.StatisticsExtention.supplementClientStatistics();
    }
    _updateStatistics() {
        let timestamp = 0;
        this.TransportInformation.length = 0;
        this.EndpointStatistic.EmptyBytesCountStatistic();
        this._vidyoCore.HunterProvider.GetStats().then((stats) => {
            this._bytesSent = 0;
            this._bytesReceived = 0;
            this._processTransportStatistic(stats);
            this._updateRemoteParticipantsStats(stats);
            this._updateLocalTracksStats(stats);
            timestamp = RTCStatsReportHelper_1.default.GetTimestamp(stats);
            this.RoomStatistics.SendBitRateTotal =
                Math.max(0, Math.floor(Constants_1.BitsInByteValue * (this._bytesSent - this._sendBytesPrev) / (timestamp - this._timestampPrev) * Constants_1.SecToMsCoefficient));
            this.RoomStatistics.ReceiveBitRateTotal =
                Math.max(0, Math.floor(Constants_1.BitsInByteValue * (this._bytesReceived - this._receiveBytesPrev) / (timestamp - this._timestampPrev) * Constants_1.SecToMsCoefficient));
            this._timestampPrev = timestamp;
            this._sendBytesPrev = this._bytesSent;
            this._receiveBytesPrev = this._bytesReceived;
            this._lastStats = stats;
            this._vidyoCore.EventDispatcher.emit(StatisticsEvents.Events.Update);
            this._setUpdateStatisticsCall();
        }).catch((e) => {
            this._vidyoCore.Controllers.LogController
                .LogError(() => `StatisticController._updateStatistics collecting statistics error ${e}`);
            this._setUpdateStatisticsCall();
        });
    }
    _logCallQuality(sourceName, localVideoSourceStatistics) {
        localVideoSourceStatistics.FillFromRTCStats(this._lastStats);
        let strToLog = '\n';
        if (localVideoSourceStatistics.QualityLimitationDurations) {
            const lastDurations = localVideoSourceStatistics.QualityLimitationDurations;
            const totalCallTime = Object.keys(lastDurations).reduce((a, b) => a + lastDurations[b], 0);
            strToLog += `encoder = ${localVideoSourceStatistics.EncoderImplementation}\n`;
            strToLog += `call duration = ${totalCallTime} ms\n`;
            strToLog += `number of resolution changes = ${localVideoSourceStatistics.QualityLimitationResolutionChanges}\n`;
            strToLog += `source = ${sourceName}\n QualityLimitationDurations statistics \n`;
            Object.keys(lastDurations).forEach(key => {
                strToLog += key + ' ' + +Math.round(100 * lastDurations[key] / totalCallTime) + '%\n';
            });
        }
        return strToLog;
    }
    _logRemoteParticipantsDecoderStats() {
        let strToLog = '';
        this.RoomStatistics.ParticipantStats.forEach((participantStatistic) => {
            const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantStatistic.Id);
            if (participant?.IsRemote) {
                participantStatistic.RemoteWindowShareStats.forEach((remoteVideoSourceStatistics) => {
                    strToLog += `Decoder for ${participant.Name}:Screenshare = ${remoteVideoSourceStatistics.DecoderImplementation}\n`;
                });
                participantStatistic.RemoteCameraStats.forEach((remoteVideoSourceStatistics) => {
                    strToLog += `Decoder for ${participant.Name}:Video = ${remoteVideoSourceStatistics.DecoderImplementation}\n`;
                });
            }
        });
        return strToLog;
    }
}
exports.StatisticsController = StatisticsController;

},{"../../vidyo_simple_api/Devices":184,"../../vidyo_simple_api/stats/Stats":216,"../SimplifiedVidyoCore":30,"../events/AdvancedSettingsEvents":62,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/EventDispatcher":68,"../events/LogEvents":69,"../events/ParticipantEvents":73,"../events/StatisticsEvents":78,"../events/StreamEvents":79,"../models/Source":98,"../models/statistics/Statistics":131,"../utils/Constants":138,"../utils/ObjectUtils":153,"../utils/OperatingSystemInfoProvider":154,"../utils/RTCStatsReportHelper":158,"../utils/StatisticsExtension":163,"../utils/StringUtils":164,"../utils/TimingProvider":166,"./BaseController":35}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStreamController = exports.TrackType = void 0;
const CallStateEvents = require("../../events/CallStateEvents");
const Constants = require("../../utils/Constants");
const DeviceEvents = require("../../events/DeviceEvents");
const StreamEvents = require("../../events/StreamEvents");
const ModerationEvents = require("../../events/ModerationEvents");
const Messages = require("../../utils/Messages");
const BaseController_1 = require("../BaseController");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const ReadOnlyMediaStream_1 = require("../../models/stream/ReadOnlyMediaStream");
const UserMediaProvider_1 = require("../../utils/UserMediaProvider");
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
const StreamEventHelper_1 = require("./StreamEventHelper");
const TrackMetaDataProvider_1 = require("./TrackMetaDataProvider");
const async_1 = require("async");
const StringUtils_1 = require("../../utils/StringUtils");
const Permission_1 = require("../../../vidyo_simple_api/Permission");
const ConnectionEvents = require("../../events/ConnectionEvents");
const VideoResolution_1 = require("../../models/VideoResolution");
const Microphone_1 = require("../../models/device/Microphone");
const RenderEvents = require("../../events/RenderEvents");
const LogEvents_1 = require("../../events/LogEvents");
const RunnelsHelper = require("../../utils/SimulcastRunnelsHelper");
const SimulcastRunnelsHelper_1 = require("../../utils/SimulcastRunnelsHelper");
const Participant_1 = require("../../models/Participant");
const ScreenInfoProvider_1 = require("../../utils/ScreenInfoProvider");
var TrackType;
(function (TrackType) {
    TrackType.AudioContent = 'AudioContent';
    TrackType.Camera = 'Camera';
    TrackType.Microphone = 'Microphone';
    TrackType.Monitor = 'Monitor';
    TrackType.VideoContent = 'VideoContent';
    TrackType.WindowShare = 'WindowShare';
})(TrackType = exports.TrackType || (exports.TrackType = {}));
class LocalVideoStreamConstraints {
    constructor(DEFAULT_WIDTH = Constants.DefaultLocalStreamWidth, DEFAULT_HEIGHT = Constants.DefaultLocalStreamHeight, DEFAULT_FRAMERATE = Constants.DefaultLocalStreamFrameRate) {
        this.DEFAULT_WIDTH = DEFAULT_WIDTH;
        this.DEFAULT_HEIGHT = DEFAULT_HEIGHT;
        this.DEFAULT_FRAMERATE = DEFAULT_FRAMERATE;
        this.locked = false;
        this.runnels = {};
        this.bandwidth = undefined;
        this.maxBandwidth = LocalVideoStreamConstraints.MAX_BITRATE_PER_STREAM;
        const constraints = {
            width: this.DEFAULT_WIDTH,
            height: this.DEFAULT_HEIGHT,
            frameRate: this.DEFAULT_FRAMERATE
        };
        this.constraints = constraints;
        this.minConstraints = {
            width: Constants.MinimumLocalStreamWidth,
            height: Constants.MinimumLocalStreamHeight
        };
        Constants.Runnels.map((runnel) => { this.runnels[runnel] = { active: false, bandwidth: 0 }; });
    }
    get MaxBandwidth() {
        return this.maxBandwidth;
    }
    set MaxBandwidth(b) {
        this.maxBandwidth = b;
    }
    set Bandwidth(b) {
        this.bandwidth = b;
    }
    get Bandwidth() {
        const bw = this.getBW();
        if (typeof bw === 'number') {
            return Math.min(LocalVideoStreamConstraints.MAX_BITRATE_PER_STREAM, bw);
        }
    }
    getBW() {
        if (this.maxBandwidth !== null && this.bandwidth) {
            return Math.min(this.bandwidth, this.maxBandwidth);
        }
        else if (this.maxBandwidth !== null) {
            return this.maxBandwidth;
        }
        else if (typeof this.bandwidth === 'number') {
            return this.bandwidth;
        }
    }
    set AspectRatioConstraints(constraints) {
        this.aspectRatioConstraints = constraints;
    }
    get AspectRatioConstraints() {
        return this.aspectRatioConstraints;
    }
    set MaxConstraints(constraints) {
        if (constraints) {
            this.constraints = constraints;
            for (let key in constraints) {
                if (this.minConstraints[key]) {
                    this.constraints[key] = Math.max(this.constraints[key], this.minConstraints[key]);
                }
            }
            this.maxConstraints = this.constraints;
        }
        else {
            this.maxConstraints = constraints;
            this.constraints = {
                width: this.DEFAULT_WIDTH,
                height: this.DEFAULT_HEIGHT
            };
        }
    }
    get MaxConstraints() {
        if (this.maxConstraints) {
            return this.maxConstraints;
        }
    }
    get CurrentConstraints() {
        const constraints = { ...this.constraints };
        const maxConstraints = this.maxConstraints;
        if (maxConstraints) {
            for (let key in maxConstraints) {
                if (constraints[key] > maxConstraints[key]) {
                    constraints[key] = maxConstraints[key];
                }
            }
        }
        return this.getConstraintsWithAspectRatio(constraints);
    }
    MaxPreferredBandwidth(codecName) {
        return this.getBandwidth(false, codecName);
    }
    NominalBandwidth(codecName) {
        return this.getBandwidth(true, codecName);
    }
    MinimumBandwidth(codecName) {
        const constraints = this.CurrentConstraints;
        const width = constraints.width || this.DEFAULT_WIDTH;
        const height = constraints.height || this.DEFAULT_HEIGHT;
        return (0, VideoResolution_1.CalculateMinimumSendBitrate)(codecName, width / height);
    }
    getConstraintsWithAspectRatio(originalConstraints) {
        const constraints = {
            width: this.DEFAULT_WIDTH,
            height: this.DEFAULT_HEIGHT,
            ...originalConstraints
        };
        if (this.aspectRatioConstraints) {
            const width = constraints.width;
            const height = constraints.height;
            const aspectRatioWidth = this.aspectRatioConstraints.width;
            const aspectRatioHeight = this.aspectRatioConstraints.height;
            if (height * aspectRatioWidth > width * aspectRatioHeight) {
                constraints.height = width * aspectRatioHeight / aspectRatioWidth;
            }
            else {
                constraints.width = height * aspectRatioWidth / aspectRatioHeight;
            }
        }
        return constraints;
    }
    getBandwidth(nominal, codecName) {
        const constraints = this.CurrentConstraints;
        const width = constraints.width || this.DEFAULT_WIDTH;
        const height = constraints.height || this.DEFAULT_HEIGHT;
        return (0, VideoResolution_1.CalculateSendBitrate)(width, height, codecName, nominal);
    }
}
LocalVideoStreamConstraints.MAX_BITRATE_PER_STREAM = Constants.MaxBitratePerStream;
class LocalStreamController extends BaseController_1.BaseController {
    constructor(vidyoCore) {
        super(vidyoCore);
        this._constraintsMap = {
            [TrackType.Camera]: new LocalVideoStreamConstraints(),
            [TrackType.Monitor]: new LocalVideoStreamConstraints(Constants.DefaultLocalShareStreamWidth, Constants.DefaultLocalShareStreamHeight, Constants.DefaultLocalShareStreamFrameRate),
            [TrackType.VideoContent]: new LocalVideoStreamConstraints(),
            [TrackType.WindowShare]: new LocalVideoStreamConstraints(Constants.DefaultLocalShareStreamWidth, Constants.DefaultLocalShareStreamHeight, Constants.DefaultLocalShareStreamFrameRate)
        };
        this._hasMonitorShare = false;
        this._hasWindowShare = false;
        this._hasVideoContentShare = false;
        this._maxAvailableOutgoingBandwidth = null;
        this._maxLocalStreamSendBandwidth = 10000000;
        this._trackIndex = {
            AudioContent: {},
            Camera: {},
            Microphone: {},
            Monitor: {},
            VideoContent: {},
            WindowShare: {}
        };
        this._remoteSpeakerAudioTracks = {};
        this._trackToMediaTypeMap = {};
        this._transmittedStream = new MediaStream();
        this._cameraPermissionGranted = false;
        this._micPermissionGranted = false;
        this._localCameraLowBandwidthCount = 0;
        this._localCameraRestricted = false;
        this._cameraBWRestriction = false;
        this._lastCameraCodecName = '';
        this._aobRampUpTimeout = null;
        this._aobIsRampingUp = true;
        this._isClientVisible = true;
        this._localStreamsMap = {};
        this._localStreamsMap.AudioContent = new MediaStream();
        this._localStreamsMap.Camera = new MediaStream();
        this._localStreamsMap.Microphone = new MediaStream();
        this._localStreamsMap.Monitor = new MediaStream();
        this._localStreamsMap.VideoContent = new MediaStream();
        this._localStreamsMap.WindowShare = new MediaStream();
        this._mediaActionsQueue = (0, async_1.queue)((action, next) => {
            action().then(next).catch(next);
        });
        this.registerVisibilityHandlers();
    }
    get CameraVideoStream() {
        return new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._localStreamsMap[TrackType.Camera]);
    }
    get MicrophoneAudioStrem() {
        return new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._localStreamsMap[TrackType.Microphone]);
    }
    set aobRampUp(rampUp) {
        const AOBRampUpTimeout = 10000;
        if (rampUp) {
            if (this._aobRampUpTimeout) {
                this._vidyoCore.Controllers.LogController.LogDebug(() => `AOB ramping up already underway`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                return;
            }
            this._vidyoCore.Controllers.LogController.LogDebug(() => `Wait for AOB to ramp up`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            this._aobIsRampingUp = true;
            this._aobRampUpTimeout = setTimeout(() => {
                this._aobRampUpTimeout = null;
                this._aobIsRampingUp = false;
                this._vidyoCore.Controllers.LogController.LogDebug(() => `AOB ramping up completed`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            }, AOBRampUpTimeout);
        }
        else {
            this._vidyoCore.Controllers.LogController.LogDebug(() => 'AOB ramping up stopped, back to default', LogEvents_1.VidyoLogCategory.VidyoResourceManager);
            if (this._aobRampUpTimeout) {
                clearTimeout(this._aobRampUpTimeout);
            }
            this._aobRampUpTimeout = null;
            this._aobIsRampingUp = true;
        }
    }
    AddMicrophone(microphone) {
        return this._pushToAsyncQueue(() => {
            const deviceSelection = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices();
            if (deviceSelection.Microphone instanceof Microphone_1.Microphone && deviceSelection.Microphone.Id === microphone.Id) {
                this.StopAudio();
            }
            const mediaState = this._vidyoCore.Controllers.CallStateController.MediaState;
            if (mediaState.ShouldRenderMedia) {
                this._removeRemoteSpeakerAudioTrackFromStream(microphone.Id);
                return this._userMediaProvider.GetAudioTrack(microphone).then((track) => {
                    if (track) {
                        this._addRemoteSpeakerAudioTrackToStream(track, microphone.Id);
                    }
                    return Promise.resolve();
                }).catch((error) => {
                    return Promise.reject(error);
                });
            }
            else {
                const messageValues = { mediaType: TrackType.Microphone, mediaState: mediaState.toString() };
                const message = StringUtils_1.default.Format(Messages.LocalMediaOperationNotPermitted, messageValues);
                return Promise.reject(message);
            }
        });
    }
    Disable() {
        this.StopMedia();
        this.clearVisibilityHandlers();
        return super.Disable();
    }
    GetApplicationStreamById(streamId) {
        if (this._localStreamsMap[TrackType.Monitor].id === streamId) {
            return this.MonitorShareStream;
        }
        if (this._localStreamsMap[TrackType.WindowShare].id === streamId) {
            return this.WindowShareStream;
        }
        return null;
    }
    GetApplicationStreams() {
        let streams = [];
        if (this._hasMonitorShare) {
            streams.push(this.MonitorShareStream);
        }
        if (this._hasWindowShare) {
            streams.push(this.WindowShareStream);
        }
        return streams;
    }
    GetTransmittedTrackSettings(trackId) {
        const track = this._transmittedStream.getAudioTracks().find((track) => track.id === trackId);
        if (track) {
            return track.getSettings();
        }
    }
    GetLocalStreamBandwidthByTrackId(trackId) {
        const constraintsObject = this._getLocalStreamConstraintsByTrack(trackId);
        if (constraintsObject) {
            return constraintsObject.Bandwidth;
        }
        return undefined;
    }
    GetLocalStreamConstraintsByTrackId(trackId) {
        const constraintsObject = this._getLocalStreamConstraintsByTrack(trackId);
        if (constraintsObject) {
            return constraintsObject.constraints;
        }
        return undefined;
    }
    GetLocalStreamVideoConstraints() {
        return this._constraintsMap.Camera.constraints;
    }
    GetCameraResolutionDownScaleFactor() {
        const trackId = this._localStreamsMap[TrackType.Camera].id;
        const track = this._trackIndex[TrackType.Camera][trackId];
        if (track && this.IsScaleResolutionDownSupported()) {
            const trackSettings = track.getSettings();
            const cameraConstraintsMap = this._constraintsMap.Camera;
            const { width, height } = cameraConstraintsMap.CurrentConstraints;
            const constraintsFactor = Math.max(Number(width), Number(height));
            const trackFactor = Math.max(trackSettings.width, trackSettings.height);
            const ratio = trackFactor / constraintsFactor;
            return Math.max(ratio, 1);
        }
    }
    GetStreamTrackMediaType(streamId) {
        let trackType;
        let streamIdToMediaTypeMap = {
            [this._localStreamsMap.Camera.id]: TrackMetaDataProvider_1.MediaTrackType.Video,
            [this._localStreamsMap.Monitor.id]: TrackMetaDataProvider_1.MediaTrackType.Application,
            [this._localStreamsMap.VideoContent.id]: TrackMetaDataProvider_1.MediaTrackType.Application,
            [this._localStreamsMap.WindowShare.id]: TrackMetaDataProvider_1.MediaTrackType.Application
        };
        trackType = streamIdToMediaTypeMap[streamId];
        return trackType || TrackMetaDataProvider_1.UnknownMediaTrackType;
    }
    GetTrackMediaProperties(trackId) {
        const trackTypes = this._getTrackTypes(trackId);
        const mediaType = trackTypes.trackMediaType;
        let isDynamic = true;
        let isSimulcast = false;
        let isContentShare = false;
        let muted = false;
        let runnels;
        let bandwidth;
        let codecName = '';
        let signalType;
        const trackType = trackTypes.trackType;
        switch (trackType) {
            case TrackType.WindowShare:
                isSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast;
                bandwidth = this._constraintsMap.WindowShare.Bandwidth;
                runnels = this._constraintsMap.WindowShare.runnels;
                break;
            case TrackType.Monitor:
                isSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast;
                bandwidth = this._constraintsMap.Monitor.Bandwidth;
                runnels = this._constraintsMap.Monitor.runnels;
                break;
            case TrackType.Microphone:
                const deviceId = this.GetTransmittedTrackSettings(trackId)?.deviceId;
                const microphoneProperties = this._vidyoCore.Controllers.DeviceController.GetMicrophoneMediaProperties(deviceId);
                if (microphoneProperties) {
                    isDynamic = microphoneProperties.isDynamic;
                    signalType = microphoneProperties.signalType;
                }
                muted = isDynamic && this._vidyoCore.Controllers.DeviceController.GetAudioMuteState();
                break;
            case TrackType.VideoContent:
                isSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast;
                bandwidth = this._constraintsMap.VideoContent.Bandwidth;
                runnels = this._constraintsMap.VideoContent.runnels;
                isContentShare = true;
                break;
            case TrackType.AudioContent:
                isContentShare = true;
                break;
            case TrackType.Camera:
                isSimulcast = this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast;
                bandwidth = (typeof this._vidyoCore.Controllers.AdvancedSettingsController.EnableFixedEncoderBitRate === 'number')
                    ? this._vidyoCore.Controllers.AdvancedSettingsController.EnableFixedEncoderBitRate
                    : this._constraintsMap.Camera.Bandwidth;
                runnels = this._constraintsMap.Camera.runnels;
                codecName = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName();
                break;
            default:
                console.log('unsupported TrackType');
                break;
        }
        return {
            bandwidth,
            codecName,
            isContentShare,
            isDynamic,
            isSimulcast,
            runnels,
            trackType,
            mediaType,
            signalType,
            muted
        };
    }
    GetTrackMediaType(trackId) {
        return this._getTrackTypes(trackId).trackMediaType;
    }
    GetTrackMediaTypeBySsrc(ssrc) {
        const trackId = this._vidyoCore.Controllers.TransmittedStreamController.GetLocalTrackId(ssrc);
        return this._getTrackTypes(trackId).trackMediaType;
    }
    GetTransmittedStream() {
        return this._transmittedStream;
    }
    Initialize() {
        this._userMediaProvider = new UserMediaProvider_1.UserMediaProvider(this._vidyoCore);
        this._streamEventHelper = new StreamEventHelper_1.StreamEventHelper(this._vidyoCore.EventDispatcher);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.LocalStreamControllerListeners);
        this._vidyoCore.EventDispatcher.on(CallStateEvents.Events.MediaStateTransition, EventDispatcher_1.LocalStreamControllerListeners, (state) => this._mediaStateTransition(state));
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneMuteStateChanged, EventDispatcher_1.LocalStreamControllerListeners, () => this._setAudioMutedState());
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneChanged, EventDispatcher_1.LocalStreamControllerListeners, () => this.StartOrStopAudio());
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraSettingsChanged, EventDispatcher_1.LocalStreamControllerListeners, (settings) => this.StartOrStopVideo());
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.AudioContentDeviceChanged, EventDispatcher_1.LocalStreamControllerListeners, () => this.StartOrStopAudioContentShare());
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraConstraintChanged, EventDispatcher_1.LocalStreamControllerListeners, () => this._setVideoStreamMaxConstraints());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.MediaSessionStarted, EventDispatcher_1.LocalStreamControllerListeners, () => this._onMediaSessionStarted());
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnected, EventDispatcher_1.LocalStreamControllerListeners, () => this._onCallDisconnected());
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.TransmittedStreamTracksUpdated, EventDispatcher_1.LocalStreamControllerListeners, () => this._transmittedTracksUpdated());
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.LocalSharePermissionChanged, EventDispatcher_1.LocalStreamControllerListeners, (payload) => this._handleSharingPermissionChanged(payload));
        this._transmittedStream.addEventListener('addtrack', () => this._transmittedTracksUpdated(), false, true);
        return super.Initialize().then(() => this._userMediaProvider.Initialize(this._vidyoCore.Controllers.LogController).then((result) => {
            this._vidyoCore.Controllers.PermissionController.TrySubscribePermission(Permission_1.PermissionType.camera, result);
            this._vidyoCore.Controllers.PermissionController.TrySubscribePermission(Permission_1.PermissionType.microphone, result);
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
                this._cameraPermissionGranted = this._micPermissionGranted = result;
            }
        }));
    }
    IsMicrophoneAddedToRemoteSpeaker(microphone) {
        return this._checkMicrophoneAddedToRemoteSpeaker(microphone);
    }
    IsScaleResolutionDownSupported() {
        const browserVersion = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.BrowserVersion;
        const browserVersionFloat = parseFloat(browserVersion);
        return (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && browserVersionFloat < 14) === false;
    }
    IsTransmittedStream(stream) {
        return this._transmittedStream.id === stream.id;
    }
    get MonitorShareStream() {
        return new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._localStreamsMap[TrackType.Monitor]);
    }
    get MaxBitrate() {
        return this._maxLocalStreamSendBandwidth;
    }
    RegisterLocalCameraStreamInterceptor(interceptor) {
        return this._userMediaProvider.RegisterLocalCameraStreamInterceptor(interceptor).then((result) => {
            this._vidyoCore.Controllers.LogController.LogWarning(() => 'Local camera stream interceptor has been registered');
            this.StartOrStopVideo();
            return result;
        });
    }
    RemoveMicrophone(microphone) {
        return this._pushToAsyncQueue(() => {
            this._removeRemoteSpeakerAudioTrackFromStream(microphone.Id);
            return Promise.resolve();
        });
    }
    SetAvailableOutgoingBitRate(bitRate) {
        this._maxAvailableOutgoingBandwidth = bitRate;
        this._checkTracksBandwidthAgainstAOB();
    }
    SetCameraBWRestrictionState(enableBWRestriction) {
        if (this._cameraBWRestriction === enableBWRestriction) {
            return;
        }
        if (enableBWRestriction) {
            this._cameraBWRestriction = enableBWRestriction;
        }
        else {
            this._cameraBWRestriction = enableBWRestriction;
            if (this._vidyoCore.Controllers.AdvancedSettingsController.EnableAudioOnlyMode) {
                this._localCameraLowBandwidthCount = 0;
                this._localCameraRestricted = false;
                this._vidyoCore.Controllers.DeviceController.SetVideoSuspendedState(this._localCameraRestricted);
                if (!this._vidyoCore.Controllers.DeviceController.GetVideoMuteState() && !this._trackIndex[TrackType.Camera][this._transmittedStream.id]) {
                    this.StartOrStopVideo();
                }
            }
        }
    }
    SetMaxSendBitRate(bitRate) {
        this._maxLocalStreamSendBandwidth = bitRate;
        this._updateLocalTracksBandwidth();
    }
    StartMedia(state) {
        let deviceSelectionActions = [];
        const hasMicrophone = !!this._trackIndex.Microphone[this._localStreamsMap[TrackType.Microphone].id];
        const hasCamera = !!this._trackIndex.Camera[this._localStreamsMap[TrackType.Camera].id];
        const hasWindowShare = !!this._trackIndex.WindowShare[this._localStreamsMap[TrackType.WindowShare].id];
        const hasMonitorShare = !!this._trackIndex.WindowShare[this._localStreamsMap[TrackType.Monitor].id];
        const isMicrophoneMuted = this._vidyoCore.Controllers.DeviceController.GetAudioMuteState();
        if (!hasMicrophone || state && !state.ShouldTransmitMedia && isMicrophoneMuted) {
            deviceSelectionActions.push(this.StartOrStopAudio(state));
        }
        if (!hasCamera) {
            deviceSelectionActions.push(this.StartOrStopVideo());
        }
        if (!hasMonitorShare && !hasWindowShare && !hasMicrophone && !hasCamera) {
            const ignoreRejectedPromises = (p) => p.catch(() => Promise.resolve());
            deviceSelectionActions = deviceSelectionActions.map(ignoreRejectedPromises);
            Promise.all(deviceSelectionActions).then(() => {
                this._updateLocalTracksBandwidth();
                this._streamEventHelper.AttachStreamEvents(this.CameraVideoStream);
                this._streamEventHelper.AttachStreamEvents(this.MicrophoneAudioStrem);
                this._streamEventHelper.AttachStreamEvents(this.WindowShareStream);
                this._streamEventHelper.AttachStreamEvents(this.MonitorShareStream);
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalStreamReady);
            });
        }
    }
    StartMonitorShare() {
        if (this._hasMonitorShare) {
            this.StopMonitorShare();
        }
        if (!this._vidyoCore.Controllers.ModerationController.IsSharingPermitted) {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Sharing is not permitted');
            return Promise.resolve(false);
        }
        return this._pushToAsyncQueue(() => {
            return this._startMonitorShare();
        }).then(() => {
            return true;
        });
    }
    StartVideoContentShare() {
        if (this._hasVideoContentShare) {
            this.StopVideoContentShare();
        }
        if (!this._vidyoCore.Controllers.ModerationController.IsSharingPermitted) {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Sharing is not permitted');
            return Promise.resolve(false);
        }
        const camera = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().VideoContent;
        if (typeof camera !== 'boolean') {
            return this._pushToAsyncQueue(() => {
                return this._startVideoContentShare(camera);
            }).then(() => {
                return true;
            });
        }
        return Promise.resolve(false);
    }
    StartOrStopAudio(mediaState = this._vidyoCore.Controllers.CallStateController.MediaState) {
        const deviceController = this._vidyoCore.Controllers.DeviceController;
        const selectedMicrophone = deviceController.GetSelectedDevices().Microphone;
        const isMicrophoneSelected = deviceController.IsMicrophoneSelected();
        const isAudioMuted = deviceController.GetAudioMuteState();
        const needToStop = this._checkMicrophoneAddedToRemoteSpeaker(selectedMicrophone)
            || (!mediaState.ShouldTransmitMedia && isAudioMuted)
            || !isMicrophoneSelected;
        if (needToStop) {
            return this.StopAudio();
        }
        else {
            return this._startAudio();
        }
    }
    StartOrStopAudioContentShare() {
        const microphone = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().AudioContent;
        if (typeof microphone !== 'boolean') {
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && microphone.Id === 'default') {
                this._startAudioContentShare(true);
            }
            else {
                this._startAudioContentShare(microphone);
            }
        }
        else {
            this.StopAudioContentShare();
        }
    }
    StartOrStopVideo() {
        if (this._vidyoCore.Controllers.DeviceController.GetVideoMuteState() || !this._isClientVisible) {
            this.SetCameraBWRestrictionState(false);
            return this.StopVideo();
        }
        else {
            return this._startVideo();
        }
    }
    StartWindowShare() {
        if (this._hasWindowShare) {
            this.StopWindowShare();
        }
        if (!this._vidyoCore.Controllers.ModerationController.IsSharingPermitted) {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Sharing is not permitted');
            return Promise.resolve(false);
        }
        return this._pushToAsyncQueue(() => {
            return this._startWindowShare();
        }).then(() => {
            return true;
        });
    }
    StopAudio() {
        return this._pushToAsyncQueue(() => {
            this._removeTrack(TrackType.Microphone);
            return Promise.resolve();
        });
    }
    StopAudioContentShare() {
        return this._pushToAsyncQueue(() => {
            this._removeTrack(TrackType.AudioContent);
            return Promise.resolve();
        });
    }
    StopMedia() {
        this.StopAudio();
        this.StopAudioContentShare();
        this.StopVideo();
        this.StopVideoContentShare();
        this.StopWindowShare();
        this.StopMonitorShare();
    }
    StopMonitorShare() {
        return this._pushToAsyncQueue(() => {
            this._hasMonitorShare = false;
            let somethingToRemove = this._trackIndex[TrackType.Monitor][this._localStreamsMap[TrackType.Monitor].id];
            this._removeTrack(TrackType.Monitor);
            if (somethingToRemove) {
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalMonitorDeselected);
            }
            return Promise.resolve();
        });
    }
    StopVideo() {
        return this._pushToAsyncQueue(() => {
            this.aobRampUp = false;
            this._removeTrack(TrackType.Camera);
            this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource);
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
                const participants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Active: true, Origin: 'remote' });
                participants.forEach((participant) => {
                    this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource, participant.Id);
                });
            }
            return Promise.resolve();
        });
    }
    StopVideoContentShare() {
        return this._pushToAsyncQueue(() => {
            this._hasVideoContentShare = false;
            this._removeTrack(TrackType.VideoContent);
            return Promise.resolve();
        });
    }
    StopWindowShare() {
        return this._pushToAsyncQueue(() => {
            this._hasWindowShare = false;
            let somethingToRemove = this._trackIndex[TrackType.WindowShare][this._localStreamsMap[TrackType.WindowShare].id];
            this._removeTrack(TrackType.WindowShare);
            if (somethingToRemove) {
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalWindowShareDeselected);
            }
            return Promise.resolve();
        });
    }
    UnregisterLocalCameraStreamInterceptor() {
        return this._userMediaProvider.UnregisterLocalCameraStreamInterceptor().then((result) => {
            if (result) {
                this._vidyoCore.Controllers.LogController.LogWarning(() => 'Local camera stream interceptor has been unregistered');
                this.StartOrStopVideo();
            }
            return result;
        });
    }
    UpdateTrackBandwidth(bandwidth, trackId) {
        this._checkTracksBandwidthAgainstAOB();
        const constraintsObject = this._getLocalStreamConstraintsByTrack(trackId);
        if (constraintsObject) {
            let preferredBitrate = constraintsObject
                .MaxPreferredBandwidth(this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName());
            let localBandwidth = bandwidth;
            if (preferredBitrate) {
                localBandwidth = Math.min(localBandwidth, preferredBitrate);
            }
            constraintsObject.Bandwidth = localBandwidth;
        }
    }
    UpdateTrackConstraints(constraints, trackId) {
        if (constraints && constraints.width && constraints.height) {
            const cameraConstraints = {
                width: constraints.width,
                height: constraints.height,
            };
            this._constraintsMap.Camera.MaxConstraints = cameraConstraints;
            this._videoTransmittedStreamConstraintsChanged();
            this._videoLocalStreamConstraintsChanged();
        }
    }
    UpdateSimulcastRunnels(sourceView, trackId) {
        const codecName = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName();
        if (codecName && this._getLocalStreamTrackTypeByTrack(trackId) !== undefined) {
            this.updateRunnels(sourceView, trackId, codecName);
        }
        else {
            this._vidyoCore.Controllers.LogController.LogWarning(() => `codecName is undefined`);
        }
        this._checkTracksBandwidthAgainstAOB();
    }
    updateRunnels(sourceView, trackId, codec_type) {
        const trackType = this._getLocalStreamTrackTypeByTrack(trackId);
        if (!trackType) {
            return;
        }
        const constraints = this._constraintsMap[trackType];
        const track = this._transmittedStream.getTracks().find((tr) => tr.id === trackId);
        const trackSettings = track && track.getSettings();
        let trackWidth = trackSettings?.width;
        let trackHeight = trackSettings?.height;
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsAndroid() && ScreenInfoProvider_1.default.IsPortrait && trackWidth > trackHeight) {
            [trackWidth, trackHeight] = [trackHeight, trackWidth];
        }
        const currentConstraints = constraints.CurrentConstraints;
        let source_width = trackWidth || currentConstraints.width;
        let source_height = trackHeight || currentConstraints.height;
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
            source_width = currentConstraints.width;
            source_height = currentConstraints.height;
        }
        const numLayersFitHorz = Math.floor(1 + Math.max(0, Math.log2(source_width / Constants.MinCameraResolutionHeightForSimulcast)));
        const numLayersFitVert = Math.floor(1 + Math.max(0, Math.log2(source_height / Constants.MinCameraResolutionHeightForSimulcast)));
        const simulcastRunnels = Math.min(numLayersFitHorz, numLayersFitVert);
        const layersCount = Object.keys(Constants.Runnels).length;
        if (simulcastRunnels < layersCount) {
            this._vidyoCore.Controllers.LogController
                .LogWarning(() => `Reducing number of spatial layers from ${layersCount} to ${simulcastRunnels} due to low input resolution`);
        }
        const MinimalSendBitrate = 100;
        let AOB = Math.max(MinimalSendBitrate, Math.min(this._maxAvailableOutgoingBandwidth || 0, constraints.MaxBandwidth || 0) / 1000);
        const show_not_received_yet = !sourceView;
        let show_info = {};
        show_info.width_max = +sourceView?.params?.width || source_width;
        show_info.width_min = +sourceView?.params?.minWidth || show_info.width_max;
        show_info.height_max = +sourceView?.params?.height || source_height;
        show_info.height_min = +sourceView?.params?.minHeight || show_info.height_max;
        show_info.framerate_max = +sourceView?.params?.framerate || constraints.DEFAULT_FRAMERATE;
        show_info.framerate_min = +sourceView?.params?.minFrameRate || show_info.framerate_max;
        show_info.pixelrate_max = +sourceView?.params?.pixelrate;
        show_info.pixelrate_min = 0;
        show_info.bw_min = (+sourceView?.params?.minBandwidth || 0) / 1000;
        show_info.bw_max = (+sourceView?.params?.bandwidth || 0) / 1000;
        let src_info = {};
        src_info.width = source_width;
        src_info.height = source_height;
        src_info.rate = currentConstraints.frameRate || constraints.DEFAULT_FRAMERATE;
        let runnels = {
            num_runnels: 0,
            frame_width: 0,
            frame_height: 0,
            frame_rate: 30.0,
            downsizing_ratio: [1, 1, 1],
            target_bitrate: [0, 0, 0]
        };
        let contenttype = -1;
        if (trackType === TrackType.Camera || trackType === TrackType.VideoContent) {
            contenttype = RunnelsHelper.ContentType.CONFERENCE;
        }
        else if (trackType === TrackType.WindowShare || trackType === TrackType.Monitor) {
            contenttype = RunnelsHelper.ContentType.STATIC;
        }
        const maxFrameSize = contenttype === RunnelsHelper.ContentType.STATIC ?
            RunnelsHelper.MaxVideoSize.SIZE_1080P : RunnelsHelper.MaxVideoSize.SIZE_720P;
        AOB = (0, SimulcastRunnelsHelper_1.normalizeAOB)(AOB, maxFrameSize);
        let ret = RunnelsHelper.find_frame_size_range_in_mb(show_not_received_yet, show_info, src_info, codec_type, AOB, contenttype);
        if (ret) {
            RunnelsHelper.update_runnels(show_info, src_info, codec_type, AOB, ret.max_frame_size_mb, ret.max_min_ratio, runnels);
            constraints.runnels['hi'].active = runnels.num_runnels >= 1;
            constraints.runnels['hi'].bandwidth = Math.floor(runnels.target_bitrate[0] * 1000);
            constraints.runnels['hi'].downScaleFactor = runnels.downsizing_ratio[0];
            constraints.runnels['mid'].active = runnels.num_runnels >= 2;
            constraints.runnels['mid'].bandwidth = Math.floor(runnels.target_bitrate[1] * 1000);
            constraints.runnels['mid'].downScaleFactor = runnels.downsizing_ratio[1];
            constraints.runnels['lo'].active = runnels.num_runnels === 3;
            constraints.runnels['lo'].bandwidth = Math.floor(runnels.target_bitrate[2] * 1000);
            constraints.runnels['lo'].downScaleFactor = runnels.downsizing_ratio[2];
            this._vidyoCore.Controllers.LogController
                .LogDebug(() => `Update runnels:
          Stream type: ${trackType},
          AOB: ${AOB} Kbps,
          Show information: ${JSON.stringify(show_info, null, '\t')},
          Source information: ${JSON.stringify(src_info, null, '\t')},
          Runnels config: ${JSON.stringify(constraints.runnels, null, '\t')}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
        }
    }
    get WindowShareStream() {
        return new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._localStreamsMap[TrackType.WindowShare]);
    }
    get LocalCameraStreamRestricted() {
        return this._localCameraRestricted;
    }
    _addRemoteSpeakerAudioTrackToStream(track, microphoneId) {
        const targetStreams = [this._localStreamsMap.Microphone, this._transmittedStream];
        for (let stream of targetStreams) {
            this._remoteSpeakerAudioTracks[microphoneId] = track;
            stream.addTrack(track);
            stream.dispatchEvent(new Event('addtrack'));
        }
        setTimeout(() => void this._updateLocalTracksBandwidth());
    }
    _addStreamTrack(track, trackType) {
        this._addTrackToStream(trackType, this._localStreamsMap[trackType], track);
        this._addTrackToStream(trackType, this._transmittedStream, track.clone());
        setTimeout(() => { this._updateLocalTracksBandwidth(); }, 0);
    }
    _addTrackToStream(trackType, stream, track) {
        this._trackIndex[trackType][stream.id] = track;
        stream.addTrack(track);
        stream.dispatchEvent(new Event('addtrack'));
    }
    _getLocalStreamConstraintsByTrack(trackId) {
        let constraints;
        const trackType = this._getLocalStreamTrackTypeByTrack(trackId);
        if (trackType) {
            constraints = this._constraintsMap[trackType];
        }
        return constraints;
    }
    _getLocalStreamTrackTypeByTrack(trackId) {
        const streamId = this._transmittedStream.id;
        for (let trackType of [TrackType.Camera, TrackType.Monitor, TrackType.WindowShare, TrackType.VideoContent]) {
            let track = this._trackIndex[trackType][streamId];
            if (track && track.id === trackId) {
                return trackType;
            }
        }
        return undefined;
    }
    _getTrackTypes(trackId) {
        if (this._trackToMediaTypeMap[trackId]) {
            return this._trackToMediaTypeMap[trackId];
        }
        else {
            return { trackMediaType: TrackMetaDataProvider_1.UnknownMediaTrackType };
        }
    }
    _mediaStateTransition(state) {
        if (state.ShouldRenderMedia) {
            this.StartMedia(state);
        }
        else {
            this.StopMedia();
        }
    }
    _onCallDisconnected() {
        this.StopWindowShare();
        this.StopMonitorShare();
        this.aobRampUp = false;
    }
    _onMediaSessionStarted() {
        for (const key in this._constraintsMap) {
            if (this._constraintsMap.hasOwnProperty(key)) {
                this._constraintsMap[key].bandwidth = undefined;
            }
        }
    }
    _handleSharingPermissionChanged(payload) {
        if (!payload.isPermitted) {
            if (this._hasWindowShare) {
                this.StopWindowShare();
            }
            if (this._hasMonitorShare) {
                this.StopMonitorShare();
            }
            if (this._hasVideoContentShare) {
                this.StopVideoContentShare();
            }
        }
    }
    _pushToAsyncQueue(action) {
        return new Promise((resolve, reject) => {
            this._mediaActionsQueue.push(action, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    _removeRemoteSpeakerAudioTrackFromStream(microphoneId) {
        for (let stream of [this._localStreamsMap.Microphone, this._transmittedStream]) {
            const track = this._remoteSpeakerAudioTracks[microphoneId];
            if (track) {
                stream.removeTrack(track);
                track.stop();
                stream.dispatchEvent(new Event('removetrack'));
            }
        }
        delete this._remoteSpeakerAudioTracks[microphoneId];
        setTimeout(() => void this._updateLocalTracksBandwidth());
    }
    _removeTrack(trackType) {
        this._removeTrackFromStream(trackType, this._localStreamsMap[trackType]);
        this._removeTrackFromStream(trackType, this._transmittedStream);
        setTimeout(() => { this._updateLocalTracksBandwidth(); }, 0);
    }
    _removeTrackFromStream(trackType, stream) {
        let track = this._trackIndex[trackType][stream.id];
        if (track) {
            stream.removeTrack(track);
            track.stop();
            stream.dispatchEvent(new Event('removetrack'));
            delete this._trackIndex[trackType][stream.id];
        }
    }
    _setAudioMutedState() {
        if (this._vidyoCore.Controllers.CallStateController.MediaState.ShouldTransmitMedia) {
            this._vidyoCore.HunterProvider.MuteAudio(this._vidyoCore.Controllers.DeviceController.GetAudioMuteState());
        }
        else {
            this.StartOrStopAudio();
        }
        this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TracksChanged, this.MicrophoneAudioStrem.Id);
    }
    _setVideoStreamMaxConstraints() {
        const devices = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices();
        this._constraintsMap.Camera.AspectRatioConstraints = (typeof devices.Camera !== 'boolean')
            ? devices.Camera.AspectRatioConstraints
            : undefined;
        this._constraintsMap.Camera.MaxConstraints = (typeof devices.Camera !== 'boolean')
            ? devices.Camera.MaxConstraints
            : undefined;
        this._constraintsMap.VideoContent.AspectRatioConstraints = (typeof devices.VideoContent !== 'boolean')
            ? devices.VideoContent.AspectRatioConstraints
            : undefined;
        this._constraintsMap.VideoContent.MaxConstraints = (typeof devices.VideoContent !== 'boolean')
            ? devices.VideoContent.MaxConstraints
            : undefined;
        this._videoTransmittedStreamConstraintsChanged();
        this._videoLocalStreamConstraintsChanged();
    }
    _startAudio() {
        return this._pushToAsyncQueue(() => {
            let selection = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Microphone;
            const isSystemDefault = selection instanceof Microphone_1.Microphone && selection.Id === 'default';
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && isSystemDefault) {
                selection = true;
            }
            return this._startTrack(TrackType.Microphone, () => this._userMediaProvider.GetAudioTrack(selection || true));
        });
    }
    _startAudioContentShare(microphone) {
        return this._startTrack(TrackType.AudioContent, () => this._userMediaProvider.GetAudioTrack(microphone)).then(() => {
            let audioContentShare = this._trackIndex[TrackType.AudioContent][this._localStreamsMap[TrackType.AudioContent].id];
            if (audioContentShare) {
                audioContentShare.addEventListener('ended', () => {
                    this.StopAudioContentShare();
                });
            }
        });
    }
    _startMonitorShare() {
        return this._startTrack(TrackType.Monitor, () => this._userMediaProvider.GetWindowShareTrack()).then(() => {
            let monitorShare = this._trackIndex[TrackType.Monitor][this._localStreamsMap[TrackType.Monitor].id];
            if (monitorShare) {
                this._hasMonitorShare = true;
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalMonitorSelected);
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource, this.CameraVideoStream.Id);
                monitorShare.addEventListener('ended', () => {
                    this.StopMonitorShare();
                });
            }
        }).catch((err) => {
            this._vidyoCore.Controllers.LogController.LogError(err);
            return Promise.reject(err);
        });
    }
    _startTrack(trackType, getUserMedia) {
        let mediaState = this._vidyoCore.Controllers.CallStateController.MediaState;
        if (mediaState.ShouldRenderMedia) {
            this._removeTrack(trackType);
            return getUserMedia().then((track) => {
                if (track) {
                    if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                        if (track.kind === 'audio' && this._micPermissionGranted === false) {
                            this._vidyoCore.Controllers.PermissionController.TrySubscribePermission(Permission_1.PermissionType.microphone, true);
                            this._micPermissionGranted = true;
                        }
                        else if (track.kind === 'video' && this._cameraPermissionGranted === false) {
                            this._vidyoCore.Controllers.PermissionController.TrySubscribePermission(Permission_1.PermissionType.camera, true);
                            this._cameraPermissionGranted = true;
                        }
                    }
                    this._addStreamTrack(track, trackType);
                }
                return Promise.resolve();
            }).catch((error) => {
                return Promise.reject(error);
            });
        }
        else {
            const messageValues = { mediaType: trackType, mediaState: mediaState.toString() };
            const message = StringUtils_1.default.Format(Messages.LocalMediaOperationNotPermitted, messageValues);
            return Promise.reject(message);
        }
    }
    _startVideo() {
        return this._pushToAsyncQueue(() => {
            const camera = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Camera;
            this._constraintsMap.Camera.MaxConstraints = undefined;
            if (typeof camera !== 'boolean') {
                this._constraintsMap.Camera.AspectRatioConstraints = camera.AspectRatioConstraints;
                if (camera.MaxConstraints
                    || this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast
                    || !this.IsScaleResolutionDownSupported()) {
                    this._constraintsMap.Camera.MaxConstraints = camera.MaxConstraints;
                }
                else {
                    this._vidyoCore.Controllers.LogController.LogDebug(() => 'Reset camera max constraints');
                    this._constraintsMap.Camera.MaxConstraints = {
                        height: this._constraintsMap.Camera.DEFAULT_HEIGHT,
                        width: this._constraintsMap.Camera.DEFAULT_WIDTH
                    };
                }
            }
            let constraints = this._constraintsMap.Camera.CurrentConstraints;
            return this._startTrack(TrackType.Camera, () => this._userMediaProvider.GetVideoTrack(camera || true, constraints));
        });
    }
    _startVideoContentShare(camera) {
        this._constraintsMap.VideoContent.AspectRatioConstraints = camera.AspectRatioConstraints;
        this._constraintsMap.VideoContent.MaxConstraints = camera.MaxConstraints || {
            height: this._constraintsMap.VideoContent.DEFAULT_HEIGHT,
            width: this._constraintsMap.VideoContent.DEFAULT_WIDTH
        };
        const constraints = this._constraintsMap.VideoContent.CurrentConstraints;
        return this._startTrack(TrackType.VideoContent, () => this._userMediaProvider.GetVideoTrack(camera, constraints)).then(() => {
            let videoContentShare = this._trackIndex[TrackType.VideoContent][this._localStreamsMap[TrackType.VideoContent].id];
            if (videoContentShare) {
                this._hasVideoContentShare = true;
                videoContentShare.addEventListener('ended', () => {
                    this.StopVideoContentShare();
                });
            }
        });
    }
    _startWindowShare() {
        return this._startTrack(TrackType.WindowShare, () => this._userMediaProvider.GetWindowShareTrack()).then(() => {
            let windowShare = this._trackIndex[TrackType.WindowShare][this._localStreamsMap[TrackType.WindowShare].id];
            if (windowShare) {
                this._hasWindowShare = true;
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalWindowShareSelected);
                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource, this.CameraVideoStream.Id);
                windowShare.addEventListener('ended', () => {
                    this.StopWindowShare();
                });
            }
        }).catch((err) => {
            this._vidyoCore.Controllers.LogController.LogError(err);
            return Promise.reject(err);
        });
    }
    _transmittedTracksUpdated() {
        const streamId = this._transmittedStream.id;
        const trackToMediaTypeMap = {
            [TrackType.AudioContent]: TrackMetaDataProvider_1.MediaTrackType.Audio,
            [TrackType.Camera]: TrackMetaDataProvider_1.MediaTrackType.Video,
            [TrackType.Monitor]: TrackMetaDataProvider_1.MediaTrackType.Application,
            [TrackType.VideoContent]: TrackMetaDataProvider_1.MediaTrackType.Application,
            [TrackType.WindowShare]: TrackMetaDataProvider_1.MediaTrackType.Application,
            [TrackType.Microphone]: TrackMetaDataProvider_1.MediaTrackType.Audio
        };
        for (let [trackType, trackMediaType] of Object.entries(trackToMediaTypeMap)) {
            let track = this._trackIndex[trackType][streamId];
            if (track) {
                this._trackToMediaTypeMap[track.id] = { trackType: trackType, trackMediaType };
            }
        }
        for (let track of Object.values(this._remoteSpeakerAudioTracks)) {
            this._trackToMediaTypeMap[track.id] = {
                trackMediaType: TrackMetaDataProvider_1.MediaTrackType.Audio,
                trackType: TrackType.Microphone
            };
        }
    }
    _updateLocalTracksBandwidth() {
        if (this._maxLocalStreamSendBandwidth) {
            const sendVideoTypes = {
                WindowShare: {
                    exist: () => this._hasWindowShare
                },
                MonitorShare: {
                    exist: () => this._hasMonitorShare
                },
                VideoContent: {
                    exist: () => typeof this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().VideoContent !== 'boolean'
                },
                Camera: {
                    exist: () => !this._vidyoCore.Controllers.DeviceController.GetVideoMuteState()
                },
                Total: () => {
                    let total = 0;
                    total += this._hasWindowShare ? 1 : 0;
                    total += this._hasMonitorShare ? 1 : 0;
                    total += (typeof this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().VideoContent !== 'boolean') ? 1 : 0;
                    total += (!this._vidyoCore.Controllers.DeviceController.GetVideoMuteState()) ? 1 : 0;
                    return total;
                }
            };
            let bitrate = this._maxLocalStreamSendBandwidth;
            if (this._vidyoCore.Controllers.DeviceController.IsMicrophoneSelected()
                && !this._vidyoCore.Controllers.DeviceController.GetAudioMuteState()) {
                bitrate = Math.max(bitrate - Constants.DefaultAudioBandwidth, 0);
            }
            if (typeof this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().AudioContent !== 'boolean') {
                bitrate = Math.max(bitrate - Constants.DefaultAudioBandwidth, 0);
            }
            if (sendVideoTypes.WindowShare.exist()) {
                this._constraintsMap.WindowShare.MaxBandwidth = Math.max(Constants.DefaultContentShareBandwidth, bitrate / sendVideoTypes.Total());
            }
            if (sendVideoTypes.MonitorShare.exist()) {
                this._constraintsMap.Monitor.MaxBandwidth = Math.max(Constants.DefaultContentShareBandwidth, bitrate / sendVideoTypes.Total());
            }
            if (sendVideoTypes.VideoContent.exist()) {
                this._constraintsMap.VideoContent.MaxBandwidth = Math.max(Constants.DefaultContentShareBandwidth, bitrate / sendVideoTypes.Total());
            }
            if (sendVideoTypes.Camera.exist()) {
                this._constraintsMap.Camera.MaxBandwidth = bitrate / sendVideoTypes.Total();
            }
            if (this._vidyoCore.HunterProvider) {
                this._vidyoCore.HunterProvider.UpdateMediaStates();
            }
        }
    }
    _checkMicrophoneAddedToRemoteSpeaker(microphone) {
        if (microphone instanceof Microphone_1.Microphone) {
            return !!this._remoteSpeakerAudioTracks[microphone.Id];
        }
    }
    _checkTracksBandwidthAgainstAOB() {
        if (this._maxAvailableOutgoingBandwidth) {
            const sendVideoTypes = {
                WindowShare: {
                    exist: () => this._hasWindowShare
                },
                MonitorShare: {
                    exist: () => this._hasMonitorShare
                },
                VideoContent: {
                    exist: () => typeof this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().VideoContent !== 'boolean'
                },
                Camera: {
                    exist: () => !this._vidyoCore.Controllers.DeviceController.GetVideoMuteState()
                }
            };
            let bitrate = this._maxAvailableOutgoingBandwidth;
            if (this._maxLocalStreamSendBandwidth) {
                bitrate = Math.min(bitrate, this._maxLocalStreamSendBandwidth);
            }
            bitrate = Math.max(bitrate - Constants.DefaultSignalingBandwidth, 0);
            if (this._vidyoCore.Controllers.DeviceController.IsMicrophoneSelected()
                && !this._vidyoCore.Controllers.DeviceController.GetAudioMuteState()) {
                bitrate = Math.max(bitrate - Constants.DefaultAudioBandwidth, 0);
            }
            if (typeof this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().AudioContent !== 'boolean') {
                bitrate = Math.max(bitrate - Constants.DefaultAudioBandwidth, 0);
            }
            if (sendVideoTypes.WindowShare.exist()) {
                bitrate = Math.max(bitrate - Constants.DefaultContentShareBandwidth, 0);
            }
            if (sendVideoTypes.MonitorShare.exist()) {
                bitrate = Math.max(bitrate - Constants.DefaultContentShareBandwidth, 0);
            }
            if (sendVideoTypes.VideoContent.exist()) {
                bitrate = Math.max(bitrate - Constants.DefaultContentShareBandwidth, 0);
            }
            if (sendVideoTypes.Camera.exist() && !this._aobIsRampingUp) {
                const MIN_BW_PERCENTAGE = 0.4;
                const CONSECUTIVE_LOW_BANDWITH_COUNTER = 10;
                const codecName = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName() ?? this._lastCameraCodecName;
                const resolution = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraResolution();
                if (codecName && resolution.width && resolution.height) {
                    if (this._cameraBWRestriction && this._vidyoCore.Controllers.AdvancedSettingsController.EnableAudioOnlyMode === true) {
                        let restrictSendingLocalVideo = false;
                        if ((Math.min(resolution.width, resolution.height) < 120
                            || (!OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()
                                && Math.min(resolution.width, resolution.height) < 180))) {
                            this._vidyoCore.Controllers.LogController.LogWarning(() => `Fallback to audio-only mode since the output resolution is ${resolution.width}x${resolution.height}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                            restrictSendingLocalVideo = true;
                        }
                        else {
                            const minBw = this._constraintsMap.Camera.MinimumBandwidth(codecName);
                            if (minBw && bitrate < (minBw * MIN_BW_PERCENTAGE)) {
                                if (this._localCameraLowBandwidthCount++ >= CONSECUTIVE_LOW_BANDWITH_COUNTER) {
                                    restrictSendingLocalVideo = true;
                                    this._vidyoCore.Controllers.LogController.LogWarning(() => `expect minimum ${minBw}, available ${bitrate}`, LogEvents_1.VidyoLogCategory.VidyoResourceManager);
                                }
                            }
                            else {
                                this._localCameraLowBandwidthCount = 0;
                            }
                        }
                        if (this.LocalCameraStreamRestricted !== restrictSendingLocalVideo) {
                            this._localCameraRestricted = restrictSendingLocalVideo;
                            if (this._localCameraRestricted) {
                                this._removeTrackFromStream(TrackType.Camera, this._transmittedStream);
                                this._vidyoCore.EventDispatcher.emit(RenderEvents.Events.UpdateSource);
                            }
                            else if (!this._trackIndex[TrackType.Camera][this._transmittedStream.id]) {
                                this.StartOrStopVideo();
                            }
                            this._vidyoCore.Controllers.DeviceController.SetVideoSuspendedState(this._localCameraRestricted);
                        }
                        this._lastCameraCodecName = codecName;
                    }
                    else if (this._cameraBWRestriction) {
                        this._constraintsMap.Camera.MaxBandwidth = Math.max(bitrate, LocalStreamController.MINIMUM_VIDEO_BANDWIDTH);
                    }
                }
            }
        }
    }
    _videoLocalStreamConstraintsChanged() {
        const track = this._trackIndex[TrackType.Camera][this._localStreamsMap[TrackType.Camera].id];
        this._videoStreamConstraintsChanged(this._constraintsMap.Camera, track).then((constraints) => {
            if (constraints) {
                this._vidyoCore.Controllers.LogController
                    .LogInfo(() => `local stream camera constraints changed. ${JSON.stringify(constraints)}`);
            }
        }).catch((constraints) => {
            this._vidyoCore.Controllers.LogController
                .LogInfo(() => `local stream camera constraints NOT changed. ${JSON.stringify(constraints)}`);
        });
        const videoContentTrack = this._trackIndex[TrackType.VideoContent][this._localStreamsMap[TrackType.VideoContent].id];
        this._videoStreamConstraintsChanged(this._constraintsMap.VideoContent, videoContentTrack).then((constraints) => {
            if (constraints) {
                this._vidyoCore.Controllers.LogController
                    .LogInfo(() => `local stream video content share constraints changed. ${JSON.stringify(constraints)}`);
            }
        }).catch((constraints) => {
            this._vidyoCore.Controllers.LogController
                .LogInfo(() => `local stream video content share constraints NOT changed. ${JSON.stringify(constraints)}`);
        });
    }
    _videoLockConstraints(lockConstraints) {
        this._constraintsMap.Camera.locked = lockConstraints;
    }
    _videoStreamConstraintsChanged(constraintsData, track) {
        if (constraintsData.locked === true) {
            return Promise.resolve(undefined);
        }
        if (track) {
            const { isContentShare } = this.GetTrackMediaProperties(track.id);
            const currentConstraints = constraintsData.CurrentConstraints;
            let constraints = {
                width: { exact: currentConstraints.width },
                height: { exact: currentConstraints.height },
                frameRate: { ideal: currentConstraints.frameRate }
            };
            if (!this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast && this.IsScaleResolutionDownSupported() && !isContentShare) {
                this._vidyoCore.Controllers.LogController.LogDebug(() => 'Stream constraints changed - use scaleResolutionDownBy');
                this._updateLocalTracksBandwidth();
                return Promise.resolve(constraints);
            }
            return new Promise((resolve, reject) => {
                track.applyConstraints(constraints).then(() => {
                    resolve(constraints);
                }).catch((e) => {
                    this._vidyoCore.Controllers.LogController.LogError(e);
                    reject(constraints);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    _videoTransmittedStreamConstraintsChanged() {
        let track = this._trackIndex[TrackType.Camera][this._transmittedStream.id];
        this._videoStreamConstraintsChanged(this._constraintsMap.Camera, track).then((constraints) => {
            if (constraints) {
                this._vidyoCore.Controllers.LogController
                    .LogInfo(() => `${new Date()} :
        LocalStreamController: transmitted stream video constraints changed. ${JSON.stringify(constraints)}`);
            }
        }).catch((constraints) => {
        });
        const videoContentTrack = this._trackIndex[TrackType.VideoContent][this._transmittedStream.id];
        this._videoStreamConstraintsChanged(this._constraintsMap.VideoContent, videoContentTrack).then((constraints) => {
            if (constraints) {
                this._vidyoCore.Controllers.LogController
                    .LogInfo(() => `transmitted stream video content share constraints changed. ${JSON.stringify(constraints)}`);
            }
        }).catch((constraints) => {
            this._vidyoCore.Controllers.LogController
                .LogInfo(() => `transmitted stream video content share constraints NOT changed. ${JSON.stringify(constraints)}`);
        });
    }
    clearVisibilityHandlers() {
        document.removeEventListener('visibilitychange', this.visibilityHandler);
    }
    registerVisibilityHandlers() {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            this.visibilityHandler = this.visibilityHandler.bind(this);
            document.addEventListener('visibilitychange', this.visibilityHandler);
        }
    }
    visibilityHandler() {
        const visible = document.visibilityState !== 'hidden';
        if (visible !== this._isClientVisible) {
            this._isClientVisible = visible;
            const isInCall = this._vidyoCore.Controllers.TransmittedStreamController.InCall;
            if (isInCall || (this._isClientVisible && !this._trackIndex[TrackType.Camera][this._transmittedStream.id])) {
                this.StartOrStopVideo();
                if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIOS() && visible) {
                    const participantsIds = this._vidyoCore.Controllers.ParticipantController
                        .GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote, Active: true });
                    participantsIds.forEach((p) => {
                        this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.UpdateSource, p.Id);
                    });
                }
            }
        }
    }
    GetTransmittedTrack(type) {
        if (this._trackIndex[type][this._transmittedStream.id]) {
            return this._trackIndex[type][this._transmittedStream.id];
        }
        return false;
    }
}
exports.LocalStreamController = LocalStreamController;
LocalStreamController.MINIMUM_VIDEO_BANDWIDTH = 100000;

},{"../../../vidyo_simple_api/Permission":189,"../../events/CallStateEvents":64,"../../events/ConnectionEvents":66,"../../events/DeviceEvents":67,"../../events/EventDispatcher":68,"../../events/LogEvents":69,"../../events/ModerationEvents":72,"../../events/RenderEvents":75,"../../events/StreamEvents":79,"../../models/Participant":94,"../../models/VideoResolution":100,"../../models/device/Microphone":105,"../../models/stream/ReadOnlyMediaStream":133,"../../utils/Constants":138,"../../utils/Messages":150,"../../utils/OperatingSystemInfoProvider":154,"../../utils/ScreenInfoProvider":160,"../../utils/SimulcastRunnelsHelper":161,"../../utils/StringUtils":164,"../../utils/UserMediaProvider":168,"../BaseController":35,"./StreamEventHelper":58,"./TrackMetaDataProvider":59,"async":1}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteStreamController = void 0;
const ConferenceEvents = require("../../events/ConferenceEvents");
const ConnectionEvents = require("../../events/ConnectionEvents");
const Messages = require("../../utils/Messages");
const StreamEvents = require("../../events/StreamEvents");
const BaseController_1 = require("../BaseController");
const ReadOnlyMediaStream_1 = require("../../models/stream/ReadOnlyMediaStream");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const StreamEventHelper_1 = require("./StreamEventHelper");
const TrackMetaDataProvider_1 = require("./TrackMetaDataProvider");
const StringUtils_1 = require("../../utils/StringUtils");
const ParticipantEvents = require("../../events/ParticipantEvents");
const LogEvents_1 = require("../../events/LogEvents");
class RemoteStreamController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this._participantStreamsData = {};
        this._participantStreamsMap = {};
        this._ssrcToGeneratedIdMap = {};
        this._streams = {};
        this._trackMetaData = {};
    }
    Disable() {
        return super.Disable();
    }
    GetNetworkStream(id) {
        let stream = this.TryGetNetworkStream(id);
        if (stream) {
            return stream;
        }
        else {
            throw (new Error(StringUtils_1.default.Format(Messages.NoSuchStream, { id })));
        }
    }
    GetParticipantApplicationStreams(participantId) {
        let streams = [];
        if (this._participantStreamsData[participantId]) {
            streams = Object.values(this._participantStreamsData[participantId].Application)
                .map((data) => new ReadOnlyMediaStream_1.ReadOnlyMediaStream(data.stream));
        }
        return streams;
    }
    GetTrackMediaType(id) {
        let stream = this.TryGetParticipantStream(id);
        let trackType;
        if (stream) {
            let track = stream.GetVideoTracks()[0];
            if (track) {
                trackType = this._trackMetaData[track.Id];
            }
        }
        return trackType || 'unknown';
    }
    Initialize() {
        this._streamEventHelper = new StreamEventHelper_1.StreamEventHelper(this._vidyoCore.EventDispatcher);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.RemoteStreamControllerListeners);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.JingleRemoteStreamAdded, EventDispatcher_1.RemoteStreamControllerListeners, ({ stream }) => this._onRemoteStreamAdded(stream));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.JingleRemoteStreamRemoved, EventDispatcher_1.RemoteStreamControllerListeners, ({ stream }) => this._onRemoteStreamRemoved(stream));
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.SourceDetected, EventDispatcher_1.RemoteStreamControllerListeners, (data) => this._onRemoteTrackMetaData(data));
        this._vidyoCore.EventDispatcher.on(ConferenceEvents.Events.SourceRemoved, EventDispatcher_1.RemoteStreamControllerListeners, (data) => this._onRemoteTrackRemoved(data));
        this._vidyoCore.EventDispatcher
            .on(ParticipantEvents.Events.ParticipantLeft, (payload) => this._onParticipantLeave(payload.participant));
        return super.Initialize();
    }
    TryGetNetworkStream(id) {
        return this._streams[id];
    }
    TryGetParticipantAudioStream(participantId) {
        let stream;
        if (this._participantStreamsData[participantId]) {
            stream = new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._participantStreamsData[participantId].Audio.stream);
        }
        return stream;
    }
    TryGetParticipantStream(streamId) {
        let stream;
        if (this._participantStreamsMap[streamId]) {
            stream = new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._participantStreamsMap[streamId]);
        }
        return stream;
    }
    TryGetParticipantStreamBySsrc(participantId, ssrc) {
        let stream;
        if (this._participantStreamsData[participantId]) {
            const data = this._participantStreamsData[participantId];
            if (data.SourceToStreamMap[ssrc]) {
                stream = new ReadOnlyMediaStream_1.ReadOnlyMediaStream(data.SourceToStreamMap[ssrc]);
            }
        }
        return stream;
    }
    TryGetParticipantVideoStream(participantId) {
        let stream;
        if (this._participantStreamsData[participantId]) {
            stream = new ReadOnlyMediaStream_1.ReadOnlyMediaStream(this._participantStreamsData[participantId].Video.stream);
        }
        return stream;
    }
    GetGeneratedIdBySsrc(ssrc) {
        return this._ssrcToGeneratedIdMap[ssrc];
    }
    _checkAndAddParticipantStreamsDataTrack(participantStreams, stream) {
        let tracks = stream.getTracks();
        tracks.forEach((track) => {
            let trackType;
            let trackSsrc = this._vidyoCore.Controllers.ConnectionController.Session.GetReceiverSsrcByTrackId(track.id);
            if (trackSsrc && this._trackMetaData[trackSsrc]) {
                trackType = this._trackMetaData[track.id] = this._trackMetaData[trackSsrc];
                this._ssrcToGeneratedIdMap[trackSsrc] = track.id;
            }
            else {
                if (track.kind === 'audio') {
                    trackType = this._trackMetaData[track.id] = TrackMetaDataProvider_1.MediaTrackType.Audio;
                }
                else if (track.kind === 'video') {
                    trackType = this._trackMetaData[track.id] = TrackMetaDataProvider_1.MediaTrackType.Video;
                }
            }
            switch (trackType) {
                case TrackMetaDataProvider_1.MediaTrackType.Audio:
                    if (!participantStreams.MediaTrackMap[track.id]) {
                        let clonedTrack = track.clone();
                        this._trackMetaData[clonedTrack.id] = trackType;
                        participantStreams.MediaTrackMap[track.id] = clonedTrack;
                        participantStreams.SourceToStreamMap[trackSsrc] = participantStreams.Audio.stream;
                        this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned ${clonedTrack.kind} track ${clonedTrack.id} mute state: ${clonedTrack.muted}`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
                        participantStreams.Audio.stream.onaddtrack = (event) => {
                            let evttrack = event.target.getTracks()[0];
                            this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned ${evttrack.kind} track ${evttrack.id} added`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
                        };
                        participantStreams.Audio.stream.onremovetrack = (event) => {
                            this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned ${clonedTrack.kind} track ${clonedTrack.id} removed`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
                        };
                        participantStreams.Audio.stream.addTrack(clonedTrack);
                        participantStreams.Audio.stream.dispatchEvent(new Event('addtrack'));
                        const ssrc = trackSsrc || track.id;
                        this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteTrackAddedSsrc.Scoped(ssrc), ssrc);
                    }
                    break;
                case TrackMetaDataProvider_1.MediaTrackType.Video:
                    if (!participantStreams.MediaTrackMap[track.id]) {
                        let clonedTrack = track.clone();
                        this._trackMetaData[clonedTrack.id] = trackType;
                        participantStreams.MediaTrackMap[track.id] = clonedTrack;
                        participantStreams.SourceToStreamMap[trackSsrc] = participantStreams.Video.stream;
                        participantStreams.Video.stream.addTrack(clonedTrack);
                        participantStreams.Video.stream.dispatchEvent(new Event('addtrack'));
                        const ssrc = trackSsrc || track.id;
                        this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteTrackAddedSsrc.Scoped(ssrc), ssrc);
                    }
                    break;
                case TrackMetaDataProvider_1.MediaTrackType.Application:
                    if (!participantStreams.Application[track.id]) {
                        let mediaStream = new MediaStream();
                        let clonedTrack = track.clone();
                        this._trackMetaData[clonedTrack.id] = trackType;
                        mediaStream.addTrack(clonedTrack);
                        this._participantStreamsMap[mediaStream.id] = mediaStream;
                        participantStreams.Application[track.id] = {
                            stream: mediaStream
                        };
                        participantStreams.SourceToStreamMap[trackSsrc] = mediaStream;
                        const ssrc = trackSsrc || track.id;
                        this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteTrackAddedSsrc.Scoped(ssrc), ssrc);
                    }
                    break;
                default:
                    console.log('unsupported MediaTrackType');
                    break;
            }
        });
    }
    _checkAndRemoveParticipantStreamsDataTracks(participantStreams, currentTracks) {
        for (let [id, track] of Object.entries(participantStreams.MediaTrackMap)) {
            if (!currentTracks.includes(id)) {
                switch (this._trackMetaData[track.id]) {
                    case TrackMetaDataProvider_1.MediaTrackType.Audio:
                        participantStreams.Audio.stream.removeTrack(track);
                        participantStreams.Audio.stream.dispatchEvent(new Event('removetrack'));
                        if (participantStreams.Participant.IsRemote) {
                            delete participantStreams.SourceToStreamMap[track.id];
                        }
                        break;
                    case TrackMetaDataProvider_1.MediaTrackType.Video:
                        participantStreams.Video.stream.removeTrack(track);
                        participantStreams.Video.stream.dispatchEvent(new Event('removetrack'));
                        if (participantStreams.Participant.IsRemote) {
                            delete participantStreams.SourceToStreamMap[track.id];
                        }
                        break;
                    default:
                        console.log('unsupported MediaTrackType');
                        break;
                }
                track.stop();
                delete this._trackMetaData[track.id];
                delete participantStreams.MediaTrackMap[id];
                this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteTrackRemovedSsrc.Scoped(id), id);
            }
        }
        for (let [id] of Object.entries(participantStreams.Application)) {
            if (!currentTracks.includes(id)) {
                let appTrack = participantStreams.Application[id].stream.getVideoTracks()[0];
                participantStreams.Application[id].stream.removeTrack(appTrack);
                participantStreams.Application[id].stream.dispatchEvent(new Event('removetrack'));
                if (participantStreams.Participant.IsRemote) {
                    delete participantStreams.SourceToStreamMap[id];
                }
                delete this._trackMetaData[appTrack.id];
                delete participantStreams.Application[id];
                this._vidyoCore.EventDispatcher.emitAsync(StreamEvents.Events.RemoteTrackRemovedSsrc.Scoped(id), id);
            }
        }
    }
    _createParticipantStreamsData(stream) {
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(stream.id);
        if (!participant) {
            return;
        }
        let participantAudioVideoStream = new MediaStream();
        let participantStreams = {
            Application: {},
            Audio: { stream: new MediaStream() },
            MediaTrackMap: {},
            Participant: participant,
            SourceToStreamMap: {},
            Video: { stream: participantAudioVideoStream }
        };
        this._participantStreamsMap[participantAudioVideoStream.id] = participantAudioVideoStream;
        this._checkAndAddParticipantStreamsDataTrack(participantStreams, stream);
        stream.addEventListener('addtrack', () => {
            this._checkAndAddParticipantStreamsDataTrack(participantStreams, stream);
        }, false, true);
        stream.addEventListener('removetrack', () => {
            let currentTracks = stream.getTracks().map((track) => track.id);
            this._checkAndRemoveParticipantStreamsDataTracks(participantStreams, currentTracks);
        }, false, true);
        this._participantStreamsData[stream.id] = participantStreams;
        this._streamEventHelper.AttachStreamEvents(new ReadOnlyMediaStream_1.ReadOnlyMediaStream(participantAudioVideoStream));
    }
    _onParticipantLeave(participant) {
        let stream = this.TryGetNetworkStream(participant.Id);
        if (stream) {
            this._onRemoteStreamRemoved(stream.GetMediaStream());
        }
    }
    _onRemoteStreamAdded(stream) {
        let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(stream.id);
        if (participant && !this._streams[stream.id]) {
            let readOnlyStream = new ReadOnlyMediaStream_1.ReadOnlyMediaStream(stream);
            this._createParticipantStreamsData(stream);
            this._streams[stream.id] = readOnlyStream;
            this._streamEventHelper.AttachStreamEvents(readOnlyStream);
        }
    }
    _onRemoteStreamRemoved(stream) {
        let readOnlyStream = this._streams[stream.id];
        if (readOnlyStream) {
            readOnlyStream.UnregisterEventListeners();
            if (this._participantStreamsData[stream.id]) {
                delete this._participantStreamsData[stream.id];
            }
            delete this._streams[stream.id];
            this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.StreamListChanged);
        }
    }
    _onRemoteTrackMetaData(data) {
        this._trackMetaData[data.ssrc] = data.type;
    }
    _onRemoteTrackRemoved(data) {
        let stream = this._streams[data.participantId];
        if (stream) {
            this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TracksChanged, data.participantId);
        }
    }
}
exports.RemoteStreamController = RemoteStreamController;

},{"../../events/ConferenceEvents":65,"../../events/ConnectionEvents":66,"../../events/EventDispatcher":68,"../../events/LogEvents":69,"../../events/ParticipantEvents":73,"../../events/StreamEvents":79,"../../models/stream/ReadOnlyMediaStream":133,"../../utils/Messages":150,"../../utils/StringUtils":164,"../BaseController":35,"./StreamEventHelper":58,"./TrackMetaDataProvider":59}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamEventHelper = void 0;
const StreamEvents = require("../../events/StreamEvents");
class StreamEventHelper {
    constructor(_eventDispatcher) {
        this._eventDispatcher = _eventDispatcher;
    }
    AttachStreamEvents(stream) {
        stream.OnTrackAdded(() => this._tracksChanged(stream.Id));
        stream.OnTrackRemoved(() => this._tracksChanged(stream.Id));
        stream.OnTrackEnabledChanged(() => this._streamEnableStateChanged(stream.Id));
        this._eventDispatcher.emit(StreamEvents.Events.StreamListChanged);
    }
    _streamEnableStateChanged(id) {
        this._eventDispatcher.emit(StreamEvents.Events.StreamEnableStateChanged, id);
    }
    _tracksChanged(id) {
        this._eventDispatcher.emit(StreamEvents.Events.TracksChanged, id);
    }
}
exports.StreamEventHelper = StreamEventHelper;

},{"../../events/StreamEvents":79}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaTrackType = exports.UnknownMediaTrackType = void 0;
const Source_1 = require("../../models/Source");
exports.UnknownMediaTrackType = 'unknown';
exports.MediaTrackType = Source_1.SourceMediaType;

},{"../../models/Source":98}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransmittedStreamController = void 0;
const BaseController_1 = require("../BaseController");
const CallStateEvents = require("../../events/CallStateEvents");
const StatisticsEvents = require("../../events/StatisticsEvents");
const ModerationEvents = require("../../events/ModerationEvents");
const StreamEvents = require("../../events/StreamEvents");
const Devices_1 = require("../../../vidyo_simple_api/Devices");
const EventDispatcher_1 = require("../../events/EventDispatcher");
const Constants_1 = require("../../utils/Constants");
const NotEqual_1 = require("../../utils/NotEqual");
const VideoResolution_1 = require("../../models/VideoResolution");
const TrackMetaDataProvider_1 = require("./TrackMetaDataProvider");
const ObjectUtils_1 = require("../../utils/ObjectUtils");
class TransmittedStreamController extends BaseController_1.BaseController {
    constructor() {
        super(...arguments);
        this.DEFAULT_MAX_RECEIVE_BANDWIDTH = 10000000;
        this.ENCODER_UPDATE_INTERVAL = 20000;
        this._encoderUpdateTimeout = {};
        this._inCall = false;
        this._showReceived = false;
        this._ssrcActiveMap = {};
        this._tracksSrrcsMap = {};
        this._tracksShowParameterMap = {};
        this._maxReceiveBandwidth = this.DEFAULT_MAX_RECEIVE_BANDWIDTH;
        this._ssrcConferenceShowHisteresticMap = {};
        this._videoRids = [];
    }
    get InCall() {
        return this._inCall;
    }
    get MaxReceiveBandwidth() {
        return this._maxReceiveBandwidth;
    }
    set MaxReceiveBandwidth(bitRate) {
        if (!bitRate || bitRate < 0) {
            this._maxReceiveBandwidth = this.DEFAULT_MAX_RECEIVE_BANDWIDTH;
        }
        else {
            this._maxReceiveBandwidth = bitRate;
        }
        this._vidyoCore.HunterProvider.UpdateConnection();
    }
    get VideoRids() {
        return this._videoRids;
    }
    set VideoRids(videoRids) {
        this._videoRids = videoRids;
    }
    GetLocalTrackId(ssrc) {
        return this._tracksSrrcsMap[ssrc];
    }
    GetTracksSSRCs() {
        return { ...this._tracksSrrcsMap };
    }
    Initialize() {
        let stream = this._vidyoCore.Controllers.LocalStreamController.GetTransmittedStream();
        stream.addEventListener('addtrack', () => this._updateStreamTracks(stream), false, true);
        stream.addEventListener('removetrack', () => this._updateStreamTracks(stream), false, true);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.TransmittedStreamControllerListeners);
        this._vidyoCore.EventDispatcher.on(CallStateEvents.Events.MediaStateTransition, EventDispatcher_1.TransmittedStreamControllerListeners, (state) => this._mediaStateTransition(state, stream));
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.ConferenceModeChanged, EventDispatcher_1.TransmittedStreamControllerListeners, () => this._onConferenceModeChanged());
        this._vidyoCore.EventDispatcher.on(StatisticsEvents.Events.CodecChanged, EventDispatcher_1.TransmittedStreamControllerListeners, (payload) => this._updateEncoderWithHysteresisConferenceShow(payload.ssrc));
        return super.Initialize();
    }
    IsSourceEnabled(trackId) {
        if (this._vidyoCore.Controllers.ModerationController.IsLobbyEnabled) {
            return false;
        }
        let trackSsrc;
        for (const ssrc in this._tracksSrrcsMap) {
            if (this._tracksSrrcsMap[ssrc] === trackId) {
                trackSsrc = ssrc;
                break;
            }
        }
        return this._ssrcActiveMap[trackSsrc] ?? true;
    }
    SetLocalSource(sourceView) {
        const trackId = this._tracksSrrcsMap[sourceView.id];
        const trackType = this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaType(trackId);
        if (trackId) {
            if (sourceView.enable === false) {
                this._ssrcConferenceShowHisteresticMap[sourceView.id] = [sourceView];
                this._vidyoCore.Controllers.LogController.LogDebug(() => `Shutting down ${sourceView.id}, update encoder immediately`);
                if (trackType == TrackMetaDataProvider_1.MediaTrackType.Video) {
                    this._vidyoCore.Controllers.LocalStreamController.aobRampUp = false;
                }
                this._updateEncoderWithHysteresisConferenceShow(sourceView.id);
            }
            else if (!this._ssrcConferenceShowHisteresticMap[sourceView.id]) {
                this._ssrcConferenceShowHisteresticMap[sourceView.id] = [sourceView];
                this._vidyoCore.Controllers.LogController.LogDebug(() => `First ${sourceView.id} rxsrc received in awhile, update encoder immediately`);
                if (trackType == TrackMetaDataProvider_1.MediaTrackType.Video) {
                    this._vidyoCore.Controllers.LocalStreamController.aobRampUp = true;
                }
                this._updateEncoderWithHysteresisConferenceShow(sourceView.id);
            }
            else {
                this._ssrcConferenceShowHisteresticMap[sourceView.id].push(sourceView);
            }
            this._tracksShowParameterMap[trackId] = sourceView;
            if (TrackMetaDataProvider_1.MediaTrackType.Video === trackType) {
                this._vidyoCore.Controllers.LocalStreamController.SetCameraBWRestrictionState(sourceView.enable);
            }
        }
    }
    _updateEncoderWithHysteresisConferenceShow(ssrc) {
        const trackId = this._tracksSrrcsMap[ssrc];
        if (!trackId) {
            delete this._ssrcConferenceShowHisteresticMap[ssrc];
            if (this._encoderUpdateTimeout[ssrc]) {
                clearTimeout(this._encoderUpdateTimeout[ssrc]);
                delete this._encoderUpdateTimeout[ssrc];
            }
            return;
        }
        const trackMediaType = this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaType(trackId);
        if (!this._ssrcConferenceShowHisteresticMap[ssrc]) {
            this._vidyoCore.Controllers.LogController.LogDebug(() => `Called to update encoder, however ${ssrc} has not been setup or removed`);
            if (this._encoderUpdateTimeout[ssrc]) {
                clearTimeout(this._encoderUpdateTimeout[ssrc]);
                delete this._encoderUpdateTimeout[ssrc];
            }
            return;
        }
        let sourceView;
        if (this._ssrcConferenceShowHisteresticMap[ssrc].length == 0) {
            this._vidyoCore.Controllers.LogController.LogDebug(() => `Called to update encoder, and there has been no updates. Next rxsrc for ${ssrc} will be processed immediately`);
            delete this._ssrcConferenceShowHisteresticMap[ssrc];
            if (trackMediaType == TrackMetaDataProvider_1.MediaTrackType.Audio) {
                return;
            }
            sourceView = this._tracksShowParameterMap[trackId];
        }
        else if (this._ssrcConferenceShowHisteresticMap[ssrc].length == 1) {
            sourceView = this._ssrcConferenceShowHisteresticMap[ssrc][0];
        }
        else {
            sourceView = this._ssrcConferenceShowHisteresticMap[ssrc].reduce((sum, cur) => {
                sum.id = cur.id;
                sum.enable = cur.enable;
                sum.params.width = cur.params.width;
                sum.params.height = cur.params.height;
                sum.params.bandwidth = (+sum.params.bandwidth + +cur.params.bandwidth).toString();
                sum.params.minBandwidth = (+sum.params.minBandwidth + +cur.params.minBandwidth).toString();
                return sum;
            });
            sourceView.params.bandwidth = ((+sourceView.params.bandwidth) / this._ssrcConferenceShowHisteresticMap[ssrc].length).toString();
            sourceView.params.minBandwidth = ((+sourceView.params.minBandwidth) / this._ssrcConferenceShowHisteresticMap[ssrc].length).toString();
        }
        this._vidyoCore.Controllers.LogController.LogDebug(() => `${ssrc}: ${JSON.stringify(sourceView)}`);
        this._ssrcActiveMap[sourceView.id] = !!sourceView.enable;
        if (this._tracksSrrcsMap[sourceView.id]) {
            const trackId = this._tracksSrrcsMap[sourceView.id];
            const trackMediaType = this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaType(trackId);
            const trackMediaProperties = this._vidyoCore.Controllers.LocalStreamController.GetTrackMediaProperties(trackId);
            this._showReceived = trackMediaType !== TrackMetaDataProvider_1.MediaTrackType.Audio;
            if (trackMediaProperties.signalType === Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed) {
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.UnprocessedAudioStateUpdated, {
                    enabled: !!sourceView.enable && !trackMediaProperties.muted
                });
            }
            if ((this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast && trackMediaType === TrackMetaDataProvider_1.MediaTrackType.Video)
                || (this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast && trackMediaType === TrackMetaDataProvider_1.MediaTrackType.Application)) {
                this._vidyoCore.Controllers.LocalStreamController.UpdateSimulcastRunnels(sourceView, trackId);
            }
            else {
                let result = this._detectAboveThresholdCondition(sourceView);
                if (result.isBandwidthAboveThreshold) {
                    this._vidyoCore.Controllers.LocalStreamController.UpdateTrackBandwidth(result.bandwidth, trackId);
                }
                if (trackMediaType === TrackMetaDataProvider_1.MediaTrackType.Video && result.isVideoConstraintsAboveThreshold) {
                    this._vidyoCore.Controllers.LocalStreamController.UpdateTrackConstraints(result.videoStreamConstraints, trackId);
                }
            }
            this._vidyoCore.HunterProvider.UpdateMediaStates();
        }
        if (sourceView.enable) {
            this._ssrcConferenceShowHisteresticMap[ssrc] = [];
            if (trackMediaType != TrackMetaDataProvider_1.MediaTrackType.Audio) {
                if (this._encoderUpdateTimeout[ssrc]) {
                    clearTimeout(this._encoderUpdateTimeout[ssrc]);
                }
                this._encoderUpdateTimeout[ssrc] = setTimeout(() => this._updateEncoderWithHysteresisConferenceShow(ssrc), this.ENCODER_UPDATE_INTERVAL);
            }
        }
        else {
            delete this._ssrcConferenceShowHisteresticMap[ssrc];
        }
    }
    GetLocalSourceRequestedShowParameters(id) {
        if (this._tracksShowParameterMap[id]) {
            return {
                bandwidth: parseInt(this._tracksShowParameterMap[id].params?.minBandwidth) || 0,
                width: parseInt(this._tracksShowParameterMap[id].params?.width) || 0,
                height: parseInt(this._tracksShowParameterMap[id].params?.height) || 0,
                framerate: parseInt(this._tracksShowParameterMap[id].params?.framerate) || 0
            };
        }
        return {
            bandwidth: 0,
            width: 0,
            height: 0,
            framerate: 0
        };
    }
    UpdateTracksSrrcs(tracksSrrcsMap) {
        const needFireUpdateEvent = !ObjectUtils_1.default.IsObjectsEqual(this._tracksSrrcsMap, tracksSrrcsMap);
        this._tracksSrrcsMap = tracksSrrcsMap;
        const currentTracks = Object.keys(this._tracksSrrcsMap);
        currentTracks.forEach((ssrc) => {
            if (!this._ssrcActiveMap.hasOwnProperty(ssrc)) {
                this._ssrcActiveMap[ssrc] = false;
            }
        });
        if (needFireUpdateEvent) {
            this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TransmittedStreamTracksSsrcUpdated);
        }
    }
    _detectAboveThresholdCondition(payload) {
        let result = {
            bandwidth: 0,
            isBandwidthAboveThreshold: false,
            isVideoConstraintsAboveThreshold: false,
            videoStreamConstraints: {}
        };
        const streamConstraints = this._vidyoCore.Controllers
            .LocalStreamController.GetLocalStreamConstraintsByTrackId(this._tracksSrrcsMap[payload.id]);
        if (streamConstraints) {
            if (payload.params && streamConstraints) {
                const baseTen = 10;
                const currentBandwidth = this._vidyoCore.Controllers
                    .LocalStreamController.GetLocalStreamBandwidthByTrackId(this._tracksSrrcsMap[payload.id]);
                if (payload.params.bandwidth) {
                    let bandwidth = parseInt(payload.params.bandwidth + '', baseTen);
                    let minBandwidth = payload.params.minBandwidth ? parseInt(payload.params.minBandwidth + '', baseTen) : bandwidth;
                    let newBandwidth = Math.min(bandwidth, minBandwidth);
                    if (!currentBandwidth || (0, NotEqual_1.NotEqual)(currentBandwidth, newBandwidth, Constants_1.Threshold)) {
                        this._vidyoCore.Controllers.LogController.LogDebug(() => '~~~~~~~~~~~~~~~~ adjusting encoder bitrate: requested=' + bandwidth + '; requestedMin=' + minBandwidth +
                            '; CALCULATED NEW=' + newBandwidth +
                            (currentBandwidth > 0 ? '; prev=' + currentBandwidth : ''));
                        result.isBandwidthAboveThreshold = true;
                        result.bandwidth = newBandwidth;
                    }
                }
                const codec = this._vidyoCore.Controllers.StatisticsController.GetLocalCameraCodecName();
                const width = this._vidyoCore.Controllers
                    .LocalStreamController.GetLocalStreamConstraintsByTrackId(this._tracksSrrcsMap[payload.id]).width;
                const height = this._vidyoCore.Controllers
                    .LocalStreamController.GetLocalStreamConstraintsByTrackId(this._tracksSrrcsMap[payload.id]).height;
                const aspectRatio = width / height;
                if (result.isBandwidthAboveThreshold && codec && VideoResolution_1.BandwidthPreferred[codec].length > 0) {
                    let BandwidthPreferredKeepAspectRatio = VideoResolution_1.BandwidthPreferred[codec].filter((constraint) => (constraint.Width / constraint.Height) == aspectRatio);
                    result.isVideoConstraintsAboveThreshold = true;
                    result.videoStreamConstraints.height = BandwidthPreferredKeepAspectRatio[0].Height;
                    result.videoStreamConstraints.width = BandwidthPreferredKeepAspectRatio[0].Width;
                    let constraintsByBandwidth = BandwidthPreferredKeepAspectRatio.filter((constraint) => (constraint.Bandwidth <= result.bandwidth)
                        && (constraint.Width <= Constants_1.DefaultLocalStreamWidth)
                        && (constraint.Height <= Constants_1.DefaultLocalStreamHeight));
                    if (constraintsByBandwidth.length > 0) {
                        let preferredConstraint = constraintsByBandwidth[constraintsByBandwidth.length - 1];
                        const payloadWidth = parseInt(payload.params.width, baseTen);
                        const payloadHeight = parseInt(payload.params.height, baseTen);
                        const maxResolutionNormalized = (0, VideoResolution_1.NormalizeResolution)(payloadWidth, payloadHeight, aspectRatio);
                        if (maxResolutionNormalized.height > preferredConstraint.Height) {
                            result.videoStreamConstraints.height = preferredConstraint.Height;
                            result.videoStreamConstraints.width = preferredConstraint.Width;
                        }
                        else {
                            let constraintsByResolution = constraintsByBandwidth.filter((constraint) => constraint.Height <= maxResolutionNormalized.height);
                            if (constraintsByResolution.length > 0) {
                                result.videoStreamConstraints.height = constraintsByResolution[constraintsByResolution.length - 1].Height;
                                result.videoStreamConstraints.width = constraintsByResolution[constraintsByResolution.length - 1].Width;
                            }
                        }
                    }
                    this._vidyoCore.Controllers.LogController.LogDebug(() => `given bandwidth ${result.bandwidth} and max resolution ${payload.params.width}x${payload.params.height},
           select ${result.videoStreamConstraints.width}x${result.videoStreamConstraints.height}}`);
                }
            }
        }
        return result;
    }
    _mediaStateTransition(state, stream) {
        if (state.ShouldTransmitMedia) {
            this._inCall = true;
            this._vidyoCore.HunterProvider.UpdateStreamTracks(stream).then(() => {
                this._vidyoCore.HunterProvider.UpdateMediaStates();
            });
        }
        else {
            if (this._inCall) {
                this._vidyoCore.Controllers.ConnectionController.RemoveStream(stream);
                this._vidyoCore.Controllers.LocalStreamController.SetCameraBWRestrictionState(false);
                Object.keys(this._encoderUpdateTimeout).forEach((ssrc) => {
                    clearTimeout(this._encoderUpdateTimeout[ssrc]);
                    delete this._encoderUpdateTimeout[ssrc];
                });
                this._inCall = false;
            }
        }
    }
    _onConferenceModeChanged() {
        this._vidyoCore.HunterProvider.UpdateMediaStates();
    }
    _updateStreamTracks(stream) {
        if (this._inCall) {
            this._vidyoCore.HunterProvider.UpdateStreamTracks(stream).then(() => {
                this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TransmittedStreamTracksUpdated);
                this._vidyoCore.HunterProvider.UpdateMediaStates();
            });
        }
        else {
            this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.TransmittedStreamTracksUpdated);
        }
    }
}
exports.TransmittedStreamController = TransmittedStreamController;

},{"../../../vidyo_simple_api/Devices":184,"../../events/CallStateEvents":64,"../../events/EventDispatcher":68,"../../events/ModerationEvents":72,"../../events/StatisticsEvents":78,"../../events/StreamEvents":79,"../../models/VideoResolution":100,"../../utils/Constants":138,"../../utils/NotEqual":151,"../../utils/ObjectUtils":153,"../BaseController":35,"./TrackMetaDataProvider":59}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserController = void 0;
const User_1 = require("../models/User");
const BaseController_1 = require("./BaseController");
class UserController extends BaseController_1.BaseController {
    constructor(vidyoCore) {
        super(vidyoCore);
        this._coreUser = new User_1.User();
    }
    Disable() {
        return super.Disable();
    }
    Initialize() {
        return super.Initialize();
    }
    SetUserDisplayName(displayName) {
        this._coreUser.DisplayName = displayName;
    }
    UserDisplayName() {
        return this._coreUser.DisplayName;
    }
}
exports.UserController = UserController;

},{"../models/User":99,"./BaseController":35}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.DisableAudioEnergyMonitorChanged = new EventListFactory_1.EventDescriptor();
        this.DisableDynamicAudioSourcesChanged = new EventListFactory_1.EventDescriptor();
        this.DisableStatsChanged = new EventListFactory_1.EventDescriptor();
        this.DynamicAudioSourcesChanged = new EventListFactory_1.EventDescriptor();
        this.EnableAudioOnlyModeChanged = new EventListFactory_1.EventDescriptor();
        this.EnableAutoReconnectChanged = new EventListFactory_1.EventDescriptor();
        this.EnableFixedEncoderBitRateChanged = new EventListFactory_1.EventDescriptor();
        this.EnableCompositorFixedParticipantsChanged = new EventListFactory_1.EventDescriptor();
        this.EnableFixedSimulcastRunnelsChanged = new EventListFactory_1.EventDescriptor();
        this.EnableScreenShareSimulcastChanged = new EventListFactory_1.EventDescriptor();
        this.EnableSimpleAPILoggingChanged = new EventListFactory_1.EventDescriptor();
        this.EnableTransportCcChanged = new EventListFactory_1.EventDescriptor();
        this.EnableVideoSimulcastChanged = new EventListFactory_1.EventDescriptor();
        this.EnableVidyoConnectorAPILoggingChanged = new EventListFactory_1.EventDescriptor();
        this.ExtDataChanged = new EventListFactory_1.EventDescriptor();
        this.ExtDataTypeChanged = new EventListFactory_1.EventDescriptor();
        this.LogCategoryChanged = new EventListFactory_1.EventDescriptor();
        this.LoggerURLChanged = new EventListFactory_1.EventDescriptor();
        this.MaxReconnectAttemptsChanged = new EventListFactory_1.EventDescriptor();
        this.ParticipantLimitChanged = new EventListFactory_1.EventDescriptor();
        this.PinnedParticipantDisplayCroppedChanged = new EventListFactory_1.EventDescriptor();
        this.OnAnalyticsEventSentChanged = new EventListFactory_1.EventDescriptor();
        this.ReconnectBackoffChanged = new EventListFactory_1.EventDescriptor();
        this.ShowStatisticsOverlayChanged = new EventListFactory_1.EventDescriptor();
        this.StatisticsRefreshIntervalChanged = new EventListFactory_1.EventDescriptor();
        this.CameraContentHintChanged = new EventListFactory_1.EventDescriptor();
        this.WindowShareContentHintChanged = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('AdvancedSettings', EventList);

},{"../utils/EventListFactory":142}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.AnalyticsEventSent = new EventListFactory_1.EventDescriptor();
        this.CreateView = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Analytics', EventList);

},{"../utils/EventListFactory":142}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.MediaStateTransition = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('CallState', EventList);

},{"../utils/EventListFactory":142}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.ActivateRemoteSource = new EventListFactory_1.EventDescriptor();
        this.ActiveSourcesChanged = new EventListFactory_1.EventDescriptor();
        this.ConferenceAccepted = new EventListFactory_1.EventDescriptor();
        this.ConferenceJoined = new EventListFactory_1.EventDescriptor();
        this.ConferenceRejected = new EventListFactory_1.EventDescriptor();
        this.DeactivateRemoteSource = new EventListFactory_1.EventDescriptor();
        this.NotifyParticipant = new EventListFactory_1.EventDescriptor();
        this.NotifyReceiveBandwidth = new EventListFactory_1.EventDescriptor();
        this.NotifySelectedParticipant = new EventListFactory_1.EventDescriptor();
        this.Reply = new EventListFactory_1.EventDescriptor();
        this.SelectedParticipantsChanged = new EventListFactory_1.EventDescriptor();
        this.SelectedParticipantUnavailable = new EventListFactory_1.EventDescriptor();
        this.SourceDetected = new EventListFactory_1.EventDescriptor();
        this.SourceRemoved = new EventListFactory_1.EventDescriptor();
        this.SubscribeTimeout = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Conference', EventList);

},{"../utils/EventListFactory":142}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = exports.ConnectionEventsInfo = exports.VidyoEventInfo = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
const Messages = require("../utils/Messages");
const VidyoConnector_1 = require("../../vidyo_connector_api/VidyoConnector");
class VidyoEventInfo {
    constructor(code, reasonCode, msg, type) {
        this.code = code;
        this.msg = msg;
        this.reasonCode = reasonCode;
        this.type = type ? type : 'info';
    }
}
exports.VidyoEventInfo = VidyoEventInfo;
class ConnectionEventsInfo {
}
exports.ConnectionEventsInfo = ConnectionEventsInfo;
ConnectionEventsInfo.ConferenceFailed = new VidyoEventInfo('ConferenceFailed', VidyoConnector_1.VidyoConnectorFailReason.ConnectionFailed, Messages.ConferenceFailed);
ConnectionEventsInfo.ConnectionLost = new VidyoEventInfo('ConnectionLost', VidyoConnector_1.VidyoConnectorDisconnectReason.ConnectionLost, Messages.ConnectionLost, 'error');
ConnectionEventsInfo.ConnectionTimeout = new VidyoEventInfo('ConnectionTimeout', VidyoConnector_1.VidyoConnectorDisconnectReason.ConnectionTimeout, Messages.ConnectionTimeout, 'error');
ConnectionEventsInfo.Disconnected = new VidyoEventInfo('Disconnected', VidyoConnector_1.VidyoConnectorDisconnectReason.Disconnected, Messages.Disconnected);
ConnectionEventsInfo.Disconnecting = new VidyoEventInfo('Disconnecting', VidyoConnector_1.VidyoConnectorDisconnectReason.Disconnected, Messages.Disconnected);
ConnectionEventsInfo.InvalidToken = new VidyoEventInfo('InvalidToken', VidyoConnector_1.VidyoConnectorFailReason.InvalidToken, Messages.InvalidToken);
ConnectionEventsInfo.MediaSessionAddingStreamError = new VidyoEventInfo('MediaSessionAddingStreamError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.MediaSessionAddingStreamError, 'error');
ConnectionEventsInfo.MediaSessionEnded = new VidyoEventInfo('MediaSessionEnded', VidyoConnector_1.VidyoConnectorDisconnectReason.ConnectionLost, Messages.MediaSessionEnded, 'error');
ConnectionEventsInfo.MediaSessionError = new VidyoEventInfo('MediaSessionError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.MediaSessionError);
ConnectionEventsInfo.MediaSessionTransportError = new VidyoEventInfo('MediaSessionTransportError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.MediaSessionTransportError, 'error');
ConnectionEventsInfo.MiscError = new VidyoEventInfo('MiscError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.MiscError, 'error');
ConnectionEventsInfo.MiscLocalError = new VidyoEventInfo('MiscLocalError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscLocalError, Messages.MiscLocalError, 'error');
ConnectionEventsInfo.MiscRemoteError = new VidyoEventInfo('MiscRemoteError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscRemoteError, Messages.MiscRemoteError, 'error');
ConnectionEventsInfo.NoResponse = new VidyoEventInfo('NoResponse', VidyoConnector_1.VidyoConnectorDisconnectReason.NoResponse, Messages.NoResponse, 'error');
ConnectionEventsInfo.SignallingError = new VidyoEventInfo('SignallingError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.SignallingError, 'error');
ConnectionEventsInfo.SignallingTransportError = new VidyoEventInfo('SignallingTransportError', VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError, Messages.SignallingTransportError, 'error');
ConnectionEventsInfo.Terminated = new VidyoEventInfo('Terminated', VidyoConnector_1.VidyoConnectorDisconnectReason.Terminated, Messages.Terminated, 'error');
ConnectionEventsInfo.InvalidRoom = new VidyoEventInfo('InvalidRoom', VidyoConnector_1.VidyoConnectorFailReason.InvalidResourceId, Messages.ErrorInFindRoomOnServer);
ConnectionEventsInfo.ResourceFull = new VidyoEventInfo('ResourceFull', VidyoConnector_1.VidyoConnectorFailReason.ResourceFull, Messages.ResourceFull);
ConnectionEventsInfo.NoLicenseAvailable = new VidyoEventInfo('NoLicenseAvailable', VidyoConnector_1.VidyoConnectorFailReason.ConnectionFailed, Messages.NoLicenseAvailable);
ConnectionEventsInfo.AllLinesInUse = new VidyoEventInfo('AllLinesInUse', VidyoConnector_1.VidyoConnectorFailReason.AllLinesInUse, Messages.AllLinesInUse);
ConnectionEventsInfo.InvalidUser = new VidyoEventInfo('InvalidUser', VidyoConnector_1.VidyoConnectorFailReason.NotMember, Messages.GuestAccessDisAllowed);
ConnectionEventsInfo.ResourceLocked = new VidyoEventInfo('ResourceLocked', VidyoConnector_1.VidyoConnectorFailReason.RoomLocked, Messages.ResourceLocked);
ConnectionEventsInfo.ResourceDisabled = new VidyoEventInfo('ResourceDisabled', VidyoConnector_1.VidyoConnectorFailReason.RoomDisabled, Messages.ResourceDisabled);
ConnectionEventsInfo.InvalidDisplayName = new VidyoEventInfo('InvalidDisplayName', VidyoConnector_1.VidyoConnectorFailReason.InvalidDisplayNameLength, Messages.InvalidDisplayName);
ConnectionEventsInfo.Booted = new VidyoEventInfo('Booted', VidyoConnector_1.VidyoConnectorDisconnectReason.Booted, Messages.Booted, 'error');
ConnectionEventsInfo.ConferenceDestroyed = new VidyoEventInfo('ConferenceDestroyed', VidyoConnector_1.VidyoConnectorDisconnectReason.ConferenceDestroyed, Messages.ConferenceDestroyed, 'error');
ConnectionEventsInfo.ServerShuttingDown = new VidyoEventInfo('ServerShuttingDown', VidyoConnector_1.VidyoConnectorDisconnectReason.ServerShuttingDown, Messages.ServerShuttingDown, 'error');
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.AuthenticationError = new EventListFactory_1.EventDescriptor();
        this.Available = new EventListFactory_1.EventDescriptor();
        this.ConferenceFailed = new EventListFactory_1.EventDescriptor();
        this.ConferenceLost = new EventListFactory_1.EventDescriptor();
        this.Connected = new EventListFactory_1.EventDescriptor();
        this.ConnectionStatusChanged = new EventListFactory_1.EventDescriptor();
        this.Disconnected = new EventListFactory_1.EventDescriptor();
        this.Disconnecting = new EventListFactory_1.EventDescriptor();
        this.JingleAccepted = new EventListFactory_1.EventDescriptor();
        this.JingleRemoteStreamAdded = new EventListFactory_1.EventDescriptor();
        this.JingleRemoteStreamRemoved = new EventListFactory_1.EventDescriptor();
        this.JingleSourceView = new EventListFactory_1.EventDescriptor();
        this.MediaConf = new EventListFactory_1.EventDescriptor();
        this.MediaSessionEnded = new EventListFactory_1.EventDescriptor();
        this.MediaSessionFailed = new EventListFactory_1.EventDescriptor();
        this.MediaSessionStarted = new EventListFactory_1.EventDescriptor();
        this.Reconnected = new EventListFactory_1.EventDescriptor();
        this.Reconnecting = new EventListFactory_1.EventDescriptor();
        this.SignallingDisconnected = new EventListFactory_1.EventDescriptor();
        this.SignallingError = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Connection', EventList);

},{"../../vidyo_connector_api/VidyoConnector":181,"../utils/EventListFactory":142,"../utils/Messages":150}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.AudioContentDeviceChanged = new EventListFactory_1.EventDescriptor();
        this.CameraAdded = new EventListFactory_1.EventDescriptor();
        this.CameraConstraintChanged = new EventListFactory_1.EventDescriptor();
        this.CameraRemoved = new EventListFactory_1.EventDescriptor();
        this.CameraSelected = new EventListFactory_1.EventDescriptor();
        this.CameraSettingsChanged = new EventListFactory_1.EventDescriptor();
        this.CameraStateUpdated = new EventListFactory_1.EventDescriptor();
        this.CameraUnplugged = new EventListFactory_1.EventDescriptor();
        this.MicrophoneAdded = new EventListFactory_1.EventDescriptor();
        this.MicrophoneChanged = new EventListFactory_1.EventDescriptor();
        this.MicrophoneMuteStateChanged = new EventListFactory_1.EventDescriptor();
        this.MicrophoneRemoved = new EventListFactory_1.EventDescriptor();
        this.MicrophoneSelected = new EventListFactory_1.EventDescriptor();
        this.MicrophoneStateUpdated = new EventListFactory_1.EventDescriptor();
        this.MicrophoneUnplugged = new EventListFactory_1.EventDescriptor();
        this.SpeakerAdded = new EventListFactory_1.EventDescriptor();
        this.SpeakerRemoved = new EventListFactory_1.EventDescriptor();
        this.SpeakerSelected = new EventListFactory_1.EventDescriptor();
        this.SpeakerSettingsChanged = new EventListFactory_1.EventDescriptor();
        this.SpeakerStateUpdated = new EventListFactory_1.EventDescriptor();
        this.SpeakerUnplugged = new EventListFactory_1.EventDescriptor();
        this.CameraListChanged = new EventListFactory_1.EventDescriptor();
        this.CameraListRemoved = new EventListFactory_1.EventDescriptor();
        this.RemoteSpeakerAdded = new EventListFactory_1.EventDescriptor();
        this.RemoteSpeakerRemoved = new EventListFactory_1.EventDescriptor();
        this.RemoteSpeakerStateUpdated = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Device', EventList);

},{"../utils/EventListFactory":142}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoRoomUnprocessedAudioEventListeners = exports.VidyoRoomRecorderInCallEventListeners = exports.VidyoRoomParticipantEventListeners = exports.VidyoResourceManagerEventListeners = exports.VidyoRemoteWindowShareEventListeners = exports.VidyoRemoteMicrophoneEventListeners = exports.VidyoRemoteCameraEventListeners = exports.VidyoReconnectEventListeners = exports.VidyoRaiseHandEventListeners = exports.VidyoPermissionEventListeners = exports.VidyoLocalWindowShareEventListeners = exports.VidyoRemoteSpeakerEventListeners = exports.VidyoLocalSpeakerEventListeners = exports.VidyoLocalMonitorEventListeners = exports.VidyoLocalMicrophoneEventListeners = exports.VidyoModerationEventListeners = exports.VidyoLectureModeEventListeners = exports.VidyoConferenceModeEventListeners = exports.VidyoMessageEventListeners = exports.VidyoLocalCameraEventListeners = exports.VidyoEnterRoomListeners = exports.VidyoEndpointListeners = exports.VidyoEnableMediaRoomListeners = exports.VidyoCustomLoggingEventListeners = exports.VidyoAdvancedSettingsEventListeners = exports.ResourceManagerEventListeners = exports.TransmittedStreamControllerListeners = exports.RoomControllerListeners = exports.RemoteStreamControllerListeners = exports.StreamControllerListeners = exports.StatisticsControllerListeners = exports.SmoothStartModeListeners = exports.ResourceControllerListeners = exports.RendererControllerListeners = exports.CompositeRenderListeners = exports.CustomRenderListeners = exports.RenderListeners = exports.PermissionControllerListeners = exports.ParticipantControllerListeners = exports.MessageControllerListeners = exports.ModerationControllerListeners = exports.MicrophoneEnergyLevelStreamListeners = exports.MicrophoneEnergyLevelControllerListeners = exports.LocalStreamControllerListeners = exports.DeviceControllerListeners = exports.ConnectionControllerListeners = exports.ConferenceControllerListeners = exports.CallStateControllerListeners = exports.GoogleAnalyticsListeners = exports.AdvancedSettingsListeners = void 0;
exports.ReleaseAllEventListeners = exports.CreateEventDispatcher = exports.VidyoUserListeners = exports.VidyoRenderVideoTileEventListener = void 0;
const WildEmitter = require("wildemitter");
exports.AdvancedSettingsListeners = 'AdvancedSettingsListeners';
exports.GoogleAnalyticsListeners = 'GoogleAnalyticsListeners';
exports.CallStateControllerListeners = 'CallStateControllerListeners';
exports.ConferenceControllerListeners = 'ConferenceControllerListeners';
exports.ConnectionControllerListeners = 'ConnectionControllerListeners';
exports.DeviceControllerListeners = 'DeviceControllerListeners';
exports.LocalStreamControllerListeners = 'LocalStreamControllerListeners';
exports.MicrophoneEnergyLevelControllerListeners = 'MicrophoneEnergyLevelControllerListeners';
exports.MicrophoneEnergyLevelStreamListeners = 'MicrophoneEnergyLevelStreamListeners';
exports.ModerationControllerListeners = 'ModerationControllerListeners';
exports.MessageControllerListeners = 'MessageControllerListeners';
exports.ParticipantControllerListeners = 'ParticipantControllerListeners';
exports.PermissionControllerListeners = 'PermissionControllerListeners';
exports.RenderListeners = 'RenderListeners';
exports.CustomRenderListeners = 'CustomRenderListeners';
exports.CompositeRenderListeners = 'CompositeRenderListeners';
exports.RendererControllerListeners = 'RendererControllerListeners';
exports.ResourceControllerListeners = 'ResourceControllerListeners';
exports.SmoothStartModeListeners = 'SmoothStartModeListeners';
exports.StatisticsControllerListeners = 'StatisticsControllerListeners';
exports.StreamControllerListeners = 'StreamControllerListeners';
exports.RemoteStreamControllerListeners = 'RemoteStreamControllerListeners';
exports.RoomControllerListeners = 'RoomControllerListeners';
exports.TransmittedStreamControllerListeners = 'TransmittedStreamControllerListeners';
exports.ResourceManagerEventListeners = 'ResourceManagerEventListeners';
exports.VidyoAdvancedSettingsEventListeners = 'VidyoAdvancedSettingsEventListeners';
exports.VidyoCustomLoggingEventListeners = 'VidyoCustomLoggingEventListeners';
exports.VidyoEnableMediaRoomListeners = 'VidyoEnableMediaRoomListeners';
exports.VidyoEndpointListeners = 'VidyoEndpointListeners';
exports.VidyoEnterRoomListeners = 'VidyoEnterRoomListeners';
exports.VidyoLocalCameraEventListeners = 'VidyoLocalCameraEventListeners';
exports.VidyoMessageEventListeners = 'VidyoMessageEventListeners';
exports.VidyoConferenceModeEventListeners = 'VidyoConferenceModeEventListeners';
exports.VidyoLectureModeEventListeners = 'VidyoLectureModeEventListeners';
exports.VidyoModerationEventListeners = 'VidyoModerationEventListeners';
exports.VidyoLocalMicrophoneEventListeners = 'VidyoLocalMicrophoneEventListeners';
exports.VidyoLocalMonitorEventListeners = 'VidyoLocalMonitorEventListeners';
exports.VidyoLocalSpeakerEventListeners = 'VidyoLocalSpeakerEventListeners';
exports.VidyoRemoteSpeakerEventListeners = 'VidyoRemoteSpeakerEventListeners';
exports.VidyoLocalWindowShareEventListeners = 'VidyoLocalWindowShareEventListeners';
exports.VidyoPermissionEventListeners = 'VidyoPermissionEventListeners';
exports.VidyoRaiseHandEventListeners = 'VidyoRaiseHandEventListeners';
exports.VidyoReconnectEventListeners = 'VidyoReconnectEventListeners';
exports.VidyoRemoteCameraEventListeners = 'VidyoRemoteCameraEventListeners';
exports.VidyoRemoteMicrophoneEventListeners = 'VidyoRemoteMicrophoneEventListeners';
exports.VidyoRemoteWindowShareEventListeners = 'VidyoRemoteWindowShareEventListeners';
exports.VidyoResourceManagerEventListeners = 'VidyoResourceManagerEventListeners';
exports.VidyoRoomParticipantEventListeners = 'VidyoRoomParticipantEventListeners';
exports.VidyoRoomRecorderInCallEventListeners = 'VidyoRoomRecorderInCallEventListeners';
exports.VidyoRoomUnprocessedAudioEventListeners = 'VidyoRoomUnprocessedAudioEventListeners';
exports.VidyoRenderVideoTileEventListener = 'VidyoRenderVideoTileEventListener';
exports.VidyoUserListeners = 'VidyoUserListeners';
function CreateEventDispatcher() {
    let dispatcher = {};
    WildEmitter.mixin(dispatcher);
    dispatcher.releaseAll = () => {
        dispatcher.callbacks = dispatcher.callbacks || {};
        for (let item in dispatcher.callbacks) {
            if (!dispatcher.callbacks.hasOwnProperty(item)) {
                continue;
            }
            let handlers = dispatcher.callbacks[item];
            for (let i = handlers.length; i > 0; i--) {
                handlers.pop();
            }
            delete dispatcher.callbacks[item];
        }
        return this;
    };
    dispatcher.getGroupCallbacks = (groupName) => {
        let groupCallbacks = [];
        dispatcher.callbacks = dispatcher.callbacks || {};
        for (let item in dispatcher.callbacks) {
            if (!dispatcher.callbacks.hasOwnProperty(item)) {
                continue;
            }
            let handlers = dispatcher.callbacks[item];
            for (let i = handlers.length - 1; i >= 0; i--) {
                if (handlers[i]['_groupName'] === groupName) {
                    groupCallbacks.push(handlers[i]);
                }
            }
        }
        return groupCallbacks;
    };
    dispatcher.emitAsync = (event, payload) => {
        const ZERO_TIMEOUT = 0;
        setTimeout(() => {
            dispatcher.emit(event, payload);
        }, ZERO_TIMEOUT);
        return dispatcher;
    };
    return dispatcher;
}
exports.CreateEventDispatcher = CreateEventDispatcher;
function ReleaseAllEventListeners(wildEmitter) {
    let callbacks = wildEmitter.callbacks || {};
    for (let item in callbacks) {
        if (!callbacks.hasOwnProperty(item)) {
            continue;
        }
        let handlers = callbacks[item];
        for (let i = handlers.length; i > 0; i--) {
            handlers.pop();
        }
        delete callbacks[item];
    }
}
exports.ReleaseAllEventListeners = ReleaseAllEventListeners;

},{"wildemitter":29}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogEventDebug = exports.LogEventApp = exports.LogEventsSDK = exports.LogEventListSDK = exports.VidyoLogLevel = exports.VidyoLogCategory = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
var VidyoLogCategory;
(function (VidyoLogCategory) {
    VidyoLogCategory["VidyoApplication"] = "VidyoApplication";
    VidyoLogCategory["VidyoConnector"] = "VidyoConnector";
    VidyoLogCategory["VidyoClient"] = "VidyoClient";
    VidyoLogCategory["VidyoDevelopment"] = "VidyoDevelopment";
    VidyoLogCategory["VidyoResourceManager"] = "VidyoResourceManager";
    VidyoLogCategory["VidyoSDP"] = "VidyoSDP";
    VidyoLogCategory["VidyoSignaling"] = "VidyoSignaling";
    VidyoLogCategory["VidyoTransport"] = "VidyoTransport";
})(VidyoLogCategory = exports.VidyoLogCategory || (exports.VidyoLogCategory = {}));
var VidyoLogLevel;
(function (VidyoLogLevel) {
    VidyoLogLevel[VidyoLogLevel["fatal"] = 1] = "fatal";
    VidyoLogLevel[VidyoLogLevel["error"] = 2] = "error";
    VidyoLogLevel[VidyoLogLevel["warning"] = 4] = "warning";
    VidyoLogLevel[VidyoLogLevel["info"] = 8] = "info";
    VidyoLogLevel[VidyoLogLevel["debug"] = 16] = "debug";
    VidyoLogLevel[VidyoLogLevel["sent"] = 32] = "sent";
    VidyoLogLevel[VidyoLogLevel["received"] = 64] = "received";
    VidyoLogLevel[VidyoLogLevel["enter"] = 128] = "enter";
    VidyoLogLevel[VidyoLogLevel["leave"] = 256] = "leave";
})(VidyoLogLevel = exports.VidyoLogLevel || (exports.VidyoLogLevel = {}));
class LogEventListSDK extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.fatal = new EventListFactory_1.EventDescriptor();
        this.error = new EventListFactory_1.EventDescriptor();
        this.warning = new EventListFactory_1.EventDescriptor();
        this.info = new EventListFactory_1.EventDescriptor();
        this.debug = new EventListFactory_1.EventDescriptor();
        this.sent = new EventListFactory_1.EventDescriptor();
        this.received = new EventListFactory_1.EventDescriptor();
        this.enter = new EventListFactory_1.EventDescriptor();
        this.leave = new EventListFactory_1.EventDescriptor();
    }
}
exports.LogEventListSDK = LogEventListSDK;
exports.LogEventsSDK = (0, EventListFactory_1.CreateEventList)('LogSDK', LogEventListSDK);
exports.LogEventApp = new EventListFactory_1.EventDescriptor('LogApp');
exports.LogEventDebug = new EventListFactory_1.EventDescriptor('LogDebug');

},{"../utils/EventListFactory":142}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.MessageChatState = new EventListFactory_1.EventDescriptor();
        this.MessageRead = new EventListFactory_1.EventDescriptor();
        this.MessageReceived = new EventListFactory_1.EventDescriptor();
        this.OnMessage = new EventListFactory_1.EventDescriptor();
        this.OnMessageAcknowledged = new EventListFactory_1.EventDescriptor();
        this.OnMessageChatState = new EventListFactory_1.EventDescriptor();
        this.OnMessageRead = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Message', EventList);

},{"../utils/EventListFactory":142}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.MicrophoneEnergyLevelUpdate = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('MicrophoneEnergy', EventList);

},{"../utils/EventListFactory":142}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = exports.EventServerModerationMessage = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
var EventServerModerationMessage;
(function (EventServerModerationMessage) {
    EventServerModerationMessage["ModerationCameraSoftMute"] = "ModerationCameraSoftMute";
    EventServerModerationMessage["ModerationMicrophoneSoftMute"] = "ModerationMicrophoneSoftMute";
    EventServerModerationMessage["ModerationCameraHardMute"] = "ModerationCameraHardMute";
    EventServerModerationMessage["ModerationMicrophoneHardMute"] = "ModerationMicrophoneHardMute";
    EventServerModerationMessage["ModerationCameraHardUnmute"] = "ModerationCameraHardUnmute";
    EventServerModerationMessage["ModerationMicrophoneHardUnmute"] = "ModerationMicrophoneHardUnmute";
})(EventServerModerationMessage = exports.EventServerModerationMessage || (exports.EventServerModerationMessage = {}));
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.EventServerConnected = new EventListFactory_1.EventDescriptor();
        this.EventServerError = new EventListFactory_1.EventDescriptor();
        this.EventServerModerationCommand = new EventListFactory_1.EventDescriptor();
        this.EndpointStateUpdate = new EventListFactory_1.EventDescriptor();
        this.LectureStatusUpdate = new EventListFactory_1.EventDescriptor();
        this.UserStatusUpdate = new EventListFactory_1.EventDescriptor();
        this.LocalSharePermissionChanged = new EventListFactory_1.EventDescriptor();
        this.OnModerationCommandReceived = new EventListFactory_1.EventDescriptor();
        this.ConferenceModeChanged = new EventListFactory_1.EventDescriptor();
        this.PresenterChanged = new EventListFactory_1.EventDescriptor();
        this.HandRaised = new EventListFactory_1.EventDescriptor();
        this.RaiseHandResponse = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Moderation', EventList);

},{"../utils/EventListFactory":142}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.DynamicParticipantChanged = new EventListFactory_1.EventDescriptor();
        this.LoudestParticipantChanged = new EventListFactory_1.EventDescriptor();
        this.ParticipantAddedOrUpdated = new EventListFactory_1.EventDescriptor();
        this.ParticipantJoined = new EventListFactory_1.EventDescriptor();
        this.ParticipantLeft = new EventListFactory_1.EventDescriptor();
        this.ParticipantRemoved = new EventListFactory_1.EventDescriptor();
        this.ParticipantsChanged = new EventListFactory_1.EventDescriptor();
        this.RecorderInCallChanged = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Participant', EventList);

},{"../utils/EventListFactory":142}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.PermissionListenerRegistered = new EventListFactory_1.EventDescriptor();
        this.PermissionListenerUnregistered = new EventListFactory_1.EventDescriptor();
        this.PermissionUpdated = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Permission', EventList);

},{"../utils/EventListFactory":142}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.AddLocalStream = new EventListFactory_1.EventDescriptor();
        this.AddRemoteStream = new EventListFactory_1.EventDescriptor();
        this.GridLayoutChanged = new EventListFactory_1.EventDescriptor();
        this.Hide = new EventListFactory_1.EventDescriptor();
        this.RecheckEachVideoSize = new EventListFactory_1.EventDescriptor();
        this.SpeakerPrivacyChanged = new EventListFactory_1.EventDescriptor();
        this.SpeakerSelected = new EventListFactory_1.EventDescriptor();
        this.StatisticsUpdate = new EventListFactory_1.EventDescriptor();
        this.Update = new EventListFactory_1.EventDescriptor();
        this.UpdateAudioMeters = new EventListFactory_1.EventDescriptor();
        this.UpdateCameraControl = new EventListFactory_1.EventDescriptor();
        this.UpdateCompositeRenderer = new EventListFactory_1.EventDescriptor();
        this.UpdateLocalViewLabel = new EventListFactory_1.EventDescriptor();
        this.UpdateMonitorShareViewLabel = new EventListFactory_1.EventDescriptor();
        this.UpdatePosition = new EventListFactory_1.EventDescriptor();
        this.UpdateSource = new EventListFactory_1.EventDescriptor();
        this.UpdateSourcesState = new EventListFactory_1.EventDescriptor();
        this.UpdateVideoTileControls = new EventListFactory_1.EventDescriptor();
        this.UpdateViewLabel = new EventListFactory_1.EventDescriptor();
        this.UpdateWindowShareViewLabel = new EventListFactory_1.EventDescriptor();
        this.VideoCropSettingsChanged = new EventListFactory_1.EventDescriptor();
        this.VideoResolutionChanged = new EventListFactory_1.EventDescriptor();
        this.VideoTileAdded = new EventListFactory_1.EventDescriptor();
        this.VideoTileRemoved = new EventListFactory_1.EventDescriptor();
        this.VideoTileUpdated = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Render', EventList);

},{"../utils/EventListFactory":142}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.AvailableResourcesChanged = new EventListFactory_1.EventDescriptor();
        this.MaxRemoteSourcesChanged = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('ResourcesManager', EventList);

},{"../utils/EventListFactory":142}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.Created = new EventListFactory_1.EventDescriptor();
        this.Entered = new EventListFactory_1.EventDescriptor();
        this.Left = new EventListFactory_1.EventDescriptor();
        this.StateUpdate = new EventListFactory_1.EventDescriptor();
        this.UnprocessedAudioSupportChanged = new EventListFactory_1.EventDescriptor();
        this.UnprocessedAudioStarted = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Room', EventList);

},{"../utils/EventListFactory":142}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.CodecChanged = new EventListFactory_1.EventDescriptor();
        this.ReceiveBandwidthUpdated = new EventListFactory_1.EventDescriptor();
        this.Update = new EventListFactory_1.EventDescriptor();
        this.UnprocessedAudioCodecUpdated = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Statistics', EventList);

},{"../utils/EventListFactory":142}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackEvents = exports.TrackEventList = exports.Events = exports.EventList = void 0;
const EventListFactory_1 = require("../utils/EventListFactory");
class EventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.LocalMonitorAdded = new EventListFactory_1.EventDescriptor();
        this.LocalMonitorDeselected = new EventListFactory_1.EventDescriptor();
        this.LocalMonitorRemoved = new EventListFactory_1.EventDescriptor();
        this.LocalMonitorSelected = new EventListFactory_1.EventDescriptor();
        this.LocalStreamReady = new EventListFactory_1.EventDescriptor();
        this.LocalWindowShareAdded = new EventListFactory_1.EventDescriptor();
        this.LocalWindowShareDeselected = new EventListFactory_1.EventDescriptor();
        this.LocalWindowShareRemoved = new EventListFactory_1.EventDescriptor();
        this.LocalWindowShareSelected = new EventListFactory_1.EventDescriptor();
        this.MediaDisabled = new EventListFactory_1.EventDescriptor();
        this.MediaEnabled = new EventListFactory_1.EventDescriptor();
        this.MediaFailed = new EventListFactory_1.EventDescriptor();
        this.RemoteCameraAdded = new EventListFactory_1.EventDescriptor();
        this.RemoteCameraRemoved = new EventListFactory_1.EventDescriptor();
        this.RemoteCameraStateUpdated = new EventListFactory_1.EventDescriptor();
        this.RemoteMicrophoneAdded = new EventListFactory_1.EventDescriptor();
        this.RemoteMicrophoneRemoved = new EventListFactory_1.EventDescriptor();
        this.RemoteMicrophoneStateUpdated = new EventListFactory_1.EventDescriptor();
        this.RemoteWindowShareAdded = new EventListFactory_1.EventDescriptor();
        this.RemoteWindowShareRemoved = new EventListFactory_1.EventDescriptor();
        this.RemoteWindowShareStateUpdated = new EventListFactory_1.EventDescriptor();
        this.StreamEnableStateChanged = new EventListFactory_1.EventDescriptor();
        this.StreamListChanged = new EventListFactory_1.EventDescriptor();
        this.TracksChanged = new EventListFactory_1.EventDescriptor();
        this.TransmittedStreamTracksSsrcUpdated = new EventListFactory_1.EventDescriptor();
        this.TransmittedStreamTracksUpdated = new EventListFactory_1.EventDescriptor();
        this.RemoteTrackAddedSsrc = new EventListFactory_1.EventDescriptor();
        this.RemoteTrackRemovedSsrc = new EventListFactory_1.EventDescriptor();
        this.UnprocessedAudioStateUpdated = new EventListFactory_1.EventDescriptor();
    }
}
exports.EventList = EventList;
exports.Events = (0, EventListFactory_1.CreateEventList)('Stream', EventList);
class TrackEventList extends EventListFactory_1.EventListBase {
    constructor() {
        super(...arguments);
        this.TrackEnded = new EventListFactory_1.EventDescriptor();
        this.TrackMute = new EventListFactory_1.EventDescriptor();
        this.TrackOverconstrained = new EventListFactory_1.EventDescriptor();
        this.TrackUnmute = new EventListFactory_1.EventDescriptor();
    }
}
exports.TrackEventList = TrackEventList;
exports.TrackEvents = (0, EventListFactory_1.CreateEventList)('Track', TrackEventList);

},{"../utils/EventListFactory":142}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CmcpSession = exports.CmcpPacketProcessor = exports.CmcpGenericCommand = exports.CmcpNotify = exports.CmcpSubscribe = exports.ConferenceDestroy = exports.ConferenceModify = exports.ConferenceCreate = exports.ConferenceShowSelected = exports.ConferenceShow = exports.ConferenceReject = exports.ConferenceUpdate = exports.ConferenceLeave = exports.ConferenceAccept = exports.ConferenceJoin = exports.CmcpGenericAck = exports.CmcpReply = exports.CmcpCommand = exports.Profile = exports.CSessionTemplate = exports.ReasonTemplate = exports.ConferenceTemplate = exports.ConferenceLeaveReason = void 0;
const ConnectionEvents = require("../events/ConnectionEvents");
const LmiProtocol = require("./LmiProtocol");
const PacketProcessor_1 = require("./PacketProcessor");
const PacketProcessor_2 = require("./PacketProcessor");
const ScipSession_1 = require("./ScipSession");
const ConferenceEvents = require("../events/ConferenceEvents");
const ParticipantEvents = require("../events/ParticipantEvents");
const MessageEvents = require("../events/MessageEvents");
const DeviceEvents = require("../events/DeviceEvents");
const Constants_1 = require("../utils/Constants");
const StringUtils_1 = require("../utils/StringUtils");
let CMCP_VERSION = 5;
var ConferenceLeaveReason;
(function (ConferenceLeaveReason) {
    ConferenceLeaveReason[ConferenceLeaveReason["Other"] = 900] = "Other";
    ConferenceLeaveReason[ConferenceLeaveReason["ShuttingDown"] = 901] = "ShuttingDown";
    ConferenceLeaveReason[ConferenceLeaveReason["ConferenceDestroyed"] = 902] = "ConferenceDestroyed";
    ConferenceLeaveReason[ConferenceLeaveReason["Booted"] = 903] = "Booted";
    ConferenceLeaveReason[ConferenceLeaveReason["SessionTerminated"] = 904] = "SessionTerminated";
    ConferenceLeaveReason[ConferenceLeaveReason["Echo"] = 905] = "Echo";
})(ConferenceLeaveReason = exports.ConferenceLeaveReason || (exports.ConferenceLeaveReason = {}));
function ConferenceTemplate(conference) {
    return `<c>${conference}</c>`;
}
exports.ConferenceTemplate = ConferenceTemplate;
function ReasonTemplate(reason) {
    return `<rsn>${reason}</rsn>`;
}
exports.ReasonTemplate = ReasonTemplate;
function CSessionTemplate(csession) {
    return `<session>${csession}</session>`;
}
exports.CSessionTemplate = CSessionTemplate;
class Profile {
}
exports.Profile = Profile;
class CmcpCommand extends PacketProcessor_2.Command {
    constructor(session) {
        super(session.dialogId);
        this.session = session;
    }
    execute() {
        throw new Error("Not Implemented");
    }
    acked(reply) {
        try {
            reply.execute();
        }
        catch (e) {
        }
    }
}
exports.CmcpCommand = CmcpCommand;
class CmcpReply extends PacketProcessor_2.Reply {
    constructor(session) {
        super(session.dialogId);
        this.session = session;
    }
}
exports.CmcpReply = CmcpReply;
class CmcpGenericAck extends CmcpReply {
    execute() { }
}
exports.CmcpGenericAck = CmcpGenericAck;
class ConferenceJoin extends CmcpCommand {
    constructor(session, conferenceName, csession) {
        super(session);
        this.gm = "gen";
        this.conference = conferenceName;
        this.csession = csession;
    }
    toXml(commandBody = '') {
        let conference = ConferenceTemplate(this.conference);
        let csession = CSessionTemplate(this.csession);
        let template = `<cJoin gm="${this.gm}">${conference}${csession}</cJoin>`;
        return super.toXml(template);
    }
}
exports.ConferenceJoin = ConferenceJoin;
class ConferenceAccept extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new CmcpGenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_2.MessageType.Local;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
        this.session.scipSession.JoinConferenceCompleted();
    }
    toXml(commandBody = '') {
        let template = `<sAcc/>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cAccCmdEl) {
        return new ConferenceAccept(session);
    }
}
exports.ConferenceAccept = ConferenceAccept;
class ConferenceLeave extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new CmcpGenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_2.MessageType.Local;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
        this.session.scipSession.ProcessConferenceBooted(this.reason);
    }
    toXml(commandBody = '') {
        let template;
        let conference = ConferenceTemplate(this.conference);
        let reason = ReasonTemplate(this.reason);
        template = `<cLeave>${conference}${reason}</cLeave>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cLeaveCmdEl) {
        const obj = new ConferenceLeave(session);
        obj.conference = cLeaveCmdEl.querySelector('c')?.innerHTML ?? '';
        obj.reason = Number(cLeaveCmdEl.querySelector('rsn')?.innerHTML ?? '');
        return obj;
    }
}
exports.ConferenceLeave = ConferenceLeave;
class ConferenceUpdate extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    toXml(commandBody = '') {
        let template;
        template = `<cUpd recording="${this.recording}" hidden="${this.hidden}" selectable="${this.selectable}" />`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cUpdCmdEl) {
        const obj = new ConferenceUpdate(session);
        obj.recording = cUpdCmdEl.hasAttribute('recording') &&
            (cUpdCmdEl.getAttribute('recording') === 'true' || cUpdCmdEl.getAttribute('recording') === '');
        obj.hidden = cUpdCmdEl.hasAttribute('hidden') &&
            (cUpdCmdEl.getAttribute('hidden') === 'true' || cUpdCmdEl.getAttribute('hidden') === '');
        obj.selectable = cUpdCmdEl.hasAttribute('selectable') &&
            (cUpdCmdEl.getAttribute('selectable') === 'true' || cUpdCmdEl.getAttribute('selectable') === '');
        return obj;
    }
}
exports.ConferenceUpdate = ConferenceUpdate;
class ConferenceReject extends CmcpCommand {
    toXml(commandBody = '') {
        let template = `<sRej/>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cRejCmdEl) {
        return new ConferenceReject(session);
    }
}
exports.ConferenceReject = ConferenceReject;
class ConferenceShow extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    SetParams(params) {
        this.params = params;
    }
    toXml(commandBody = '') {
        let template;
        let sid = `<sid>${this.params.sourceId}</sid>`;
        let state = `<state>${this.params.state}</state>`;
        let params = ``;
        if (this.params.params) {
            params = `<p>`;
            if (this.params.params.windowSize) {
                params += `<ws><w>${this.params.params.windowSize.width}</w><h>${this.params.params.windowSize.height}</h></ws>`;
            }
            if (this.params.params.pixelRate) {
                params += `<pr>${this.params.params.pixelRate}</pr>`;
            }
            if (this.params.params.framesPerSec) {
                params += `<fps>${this.params.params.framesPerSec}</fps>`;
            }
            params += `</p>`;
        }
        template = `<cShow>${sid}${state}${params}</cShow>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cShowCmdEl) {
        return new ConferenceShow(session);
    }
}
exports.ConferenceShow = ConferenceShow;
class ConferenceShowSelected extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    SetParams(params) {
        this.params = params;
    }
    toXml(commandBody = '') {
        let template;
        let vid = ``;
        let app = ``;
        let aud = ``;
        if (this.params.audio) {
            aud = `<aud><ct>${this.params.audio.count}</ct><pl>${this.params.audio.policy}</pl></aud>`;
        }
        if (this.params.video) {
            let policy = ``;
            if (this.params.video.policy) {
                policy = `policy="${this.params.video.policy}"`;
            }
            let dynamicViewPolicy = ``;
            if (this.params.video.dynamicViewPolicy) {
                dynamicViewPolicy = `dynamicViewPolicy="${this.params.video.dynamicViewPolicy}"`;
            }
            let gen = ``;
            if (this.params.video.generation) {
                this.params.video.generation.forEach(function (g) {
                    gen += `<gen id="${g.id}" state="${g.state}">`;
                    if (g.params) {
                        gen += `<par>`;
                        if (g.params.windowSize) {
                            gen += `<ws><w>${g.params.windowSize.width}</w><h>${g.params.windowSize.height}</h></ws>`;
                        }
                        if (g.params.pixelRate) {
                            gen += `<pr>${g.params.pixelRate}</pr>`;
                        }
                        if (g.params.bandwidth) {
                            gen += `<bw>${g.params.bandwidth}</bw>`;
                        }
                        if (g.params.framesPerSec) {
                            gen += `<fps>${g.params.framesPerSec}</fps>`;
                        }
                        gen += `</par>`;
                    }
                    gen += `</gen>`;
                });
                vid = `<vid ${policy} ${dynamicViewPolicy}>${gen}</vid>`;
            }
        }
        template = `<cShowSel>${vid}${app}${aud}</cShowSel>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, cShowSelCmdEl) {
        return new ConferenceShowSelected(session);
    }
}
exports.ConferenceShowSelected = ConferenceShowSelected;
class ConferenceCreate extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    toXml(commandBody = '') {
        let template;
        console.error("NOT IMPLEMENTED");
        return super.toXml(template);
    }
}
exports.ConferenceCreate = ConferenceCreate;
class ConferenceModify extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    toXml(commandBody = '') {
        let template;
        console.error("NOT IMPLEMENTED");
        return super.toXml(template);
    }
}
exports.ConferenceModify = ConferenceModify;
class ConferenceDestroy extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    toXml(commandBody = '') {
        let template;
        console.error("NOT IMPLEMENTED");
        return super.toXml(template);
    }
}
exports.ConferenceDestroy = ConferenceDestroy;
class CmcpSubscribe extends CmcpCommand {
    constructor(session, resource, pkg, duration) {
        super(session);
        this.package = pkg;
        this.duration = duration;
        this.resource = resource;
    }
    SetEndpointId(endpointId) {
        this.endpointId = endpointId;
    }
    acked(reply) {
    }
    toXml(commandBody) {
        let suppressIfMatch = "";
        if (this.suppressIfMatch) {
            suppressIfMatch = `suppressIfMatch="${this.suppressIfMatch}"`;
        }
        let rsrc = "<rsrc>TEST</rsrc>";
        if (this.resource) {
            rsrc = `<rsrc>${this.resource}</rsrc>`;
        }
        let endpointId = "";
        if (this.endpointId) {
            endpointId = `<endpoint>${this.endpointId}</endpoint>`;
        }
        let template = `<sub ${suppressIfMatch}>${rsrc}<pkg>${this.package}</pkg><dur>${this.duration}</dur>${endpointId}</sub>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, subCmdEl) {
        const duration = Number(subCmdEl.querySelector('dur')?.innerHTML ?? '');
        const pkg = subCmdEl.querySelector('pkg')?.innerHTML ?? '';
        return new CmcpSubscribe(session, "", pkg, duration);
    }
}
exports.CmcpSubscribe = CmcpSubscribe;
class CmcpNotify extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new CmcpGenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_2.MessageType.Local;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    acked(reply) {
    }
    toXml(replyBody) {
        let evt = "";
        let uri = this.rsrc;
        let template = `<noti><rsrc>${uri}</rsrc><pkg>${this.pkg}</pkg>${evt}<et>${this.eTag}</et></noti>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, notiCmdEl) {
        const obj = new CmcpNotify(session);
        obj.pkg = notiCmdEl.querySelector('pkg')?.innerHTML ?? '';
        obj.eTag = notiCmdEl.querySelector('et')?.innerHTML ?? '';
        switch (obj.pkg) {
            case 'selectedparticipant':
                const spp = {
                    dialogId: obj.dialogId,
                    notify: {
                        package: obj.pkg,
                        event: {
                            selectedParticipantPackageContent: {
                                conference: notiCmdEl.querySelector('evt content c')?.innerHTML ?? '',
                                selectedParticipants: []
                            }
                        }
                    }
                };
                notiCmdEl.querySelectorAll(':scope sp').forEach(spEl => {
                    const selectedParticipant = {
                        active: spEl.getAttribute('active') ?? '',
                        generation: Number(spEl.getAttribute('generation') ?? ''),
                        id: spEl.getAttribute('id') ?? '',
                        value: spEl.innerHTML
                    };
                    spp.notify.event.selectedParticipantPackageContent.selectedParticipants.push(selectedParticipant);
                });
                session.eventDispatcher.emit(ConferenceEvents.Events.NotifySelectedParticipant.Scoped(session.dialogId.local), spp);
                break;
            case 'participant':
                const npp = {
                    dialogId: obj.dialogId,
                    notify: {
                        package: obj.pkg,
                        event: {
                            participantPackageContent: {
                                participants: [],
                                status: notiCmdEl.querySelector('evt content')?.getAttribute('status') ?? ''
                            }
                        }
                    }
                };
                notiCmdEl.querySelectorAll('evt content p').forEach(pEl => {
                    const participant = {
                        confUri: pEl.querySelector('c')?.innerHTML ?? '',
                        displayText: StringUtils_1.default.fromSecureString(pEl.querySelector('dt')?.innerHTML ?? ''),
                        duration: pEl.querySelector('dur')?.innerHTML ?? '',
                        event: pEl.querySelector('evt')?.innerHTML ?? '',
                        participantUri: pEl.querySelector('uri')?.innerHTML ?? '',
                        sources: []
                    };
                    participant.participantUri = participant.confUri;
                    pEl.querySelectorAll('src').forEach(srcEl => {
                        const source = {};
                        source.dyn = srcEl.getAttribute('dyn') ?? 'true';
                        source.id = Number(srcEl.getAttribute('id'));
                        source.idStr = srcEl.getAttribute('idStr');
                        source.name = srcEl.getAttribute('name');
                        source.properties = [];
                        srcEl.querySelectorAll('prop').forEach(propEl => {
                            const prop = {
                                name: srcEl.querySelector('nm')?.innerHTML ?? '',
                                value: srcEl.querySelector('val')?.innerHTML ?? ''
                            };
                            source.properties.push(prop);
                        });
                        source.signal = srcEl.getAttribute('signal');
                        source.ssrcMap = {
                            connId: Number(srcEl.querySelector('ssrcMap')?.getAttribute('connId')),
                            ssrc: []
                        };
                        srcEl.querySelectorAll('ssrcMap ssrc').forEach(ssrcMapSsrcEl => {
                            source.ssrcMap.ssrc.push(Number(ssrcMapSsrcEl.innerHTML));
                        });
                        source.type = (srcEl.getAttribute('type') ?? '');
                        participant.sources.push(source);
                    });
                    npp.notify.event.participantPackageContent.participants.push(participant);
                });
                session.eventDispatcher.emit(ConferenceEvents.Events.NotifyParticipant.Scoped(session.dialogId.local), npp);
                break;
            case 'receivebw':
                const rbp = {
                    receiveBw: Number(notiCmdEl.querySelector('receiveBw')?.innerHTML ?? '')
                };
                session.eventDispatcher.emit(ConferenceEvents.Events.NotifyReceiveBandwidth.Scoped(session.dialogId.local), rbp);
                break;
            default:
                break;
        }
        return obj;
    }
}
exports.CmcpNotify = CmcpNotify;
class CmcpGenericCommand extends CmcpCommand {
    constructor(session) {
        super(session);
    }
    setProtocol(protocol) {
        this.protocol = protocol;
    }
    setDestination(destination) {
        this.destination = destination;
    }
    setContent(content) {
        this.content = content;
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new CmcpGenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_2.MessageType.Local;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    acked(reply) {
    }
    toXml(commandBody) {
        const source = this.session.scipSession._context.localUri;
        const attributes = {
            protocol: this.protocol,
            source
        };
        if (this.destination) {
            attributes.destination = this.destination;
        }
        const attributesArray = Object.entries(attributes).map(([name, value]) => `${name}="${value}"`);
        const template = `<genc ${attributesArray.join(' ')}><cnt>${this.content}</cnt></genc>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, gencCmdEl) {
        const obj = new CmcpGenericCommand(session);
        const contentEl = gencCmdEl.querySelector('cnt');
        const content = contentEl.innerHTML;
        const protocol = gencCmdEl.getAttribute('protocol');
        if (contentEl) {
            switch (protocol) {
                case "ConfData":
                    gencCmdEl.querySelectorAll('cnt ConfDataMessage ParticipantTable Updates Participants').forEach(participantEl => {
                        const infoType = participantEl.querySelector('InfoType')?.innerHTML ?? '';
                        const clientTypeStr = participantEl.querySelector('ClientType')?.innerHTML ?? '';
                        switch (infoType) {
                            case 'Add':
                                const userId = participantEl.querySelector('UserId')?.innerHTML ?? '';
                                const pUri = participantEl.querySelector('ParticipantUri')?.innerHTML ?? '';
                                if (userId && pUri) {
                                    let userIdStr = '';
                                    const userIdValues = userId.split(':');
                                    if (userIdValues.length === 3) {
                                        if (Number(userIdValues[2]) === 0) {
                                            userIdStr = `Guest_${userIdValues[1]}`;
                                        }
                                        else {
                                            userIdStr = `User_${userIdValues[2]}`;
                                        }
                                    }
                                    else {
                                        userIdStr = `Guest_${userId}`;
                                    }
                                    session.eventDispatcher.emit(ConnectionEvents.Events.Available, { fullJid: pUri, jid: userIdStr, resource: pUri, clientType: clientTypeStr });
                                }
                                break;
                            case 'Remove':
                                break;
                            default:
                                break;
                        }
                    });
                    gencCmdEl.querySelectorAll('cnt ConfDataMessage CameraTable Updates Cameras').forEach(cameraEl => {
                        const cameraId = cameraEl.querySelector('CameraId')?.innerHTML ?? '';
                        const infoType = cameraEl.querySelector('InfoType')?.innerHTML ?? '';
                        switch (infoType) {
                            case 'Add':
                            case 'Change':
                                session.eventDispatcher.emit(DeviceEvents.Events.CameraListChanged, {
                                    participantUri: cameraEl.querySelector('ParticipantUri')?.innerHTML ?? '',
                                    control: cameraEl.querySelector('CameraControl')?.innerHTML ?? '',
                                    status: cameraEl.querySelector('CameraStatus')?.innerHTML ?? '',
                                    name: cameraEl.querySelector('CameraName')?.innerHTML ?? '',
                                    altId: cameraEl.querySelector('AltId')?.innerHTML ?? '',
                                    id: cameraId
                                });
                                break;
                            case 'Remove':
                                session.eventDispatcher.emit(DeviceEvents.Events.CameraListRemoved, {
                                    altId: cameraEl.querySelector('AltId')?.innerHTML ?? '',
                                    id: cameraId
                                });
                                break;
                            default:
                                break;
                        }
                    });
                    gencCmdEl.querySelectorAll('cnt ConfDataMessage RecorderTable Updates Recorders').forEach(recorderEl => {
                        const infoType = recorderEl.querySelector('InfoType')?.innerHTML ?? '';
                        switch (infoType) {
                            case 'Add':
                            case 'Change':
                                const status = recorderEl.querySelector('RecorderStatus')?.innerHTML ?? '';
                                if (status === "Recording Paused") {
                                    session.eventDispatcher.emit(ParticipantEvents.Events.RecorderInCallChanged, { hasRecorder: true, isPaused: true, isWebcasting: false });
                                }
                                else if (status === "Recording WebCasting") {
                                    session.eventDispatcher.emit(ParticipantEvents.Events.RecorderInCallChanged, { hasRecorder: true, isPaused: false, isWebcasting: true });
                                }
                                else {
                                    session.eventDispatcher.emit(ParticipantEvents.Events.RecorderInCallChanged, { hasRecorder: true, isPaused: false, isWebcasting: false });
                                }
                                break;
                            case 'Remove':
                                session.eventDispatcher.emit(ParticipantEvents.Events.RecorderInCallChanged, { hasRecorder: false, isPaused: false, isWebcasting: false });
                                break;
                            default:
                                break;
                        }
                    });
                    break;
                case "ConfMsg":
                    const messageId = gencCmdEl.querySelector('cnt ConfMsgMessage MessageId')?.innerHTML ?? '';
                    const broadcast = (gencCmdEl.querySelector('cnt ConfMsgMessage TextMsg Broadcast')?.innerHTML ?? '') === 'true';
                    const text = StringUtils_1.default.fromSecureString(gencCmdEl.querySelector('cnt ConfMsgMessage TextMsg Text')?.innerHTML ?? '');
                    const gencSource = gencCmdEl.getAttribute('source') ?? '';
                    const gencDest = gencCmdEl.getAttribute('destination') ?? '';
                    if (broadcast) {
                        const messagePayload = {
                            body: text,
                            id: messageId,
                            resource: gencSource
                        };
                        session.eventDispatcher.emit(MessageEvents.Events.MessageReceived, messagePayload);
                    }
                    else if (gencDest == session.scipSession._context.localUri) {
                        const messagePayload = {
                            body: text,
                            id: messageId,
                            resource: gencSource,
                            type: 'privatechat'
                        };
                        session.eventDispatcher.emit(MessageEvents.Events.MessageReceived, messagePayload);
                    }
                    break;
                default:
                    break;
            }
        }
        obj.setProtocol(protocol);
        obj.setContent(content);
        return obj;
    }
}
exports.CmcpGenericCommand = CmcpGenericCommand;
class CmcpPacketProcessor extends PacketProcessor_1.Processor {
    constructor(session, logger) {
        super(logger);
        this.session = session;
        this.logger = logger;
    }
    process(decodedPacketEl) {
        decodedPacketEl.querySelectorAll(':scope > request').forEach(request => this._processRequest(request));
        decodedPacketEl.querySelectorAll(':scope > response').forEach(request => this._processResponse(request));
    }
    _processRequest(requestEl) {
        const request_tid = Number(requestEl.getAttribute('transactionId'));
        const commandsEl = requestEl.querySelector(':scope > commands');
        if (request_tid && commandsEl) {
            const commands_atomic = commandsEl.getAttribute('atomic') ?? '';
            const commands_version = commandsEl.getAttribute('version') ?? '';
            const commandsFrom = commandsEl.getAttribute('from') ?? '';
            commandsEl.querySelectorAll(':scope > command').forEach((commandEL) => {
                Array.from(commandEL.children).forEach((cmdPart) => {
                    const command = this._processRequestCommand(cmdPart);
                    if (command != null) {
                        command.transactionId = request_tid;
                        command.version = Number(commands_version);
                        command.type = PacketProcessor_2.MessageType.Remote;
                        command.atomic = (Number(commands_atomic));
                        this.processRemoteCommand(command);
                    }
                });
            });
        }
    }
    _processRequestCommand(cmdElement) {
        let command = null;
        const iDOM = (new DOMParser()).parseFromString(cmdElement.outerHTML, "application/xml");
        const tagName = cmdElement.tagName;
        switch (tagName) {
            case 'dialogId':
                break;
            case "cCreate":
            case "ConferenceCreate":
                break;
            case "cModify":
            case "ConferenceModify":
                break;
            case "cDestroy":
            case "ConferenceDestroy":
                break;
            case "me":
            case "mesh":
                break;
            case "ume":
            case "unmesh":
                break;
            case "md":
            case "meshed":
                break;
            case "AddUsers":
                break;
            case "Joined":
                break;
            case "Left":
                break;
            case "cJoin":
            case "ConferenceJoin":
                break;
            case "cAcc":
            case "ConferenceAccept":
                command = ConferenceAccept.fromCmdDOM(this.session, cmdElement);
                break;
            case "cRej":
            case "ConferenceReject":
                command = ConferenceReject.fromCmdDOM(this.session, cmdElement);
                break;
            case "cLeave":
            case "ConferenceLeave":
                command = ConferenceLeave.fromCmdDOM(this.session, cmdElement);
                break;
            case "cUpd":
            case "ConferenceUpdate":
                command = ConferenceUpdate.fromCmdDOM(this.session, cmdElement);
                break;
            case "cShow":
            case "ConferenceShow":
                command = ConferenceShow.fromCmdDOM(this.session, cmdElement);
                break;
            case "cShowSel":
            case "ConferenceShowSelected":
                command = ConferenceShowSelected.fromCmdDOM(this.session, cmdElement);
                break;
            case "sub":
            case "subscribe":
                command = CmcpSubscribe.fromCmdDOM(this.session, cmdElement);
                break;
            case "cUnsub":
            case "unsubscribe":
                break;
            case "noti":
            case "notify":
                command = CmcpNotify.fromCmdDOM(this.session, cmdElement);
                break;
            case "genc":
            case "genericCommand":
                command = CmcpGenericCommand.fromCmdDOM(this.session, cmdElement);
                break;
            default:
                console.error(`ERROR: ${tagName}`);
                break;
        }
        return command;
    }
    _processResponse(responseEl) {
        const response_tid = Number(responseEl.getAttribute('transactionId'));
        const repliesEl = responseEl.querySelector(':scope > replies');
        if (response_tid && repliesEl) {
            const replies_version = repliesEl.getAttribute('version') ?? '';
            repliesEl.querySelectorAll(':scope > reply').forEach((replyEl) => {
                const reply_code = Number(replyEl.getAttribute('result') ?? '');
                Array.from(replyEl.children).forEach((replyElement) => {
                    let reply;
                    const tagName = replyElement.tagName;
                    switch (tagName) {
                        case 'dialogId':
                            const remoteId = replyElement.querySelector('remote')?.innerHTML ?? '';
                            if (remoteId) {
                                this.session.dialogId.remote = Number(remoteId);
                            }
                            break;
                        default:
                            console.error(`ERROR: ${tagName}`);
                            break;
                    }
                    if (!reply) {
                        reply = new CmcpGenericAck(this.session);
                    }
                    reply.result = reply_code;
                    reply.transactionId = response_tid;
                    reply.version = replies_version;
                    reply.session = this.session;
                    reply.type = PacketProcessor_2.MessageType.Remote;
                    this.processRemoteReply(reply);
                });
            });
        }
    }
}
exports.CmcpPacketProcessor = CmcpPacketProcessor;
class CmcpSession {
    constructor(scipSession, localId, eventDispatcher, logger) {
        this.scipSession = scipSession;
        this.eventDispatcher = eventDispatcher;
        this.logger = logger;
        this.logger.LogDebug(() => `Construct CmcpSession with local dialog ID ${localId}`);
        this.dialogId = new LmiProtocol.DialogId(localId);
        this.processor = new CmcpPacketProcessor(this, logger);
        this.transactionId = 1;
    }
    SendConferenceJoin(conferenceName, session) {
        let cmcpSession = this;
        this.conferenceName = conferenceName;
        return new Promise((resolve, reject) => {
            let cj = new ConferenceJoin(cmcpSession, conferenceName, session);
            let cmcpCommandsList = new Array();
            cmcpCommandsList.push(cj);
            cmcpSession.sendCommands(cmcpCommandsList);
            resolve();
        });
    }
    SendConferenceMessage(message, id) {
        const CONF_MSG_VERSION = '1.0.2';
        message = StringUtils_1.default.encodeXML(message);
        return new Promise((resolve, reject) => {
            const gc = new CmcpGenericCommand(this);
            const content = `<ConfMsgMessage>
          <Version>${CONF_MSG_VERSION}</Version>
          <MessageId>${id}</MessageId>
          <TextMsg>
            <Text>${message}</Text>
            <Broadcast>true</Broadcast>
          </TextMsg>
        </ConfMsgMessage>`;
            gc.setContent(content);
            gc.setProtocol('ConfMsg');
            this.sendCommands([gc]);
            resolve();
        });
    }
    SendPrivateMessage(participantUri, message, id) {
        const CONF_MSG_VERSION = '1.0.2';
        message = StringUtils_1.default.encodeXML(message);
        return new Promise((resolve, reject) => {
            const gc = new CmcpGenericCommand(this);
            const content = `<ConfMsgMessage>
          <Version>${CONF_MSG_VERSION}</Version>
          <MessageId>${id}</MessageId>
          <TextMsg>
            <Text>${message}</Text>
          </TextMsg>
        </ConfMsgMessage>`;
            gc.setContent(content);
            gc.setProtocol('ConfMsg');
            gc.setDestination(participantUri);
            this.sendCommands([gc]);
            resolve();
        });
    }
    SendFeccMessage(options) {
        const CONF_MSG_VERSION = '2.0.0';
        const feccCommands = [];
        if (options.fecc.hasOwnProperty('pan')) {
            feccCommands.push(`<Pan>${options.fecc.pan}</Pan>`);
        }
        if (options.fecc.hasOwnProperty('tilt')) {
            feccCommands.push(`<Tilt>${options.fecc.tilt}</Tilt>`);
        }
        if (options.fecc.hasOwnProperty('zoom')) {
            feccCommands.push(`<Zoom>${options.fecc.zoom}</Zoom>`);
        }
        if (options.fecc.hasOwnProperty('timeout')) {
            feccCommands.push(`<Timeout>${options.fecc.timeout}</Timeout>`);
        }
        return new Promise((resolve, reject) => {
            const gc = new CmcpGenericCommand(this);
            const content = `<ConfMsgMessage xmlns="http://www.vidyo.com/LmiCsConfMsgParser.xsd">
          <Version>${CONF_MSG_VERSION}</Version>
          <MessageId>${options.id}</MessageId>
          <Camera>
            <CameraId>${options.fecc.cameraId}</CameraId>
            <Command>${options.fecc.command}</Command>
            ${feccCommands.join('')}
          </Camera>
        </ConfMsgMessage>`;
            gc.setContent(content);
            gc.setProtocol('ConfMsg');
            gc.setDestination(options.to);
            this.sendCommands([gc]);
            resolve();
        });
    }
    SendConferenceShow(parameter) {
        let cmcpSession = this;
        return new Promise((resolve, reject) => {
            let show = new ConferenceShow(cmcpSession);
            show.SetParams(parameter);
            let cmcpCommandsList = new Array();
            cmcpCommandsList.push(show);
            cmcpSession.sendCommands(cmcpCommandsList);
            resolve();
        });
    }
    SendConferenceShowSelected(parameter) {
        let cmcpSession = this;
        return new Promise((resolve, reject) => {
            let showSelected = new ConferenceShowSelected(cmcpSession);
            showSelected.SetParams(parameter);
            let cmcpCommandsList = new Array();
            cmcpCommandsList.push(showSelected);
            cmcpSession.sendCommands(cmcpCommandsList);
            resolve();
        });
    }
    SendSubscribeReceiveBandwidthPackage(pkg) {
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let subReceiveBw = new CmcpSubscribe(this, `${this.scipSession.dialogId.remote}`, pkg, Constants_1.SubscriptionDialogDuration);
            subReceiveBw.type = PacketProcessor_2.MessageType.Local;
            commandsList.push(subReceiveBw);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    SendSubsribeParticipantPackage(pkg) {
        let session = this;
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let subParticipant = new CmcpSubscribe(this, this.scipSession._context.roomName, pkg, Constants_1.SubscriptionDialogDuration);
            subParticipant.type = PacketProcessor_2.MessageType.Local;
            commandsList.push(subParticipant);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    SendLeaveConference() {
        let cmcpSession = this;
        return new Promise((resolve, reject) => {
            let cl = new ConferenceLeave(cmcpSession);
            cl.conference = cmcpSession.conferenceName;
            cl.reason = ConferenceLeaveReason.SessionTerminated;
            let cmcpCommandsList = new Array();
            cmcpCommandsList.push(cl);
            cmcpSession.sendCommands(cmcpCommandsList);
            resolve();
        });
    }
    sendCommands(cmcpCommandsList) {
        let from = this.scipSession._context.endpointId;
        let to = this.scipSession._context.routerId;
        let cmcpPacket = new PacketProcessor_2.Packet(this.scipSession._context.localUri, this.scipSession._context.remoteUri);
        let cmcpRequest = new PacketProcessor_2.Request(this.scipSession._context.localUri, from, to, CMCP_VERSION, this.transactionId++, cmcpCommandsList);
        for (let i = 0; i < cmcpCommandsList.length; i++) {
            let command = cmcpCommandsList[i];
            command.transactionId = cmcpRequest.transactionId;
            command.type = PacketProcessor_2.MessageType.Local;
            this.processor.processLocalCommand(command);
        }
        let cmcpMessage = cmcpRequest.toXml();
        cmcpMessage = cmcpPacket.toXml(cmcpMessage);
        let scipCommandsList = new Array();
        let gc = new ScipSession_1.GenericCommand(this.scipSession);
        gc.type = PacketProcessor_2.MessageType.Local;
        gc.setContent(cmcpMessage);
        gc.setProtocol("CMCP");
        scipCommandsList.push(gc);
        this.scipSession.sendCommands(scipCommandsList);
    }
    sendReplies(transactionId, repliesList, versionMismatch) {
        let fromUri = this.scipSession._context.localUri;
        let response = new PacketProcessor_2.Response(transactionId, fromUri, repliesList, versionMismatch);
        let cnt = response.toXml();
        cnt = '<packet srcUri="' + fromUri + '" dstUri="' + this.scipSession._context.remoteUri + '" version="2">' + cnt + '</packet>';
        let processor = this.processor;
        let session = this;
        for (let i = 0; i < repliesList.length; i++) {
            let reply = repliesList[i];
            reply.transactionId = transactionId;
            processor.processLocalReply(reply);
        }
        let scipCommandsList = new Array();
        let gc = new ScipSession_1.GenericCommand(this.scipSession);
        gc.type = PacketProcessor_2.MessageType.Local;
        gc.setContent(cnt);
        gc.setProtocol("CMCP");
        scipCommandsList.push(gc);
        this.scipSession.sendCommands(scipCommandsList);
    }
}
exports.CmcpSession = CmcpSession;

},{"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/DeviceEvents":67,"../events/MessageEvents":70,"../events/ParticipantEvents":73,"../utils/Constants":138,"../utils/StringUtils":164,"./LmiProtocol":84,"./PacketProcessor":85,"./ScipSession":87}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventServerSession = void 0;
const Stomp = require("stompjs");
const ModerationEvents = require("../events/ModerationEvents");
const LogEvents_1 = require("../events/LogEvents");
const Constants_1 = require("../utils/Constants");
class VCAPMessageProcessor {
    static process(session, message) {
        const parser = new DOMParser();
        const vcapDOM = parser.parseFromString(message, 'application/xml');
        const request = vcapDOM.querySelector('Request');
        if (request) {
            Array.from(request.children).forEach((tag) => {
                let cmd;
                switch (tag.tagName) {
                    case 'vcap:MediaControl':
                        cmd = MediaControlCommand.fromXMLDomElement(session, tag);
                        break;
                    case 'vcap:LectureMode':
                        cmd = LectureModeCommand.fromXMLDomElement(session, tag);
                        break;
                    default:
                        console.log("unsupported vcap message type " + tag.tagName);
                        break;
                }
                if (cmd) {
                    cmd.execute();
                }
            });
        }
    }
}
var ModerationCommandType;
(function (ModerationCommandType) {
    ModerationCommandType[ModerationCommandType["Mute"] = 16] = "Mute";
    ModerationCommandType[ModerationCommandType["Unmute"] = 32] = "Unmute";
    ModerationCommandType[ModerationCommandType["Silence"] = 64] = "Silence";
})(ModerationCommandType || (ModerationCommandType = {}));
var ModerationCommandMediaType;
(function (ModerationCommandMediaType) {
    ModerationCommandMediaType[ModerationCommandMediaType["Audio"] = 1] = "Audio";
    ModerationCommandMediaType[ModerationCommandMediaType["Video"] = 2] = "Video";
})(ModerationCommandMediaType || (ModerationCommandMediaType = {}));
var MediaControlModerationCommand;
(function (MediaControlModerationCommand) {
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationMicrophoneSoftMute"] = 65] = "ModerationMicrophoneSoftMute";
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationCameraSoftMute"] = 66] = "ModerationCameraSoftMute";
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationCameraHardMute"] = 18] = "ModerationCameraHardMute";
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationMicrophoneHardMute"] = 17] = "ModerationMicrophoneHardMute";
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationCameraHardUnmute"] = 34] = "ModerationCameraHardUnmute";
    MediaControlModerationCommand[MediaControlModerationCommand["ModerationMicrophoneHardUnmute"] = 33] = "ModerationMicrophoneHardUnmute";
})(MediaControlModerationCommand || (MediaControlModerationCommand = {}));
class MediaControlCommand {
    constructor(_session) {
        this._session = _session;
    }
    execute() {
        const commandPayload = this.getModerationCommandEventPayload();
        if (commandPayload) {
            this._session.eventDispatcher.emit(ModerationEvents.Events.EventServerModerationCommand, commandPayload);
        }
    }
    getModerationCommandEventPayload() {
        return ModerationEvents.EventServerModerationMessage[MediaControlModerationCommand[this.MediaType | this.Command]];
    }
    static fromXMLDomElement(session, dom) {
        const cmd = new MediaControlCommand(session);
        cmd.Command = ModerationCommandType[dom.querySelector('Command').innerHTML] ?? '';
        cmd.MediaType = ModerationCommandMediaType[dom.querySelector('MediaType').innerHTML] ?? '';
        return cmd;
    }
}
class LectureModeCommand {
    constructor(_session) {
        this._session = _session;
    }
    execute() {
        if (this.LectureStatusUpdate) {
            this._session.eventDispatcher.emit(ModerationEvents.Events.LectureStatusUpdate, this.LectureStatusUpdate);
        }
        if (this.UserStatusUpdate) {
            this._session.eventDispatcher.emit(ModerationEvents.Events.UserStatusUpdate, this.UserStatusUpdate);
        }
    }
    static fromXMLDomElement(session, dom) {
        const cmd = new LectureModeCommand(session);
        const tag = dom.firstElementChild;
        switch (tag.tagName) {
            case 'vcap:LectureStatusUpdate':
                const lecture = tag.querySelector('Lecture')?.innerHTML?.toLowerCase() === 'true';
                const presenter = tag.querySelector('PresenterParticipantId')?.innerHTML ?? undefined;
                cmd.LectureStatusUpdate = { lecture, presenter };
                if (tag.hasAttribute('muteAudio')) {
                    cmd.LectureStatusUpdate.muteAudio = tag.getAttribute('muteAudio').toLowerCase() === 'true';
                }
                break;
            case 'vcap:UserStatusUpdate':
                const handDismissed = tag.querySelector('HandDismissedNotification');
                if (handDismissed) {
                    cmd.UserStatusUpdate = { handApproved: false };
                }
                break;
            default:
                console.info("unsupported vcap message type " + tag.tagName);
                break;
        }
        return cmd;
    }
}
class EventServerSession {
    constructor(eventDispatcher, logger) {
        this.eventDispatcher = eventDispatcher;
        this.logger = logger;
    }
    Close() {
        if (this._clientSubscription) {
            this._clientSubscription.unsubscribe();
        }
        if (this._stompClient) {
            if (this._stompClient.ws.readyState === WebSocket.CONNECTING) {
                this._stompClient.ws.close();
            }
            else {
                this._stompClient.disconnect(() => { });
            }
        }
    }
    Connect(url, jwt, endpointId) {
        this._endpointID = endpointId;
        this._serverURL = url;
        this._jwt = jwt;
        if (this._serverURL && this._jwt) {
            this._connect();
        }
        else {
            if (!this._serverURL) {
                this.logger.LogWarning(() => `EventServer: can't connect to event server. Server url is missing`);
            }
            if (!this._jwt) {
                this.logger.LogWarning(() => `EventServer: can't connect to event server. JWT is missing`);
            }
            this.eventDispatcher.emit(ModerationEvents.Events.EventServerError, { error: `Missing connection params` });
        }
    }
    _connect() {
        try {
            this._stompClient = Stomp.client(this._serverURL, ['v10.stomp', 'v11.stomp', `Bearer.${this._jwt}`]);
            this._stompClient.connect({}, () => this._onConnected(), (error) => this._onConnectingError(error));
            this._connectingTimeout = window.setTimeout(() => {
                if (this._stompClient.ws.readyState === WebSocket.CONNECTING) {
                    this._stompClient.ws.close();
                }
            }, Constants_1.EventServerConnectingTimeout);
        }
        catch (error) {
            this._onConnectingError(error);
        }
    }
    _onConnected() {
        clearTimeout(this._connectingTimeout);
        this.logger.LogDebug(() => `EventServer: connected to ${this._serverURL}`);
        this.eventDispatcher.emit(ModerationEvents.Events.EventServerConnected);
        this._clientSubscription = this._stompClient.subscribe(`/user/topic/${this._endpointID}`, (message) => this._onMessage(message), { id: this._endpointID });
    }
    _onConnectingError(error) {
        this.logger.LogWarning(() => `EventServer: connection failed: ${error}`);
        this.eventDispatcher.emit(ModerationEvents.Events.EventServerError, { error });
    }
    _onMessage(message) {
        this.logger.LogDebug(() => `EventServer: message received: ${message.body}`, LogEvents_1.VidyoLogCategory.VidyoSignaling);
        VCAPMessageProcessor.process(this, message.body);
    }
}
exports.EventServerSession = EventServerSession;

},{"../events/LogEvents":69,"../events/ModerationEvents":72,"../utils/Constants":138,"stompjs":7}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloseEventCode = void 0;
var CloseEventCode;
(function (CloseEventCode) {
    CloseEventCode[CloseEventCode["NormalClosure"] = 1000] = "NormalClosure";
    CloseEventCode[CloseEventCode["NoStatusProvided"] = 1005] = "NoStatusProvided";
    CloseEventCode[CloseEventCode["AbnormalClosure"] = 1006] = "AbnormalClosure";
})(CloseEventCode = exports.CloseEventCode || (exports.CloseEventCode = {}));

},{}],83:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HunterProvider = exports.HunterProviderContext = exports.HunterProviderEventListeners = void 0;
__exportStar(require("./HunterBase"), exports);
const ConferenceEvents = require("../events/ConferenceEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const ModerationEvents = require("../events/ModerationEvents");
const RoomEvents = require("../events/RoomEvents");
const Constants = require("../utils/Constants");
const EndpointInfoProvider_1 = require("../utils/EndpointInfoProvider");
const PromiseHelper_1 = require("../utils/PromiseHelper");
const ConnectionEvents_1 = require("../events/ConnectionEvents");
const LogEvents_1 = require("../events/LogEvents");
const WebSocketTransport = require("./WebSocketTransport");
const ScipSession_1 = require("./ScipSession");
const ScipMediaSession = require("./ScipMediaSession");
const EventServerSession_1 = require("./EventServerSession");
const StringUtils_1 = require("../utils/StringUtils");
exports.HunterProviderEventListeners = 'VidyoHunterProviderEventListeners';
self['bigInt'] = require("big-integer");
const _bigIntScriptDecoded = `dmFyIGJpZ0ludD1mdW5jdGlvbih1bmRlZmluZWQpeyJ1c2Ugc3RyaWN0Ijt2YXIgQkFTRT0xZTcsTE9HX0JBU0U9NyxNQVhfSU5UPTkwMDcxOTkyNTQ3NDA5OTIsTUFYX0lOVF9BUlI9c21hbGxUb0FycmF5KE1BWF9JTlQpLERFRkFVTFRfQUxQSEFCRVQ9IjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiI7dmFyIHN1cHBvcnRzTmF0aXZlQmlnSW50PXR5cGVvZiBCaWdJbnQ9PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIEludGVnZXIodixyYWRpeCxhbHBoYWJldCxjYXNlU2Vuc2l0aXZlKXtpZih0eXBlb2Ygdj09PSJ1bmRlZmluZWQiKXJldHVybiBJbnRlZ2VyWzBdO2lmKHR5cGVvZiByYWRpeCE9PSJ1bmRlZmluZWQiKXJldHVybityYWRpeD09PTEwJiYhYWxwaGFiZXQ/cGFyc2VWYWx1ZSh2KTpwYXJzZUJhc2UodixyYWRpeCxhbHBoYWJldCxjYXNlU2Vuc2l0aXZlKTtyZXR1cm4gcGFyc2VWYWx1ZSh2KX1mdW5jdGlvbiBCaWdJbnRlZ2VyKHZhbHVlLHNpZ24pe3RoaXMudmFsdWU9dmFsdWU7dGhpcy5zaWduPXNpZ247dGhpcy5pc1NtYWxsPWZhbHNlfUJpZ0ludGVnZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO2Z1bmN0aW9uIFNtYWxsSW50ZWdlcih2YWx1ZSl7dGhpcy52YWx1ZT12YWx1ZTt0aGlzLnNpZ249dmFsdWU8MDt0aGlzLmlzU21hbGw9dHJ1ZX1TbWFsbEludGVnZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO2Z1bmN0aW9uIE5hdGl2ZUJpZ0ludCh2YWx1ZSl7dGhpcy52YWx1ZT12YWx1ZX1OYXRpdmVCaWdJbnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO2Z1bmN0aW9uIGlzUHJlY2lzZShuKXtyZXR1cm4tTUFYX0lOVDxuJiZuPE1BWF9JTlR9ZnVuY3Rpb24gc21hbGxUb0FycmF5KG4pe2lmKG48MWU3KXJldHVybltuXTtpZihuPDFlMTQpcmV0dXJuW24lMWU3LE1hdGguZmxvb3Iobi8xZTcpXTtyZXR1cm5bbiUxZTcsTWF0aC5mbG9vcihuLzFlNyklMWU3LE1hdGguZmxvb3Iobi8xZTE0KV19ZnVuY3Rpb24gYXJyYXlUb1NtYWxsKGFycil7dHJpbShhcnIpO3ZhciBsZW5ndGg9YXJyLmxlbmd0aDtpZihsZW5ndGg8NCYmY29tcGFyZUFicyhhcnIsTUFYX0lOVF9BUlIpPDApe3N3aXRjaChsZW5ndGgpe2Nhc2UgMDpyZXR1cm4gMDtjYXNlIDE6cmV0dXJuIGFyclswXTtjYXNlIDI6cmV0dXJuIGFyclswXSthcnJbMV0qQkFTRTtkZWZhdWx0OnJldHVybiBhcnJbMF0rKGFyclsxXSthcnJbMl0qQkFTRSkqQkFTRX19cmV0dXJuIGFycn1mdW5jdGlvbiB0cmltKHYpe3ZhciBpPXYubGVuZ3RoO3doaWxlKHZbLS1pXT09PTApO3YubGVuZ3RoPWkrMX1mdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpe3ZhciB4PW5ldyBBcnJheShsZW5ndGgpO3ZhciBpPS0xO3doaWxlKCsraTxsZW5ndGgpe3hbaV09MH1yZXR1cm4geH1mdW5jdGlvbiB0cnVuY2F0ZShuKXtpZihuPjApcmV0dXJuIE1hdGguZmxvb3Iobik7cmV0dXJuIE1hdGguY2VpbChuKX1mdW5jdGlvbiBhZGQoYSxiKXt2YXIgbF9hPWEubGVuZ3RoLGxfYj1iLmxlbmd0aCxyPW5ldyBBcnJheShsX2EpLGNhcnJ5PTAsYmFzZT1CQVNFLHN1bSxpO2ZvcihpPTA7aTxsX2I7aSsrKXtzdW09YVtpXStiW2ldK2NhcnJ5O2NhcnJ5PXN1bT49YmFzZT8xOjA7cltpXT1zdW0tY2FycnkqYmFzZX13aGlsZShpPGxfYSl7c3VtPWFbaV0rY2Fycnk7Y2Fycnk9c3VtPT09YmFzZT8xOjA7cltpKytdPXN1bS1jYXJyeSpiYXNlfWlmKGNhcnJ5PjApci5wdXNoKGNhcnJ5KTtyZXR1cm4gcn1mdW5jdGlvbiBhZGRBbnkoYSxiKXtpZihhLmxlbmd0aD49Yi5sZW5ndGgpcmV0dXJuIGFkZChhLGIpO3JldHVybiBhZGQoYixhKX1mdW5jdGlvbiBhZGRTbWFsbChhLGNhcnJ5KXt2YXIgbD1hLmxlbmd0aCxyPW5ldyBBcnJheShsKSxiYXNlPUJBU0Usc3VtLGk7Zm9yKGk9MDtpPGw7aSsrKXtzdW09YVtpXS1iYXNlK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3Ioc3VtL2Jhc2UpO3JbaV09c3VtLWNhcnJ5KmJhc2U7Y2FycnkrPTF9d2hpbGUoY2Fycnk+MCl7cltpKytdPWNhcnJ5JWJhc2U7Y2Fycnk9TWF0aC5mbG9vcihjYXJyeS9iYXNlKX1yZXR1cm4gcn1CaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KTtpZih0aGlzLnNpZ24hPT1uLnNpZ24pe3JldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpfXZhciBhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGEsTWF0aC5hYnMoYikpLHRoaXMuc2lnbil9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZEFueShhLGIpLHRoaXMuc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLnBsdXM9QmlnSW50ZWdlci5wcm90b3R5cGUuYWRkO1NtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7dmFyIGE9dGhpcy52YWx1ZTtpZihhPDAhPT1uLnNpZ24pe3JldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpfXZhciBiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtpZihpc1ByZWNpc2UoYStiKSlyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhK2IpO2I9c21hbGxUb0FycmF5KE1hdGguYWJzKGIpKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYixNYXRoLmFicyhhKSksYTwwKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkO05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHYpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUrcGFyc2VWYWx1ZSh2KS52YWx1ZSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUucGx1cz1OYXRpdmVCaWdJbnQucHJvdG90eXBlLmFkZDtmdW5jdGlvbiBzdWJ0cmFjdChhLGIpe3ZhciBhX2w9YS5sZW5ndGgsYl9sPWIubGVuZ3RoLHI9bmV3IEFycmF5KGFfbCksYm9ycm93PTAsYmFzZT1CQVNFLGksZGlmZmVyZW5jZTtmb3IoaT0wO2k8Yl9sO2krKyl7ZGlmZmVyZW5jZT1hW2ldLWJvcnJvdy1iW2ldO2lmKGRpZmZlcmVuY2U8MCl7ZGlmZmVyZW5jZSs9YmFzZTtib3Jyb3c9MX1lbHNlIGJvcnJvdz0wO3JbaV09ZGlmZmVyZW5jZX1mb3IoaT1iX2w7aTxhX2w7aSsrKXtkaWZmZXJlbmNlPWFbaV0tYm9ycm93O2lmKGRpZmZlcmVuY2U8MClkaWZmZXJlbmNlKz1iYXNlO2Vsc2V7cltpKytdPWRpZmZlcmVuY2U7YnJlYWt9cltpXT1kaWZmZXJlbmNlfWZvcig7aTxhX2w7aSsrKXtyW2ldPWFbaV19dHJpbShyKTtyZXR1cm4gcn1mdW5jdGlvbiBzdWJ0cmFjdEFueShhLGIsc2lnbil7dmFyIHZhbHVlO2lmKGNvbXBhcmVBYnMoYSxiKT49MCl7dmFsdWU9c3VidHJhY3QoYSxiKX1lbHNle3ZhbHVlPXN1YnRyYWN0KGIsYSk7c2lnbj0hc2lnbn12YWx1ZT1hcnJheVRvU21hbGwodmFsdWUpO2lmKHR5cGVvZiB2YWx1ZT09PSJudW1iZXIiKXtpZihzaWduKXZhbHVlPS12YWx1ZTtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSl9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHZhbHVlLHNpZ24pfWZ1bmN0aW9uIHN1YnRyYWN0U21hbGwoYSxiLHNpZ24pe3ZhciBsPWEubGVuZ3RoLHI9bmV3IEFycmF5KGwpLGNhcnJ5PS1iLGJhc2U9QkFTRSxpLGRpZmZlcmVuY2U7Zm9yKGk9MDtpPGw7aSsrKXtkaWZmZXJlbmNlPWFbaV0rY2Fycnk7Y2Fycnk9TWF0aC5mbG9vcihkaWZmZXJlbmNlL2Jhc2UpO2RpZmZlcmVuY2UlPWJhc2U7cltpXT1kaWZmZXJlbmNlPDA/ZGlmZmVyZW5jZStiYXNlOmRpZmZlcmVuY2V9cj1hcnJheVRvU21hbGwocik7aWYodHlwZW9mIHI9PT0ibnVtYmVyIil7aWYoc2lnbilyPS1yO3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpfXJldHVybiBuZXcgQmlnSW50ZWdlcihyLHNpZ24pfUJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7aWYodGhpcy5zaWduIT09bi5zaWduKXtyZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSl9dmFyIGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYobi5pc1NtYWxsKXJldHVybiBzdWJ0cmFjdFNtYWxsKGEsTWF0aC5hYnMoYiksdGhpcy5zaWduKTtyZXR1cm4gc3VidHJhY3RBbnkoYSxiLHRoaXMuc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLm1pbnVzPUJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KTt2YXIgYT10aGlzLnZhbHVlO2lmKGE8MCE9PW4uc2lnbil7cmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpfXZhciBiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhLWIpfXJldHVybiBzdWJ0cmFjdFNtYWxsKGIsTWF0aC5hYnMoYSksYT49MCl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXM9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtOYXRpdmVCaWdJbnQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHYpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUtcGFyc2VWYWx1ZSh2KS52YWx1ZSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubWludXM9TmF0aXZlQmlnSW50LnByb3RvdHlwZS5zdWJ0cmFjdDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwhdGhpcy5zaWduKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXt2YXIgc2lnbj10aGlzLnNpZ247dmFyIHNtYWxsPW5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO3NtYWxsLnNpZ249IXNpZ247cmV0dXJuIHNtYWxsfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5lZ2F0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KC10aGlzLnZhbHVlKX07QmlnSW50ZWdlci5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsZmFsc2UpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlPj0wP3RoaXMudmFsdWU6LXRoaXMudmFsdWUpfTtmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSxiKXt2YXIgYV9sPWEubGVuZ3RoLGJfbD1iLmxlbmd0aCxsPWFfbCtiX2wscj1jcmVhdGVBcnJheShsKSxiYXNlPUJBU0UscHJvZHVjdCxjYXJyeSxpLGFfaSxiX2o7Zm9yKGk9MDtpPGFfbDsrK2kpe2FfaT1hW2ldO2Zvcih2YXIgaj0wO2o8Yl9sOysrail7Yl9qPWJbal07cHJvZHVjdD1hX2kqYl9qK3JbaStqXTtjYXJyeT1NYXRoLmZsb29yKHByb2R1Y3QvYmFzZSk7cltpK2pdPXByb2R1Y3QtY2FycnkqYmFzZTtyW2kraisxXSs9Y2Fycnl9fXRyaW0ocik7cmV0dXJuIHJ9ZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLGIpe3ZhciBsPWEubGVuZ3RoLHI9bmV3IEFycmF5KGwpLGJhc2U9QkFTRSxjYXJyeT0wLHByb2R1Y3QsaTtmb3IoaT0wO2k8bDtpKyspe3Byb2R1Y3Q9YVtpXSpiK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3IocHJvZHVjdC9iYXNlKTtyW2ldPXByb2R1Y3QtY2FycnkqYmFzZX13aGlsZShjYXJyeT4wKXtyW2krK109Y2FycnklYmFzZTtjYXJyeT1NYXRoLmZsb29yKGNhcnJ5L2Jhc2UpfXJldHVybiByfWZ1bmN0aW9uIHNoaWZ0TGVmdCh4LG4pe3ZhciByPVtdO3doaWxlKG4tLSA+MClyLnB1c2goMCk7cmV0dXJuIHIuY29uY2F0KHgpfWZ1bmN0aW9uIG11bHRpcGx5S2FyYXRzdWJhKHgseSl7dmFyIG49TWF0aC5tYXgoeC5sZW5ndGgseS5sZW5ndGgpO2lmKG48PTMwKXJldHVybiBtdWx0aXBseUxvbmcoeCx5KTtuPU1hdGguY2VpbChuLzIpO3ZhciBiPXguc2xpY2UobiksYT14LnNsaWNlKDAsbiksZD15LnNsaWNlKG4pLGM9eS5zbGljZSgwLG4pO3ZhciBhYz1tdWx0aXBseUthcmF0c3ViYShhLGMpLGJkPW11bHRpcGx5S2FyYXRzdWJhKGIsZCksYWJjZD1tdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSxiKSxhZGRBbnkoYyxkKSk7dmFyIHByb2R1Y3Q9YWRkQW55KGFkZEFueShhYyxzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCxhYyksYmQpLG4pKSxzaGlmdExlZnQoYmQsMipuKSk7dHJpbShwcm9kdWN0KTtyZXR1cm4gcHJvZHVjdH1mdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsbDIpe3JldHVybi0uMDEyKmwxLS4wMTIqbDIrMTVlLTYqbDEqbDI+MH1CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWUsc2lnbj10aGlzLnNpZ24hPT1uLnNpZ24sYWJzO2lmKG4uaXNTbWFsbCl7aWYoYj09PTApcmV0dXJuIEludGVnZXJbMF07aWYoYj09PTEpcmV0dXJuIHRoaXM7aWYoYj09PS0xKXJldHVybiB0aGlzLm5lZ2F0ZSgpO2Ficz1NYXRoLmFicyhiKTtpZihhYnM8QkFTRSl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYSxhYnMpLHNpZ24pfWI9c21hbGxUb0FycmF5KGFicyl9aWYodXNlS2FyYXRzdWJhKGEubGVuZ3RoLGIubGVuZ3RoKSlyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlLYXJhdHN1YmEoYSxiKSxzaWduKTtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsYiksc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzPUJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O2Z1bmN0aW9uIG11bHRpcGx5U21hbGxBbmRBcnJheShhLGIsc2lnbil7aWYoYTxCQVNFKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChiLGEpLHNpZ24pfXJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYixzbWFsbFRvQXJyYXkoYSkpLHNpZ24pfVNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbD1mdW5jdGlvbihhKXtpZihpc1ByZWNpc2UoYS52YWx1ZSp0aGlzLnZhbHVlKSl7cmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS52YWx1ZSp0aGlzLnZhbHVlKX1yZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSksdGhpcy5zaWduIT09YS5zaWduKX07QmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbD1mdW5jdGlvbihhKXtpZihhLnZhbHVlPT09MClyZXR1cm4gSW50ZWdlclswXTtpZihhLnZhbHVlPT09MSlyZXR1cm4gdGhpcztpZihhLnZhbHVlPT09LTEpcmV0dXJuIHRoaXMubmVnYXRlKCk7cmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSx0aGlzLnZhbHVlLHRoaXMuc2lnbiE9PWEuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odil7cmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50aW1lcz1TbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odil7cmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSpwYXJzZVZhbHVlKHYpLnZhbHVlKX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS50aW1lcz1OYXRpdmVCaWdJbnQucHJvdG90eXBlLm11bHRpcGx5O2Z1bmN0aW9uIHNxdWFyZShhKXt2YXIgbD1hLmxlbmd0aCxyPWNyZWF0ZUFycmF5KGwrbCksYmFzZT1CQVNFLHByb2R1Y3QsY2FycnksaSxhX2ksYV9qO2ZvcihpPTA7aTxsO2krKyl7YV9pPWFbaV07Y2Fycnk9MC1hX2kqYV9pO2Zvcih2YXIgaj1pO2o8bDtqKyspe2Ffaj1hW2pdO3Byb2R1Y3Q9MiooYV9pKmFfaikrcltpK2pdK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3IocHJvZHVjdC9iYXNlKTtyW2kral09cHJvZHVjdC1jYXJyeSpiYXNlfXJbaStsXT1jYXJyeX10cmltKHIpO3JldHVybiByfUJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUodGhpcy52YWx1ZSksZmFsc2UpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlKnRoaXMudmFsdWU7aWYoaXNQcmVjaXNlKHZhbHVlKSlyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZShzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpKSxmYWxzZSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKHYpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUqdGhpcy52YWx1ZSl9O2Z1bmN0aW9uIGRpdk1vZDEoYSxiKXt2YXIgYV9sPWEubGVuZ3RoLGJfbD1iLmxlbmd0aCxiYXNlPUJBU0UscmVzdWx0PWNyZWF0ZUFycmF5KGIubGVuZ3RoKSxkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQ9YltiX2wtMV0sbGFtYmRhPU1hdGguY2VpbChiYXNlLygyKmRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkpLHJlbWFpbmRlcj1tdWx0aXBseVNtYWxsKGEsbGFtYmRhKSxkaXZpc29yPW11bHRpcGx5U21hbGwoYixsYW1iZGEpLHF1b3RpZW50RGlnaXQsc2hpZnQsY2FycnksYm9ycm93LGksbCxxO2lmKHJlbWFpbmRlci5sZW5ndGg8PWFfbClyZW1haW5kZXIucHVzaCgwKTtkaXZpc29yLnB1c2goMCk7ZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0PWRpdmlzb3JbYl9sLTFdO2ZvcihzaGlmdD1hX2wtYl9sO3NoaWZ0Pj0wO3NoaWZ0LS0pe3F1b3RpZW50RGlnaXQ9YmFzZS0xO2lmKHJlbWFpbmRlcltzaGlmdCtiX2xdIT09ZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KXtxdW90aWVudERpZ2l0PU1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCtiX2xdKmJhc2UrcmVtYWluZGVyW3NoaWZ0K2JfbC0xXSkvZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KX1jYXJyeT0wO2JvcnJvdz0wO2w9ZGl2aXNvci5sZW5ndGg7Zm9yKGk9MDtpPGw7aSsrKXtjYXJyeSs9cXVvdGllbnREaWdpdCpkaXZpc29yW2ldO3E9TWF0aC5mbG9vcihjYXJyeS9iYXNlKTtib3Jyb3crPXJlbWFpbmRlcltzaGlmdCtpXS0oY2FycnktcSpiYXNlKTtjYXJyeT1xO2lmKGJvcnJvdzwwKXtyZW1haW5kZXJbc2hpZnQraV09Ym9ycm93K2Jhc2U7Ym9ycm93PS0xfWVsc2V7cmVtYWluZGVyW3NoaWZ0K2ldPWJvcnJvdztib3Jyb3c9MH19d2hpbGUoYm9ycm93IT09MCl7cXVvdGllbnREaWdpdC09MTtjYXJyeT0wO2ZvcihpPTA7aTxsO2krKyl7Y2FycnkrPXJlbWFpbmRlcltzaGlmdCtpXS1iYXNlK2Rpdmlzb3JbaV07aWYoY2Fycnk8MCl7cmVtYWluZGVyW3NoaWZ0K2ldPWNhcnJ5K2Jhc2U7Y2Fycnk9MH1lbHNle3JlbWFpbmRlcltzaGlmdCtpXT1jYXJyeTtjYXJyeT0xfX1ib3Jyb3crPWNhcnJ5fXJlc3VsdFtzaGlmdF09cXVvdGllbnREaWdpdH1yZW1haW5kZXI9ZGl2TW9kU21hbGwocmVtYWluZGVyLGxhbWJkYSlbMF07cmV0dXJuW2FycmF5VG9TbWFsbChyZXN1bHQpLGFycmF5VG9TbWFsbChyZW1haW5kZXIpXX1mdW5jdGlvbiBkaXZNb2QyKGEsYil7dmFyIGFfbD1hLmxlbmd0aCxiX2w9Yi5sZW5ndGgscmVzdWx0PVtdLHBhcnQ9W10sYmFzZT1CQVNFLGd1ZXNzLHhsZW4saGlnaHgsaGlnaHksY2hlY2s7d2hpbGUoYV9sKXtwYXJ0LnVuc2hpZnQoYVstLWFfbF0pO3RyaW0ocGFydCk7aWYoY29tcGFyZUFicyhwYXJ0LGIpPDApe3Jlc3VsdC5wdXNoKDApO2NvbnRpbnVlfXhsZW49cGFydC5sZW5ndGg7aGlnaHg9cGFydFt4bGVuLTFdKmJhc2UrcGFydFt4bGVuLTJdO2hpZ2h5PWJbYl9sLTFdKmJhc2UrYltiX2wtMl07aWYoeGxlbj5iX2wpe2hpZ2h4PShoaWdoeCsxKSpiYXNlfWd1ZXNzPU1hdGguY2VpbChoaWdoeC9oaWdoeSk7ZG97Y2hlY2s9bXVsdGlwbHlTbWFsbChiLGd1ZXNzKTtpZihjb21wYXJlQWJzKGNoZWNrLHBhcnQpPD0wKWJyZWFrO2d1ZXNzLS19d2hpbGUoZ3Vlc3MpO3Jlc3VsdC5wdXNoKGd1ZXNzKTtwYXJ0PXN1YnRyYWN0KHBhcnQsY2hlY2spfXJlc3VsdC5yZXZlcnNlKCk7cmV0dXJuW2FycmF5VG9TbWFsbChyZXN1bHQpLGFycmF5VG9TbWFsbChwYXJ0KV19ZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsbGFtYmRhKXt2YXIgbGVuZ3RoPXZhbHVlLmxlbmd0aCxxdW90aWVudD1jcmVhdGVBcnJheShsZW5ndGgpLGJhc2U9QkFTRSxpLHEscmVtYWluZGVyLGRpdmlzb3I7cmVtYWluZGVyPTA7Zm9yKGk9bGVuZ3RoLTE7aT49MDstLWkpe2Rpdmlzb3I9cmVtYWluZGVyKmJhc2UrdmFsdWVbaV07cT10cnVuY2F0ZShkaXZpc29yL2xhbWJkYSk7cmVtYWluZGVyPWRpdmlzb3ItcSpsYW1iZGE7cXVvdGllbnRbaV09cXwwfXJldHVybltxdW90aWVudCxyZW1haW5kZXJ8MF19ZnVuY3Rpb24gZGl2TW9kQW55KHNlbGYsdil7dmFyIHZhbHVlLG49cGFyc2VWYWx1ZSh2KTtpZihzdXBwb3J0c05hdGl2ZUJpZ0ludCl7cmV0dXJuW25ldyBOYXRpdmVCaWdJbnQoc2VsZi52YWx1ZS9uLnZhbHVlKSxuZXcgTmF0aXZlQmlnSW50KHNlbGYudmFsdWUlbi52YWx1ZSldfXZhciBhPXNlbGYudmFsdWUsYj1uLnZhbHVlO3ZhciBxdW90aWVudDtpZihiPT09MCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBkaXZpZGUgYnkgemVybyIpO2lmKHNlbGYuaXNTbWFsbCl7aWYobi5pc1NtYWxsKXtyZXR1cm5bbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhL2IpKSxuZXcgU21hbGxJbnRlZ2VyKGElYildfXJldHVybltJbnRlZ2VyWzBdLHNlbGZdfWlmKG4uaXNTbWFsbCl7aWYoYj09PTEpcmV0dXJuW3NlbGYsSW50ZWdlclswXV07aWYoYj09LTEpcmV0dXJuW3NlbGYubmVnYXRlKCksSW50ZWdlclswXV07dmFyIGFicz1NYXRoLmFicyhiKTtpZihhYnM8QkFTRSl7dmFsdWU9ZGl2TW9kU21hbGwoYSxhYnMpO3F1b3RpZW50PWFycmF5VG9TbWFsbCh2YWx1ZVswXSk7dmFyIHJlbWFpbmRlcj12YWx1ZVsxXTtpZihzZWxmLnNpZ24pcmVtYWluZGVyPS1yZW1haW5kZXI7aWYodHlwZW9mIHF1b3RpZW50PT09Im51bWJlciIpe2lmKHNlbGYuc2lnbiE9PW4uc2lnbilxdW90aWVudD0tcXVvdGllbnQ7cmV0dXJuW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV19cmV0dXJuW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LHNlbGYuc2lnbiE9PW4uc2lnbiksbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXX1iPXNtYWxsVG9BcnJheShhYnMpfXZhciBjb21wYXJpc29uPWNvbXBhcmVBYnMoYSxiKTtpZihjb21wYXJpc29uPT09LTEpcmV0dXJuW0ludGVnZXJbMF0sc2VsZl07aWYoY29tcGFyaXNvbj09PTApcmV0dXJuW0ludGVnZXJbc2VsZi5zaWduPT09bi5zaWduPzE6LTFdLEludGVnZXJbMF1dO2lmKGEubGVuZ3RoK2IubGVuZ3RoPD0yMDApdmFsdWU9ZGl2TW9kMShhLGIpO2Vsc2UgdmFsdWU9ZGl2TW9kMihhLGIpO3F1b3RpZW50PXZhbHVlWzBdO3ZhciBxU2lnbj1zZWxmLnNpZ24hPT1uLnNpZ24sbW9kPXZhbHVlWzFdLG1TaWduPXNlbGYuc2lnbjtpZih0eXBlb2YgcXVvdGllbnQ9PT0ibnVtYmVyIil7aWYocVNpZ24pcXVvdGllbnQ9LXF1b3RpZW50O3F1b3RpZW50PW5ldyBTbWFsbEludGVnZXIocXVvdGllbnQpfWVsc2UgcXVvdGllbnQ9bmV3IEJpZ0ludGVnZXIocXVvdGllbnQscVNpZ24pO2lmKHR5cGVvZiBtb2Q9PT0ibnVtYmVyIil7aWYobVNpZ24pbW9kPS1tb2Q7bW9kPW5ldyBTbWFsbEludGVnZXIobW9kKX1lbHNlIG1vZD1uZXcgQmlnSW50ZWdlcihtb2QsbVNpZ24pO3JldHVybltxdW90aWVudCxtb2RdfUJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZD1mdW5jdGlvbih2KXt2YXIgcmVzdWx0PWRpdk1vZEFueSh0aGlzLHYpO3JldHVybntxdW90aWVudDpyZXN1bHRbMF0scmVtYWluZGVyOnJlc3VsdFsxXX19O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZGl2bW9kPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kPUJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU9ZnVuY3Rpb24odil7cmV0dXJuIGRpdk1vZEFueSh0aGlzLHYpWzBdfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLm92ZXI9TmF0aXZlQmlnSW50LnByb3RvdHlwZS5kaXZpZGU9ZnVuY3Rpb24odil7cmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZS9wYXJzZVZhbHVlKHYpLnZhbHVlKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlPUJpZ0ludGVnZXIucHJvdG90eXBlLm92ZXI9QmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO0JpZ0ludGVnZXIucHJvdG90eXBlLm1vZD1mdW5jdGlvbih2KXtyZXR1cm4gZGl2TW9kQW55KHRoaXMsdilbMV19O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kPU5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucmVtYWluZGVyPWZ1bmN0aW9uKHYpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUlcGFyc2VWYWx1ZSh2KS52YWx1ZSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kPUJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2Q7QmlnSW50ZWdlci5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodiksYT10aGlzLnZhbHVlLGI9bi52YWx1ZSx2YWx1ZSx4LHk7aWYoYj09PTApcmV0dXJuIEludGVnZXJbMV07aWYoYT09PTApcmV0dXJuIEludGVnZXJbMF07aWYoYT09PTEpcmV0dXJuIEludGVnZXJbMV07aWYoYT09PS0xKXJldHVybiBuLmlzRXZlbigpP0ludGVnZXJbMV06SW50ZWdlclstMV07aWYobi5zaWduKXtyZXR1cm4gSW50ZWdlclswXX1pZighbi5pc1NtYWxsKXRocm93IG5ldyBFcnJvcigiVGhlIGV4cG9uZW50ICIrbi50b1N0cmluZygpKyIgaXMgdG9vIGxhcmdlLiIpO2lmKHRoaXMuaXNTbWFsbCl7aWYoaXNQcmVjaXNlKHZhbHVlPU1hdGgucG93KGEsYikpKXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSl9eD10aGlzO3k9SW50ZWdlclsxXTt3aGlsZSh0cnVlKXtpZihiJjE9PT0xKXt5PXkudGltZXMoeCk7LS1ifWlmKGI9PT0wKWJyZWFrO2IvPTI7eD14LnNxdWFyZSgpfXJldHVybiB5fTtTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3c7TmF0aXZlQmlnSW50LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KTt2YXIgYT10aGlzLnZhbHVlLGI9bi52YWx1ZTt2YXIgXzA9QmlnSW50KDApLF8xPUJpZ0ludCgxKSxfMj1CaWdJbnQoMik7aWYoYj09PV8wKXJldHVybiBJbnRlZ2VyWzFdO2lmKGE9PT1fMClyZXR1cm4gSW50ZWdlclswXTtpZihhPT09XzEpcmV0dXJuIEludGVnZXJbMV07aWYoYT09PUJpZ0ludCgtMSkpcmV0dXJuIG4uaXNFdmVuKCk/SW50ZWdlclsxXTpJbnRlZ2VyWy0xXTtpZihuLmlzTmVnYXRpdmUoKSlyZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChfMCk7dmFyIHg9dGhpczt2YXIgeT1JbnRlZ2VyWzFdO3doaWxlKHRydWUpe2lmKChiJl8xKT09PV8xKXt5PXkudGltZXMoeCk7LS1ifWlmKGI9PT1fMClicmVhaztiLz1fMjt4PXguc3F1YXJlKCl9cmV0dXJuIHl9O0JpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdz1mdW5jdGlvbihleHAsbW9kKXtleHA9cGFyc2VWYWx1ZShleHApO21vZD1wYXJzZVZhbHVlKG1vZCk7aWYobW9kLmlzWmVybygpKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwIik7dmFyIHI9SW50ZWdlclsxXSxiYXNlPXRoaXMubW9kKG1vZCk7aWYoZXhwLmlzTmVnYXRpdmUoKSl7ZXhwPWV4cC5tdWx0aXBseShJbnRlZ2VyWy0xXSk7YmFzZT1iYXNlLm1vZEludihtb2QpfXdoaWxlKGV4cC5pc1Bvc2l0aXZlKCkpe2lmKGJhc2UuaXNaZXJvKCkpcmV0dXJuIEludGVnZXJbMF07aWYoZXhwLmlzT2RkKCkpcj1yLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO2V4cD1leHAuZGl2aWRlKDIpO2Jhc2U9YmFzZS5zcXVhcmUoKS5tb2QobW9kKX1yZXR1cm4gcn07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2RQb3c9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c9QmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O2Z1bmN0aW9uIGNvbXBhcmVBYnMoYSxiKXtpZihhLmxlbmd0aCE9PWIubGVuZ3RoKXtyZXR1cm4gYS5sZW5ndGg+Yi5sZW5ndGg/MTotMX1mb3IodmFyIGk9YS5sZW5ndGgtMTtpPj0wO2ktLSl7aWYoYVtpXSE9PWJbaV0pcmV0dXJuIGFbaV0+YltpXT8xOi0xfXJldHVybiAwfUJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnM9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbClyZXR1cm4gMTtyZXR1cm4gY29tcGFyZUFicyhhLGIpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnM9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPU1hdGguYWJzKHRoaXMudmFsdWUpLGI9bi52YWx1ZTtpZihuLmlzU21hbGwpe2I9TWF0aC5hYnMoYik7cmV0dXJuIGE9PT1iPzA6YT5iPzE6LTF9cmV0dXJuLTF9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZUFicz1mdW5jdGlvbih2KXt2YXIgYT10aGlzLnZhbHVlO3ZhciBiPXBhcnNlVmFsdWUodikudmFsdWU7YT1hPj0wP2E6LWE7Yj1iPj0wP2I6LWI7cmV0dXJuIGE9PT1iPzA6YT5iPzE6LTF9O0JpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odil7aWYodj09PUluZmluaXR5KXtyZXR1cm4tMX1pZih2PT09LUluZmluaXR5KXtyZXR1cm4gMX12YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYodGhpcy5zaWduIT09bi5zaWduKXtyZXR1cm4gbi5zaWduPzE6LTF9aWYobi5pc1NtYWxsKXtyZXR1cm4gdGhpcy5zaWduPy0xOjF9cmV0dXJuIGNvbXBhcmVBYnMoYSxiKSoodGhpcy5zaWduPy0xOjEpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG89QmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odil7aWYodj09PUluZmluaXR5KXtyZXR1cm4tMX1pZih2PT09LUluZmluaXR5KXtyZXR1cm4gMX12YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtyZXR1cm4gYT09Yj8wOmE+Yj8xOi0xfWlmKGE8MCE9PW4uc2lnbil7cmV0dXJuIGE8MD8tMToxfXJldHVybiBhPDA/MTotMX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG89U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbih2KXtpZih2PT09SW5maW5pdHkpe3JldHVybi0xfWlmKHY9PT0tSW5maW5pdHkpe3JldHVybiAxfXZhciBhPXRoaXMudmFsdWU7dmFyIGI9cGFyc2VWYWx1ZSh2KS52YWx1ZTtyZXR1cm4gYT09PWI/MDphPmI/MTotMX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlVG89TmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlO0JpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPT09MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5lcT1OYXRpdmVCaWdJbnQucHJvdG90eXBlLmVxdWFscz1TbWFsbEludGVnZXIucHJvdG90eXBlLmVxPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzPUJpZ0ludGVnZXIucHJvdG90eXBlLmVxPUJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscztCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KSE9PTB9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmVxPU5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90RXF1YWxzPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVxPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzPUJpZ0ludGVnZXIucHJvdG90eXBlLm5lcT1CaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM7QmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPjB9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3Q9TmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3Q9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyPUJpZ0ludGVnZXIucHJvdG90eXBlLmd0PUJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI7QmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyPWZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLmNvbXBhcmUodik8MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5sdD1OYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3Nlcj1TbWFsbEludGVnZXIucHJvdG90eXBlLmx0PVNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyPUJpZ0ludGVnZXIucHJvdG90eXBlLmx0PUJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KT49MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5nZXE9TmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5nZXE9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxPUJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscztCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPD0wfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlcT1OYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVxPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUubGVxPUJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzO0JpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlWzBdJjEpPT09MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZSYxKT09PTB9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMudmFsdWUmQmlnSW50KDEpKT09PUJpZ0ludCgwKX07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZVswXSYxKT09PTF9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZSYxKT09PTF9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZSZCaWdJbnQoMSkpPT09QmlnSW50KDEpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc2lnbn07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU+MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1Bvc2l0aXZlPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2lnbn07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU8MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc05lZ2F0aXZlPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2V9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpPT09MX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1VuaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYnMoKS52YWx1ZT09PUJpZ0ludCgxKX07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPT09MH07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZT09PUJpZ0ludCgwKX07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeT1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpO2lmKG4uaXNaZXJvKCkpcmV0dXJuIGZhbHNlO2lmKG4uaXNVbml0KCkpcmV0dXJuIHRydWU7aWYobi5jb21wYXJlQWJzKDIpPT09MClyZXR1cm4gdGhpcy5pc0V2ZW4oKTtyZXR1cm4gdGhpcy5tb2QobikuaXNaZXJvKCl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNEaXZpc2libGVCeT1TbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk9QmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeTtmdW5jdGlvbiBpc0Jhc2ljUHJpbWUodil7dmFyIG49di5hYnMoKTtpZihuLmlzVW5pdCgpKXJldHVybiBmYWxzZTtpZihuLmVxdWFscygyKXx8bi5lcXVhbHMoMyl8fG4uZXF1YWxzKDUpKXJldHVybiB0cnVlO2lmKG4uaXNFdmVuKCl8fG4uaXNEaXZpc2libGVCeSgzKXx8bi5pc0RpdmlzaWJsZUJ5KDUpKXJldHVybiBmYWxzZTtpZihuLmxlc3Nlcig0OSkpcmV0dXJuIHRydWV9ZnVuY3Rpb24gbWlsbGVyUmFiaW5UZXN0KG4sYSl7dmFyIG5QcmV2PW4ucHJldigpLGI9blByZXYscj0wLGQsdCxpLHg7d2hpbGUoYi5pc0V2ZW4oKSliPWIuZGl2aWRlKDIpLHIrKztuZXh0OmZvcihpPTA7aTxhLmxlbmd0aDtpKyspe2lmKG4ubGVzc2VyKGFbaV0pKWNvbnRpbnVlO3g9YmlnSW50KGFbaV0pLm1vZFBvdyhiLG4pO2lmKHguaXNVbml0KCl8fHguZXF1YWxzKG5QcmV2KSljb250aW51ZTtmb3IoZD1yLTE7ZCE9MDtkLS0pe3g9eC5zcXVhcmUoKS5tb2Qobik7aWYoeC5pc1VuaXQoKSlyZXR1cm4gZmFsc2U7aWYoeC5lcXVhbHMoblByZXYpKWNvbnRpbnVlIG5leHR9cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfUJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWU9ZnVuY3Rpb24oc3RyaWN0KXt2YXIgaXNQcmltZT1pc0Jhc2ljUHJpbWUodGhpcyk7aWYoaXNQcmltZSE9PXVuZGVmaW5lZClyZXR1cm4gaXNQcmltZTt2YXIgbj10aGlzLmFicygpO3ZhciBiaXRzPW4uYml0TGVuZ3RoKCk7aWYoYml0czw9NjQpcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3XSk7dmFyIGxvZ049TWF0aC5sb2coMikqYml0cy50b0pTTnVtYmVyKCk7dmFyIHQ9TWF0aC5jZWlsKHN0cmljdD09PXRydWU/MipNYXRoLnBvdyhsb2dOLDIpOmxvZ04pO2Zvcih2YXIgYT1bXSxpPTA7aTx0O2krKyl7YS5wdXNoKGJpZ0ludChpKzIpKX1yZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sYSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcmltZT1TbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWU9QmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU9ZnVuY3Rpb24oaXRlcmF0aW9ucyxybmcpe3ZhciBpc1ByaW1lPWlzQmFzaWNQcmltZSh0aGlzKTtpZihpc1ByaW1lIT09dW5kZWZpbmVkKXJldHVybiBpc1ByaW1lO3ZhciBuPXRoaXMuYWJzKCk7dmFyIHQ9aXRlcmF0aW9ucz09PXVuZGVmaW5lZD81Oml0ZXJhdGlvbnM7Zm9yKHZhciBhPVtdLGk9MDtpPHQ7aSsrKXthLnB1c2goYmlnSW50LnJhbmRCZXR3ZWVuKDIsbi5taW51cygyKSxybmcpKX1yZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sYSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lPUJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY9ZnVuY3Rpb24obil7dmFyIHQ9YmlnSW50Lnplcm8sbmV3VD1iaWdJbnQub25lLHI9cGFyc2VWYWx1ZShuKSxuZXdSPXRoaXMuYWJzKCkscSxsYXN0VCxsYXN0Ujt3aGlsZSghbmV3Ui5pc1plcm8oKSl7cT1yLmRpdmlkZShuZXdSKTtsYXN0VD10O2xhc3RSPXI7dD1uZXdUO3I9bmV3UjtuZXdUPWxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO25ld1I9bGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSl9aWYoIXIuaXNVbml0KCkpdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSsiIGFuZCAiK24udG9TdHJpbmcoKSsiIGFyZSBub3QgY28tcHJpbWUiKTtpZih0LmNvbXBhcmUoMCk9PT0tMSl7dD10LmFkZChuKX1pZih0aGlzLmlzTmVnYXRpdmUoKSl7cmV0dXJuIHQubmVnYXRlKCl9cmV0dXJuIHR9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kSW52PVNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kSW52PUJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHZhbHVlPXRoaXMudmFsdWU7aWYodGhpcy5zaWduKXtyZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwxLHRoaXMuc2lnbil9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLDEpLHRoaXMuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlO2lmKHZhbHVlKzE8TUFYX0lOVClyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSsxKTtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsZmFsc2UpfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlK0JpZ0ludCgxKSl9O0JpZ0ludGVnZXIucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy52YWx1ZTtpZih0aGlzLnNpZ24pe3JldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwxKSx0cnVlKX1yZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwxLHRoaXMuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUucHJldj1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlO2lmKHZhbHVlLTE+LU1BWF9JTlQpcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUtMSk7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLHRydWUpfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlLUJpZ0ludCgxKSl9O3ZhciBwb3dlcnNPZlR3bz1bMV07d2hpbGUoMipwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGgtMV08PUJBU0UpcG93ZXJzT2ZUd28ucHVzaCgyKnBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aC0xXSk7dmFyIHBvd2VyczJMZW5ndGg9cG93ZXJzT2ZUd28ubGVuZ3RoLGhpZ2hlc3RQb3dlcjI9cG93ZXJzT2ZUd29bcG93ZXJzMkxlbmd0aC0xXTtmdW5jdGlvbiBzaGlmdF9pc1NtYWxsKG4pe3JldHVybiBNYXRoLmFicyhuKTw9QkFTRX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7aWYoIXNoaWZ0X2lzU21hbGwobikpe3Rocm93IG5ldyBFcnJvcihTdHJpbmcobikrIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLiIpfWlmKG48MClyZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KC1uKTt2YXIgcmVzdWx0PXRoaXM7aWYocmVzdWx0LmlzWmVybygpKXJldHVybiByZXN1bHQ7d2hpbGUobj49cG93ZXJzMkxlbmd0aCl7cmVzdWx0PXJlc3VsdC5tdWx0aXBseShoaWdoZXN0UG93ZXIyKTtuLT1wb3dlcnMyTGVuZ3RoLTF9cmV0dXJuIHJlc3VsdC5tdWx0aXBseShwb3dlcnNPZlR3b1tuXSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRMZWZ0PVNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0PUJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0PWZ1bmN0aW9uKHYpe3ZhciByZW1RdW87dmFyIG49cGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7aWYoIXNoaWZ0X2lzU21hbGwobikpe3Rocm93IG5ldyBFcnJvcihTdHJpbmcobikrIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLiIpfWlmKG48MClyZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO3ZhciByZXN1bHQ9dGhpczt3aGlsZShuPj1wb3dlcnMyTGVuZ3RoKXtpZihyZXN1bHQuaXNaZXJvKCl8fHJlc3VsdC5pc05lZ2F0aXZlKCkmJnJlc3VsdC5pc1VuaXQoKSlyZXR1cm4gcmVzdWx0O3JlbVF1bz1kaXZNb2RBbnkocmVzdWx0LGhpZ2hlc3RQb3dlcjIpO3Jlc3VsdD1yZW1RdW9bMV0uaXNOZWdhdGl2ZSgpP3JlbVF1b1swXS5wcmV2KCk6cmVtUXVvWzBdO24tPXBvd2VyczJMZW5ndGgtMX1yZW1RdW89ZGl2TW9kQW55KHJlc3VsdCxwb3dlcnNPZlR3b1tuXSk7cmV0dXJuIHJlbVF1b1sxXS5pc05lZ2F0aXZlKCk/cmVtUXVvWzBdLnByZXYoKTpyZW1RdW9bMF19O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRSaWdodD1TbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ9QmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtmdW5jdGlvbiBiaXR3aXNlKHgseSxmbil7eT1wYXJzZVZhbHVlKHkpO3ZhciB4U2lnbj14LmlzTmVnYXRpdmUoKSx5U2lnbj15LmlzTmVnYXRpdmUoKTt2YXIgeFJlbT14U2lnbj94Lm5vdCgpOngseVJlbT15U2lnbj95Lm5vdCgpOnk7dmFyIHhEaWdpdD0wLHlEaWdpdD0wO3ZhciB4RGl2TW9kPW51bGwseURpdk1vZD1udWxsO3ZhciByZXN1bHQ9W107d2hpbGUoIXhSZW0uaXNaZXJvKCl8fCF5UmVtLmlzWmVybygpKXt4RGl2TW9kPWRpdk1vZEFueSh4UmVtLGhpZ2hlc3RQb3dlcjIpO3hEaWdpdD14RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtpZih4U2lnbil7eERpZ2l0PWhpZ2hlc3RQb3dlcjItMS14RGlnaXR9eURpdk1vZD1kaXZNb2RBbnkoeVJlbSxoaWdoZXN0UG93ZXIyKTt5RGlnaXQ9eURpdk1vZFsxXS50b0pTTnVtYmVyKCk7aWYoeVNpZ24pe3lEaWdpdD1oaWdoZXN0UG93ZXIyLTEteURpZ2l0fXhSZW09eERpdk1vZFswXTt5UmVtPXlEaXZNb2RbMF07cmVzdWx0LnB1c2goZm4oeERpZ2l0LHlEaWdpdCkpfXZhciBzdW09Zm4oeFNpZ24/MTowLHlTaWduPzE6MCkhPT0wP2JpZ0ludCgtMSk6YmlnSW50KDApO2Zvcih2YXIgaT1yZXN1bHQubGVuZ3RoLTE7aT49MDtpLT0xKXtzdW09c3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSl9cmV0dXJuIHN1bX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZWdhdGUoKS5wcmV2KCl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90PVNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90PUJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ9ZnVuY3Rpb24obil7cmV0dXJuIGJpdHdpc2UodGhpcyxuLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEmYn0pfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFuZD1TbWFsbEludGVnZXIucHJvdG90eXBlLmFuZD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7QmlnSW50ZWdlci5wcm90b3R5cGUub3I9ZnVuY3Rpb24obil7cmV0dXJuIGJpdHdpc2UodGhpcyxuLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGF8Yn0pfTtOYXRpdmVCaWdJbnQucHJvdG90eXBlLm9yPVNtYWxsSW50ZWdlci5wcm90b3R5cGUub3I9QmlnSW50ZWdlci5wcm90b3R5cGUub3I7QmlnSW50ZWdlci5wcm90b3R5cGUueG9yPWZ1bmN0aW9uKG4pe3JldHVybiBiaXR3aXNlKHRoaXMsbixmdW5jdGlvbihhLGIpe3JldHVybiBhXmJ9KX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS54b3I9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS54b3I9QmlnSW50ZWdlci5wcm90b3R5cGUueG9yO3ZhciBMT0JNQVNLX0k9MTw8MzAsTE9CTUFTS19CST0oQkFTRSYtQkFTRSkqKEJBU0UmLUJBU0UpfExPQk1BU0tfSTtmdW5jdGlvbiByb3VnaExPQihuKXt2YXIgdj1uLnZhbHVlLHg9dHlwZW9mIHY9PT0ibnVtYmVyIj92fExPQk1BU0tfSTp0eXBlb2Ygdj09PSJiaWdpbnQiP3Z8QmlnSW50KExPQk1BU0tfSSk6dlswXSt2WzFdKkJBU0V8TE9CTUFTS19CSTtyZXR1cm4geCYteH1mdW5jdGlvbiBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLGJhc2Upe2lmKGJhc2UuY29tcGFyZVRvKHZhbHVlKTw9MCl7dmFyIHRtcD1pbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLGJhc2Uuc3F1YXJlKGJhc2UpKTt2YXIgcD10bXAucDt2YXIgZT10bXAuZTt2YXIgdD1wLm11bHRpcGx5KGJhc2UpO3JldHVybiB0LmNvbXBhcmVUbyh2YWx1ZSk8PTA/e3A6dCxlOmUqMisxfTp7cDpwLGU6ZSoyfX1yZXR1cm57cDpiaWdJbnQoMSksZTowfX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2lmKG4uY29tcGFyZVRvKGJpZ0ludCgwKSk8MCl7bj1uLm5lZ2F0ZSgpLnN1YnRyYWN0KGJpZ0ludCgxKSl9aWYobi5jb21wYXJlVG8oYmlnSW50KDApKT09PTApe3JldHVybiBiaWdJbnQoMCl9cmV0dXJuIGJpZ0ludChpbnRlZ2VyTG9nYXJpdGhtKG4sYmlnSW50KDIpKS5lKS5hZGQoYmlnSW50KDEpKX07TmF0aXZlQmlnSW50LnByb3RvdHlwZS5iaXRMZW5ndGg9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg9QmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoO2Z1bmN0aW9uIG1heChhLGIpe2E9cGFyc2VWYWx1ZShhKTtiPXBhcnNlVmFsdWUoYik7cmV0dXJuIGEuZ3JlYXRlcihiKT9hOmJ9ZnVuY3Rpb24gbWluKGEsYil7YT1wYXJzZVZhbHVlKGEpO2I9cGFyc2VWYWx1ZShiKTtyZXR1cm4gYS5sZXNzZXIoYik/YTpifWZ1bmN0aW9uIGdjZChhLGIpe2E9cGFyc2VWYWx1ZShhKS5hYnMoKTtiPXBhcnNlVmFsdWUoYikuYWJzKCk7aWYoYS5lcXVhbHMoYikpcmV0dXJuIGE7aWYoYS5pc1plcm8oKSlyZXR1cm4gYjtpZihiLmlzWmVybygpKXJldHVybiBhO3ZhciBjPUludGVnZXJbMV0sZCx0O3doaWxlKGEuaXNFdmVuKCkmJmIuaXNFdmVuKCkpe2Q9bWluKHJvdWdoTE9CKGEpLHJvdWdoTE9CKGIpKTthPWEuZGl2aWRlKGQpO2I9Yi5kaXZpZGUoZCk7Yz1jLm11bHRpcGx5KGQpfXdoaWxlKGEuaXNFdmVuKCkpe2E9YS5kaXZpZGUocm91Z2hMT0IoYSkpfWRve3doaWxlKGIuaXNFdmVuKCkpe2I9Yi5kaXZpZGUocm91Z2hMT0IoYikpfWlmKGEuZ3JlYXRlcihiKSl7dD1iO2I9YTthPXR9Yj1iLnN1YnRyYWN0KGEpfXdoaWxlKCFiLmlzWmVybygpKTtyZXR1cm4gYy5pc1VuaXQoKT9hOmEubXVsdGlwbHkoYyl9ZnVuY3Rpb24gbGNtKGEsYil7YT1wYXJzZVZhbHVlKGEpLmFicygpO2I9cGFyc2VWYWx1ZShiKS5hYnMoKTtyZXR1cm4gYS5kaXZpZGUoZ2NkKGEsYikpLm11bHRpcGx5KGIpfWZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsYixybmcpe2E9cGFyc2VWYWx1ZShhKTtiPXBhcnNlVmFsdWUoYik7dmFyIHVzZWRSTkc9cm5nfHxNYXRoLnJhbmRvbTt2YXIgbG93PW1pbihhLGIpLGhpZ2g9bWF4KGEsYik7dmFyIHJhbmdlPWhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7aWYocmFuZ2UuaXNTbWFsbClyZXR1cm4gbG93LmFkZChNYXRoLmZsb29yKHVzZWRSTkcoKSpyYW5nZSkpO3ZhciBkaWdpdHM9dG9CYXNlKHJhbmdlLEJBU0UpLnZhbHVlO3ZhciByZXN1bHQ9W10scmVzdHJpY3RlZD10cnVlO2Zvcih2YXIgaT0wO2k8ZGlnaXRzLmxlbmd0aDtpKyspe3ZhciB0b3A9cmVzdHJpY3RlZD9kaWdpdHNbaV06QkFTRTt2YXIgZGlnaXQ9dHJ1bmNhdGUodXNlZFJORygpKnRvcCk7cmVzdWx0LnB1c2goZGlnaXQpO2lmKGRpZ2l0PHRvcClyZXN0cmljdGVkPWZhbHNlfXJldHVybiBsb3cuYWRkKEludGVnZXIuZnJvbUFycmF5KHJlc3VsdCxCQVNFLGZhbHNlKSl9dmFyIHBhcnNlQmFzZT1mdW5jdGlvbih0ZXh0LGJhc2UsYWxwaGFiZXQsY2FzZVNlbnNpdGl2ZSl7YWxwaGFiZXQ9YWxwaGFiZXR8fERFRkFVTFRfQUxQSEFCRVQ7dGV4dD1TdHJpbmcodGV4dCk7aWYoIWNhc2VTZW5zaXRpdmUpe3RleHQ9dGV4dC50b0xvd2VyQ2FzZSgpO2FscGhhYmV0PWFscGhhYmV0LnRvTG93ZXJDYXNlKCl9dmFyIGxlbmd0aD10ZXh0Lmxlbmd0aDt2YXIgaTt2YXIgYWJzQmFzZT1NYXRoLmFicyhiYXNlKTt2YXIgYWxwaGFiZXRWYWx1ZXM9e307Zm9yKGk9MDtpPGFscGhhYmV0Lmxlbmd0aDtpKyspe2FscGhhYmV0VmFsdWVzW2FscGhhYmV0W2ldXT1pfWZvcihpPTA7aTxsZW5ndGg7aSsrKXt2YXIgYz10ZXh0W2ldO2lmKGM9PT0iLSIpY29udGludWU7aWYoYyBpbiBhbHBoYWJldFZhbHVlcyl7aWYoYWxwaGFiZXRWYWx1ZXNbY10+PWFic0Jhc2Upe2lmKGM9PT0iMSImJmFic0Jhc2U9PT0xKWNvbnRpbnVlO3Rocm93IG5ldyBFcnJvcihjKyIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSAiK2Jhc2UrIi4iKX19fWJhc2U9cGFyc2VWYWx1ZShiYXNlKTt2YXIgZGlnaXRzPVtdO3ZhciBpc05lZ2F0aXZlPXRleHRbMF09PT0iLSI7Zm9yKGk9aXNOZWdhdGl2ZT8xOjA7aTx0ZXh0Lmxlbmd0aDtpKyspe3ZhciBjPXRleHRbaV07aWYoYyBpbiBhbHBoYWJldFZhbHVlcylkaWdpdHMucHVzaChwYXJzZVZhbHVlKGFscGhhYmV0VmFsdWVzW2NdKSk7ZWxzZSBpZihjPT09IjwiKXt2YXIgc3RhcnQ9aTtkb3tpKyt9d2hpbGUodGV4dFtpXSE9PSI+IiYmaTx0ZXh0Lmxlbmd0aCk7ZGlnaXRzLnB1c2gocGFyc2VWYWx1ZSh0ZXh0LnNsaWNlKHN0YXJ0KzEsaSkpKX1lbHNlIHRocm93IG5ldyBFcnJvcihjKyIgaXMgbm90IGEgdmFsaWQgY2hhcmFjdGVyIil9cmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsYmFzZSxpc05lZ2F0aXZlKX07ZnVuY3Rpb24gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cyxiYXNlLGlzTmVnYXRpdmUpe3ZhciB2YWw9SW50ZWdlclswXSxwb3c9SW50ZWdlclsxXSxpO2ZvcihpPWRpZ2l0cy5sZW5ndGgtMTtpPj0wO2ktLSl7dmFsPXZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO3Bvdz1wb3cudGltZXMoYmFzZSl9cmV0dXJuIGlzTmVnYXRpdmU/dmFsLm5lZ2F0ZSgpOnZhbH1mdW5jdGlvbiBzdHJpbmdpZnkoZGlnaXQsYWxwaGFiZXQpe2FscGhhYmV0PWFscGhhYmV0fHxERUZBVUxUX0FMUEhBQkVUO2lmKGRpZ2l0PGFscGhhYmV0Lmxlbmd0aCl7cmV0dXJuIGFscGhhYmV0W2RpZ2l0XX1yZXR1cm4iPCIrZGlnaXQrIj4ifWZ1bmN0aW9uIHRvQmFzZShuLGJhc2Upe2Jhc2U9YmlnSW50KGJhc2UpO2lmKGJhc2UuaXNaZXJvKCkpe2lmKG4uaXNaZXJvKCkpcmV0dXJue3ZhbHVlOlswXSxpc05lZ2F0aXZlOmZhbHNlfTt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuIil9aWYoYmFzZS5lcXVhbHMoLTEpKXtpZihuLmlzWmVybygpKXJldHVybnt2YWx1ZTpbMF0saXNOZWdhdGl2ZTpmYWxzZX07aWYobi5pc05lZ2F0aXZlKCkpcmV0dXJue3ZhbHVlOltdLmNvbmNhdC5hcHBseShbXSxBcnJheS5hcHBseShudWxsLEFycmF5KC1uLnRvSlNOdW1iZXIoKSkpLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZixbMSwwXSkpLGlzTmVnYXRpdmU6ZmFsc2V9O3ZhciBhcnI9QXJyYXkuYXBwbHkobnVsbCxBcnJheShuLnRvSlNOdW1iZXIoKS0xKSkubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLFswLDFdKTthcnIudW5zaGlmdChbMV0pO3JldHVybnt2YWx1ZTpbXS5jb25jYXQuYXBwbHkoW10sYXJyKSxpc05lZ2F0aXZlOmZhbHNlfX12YXIgbmVnPWZhbHNlO2lmKG4uaXNOZWdhdGl2ZSgpJiZiYXNlLmlzUG9zaXRpdmUoKSl7bmVnPXRydWU7bj1uLmFicygpfWlmKGJhc2UuaXNVbml0KCkpe2lmKG4uaXNaZXJvKCkpcmV0dXJue3ZhbHVlOlswXSxpc05lZ2F0aXZlOmZhbHNlfTtyZXR1cm57dmFsdWU6QXJyYXkuYXBwbHkobnVsbCxBcnJheShuLnRvSlNOdW1iZXIoKSkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsMSksaXNOZWdhdGl2ZTpuZWd9fXZhciBvdXQ9W107dmFyIGxlZnQ9bixkaXZtb2Q7d2hpbGUobGVmdC5pc05lZ2F0aXZlKCl8fGxlZnQuY29tcGFyZUFicyhiYXNlKT49MCl7ZGl2bW9kPWxlZnQuZGl2bW9kKGJhc2UpO2xlZnQ9ZGl2bW9kLnF1b3RpZW50O3ZhciBkaWdpdD1kaXZtb2QucmVtYWluZGVyO2lmKGRpZ2l0LmlzTmVnYXRpdmUoKSl7ZGlnaXQ9YmFzZS5taW51cyhkaWdpdCkuYWJzKCk7bGVmdD1sZWZ0Lm5leHQoKX1vdXQucHVzaChkaWdpdC50b0pTTnVtYmVyKCkpfW91dC5wdXNoKGxlZnQudG9KU051bWJlcigpKTtyZXR1cm57dmFsdWU6b3V0LnJldmVyc2UoKSxpc05lZ2F0aXZlOm5lZ319ZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sYmFzZSxhbHBoYWJldCl7dmFyIGFycj10b0Jhc2UobixiYXNlKTtyZXR1cm4oYXJyLmlzTmVnYXRpdmU/Ii0iOiIiKSthcnIudmFsdWUubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBzdHJpbmdpZnkoeCxhbHBoYWJldCl9KS5qb2luKCIiKX1CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKHJhZGl4KXtyZXR1cm4gdG9CYXNlKHRoaXMscmFkaXgpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24ocmFkaXgpe3JldHVybiB0b0Jhc2UodGhpcyxyYWRpeCl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihyYWRpeCl7cmV0dXJuIHRvQmFzZSh0aGlzLHJhZGl4KX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24ocmFkaXgsYWxwaGFiZXQpe2lmKHJhZGl4PT09dW5kZWZpbmVkKXJhZGl4PTEwO2lmKHJhZGl4IT09MTApcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLHJhZGl4LGFscGhhYmV0KTt2YXIgdj10aGlzLnZhbHVlLGw9di5sZW5ndGgsc3RyPVN0cmluZyh2Wy0tbF0pLHplcm9zPSIwMDAwMDAwIixkaWdpdDt3aGlsZSgtLWw+PTApe2RpZ2l0PVN0cmluZyh2W2xdKTtzdHIrPXplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkrZGlnaXR9dmFyIHNpZ249dGhpcy5zaWduPyItIjoiIjtyZXR1cm4gc2lnbitzdHJ9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24ocmFkaXgsYWxwaGFiZXQpe2lmKHJhZGl4PT09dW5kZWZpbmVkKXJhZGl4PTEwO2lmKHJhZGl4IT0xMClyZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMscmFkaXgsYWxwaGFiZXQpO3JldHVybiBTdHJpbmcodGhpcy52YWx1ZSl9O05hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9TdHJpbmc9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZztOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvSlNPTj1CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTT049U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b1N0cmluZygpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwxMCl9O0JpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXI9QmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtOYXRpdmVCaWdJbnQucHJvdG90eXBlLnZhbHVlT2Y9TmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0pTTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwxMCl9O2Z1bmN0aW9uIHBhcnNlU3RyaW5nVmFsdWUodil7aWYoaXNQcmVjaXNlKCt2KSl7dmFyIHg9K3Y7aWYoeD09PXRydW5jYXRlKHgpKXJldHVybiBzdXBwb3J0c05hdGl2ZUJpZ0ludD9uZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh4KSk6bmV3IFNtYWxsSW50ZWdlcih4KTt0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgaW50ZWdlcjogIit2KX12YXIgc2lnbj12WzBdPT09Ii0iO2lmKHNpZ24pdj12LnNsaWNlKDEpO3ZhciBzcGxpdD12LnNwbGl0KC9lL2kpO2lmKHNwbGl0Lmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBpbnRlZ2VyOiAiK3NwbGl0LmpvaW4oImUiKSk7aWYoc3BsaXQubGVuZ3RoPT09Mil7dmFyIGV4cD1zcGxpdFsxXTtpZihleHBbMF09PT0iKyIpZXhwPWV4cC5zbGljZSgxKTtleHA9K2V4cDtpZihleHAhPT10cnVuY2F0ZShleHApfHwhaXNQcmVjaXNlKGV4cCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGludGVnZXI6ICIrZXhwKyIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuIik7dmFyIHRleHQ9c3BsaXRbMF07dmFyIGRlY2ltYWxQbGFjZT10ZXh0LmluZGV4T2YoIi4iKTtpZihkZWNpbWFsUGxhY2U+PTApe2V4cC09dGV4dC5sZW5ndGgtZGVjaW1hbFBsYWNlLTE7dGV4dD10ZXh0LnNsaWNlKDAsZGVjaW1hbFBsYWNlKSt0ZXh0LnNsaWNlKGRlY2ltYWxQbGFjZSsxKX1pZihleHA8MCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBpbmNsdWRlIG5lZ2F0aXZlIGV4cG9uZW50IHBhcnQgZm9yIGludGVnZXJzIik7dGV4dCs9bmV3IEFycmF5KGV4cCsxKS5qb2luKCIwIik7dj10ZXh0fXZhciBpc1ZhbGlkPS9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7aWYoIWlzVmFsaWQpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGludGVnZXI6ICIrdik7aWYoc3VwcG9ydHNOYXRpdmVCaWdJbnQpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludChzaWduPyItIit2OnYpKX12YXIgcj1bXSxtYXg9di5sZW5ndGgsbD1MT0dfQkFTRSxtaW49bWF4LWw7d2hpbGUobWF4PjApe3IucHVzaCgrdi5zbGljZShtaW4sbWF4KSk7bWluLT1sO2lmKG1pbjwwKW1pbj0wO21heC09bH10cmltKHIpO3JldHVybiBuZXcgQmlnSW50ZWdlcihyLHNpZ24pfWZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodil7aWYoc3VwcG9ydHNOYXRpdmVCaWdJbnQpe3JldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh2KSl9aWYoaXNQcmVjaXNlKHYpKXtpZih2IT09dHJ1bmNhdGUodikpdGhyb3cgbmV3IEVycm9yKHYrIiBpcyBub3QgYW4gaW50ZWdlci4iKTtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2KX1yZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2LnRvU3RyaW5nKCkpfWZ1bmN0aW9uIHBhcnNlVmFsdWUodil7aWYodHlwZW9mIHY9PT0ibnVtYmVyIil7cmV0dXJuIHBhcnNlTnVtYmVyVmFsdWUodil9aWYodHlwZW9mIHY9PT0ic3RyaW5nIil7cmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodil9aWYodHlwZW9mIHY9PT0iYmlnaW50Iil7cmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodil9cmV0dXJuIHZ9Zm9yKHZhciBpPTA7aTwxZTM7aSsrKXtJbnRlZ2VyW2ldPXBhcnNlVmFsdWUoaSk7aWYoaT4wKUludGVnZXJbLWldPXBhcnNlVmFsdWUoLWkpfUludGVnZXIub25lPUludGVnZXJbMV07SW50ZWdlci56ZXJvPUludGVnZXJbMF07SW50ZWdlci5taW51c09uZT1JbnRlZ2VyWy0xXTtJbnRlZ2VyLm1heD1tYXg7SW50ZWdlci5taW49bWluO0ludGVnZXIuZ2NkPWdjZDtJbnRlZ2VyLmxjbT1sY207SW50ZWdlci5pc0luc3RhbmNlPWZ1bmN0aW9uKHgpe3JldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlcnx8eCBpbnN0YW5jZW9mIFNtYWxsSW50ZWdlcnx8eCBpbnN0YW5jZW9mIE5hdGl2ZUJpZ0ludH07SW50ZWdlci5yYW5kQmV0d2Vlbj1yYW5kQmV0d2VlbjtJbnRlZ2VyLmZyb21BcnJheT1mdW5jdGlvbihkaWdpdHMsYmFzZSxpc05lZ2F0aXZlKXtyZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cy5tYXAocGFyc2VWYWx1ZSkscGFyc2VWYWx1ZShiYXNlfHwxMCksaXNOZWdhdGl2ZSl9O3JldHVybiBJbnRlZ2VyfSgpO2lmKHR5cGVvZiBtb2R1bGUhPT0idW5kZWZpbmVkIiYmbW9kdWxlLmhhc093blByb3BlcnR5KCJleHBvcnRzIikpe21vZHVsZS5leHBvcnRzPWJpZ0ludH1pZih0eXBlb2YgZGVmaW5lPT09ImZ1bmN0aW9uIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGJpZ0ludH0pfQ==`;
function getBigIntegerBlobUri() {
    const libInlineScript = self.atob(_bigIntScriptDecoded);
    const libBlob = new Blob([libInlineScript], { type: 'text/javascript' });
    return URL.createObjectURL(libBlob);
}
function getCurrentNTPTimestamp(timestamp = Date.now()) {
    let ret = '0';
    const epoch_diff = 2208988800;
    try {
        const ntp_timestamp_msb = Math.floor(timestamp / 1000) + epoch_diff;
        const ntp_timestamp_lsb = Math.round(Math.round(timestamp % 1000) * Math.pow(2, 32) / 1000);
        const ntp_timestamp = self['bigInt'](ntp_timestamp_msb).shiftLeft(32).plus(ntp_timestamp_lsb);
        ret = ntp_timestamp.toString();
    }
    catch (err) {
        console.error(err);
    }
    return ret;
}
class HunterProviderContext {
}
exports.HunterProviderContext = HunterProviderContext;
class HunterProvider {
    constructor(_eventDispatcher, _simplifiedVidyoCore, _logger) {
        this._eventDispatcher = _eventDispatcher;
        this._simplifiedVidyoCore = _simplifiedVidyoCore;
        this._logger = _logger;
        this._presenceHelper = new PresenceHelper(this._logger);
        this._xmlhttp = null;
        this._ws_connection_string = "";
        this._context = new HunterProviderContext();
        this._context.localUri = "";
        this._context.remoteUri = "";
    }
    AddStream(stream, renegotiate) {
        let provider = this;
        let promise = new Promise((resolve, reject) => {
            provider._scipMediaSession.AddStream(stream);
        });
        return promise;
    }
    ConferenceJoin(identity, parameter) {
        this._cmcpConferenceDialogSession = this._scipSession.CreateDialogSessionAndSendConferenceJoin(identity.LocalId);
        let provider = this;
        let schema = "http";
        if (this._options.secure) {
            schema += 's';
        }
        this._eventDispatcher.once(ConferenceEvents.Events.ConferenceAccepted.Scoped(identity.LocalId), () => {
            provider._presenceHelper
                .StartPresence(`${schema}://${provider._options.host}/api/guest/v1/presenceUpdate`, provider._context.authToken, (error) => {
                provider._logger.LogError(error || 'Failure sending presenceUpdate', LogEvents_1.VidyoLogCategory.VidyoSignaling, 'Send presenceUpdate');
                if (provider._scipSession.state == ScipSession_1.SessionState.Active) {
                    provider._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents_1.ConnectionEventsInfo.ConnectionLost);
                }
                else {
                    provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ConferenceFailed);
                }
            }, (response) => {
                if (response.status === 'OK') {
                    this._context.jwtToken = response.jwtToken;
                }
            });
        });
        let result = { from: '',
            id: '',
            to: '',
        };
        return Promise.resolve(result);
    }
    ConferenceLeave(identity, parameter) {
        this._cmcpConferenceDialogSession.SendLeaveConference();
        return Promise.resolve(true);
    }
    ConferenceShow(identity, parameter) {
        this._cmcpConferenceDialogSession.SendConferenceShow(parameter);
        return Promise.resolve(true);
    }
    ConferenceShowSelected(identity, parameter) {
        this._cmcpConferenceDialogSession.SendConferenceShowSelected(parameter);
        return Promise.resolve(true);
    }
    ConferenceUpdate(identity, parameter) {
        return Promise.resolve(true);
    }
    Connect() {
        let provider = this;
        this._xmlhttp = new XMLHttpRequest();
        let schema = "http";
        if (this._options.secure) {
            schema += 's';
        }
        this._xmlhttp.open("POST", `${schema}://${this._options.host}/api/guest/v1/joinWeb`);
        this._xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        this._xmlhttp.onreadystatechange = function () {
            if (provider._xmlhttp.readyState === XMLHttpRequest.DONE) {
                provider._logger.LogDebug(provider._xmlhttp.response);
                if (provider._xmlhttp.response == '') {
                    provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.SignallingTransportError);
                    return;
                }
                try {
                    let response_body = JSON.parse(provider._xmlhttp.response);
                    if (response_body.errorCode == undefined) {
                        provider._ws_connection_string = response_body.websocketURI;
                        provider._context.routerId = response_body.routerId;
                        provider._context.remoteUri = response_body.routerURI;
                        provider._context.roomName = response_body.conferenceId;
                        provider._context.roomId = response_body.roomId;
                        provider._context.authToken = response_body.authToken;
                        provider._context.turnUri = response_body.turnURI;
                        provider._context.userId = response_body.userId;
                        provider._context.userName = response_body.username;
                        provider._context.eventServerURL = response_body.eventServerURL;
                        provider._context.jwtToken = response_body.jwtToken;
                        provider._context.portalDetails = response_body.portalDetails;
                        let transport = 'transport=TLS';
                        if (response_body.routerURI.split(';').length == 2) {
                            transport = response_body.routerURI.split(';')[1];
                        }
                        provider._context.localUri = `scip:${response_body.participantId};${transport}`;
                        provider._context.endpointId = provider._context.localUri;
                        provider._logger.UpdateEndpointId(provider._context.endpointId);
                        provider._logger.UpdateUserId(provider._context.userId);
                        provider._connection = new WebSocketTransport.Connection(provider._logger, provider._ws_connection_string, provider._scipSession);
                        provider._connection.connect();
                        let confPayload = {
                            reflector: provider._context.remoteUri,
                            id: provider._context.roomName,
                            displayName: response_body.roomDisplayName,
                            properties: []
                        };
                        if (response_body.portalDetails.maxSendBandWidth && typeof response_body.portalDetails.maxSendBandWidth === 'number') {
                            confPayload.properties.push({ name: 'maxSendBandwith', type: 'number', value: response_body.portalDetails.maxSendBandWidth });
                        }
                        if (response_body.portalDetails.maxRecvBandWidth && typeof response_body.portalDetails.maxRecvBandWidth === 'number') {
                            confPayload.properties.push({ name: 'maxRecvBandwith', type: 'number', value: response_body.portalDetails.maxRecvBandWidth });
                        }
                        provider._eventDispatcher.emit(ConnectionEvents.Events.MediaConf, confPayload);
                        const tokenData = StringUtils_1.default.parseJwt(provider._context.jwtToken);
                        const connectedPayload = {
                            isSecure: true,
                            result: "all good",
                            guestId: tokenData?.userId,
                            userName: provider._context.userName
                        };
                        provider._eventDispatcher.emit(ConnectionEvents.Events.Connected, connectedPayload);
                        provider.jid = {
                            "bare": provider._context.localUri,
                            "domain": "",
                            "full": provider._context.localUri,
                            "local": "",
                            "resource": provider._context.localUri
                        };
                        provider._eventServerSession.Connect(provider._context.eventServerURL, provider._context.jwtToken, response_body.endpointId);
                    }
                    else {
                        provider._logger.LogError(() => `${response_body.errorCode}, ${response_body.message}`);
                        switch (response_body.errorCode) {
                            case "6001":
                            case "6035":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.InvalidRoom);
                                break;
                            case "6002":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.InvalidToken);
                                break;
                            case "6005":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.AllLinesInUse);
                                break;
                            case "6009":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ResourceLocked);
                                break;
                            case "6011":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ResourceDisabled);
                                break;
                            case "6010":
                            case "6013":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.InvalidUser);
                                break;
                            case "6015":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ResourceFull);
                                break;
                            case "6036":
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.InvalidDisplayName);
                                break;
                            case "6006":
                            case "6030":
                            case "6032":
                            default:
                                provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.ConferenceFailed);
                        }
                    }
                }
                catch (object) {
                    console.error(object);
                    provider._eventDispatcher.emit(ConnectionEvents.Events.ConferenceFailed, ConnectionEvents_1.ConnectionEventsInfo.SignallingTransportError);
                }
            }
        };
        let request_body = {
            displayName: this._context.displayName,
            endpointDetails: {
                applicationName: EndpointInfoProvider_1.EndpointInfoProvider.ApplicationName,
                applicationOs: EndpointInfoProvider_1.EndpointInfoProvider.ApplicationOS,
                applicationVersion: EndpointInfoProvider_1.EndpointInfoProvider.ApplicationVersion,
                lectureMode: true
            },
            notifications: 'vcap1',
            roomKey: this._options.roomKey,
            timestamp: getCurrentNTPTimestamp(),
        };
        if (this._options.locationTag && this._options.locationTag !== '') {
            request_body.locationTag = this._options.locationTag;
        }
        if (this._options.roomPin && this._options.roomPin !== '') {
            request_body.roomPin = this._options.roomPin;
        }
        if (this._options.extData && this._options.extData !== '' && this._options.extDataType) {
            request_body.endpointDetails.extDataType = this._options.extDataType;
            request_body.endpointDetails.extData = this._options.extData;
        }
        this._xmlhttp.send(JSON.stringify(request_body));
    }
    CreateClient(options) {
        this._options = options;
        this._context.displayName = options.displayName || "";
        this._eventServerSession = new EventServerSession_1.EventServerSession(this._eventDispatcher, this._logger);
        this._scipSession = new ScipSession_1.ScipSession(this, this._eventDispatcher, this._logger, this._context);
        const mediaSessionOptions = {
            enableTCPTransport: options.enableTCPTransport,
            enableUDPTransport: options.enableUDPTransport,
            enableScreenShareSimulcast: options.enableScreenShareSimulcast,
            enableVideoSimulcast: options.enableVideoSimulcast
        };
        this._scipMediaSession = new ScipMediaSession.MediaSession(this, this._context, this._simplifiedVidyoCore.LocalStreamController, this._simplifiedVidyoCore.RemoteStreamController, this._simplifiedVidyoCore.TransmittedStreamController, this._eventDispatcher, this._logger, mediaSessionOptions);
        return this._scipMediaSession;
    }
    Disconnect() {
        if (this._xmlhttp && this._xmlhttp.readyState !== XMLHttpRequest.DONE) {
            this._xmlhttp.abort();
        }
        if (this._eventServerSession) {
            this._eventServerSession.Close();
        }
        if (this._scipMediaSession) {
            this._scipMediaSession.Close();
        }
        if (this._scipSession) {
            this._scipSession.Disconnect();
        }
        if (this._connection) {
            this._connection.disconnect();
        }
        this._presenceHelper.StopPresence();
        this._xmlhttp = null;
    }
    GetStats() {
        if (this._scipMediaSession) {
            return this._scipMediaSession.GetStats();
        }
        return Promise.reject();
    }
    GetTrackEncodingParameters(trackId) {
        if (this._scipMediaSession) {
            return this._scipMediaSession.GetTrackEncodingParameters(trackId);
        }
        return [];
    }
    Jid() {
        return this.jid;
    }
    JoinRoom() {
        this._scipMediaSession._initPeerConnection();
        return Promise.resolve({ roomId: this._context.roomId, roomName: this._context.roomName });
    }
    LeaveRoom() {
        if (this._scipMediaSession) {
            this._scipMediaSession.Close();
        }
        if (this._scipSession) {
            this._scipSession.Disconnect();
        }
        return Promise.resolve();
    }
    MediaStart(options) {
        this._scipSession.StartMedia(options);
    }
    MuteAudio(mute) {
        if (this._scipMediaSession) {
            this._scipMediaSession.UpdateMediaStates(true);
        }
    }
    RemoveStream(stream) {
        let promise = new Promise((resolve, reject) => {
            resolve({ ssrcs: [] });
        });
        return promise;
    }
    async RequestConferenceState() {
        if (!this._context.roomId) {
            return Promise.resolve(false);
        }
        const schema = this._options.secure ? 'https' : 'http';
        try {
            const response = await fetch(`${schema}://${this._options.host}/api/v1/conferences/rooms/${this._context.roomId}`, {
                headers: { 'Authorization': `Bearer ${this._context.jwtToken}` }
            });
            if (!response.ok) {
                return Promise.resolve(false);
            }
            const result = await response.json();
            const endpointState = result?.data?.endpointState;
            if (endpointState) {
                const payload = {
                    endpointAudio: endpointState.endpointAudio || {},
                    endpointSpeaker: endpointState.endpointSpeaker || {},
                    endpointVideo: endpointState.endpointVideo || {},
                    handRaised: endpointState.handRaised,
                    moderator: endpointState.moderator,
                    presenter: endpointState.presenter
                };
                this._eventDispatcher.emit(ModerationEvents.Events.EndpointStateUpdate, payload);
            }
            const roomState = result?.data?.roomState;
            if (roomState) {
                const payload = {
                    full: roomState.full,
                    lectureMode: roomState.lectureMode,
                    locked: roomState.locked,
                    numParticipants: roomState.numParticipants,
                    presenter: roomState.presenter,
                    raisedHands: roomState.raisedHands,
                    roomId: roomState.roomId,
                    roomAudio: roomState.roomAudio || {},
                    roomSpeaker: roomState.roomSpeaker || {},
                    roomVideo: roomState.roomVideo || {},
                    waitingRoom: roomState.waitingRoom
                };
                this._eventDispatcher.emit(RoomEvents.Events.StateUpdate, payload);
            }
        }
        catch (err) {
            this._logger.LogError(err);
        }
        return Promise.resolve(true);
    }
    SendClientStats(reflector, stats) {
        this._logger.LogInfo(() => `${stats}`, LogEvents_1.VidyoLogCategory.VidyoSignaling);
    }
    SendFeccMessage(options) {
        this._cmcpConferenceDialogSession.SendFeccMessage(options);
    }
    SendMessage(options) {
        if (this._context.portalDetails?.portalFeatures?.endpointPublicChat === false) {
            return false;
        }
        this._cmcpConferenceDialogSession.SendConferenceMessage(options.message, options.id);
        return true;
    }
    SendPrivateMessage(options) {
        if (this._context.portalDetails?.portalFeatures?.endpointPrivateChat === false) {
            return false;
        }
        this._cmcpConferenceDialogSession.SendPrivateMessage(options.participantUri, options.message, options.id);
        return true;
    }
    Subscribe(identity, parameter) {
        switch (parameter.package) {
            case 'participant':
                this._cmcpParticipantDialogSession =
                    this._scipSession.CreateDialogSessionAndSendSubscribe(identity.LocalId, parameter.package);
                break;
            case 'receivebw':
                this._cmcpReceiveBandwidthDialogSession =
                    this._scipSession.CreateDialogSessionAndSendSubscribe(identity.LocalId, parameter.package);
                break;
            case 'selectedparticipant':
                this._cmcpSelectedParticipantDialogSession =
                    this._scipSession.CreateDialogSessionAndSendSubscribe(identity.LocalId, parameter.package);
                break;
            default:
                this._logger.LogInfo(() => `Unhandled subscription request: ${parameter.package}`);
        }
        let result = { from: '',
            id: '',
            to: '',
        };
        return Promise.resolve(result);
    }
    Unsubscribe(identity, parameter) {
        let result = { from: '',
            id: '',
            to: '',
        };
        return Promise.resolve(result);
    }
    UpdateConnection() {
        return new Promise((resolve, reject) => {
            this._scipMediaSession.resetPeerConnection();
            resolve();
        });
    }
    UpdateStreamTracks(stream) {
        return new Promise((resolve, reject) => {
            this._scipMediaSession.UpdateStreamTracks(stream);
            resolve();
        });
    }
    UpdateMediaStates() {
        return new Promise((resolve, reject) => {
            if (this._scipMediaSession) {
                this._scipMediaSession.UpdateMediaStates(false);
            }
            resolve();
        });
    }
    _timeOut(cleanUp) {
        let pt = new PromiseHelper_1.PromiseTimeout(Constants.BatchTimeOut, cleanUp);
        return pt;
    }
    _SetLocalCapabilities(caps) {
        this._scipSession.setLocalCapabilities(caps);
    }
    ProcessRemoteSessionAnswer(caps) {
        caps = caps.replace(/caps/g, "capabilities");
        this._scipMediaSession._SetSessionAnswer(caps);
    }
    ProcessRemoteSessionInitiate(scel) {
        this._scipMediaSession.ProcessRemoteOffer(scel);
    }
}
exports.HunterProvider = HunterProvider;
class PresenceHelper {
    constructor(_logger) {
        this._logger = _logger;
        this._handleMessageFromWorker = (msgEvent) => {
            if (typeof this[msgEvent.data.queryCallback] === 'function') {
                this[msgEvent.data.queryCallback](...msgEvent.data.queryCallbackArguments);
            }
            else {
                this._logger.LogInfo(() => `Unhandled message from worker: ${JSON.stringify(msgEvent.data)}`);
            }
        };
        this._workerScript = (getCurrentNTPTimestamp, bigIntegerBlobUri) => {
            self['importScripts'](bigIntegerBlobUri);
            const RETRY_NUMBER_AFTER_FAIL = 3;
            const FETCH_TIMEOUT = 5000;
            const TIMEOUT = 15000;
            let url = '';
            let authToken = '';
            let timeoutRef = null;
            let failedRequestCounter = 0;
            let lastTimestamp = 0;
            const queryableFunctions = { startPresence, stopPresence };
            self.addEventListener('message', (event) => {
                if (event.data.hasOwnProperty('queryMethod')) {
                    queryableFunctions[event.data.queryMethod].apply(self, event.data.queryMethodArguments);
                }
                else {
                    replyLog('LogDebug', `Unknown command ${JSON.stringify(event.data)}`);
                }
            });
            function startPresence(apiURL, token) {
                stopPresence();
                url = apiURL;
                authToken = token;
                failedRequestCounter = 0;
                sendPresence();
            }
            function stopPresence() {
                clearTimeout(timeoutRef);
            }
            function sendPresence() {
                lastTimestamp = Date.now();
                const data = {
                    authToken,
                    state: 'Online',
                    timestamp: getCurrentNTPTimestamp(lastTimestamp)
                };
                replyLog('LogDebug', `presenceUpdate request: ${JSON.stringify(data)}`, 'VidyoSignaling');
                Promise.race([
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Fetch timed out')), FETCH_TIMEOUT)),
                    fetch(url, {
                        method: 'post',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    })
                ])
                    .then((response) => response.json())
                    .then(onResponse)
                    .catch((err) => {
                    replyLog('LogError', `send presenceUpdate failed ${err}`);
                    onFailure();
                });
            }
            function initNextPresence(timeout) {
                this.timeoutRef = setTimeout(sendPresence, timeout);
            }
            function onResponse(responseData) {
                if (responseData) {
                    replySuccess(responseData);
                    replyLog('LogDebug', `presenceUpdate response: ${JSON.stringify(responseData)}`, 'VidyoSignaling');
                }
                else {
                    replyLog('LogError', 'presenceUpdate response is empty');
                }
                if (responseData.status && responseData.status === 'OK') {
                    let nextTimeout;
                    if (!lastTimestamp) {
                        nextTimeout = TIMEOUT;
                    }
                    else {
                        nextTimeout = Math.max(TIMEOUT - (Date.now() - lastTimestamp), 0);
                    }
                    replyLog('LogDebug', `next presenceUpdate scheduled in ${nextTimeout}ms`);
                    failedRequestCounter = 0;
                    initNextPresence(nextTimeout);
                }
                else if (responseData.errorCode) {
                    const errorCode = parseInt(responseData.errorCode);
                    switch (errorCode) {
                        case 6042:
                            initNextPresence(1000);
                            break;
                        default:
                            replyFailure(responseData);
                            break;
                    }
                }
                else {
                    replyFailure(responseData);
                }
            }
            function onFailure() {
                if (failedRequestCounter >= RETRY_NUMBER_AFTER_FAIL) {
                    replyFailure();
                }
                else {
                    const timeout = (failedRequestCounter + Math.random()) * 1000;
                    failedRequestCounter++;
                    initNextPresence(timeout);
                }
            }
            function reply(queryCallback, queryCallbackArguments = []) {
                self.postMessage({
                    queryCallback,
                    queryCallbackArguments
                });
            }
            function replySuccess(responseData) {
                reply('_onSuccess', [responseData]);
            }
            function replyFailure(responseData) {
                reply('_onFailure', [responseData]);
            }
            function replyLog(level, message, category) {
                reply('_onLog', [level, message, category]);
            }
        };
        const url = getBigIntegerBlobUri();
        const workerInlineScript = `(${this._workerScript})(${getCurrentNTPTimestamp}, '${url}')`;
        const workerBlob = new Blob([workerInlineScript], { type: 'text/javascript' });
        this._workerBlobURL = URL.createObjectURL(workerBlob);
    }
    StartPresence(apiURL, authToken, failCallback, progressCallback) {
        this.StopPresence();
        this._failCallback = failCallback;
        this._progressCallback = progressCallback;
        this._worker = new Worker(this._workerBlobURL);
        this._worker.addEventListener('message', this._handleMessageFromWorker);
        this._worker.postMessage({ queryMethod: 'startPresence', queryMethodArguments: [apiURL, authToken] });
    }
    StopPresence() {
        if (this._worker instanceof Worker) {
            this._worker.removeEventListener('message', this._handleMessageFromWorker);
            this._worker.postMessage({ queryMethod: 'stopPresence' });
            this._worker.terminate();
        }
    }
    _onSuccess(responseData) {
        this._progressCallback(responseData);
    }
    _onFailure(responseData) {
        this._failCallback(responseData);
    }
    _onLog(level, message, category) {
        this._logger[level](message, LogEvents_1.VidyoLogCategory[category]);
    }
}

},{"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/LogEvents":69,"../events/ModerationEvents":72,"../events/RoomEvents":77,"../utils/Constants":138,"../utils/EndpointInfoProvider":140,"../utils/PromiseHelper":157,"../utils/StringUtils":164,"./EventServerSession":81,"./HunterBase":82,"./ScipMediaSession":86,"./ScipSession":87,"./WebSocketTransport":89,"big-integer":2}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogIdTemplate = exports.IdentityListTemplate = exports.RemoteControl = exports.DialogId = exports.VersionMismatch = exports.Identity = void 0;
class Identity {
}
exports.Identity = Identity;
class VersionMismatch {
}
exports.VersionMismatch = VersionMismatch;
class DialogId {
    constructor(id) {
        if (id) {
            this.local = id;
        }
        else {
            this.local = 1;
        }
    }
}
exports.DialogId = DialogId;
class RemoteControl {
}
exports.RemoteControl = RemoteControl;
function IdentityListTemplate(identityList) {
    let result = '';
    identityList.forEach(function (identity) {
        let body = `<id><n>${identity.name}</n><v>${identity.version}</v></id>`;
        result += body;
    });
    return result;
}
exports.IdentityListTemplate = IdentityListTemplate;
function DialogIdTemplate(dialogId) {
    let template = '';
    if (dialogId.remote > 0) {
        template = `<dialogId><local>${dialogId.local}</local><remote>${dialogId.remote}</remote></dialogId>`;
    }
    else {
        template = `<dialogId><local>${dialogId.local}</local></dialogId>`;
    }
    return template;
}
exports.DialogIdTemplate = DialogIdTemplate;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Processor = exports.Response = exports.Request = exports.Commands = exports.Replies = exports.Packet = exports.XmlDocument = exports.Reply = exports.Command = exports.ExecutableElement = exports.Element = exports.Atomic = exports.MessageType = void 0;
const LmiProtocol = require("./LmiProtocol");
var MessageType;
(function (MessageType) {
    MessageType[MessageType["Local"] = 0] = "Local";
    MessageType[MessageType["Remote"] = 1] = "Remote";
    MessageType[MessageType["Error"] = 2] = "Error";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
var Atomic;
(function (Atomic) {
    Atomic[Atomic["parallel"] = 0] = "parallel";
    Atomic[Atomic["inorder"] = 1] = "inorder";
    Atomic[Atomic["failabort"] = 2] = "failabort";
    Atomic[Atomic["failundo"] = 3] = "failundo";
})(Atomic = exports.Atomic || (exports.Atomic = {}));
class Element {
    toXml(body) {
        return body || "";
    }
}
exports.Element = Element;
class ExecutableElement extends Element {
    constructor(dialogId) {
        super();
        this.type = MessageType.Error;
        this.dialogId = dialogId;
    }
}
exports.ExecutableElement = ExecutableElement;
class Command extends ExecutableElement {
    toXml(body) {
        let dialogId = LmiProtocol.DialogIdTemplate(this.dialogId);
        let template = `<command>${dialogId}${body}</command>`;
        return super.toXml(template);
    }
}
exports.Command = Command;
class Reply extends ExecutableElement {
    toXml(replyBody) {
        let dialogId = LmiProtocol.DialogIdTemplate(this.dialogId);
        if (replyBody == undefined) {
            replyBody = "";
        }
        let template = `<reply result="${this.result}">${dialogId}${replyBody}</reply>`;
        return super.toXml(template);
    }
}
exports.Reply = Reply;
class XmlDocument extends Element {
    toXml(body) {
        return super.toXml(body);
    }
}
exports.XmlDocument = XmlDocument;
class Packet extends XmlDocument {
    constructor(localUri, remoteUri) {
        super();
        this.srcUri = localUri;
        this.dstUri = remoteUri;
    }
    toXml(body) {
        let template = `<packet srcUri="${this.srcUri}" dstUri="${this.dstUri}" version="2"> ${body}</packet>`;
        return super.toXml(template);
    }
}
exports.Packet = Packet;
class Replies extends Element {
    constructor(replyList, versionMismatch) {
        super();
        this.repliesList = replyList;
        this.versionMismatch = versionMismatch;
    }
    toXml(body = '') {
        let repliesBody = '';
        let repliesTo = '';
        this.repliesList.forEach(function (reply) {
            let body = reply.toXml();
            repliesBody += body;
        });
        if (this.to) {
            repliesTo = `to="${this.to}"`;
        }
        let template = `<replies version="1" ${repliesTo}><from>${this.fromUri}</from>${repliesBody}</replies>`;
        return super.toXml(template);
    }
}
exports.Replies = Replies;
class Commands extends Element {
    constructor(srcUri, from, to, version, commandList) {
        super();
        this.srcUri = srcUri;
        this.commandsFrom = from;
        this.commandsTo = to;
        this.commandList = commandList;
        this.version = version;
    }
    toXml(body) {
        let commandsBody = '';
        let atomic = '';
        let commandsTo = '';
        let commandsFrom = '';
        this.commandList.forEach(function (command) {
            commandsBody += command.toXml();
        });
        if (this.atomic) {
            atomic = `atomic=${this.atomic}`;
        }
        if (this.commandsTo) {
            commandsTo = `to="${this.commandsTo}"`;
        }
        if (this.commandsFrom) {
            commandsFrom = `from="${this.commandsFrom}"`;
        }
        let template = `<commands ${commandsFrom} ${commandsTo} version="${this.version}" ${atomic}><from>${this.srcUri}</from>${commandsBody}</commands>`;
        return template;
    }
}
exports.Commands = Commands;
class Request extends Element {
    constructor(srcUri, from, to, version, transactionId, commandList) {
        super();
        this.version = version;
        this.transactionId = transactionId;
        this.commands = new Commands(srcUri, from, to, this.version, commandList);
    }
    toXml(body) {
        let cid = this.transactionId;
        let commandsBody = this.commands.toXml();
        let template = `<request transactionId="${cid}">${commandsBody}</request>`;
        return super.toXml(template);
    }
}
exports.Request = Request;
class Response extends Element {
    constructor(transactionId, fromUri, replyList, versionMismatch) {
        super();
        this.transactionId = transactionId;
        this.replies = new Replies(replyList, versionMismatch);
        this.replies.fromUri = fromUri;
    }
    toXml(body) {
        let cid = this.transactionId;
        let repliesBody = this.replies.toXml();
        let template = `<response transactionId="${cid}">${repliesBody}</response>`;
        return super.toXml(template);
    }
}
exports.Response = Response;
class Processor {
    constructor(logger) {
        this.logger = logger;
        this.pendingCommands = {};
    }
    executeCmd(command) {
        let replyCommandList = "";
        switch (command.type) {
            case MessageType.Local:
                if (typeof this.pendingCommands[command.transactionId] === 'undefined') {
                    this.pendingCommands[command.transactionId] = new Array();
                }
                this.pendingCommands[command.transactionId].push(command);
                break;
            case MessageType.Remote:
                try {
                    command.execute();
                }
                catch (error) {
                    this.logger.LogError(() => `${JSON.stringify(error)}: ${command.constructor?.name}`);
                }
                break;
            default:
                this.logger.LogError(() => `Invalid MessageType for Command: ${command.constructor.name}`);
                break;
        }
    }
    executeReply(reply) {
        let replyCommandList;
        let arrow = '<-';
        switch (reply.type) {
            case MessageType.Local:
                arrow = '->';
                break;
            case MessageType.Remote:
                arrow = '<-';
                break;
            default:
                arrow = '???';
        }
        switch (reply.type) {
            case MessageType.Local:
                break;
            case MessageType.Remote:
                let commands = this.pendingCommands[reply.transactionId];
                if (commands) {
                    commands.forEach((command, index, array) => {
                        if (command) {
                            command.acked(reply);
                            const inst = command.constructor;
                            replyCommandList = `${inst.name} ${replyCommandList}`;
                        }
                        else {
                            this.logger.LogError(() => `TID Missing: ${reply.transactionId}`);
                        }
                    });
                    delete this.pendingCommands[reply.transactionId];
                }
                else {
                    this.logger.LogError(() => `Recv Reply when no remote commands pending: ${reply.transactionId}`);
                }
                break;
            default:
                this.logger.LogError(() => `Invalid MessageType for Reply: ${reply.constructor.name}`);
                break;
        }
        if (reply.result != 200) {
            this.logger.LogError(() => `${arrow} (${reply.transactionId}) : ${reply.result} ${reply.constructor.name}, commands: ${replyCommandList}`);
        }
    }
    processLocalCommand(command) {
        this.executeCmd(command);
    }
    processRemoteCommand(command) {
        this.executeCmd(command);
    }
    processLocalReply(reply) {
        this.executeReply(reply);
    }
    processRemoteReply(reply) {
        this.executeReply(reply);
    }
}
exports.Processor = Processor;

},{"./LmiProtocol":84}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaSession = void 0;
const AdvancedSettingsEvents = require("../events/AdvancedSettingsEvents");
const ConnectionEvents = require("../events/ConnectionEvents");
const Source_1 = require("../models/Source");
const WebRtcSdpScel_1 = require("./WebRtcSdpScel");
const ConferenceEvents = require("../events/ConferenceEvents");
const LogEvents_1 = require("../events/LogEvents");
const OperatingSystemInfoProvider_1 = require("../utils/OperatingSystemInfoProvider");
const ConnectionEvents_1 = require("../events/ConnectionEvents");
const Constants_1 = require("../utils/Constants");
const TrackMetaDataProvider_1 = require("../controllers/StreamController/TrackMetaDataProvider");
const Devices_1 = require("../../vidyo_simple_api/Devices");
const TimingProvider_1 = require("../utils/TimingProvider");
const Constants = require("../utils/Constants");
function ArrangeVideoCodecByPreferenceList(sdp, codecs) {
    if (!codecs || codecs.length <= 1) {
        return sdp;
    }
    let payloads = [];
    codecs.forEach((codec) => {
        let codecRegExp = new RegExp(`(a=rtpmap:(\\d*) ${codec.mimeType.replace('video/', '')}.*\\r\\n)`, 'g');
        let rtpmaps = sdp.match(codecRegExp);
        if (rtpmaps != null) {
            rtpmaps.forEach((rtpmap) => {
                let payload = rtpmap.replace('a=rtpmap:', '').split(' ')[0];
                if (!payloads.includes(payload)) {
                    payloads.push(payload);
                }
            });
        }
    });
    return sdp.split('\r\n').map((line) => {
        if (line.startsWith('m=video')) {
            let words = line.split(' ');
            let originalPayloads = words.splice(3, words.length - 3);
            let filteredPayloads = payloads.filter(payload => originalPayloads.includes(payload));
            filteredPayloads.push(...originalPayloads.filter(payload => !payloads.includes(payload)));
            return words.concat(filteredPayloads).join(' ');
        }
        else {
            return line;
        }
    }).join('\r\n');
}
function isLocalDescriptionVideoLineChanged(current, pending, remote) {
    let currentVideoLine = '';
    let pendingVideoLine = '';
    let remoteVideoLine = '';
    current.split('m=').map((mline) => {
        if (mline.startsWith('video') && currentVideoLine === '') {
            currentVideoLine = mline.split('\r\n')[0];
        }
    });
    pending.split('m=').map((mline) => {
        if (mline.startsWith('video') && pendingVideoLine === '') {
            pendingVideoLine = mline.split('\r\n')[0];
        }
    });
    remote.split('m=').map((mline) => {
        if (mline.startsWith('video') && remoteVideoLine === '') {
            remoteVideoLine = mline.split('\r\n')[0];
        }
    });
    if (currentVideoLine != pendingVideoLine) {
        let currentPayloads = currentVideoLine.split(' ');
        currentPayloads.splice(0, 3);
        let pendingPayloads = pendingVideoLine.split(' ');
        pendingPayloads.splice(0, 3);
        let remotePayloads = remoteVideoLine.split(' ');
        remotePayloads.splice(0, 3);
        let removedPayloads = currentPayloads.filter(p => !pendingPayloads.includes(p)).filter(p => remotePayloads.includes(p));
        return (removedPayloads.length > 0);
    }
    return false;
}
function SDPStripPayload(originalSDP, mediaType, payload) {
    return originalSDP.split('m=').map((mline) => {
        let newMline = mline;
        if (newMline.startsWith(mediaType)) {
            while (true) {
                let codecRegExp = new RegExp(`(a=rtpmap:(\\d*) ${payload}.*\\r\\n)`);
                let rtpmaps = newMline.match(codecRegExp);
                if (rtpmaps === null || rtpmaps.length <= 2) {
                    break;
                }
                let rtpmap = rtpmaps[2];
                newMline = newMline.replace(codecRegExp, '');
                let rtcpRegExp = new RegExp(`(a=rtcp-fb:${rtpmap}.*\r\n)`, 'g');
                newMline = newMline.replace(rtcpRegExp, '');
                let fmtpRegExp = new RegExp(`(a=fmtp:${rtpmap}.*\r\n)`, 'g');
                newMline = newMline.replace(fmtpRegExp, '');
                let aptpre = new RegExp(`(a=fmtp:(\\d*) apt=${rtpmap}\\r\\n)`);
                let aptmaps = newMline.match(aptpre);
                let fmtpmap = '';
                if (aptmaps != null && aptmaps.length >= 3) {
                    fmtpmap = aptmaps[2];
                    newMline = newMline.replace(aptpre, '');
                    let rtppre = new RegExp(`(a=rtpmap:${fmtpmap}.*\r\n)`, 'g');
                    newMline = newMline.replace(rtppre, '');
                }
                let mlines = newMline.split('\r\n');
                mlines[0] = mlines[0].split(' ').filter((elem, index) => {
                    return index < 2 || elem !== rtpmap && elem !== fmtpmap;
                }).join(' ');
                newMline = mlines.join('\r\n');
            }
            return newMline;
        }
        return mline;
    }).join('m=');
}
function AddLPrefixToSendMids(sdp) {
    if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
        return sdp;
    }
    else {
        return sdp.replace(/a=group:BUNDLE(.*)|a=mid:\d+/g, (a) => {
            if (a.startsWith('a=group')) {
                let lines = a.split(' ');
                return lines.map((n) => isNaN(Number(n)) ? n : `L${n}`).join(' ');
            }
            else if (a.startsWith('a=mid:')) {
                const midLine = a.split(':');
                midLine[1] = `L${midLine[1]}`;
                return midLine.join(':');
            }
        });
    }
}
function disableTCPCandidates(input) {
    if (input != null) {
        input = input.replace(/a=candidate:.* tcp .*\r\n/gi, '');
        input = input.replace(/a=candidate:.* typ relay .*\r\n/gi, '');
    }
    return input;
}
function disableCodecs(input) {
    if (input != null) {
        if (Array.isArray(window['__VIDEO_CODEC_BLACK_LIST__'])) {
            const validate = (codec) => typeof codec === 'string' && ['VP9', 'VP8'].includes(codec.toUpperCase());
            window['__VIDEO_CODEC_BLACK_LIST__'].filter(validate).forEach((codec) => {
                input = SDPStripPayload(input, 'video', codec.toUpperCase());
            });
        }
        input = SDPStripPayload(input, 'video', 'red');
        input = SDPStripPayload(input, 'video', 'ulpfec');
        input = SDPStripPayload(input, 'audio', 'PCMU');
        input = SDPStripPayload(input, 'audio', 'PCMA');
        input = SDPStripPayload(input, 'video', 'H264');
    }
    return input;
}
function fixLocalSDP(input) {
    if (input != null) {
        input = input.replace(/a=setup:actpass/g, "a=setup:passive");
        input = input.replace(/ active /g, ` passive `);
        input = input.replace(/ udp /g, " UDP ");
        input = input.replace(/ tcp /g, " TCP ");
        input = input.replace(/^.*ice-options:trickle.*$/mg, "");
        input = input.replace(/VP9/g, "preVP9");
        input = input.replace(/ red/g, ' RED');
        input = input.replace(/[\r\n]+/g, "\r\n");
    }
    return input;
}
function fixRemoteSDP(input) {
    if (input != null) {
        input = input.replace(/preVP9/g, 'VP9');
    }
    return input;
}
function createSrcPropPausedScelElement(paused) {
    const prop = document.createElementNS('http://www.vidyo.com/ns/LmiProtocol.xsd', 'prop');
    const nm = document.createElement('nm');
    nm.innerHTML = 'paused';
    const val = document.createElement('val');
    val.innerHTML = String(paused);
    prop.appendChild(nm);
    prop.appendChild(val);
    return prop;
}
function generateNewSSRC(sdp) {
    while (true) {
        const ssrc = '' + Math.floor(Math.random() * 0xffffffff);
        if (!sdp.includes(ssrc)) {
            return ssrc;
        }
    }
}
var RECEIVE_TRANSCEIVERS_USE_TYPE;
(function (RECEIVE_TRANSCEIVERS_USE_TYPE) {
    RECEIVE_TRANSCEIVERS_USE_TYPE[RECEIVE_TRANSCEIVERS_USE_TYPE["REUSE"] = 0] = "REUSE";
    RECEIVE_TRANSCEIVERS_USE_TYPE[RECEIVE_TRANSCEIVERS_USE_TYPE["CREATE_NEW"] = 1] = "CREATE_NEW";
    RECEIVE_TRANSCEIVERS_USE_TYPE[RECEIVE_TRANSCEIVERS_USE_TYPE["POOL"] = 2] = "POOL";
})(RECEIVE_TRANSCEIVERS_USE_TYPE || (RECEIVE_TRANSCEIVERS_USE_TYPE = {}));
class UnifiedSDPHelper {
    constructor(_pc, _localStreamController, _logger) {
        this._pc = _pc;
        this._localStreamController = _localStreamController;
        this._logger = _logger;
        this._cachedLocalAnswerSDP = '';
        this.actualLocalSDP = '';
        this.mlines = {};
        this._sendTransceivers = [];
        this._receiveTransceivers = {};
        this._receiveTransceiverUseType = RECEIVE_TRANSCEIVERS_USE_TYPE.CREATE_NEW;
        this.audioOfferExtmaps = [];
        this.videoOfferExtmaps = [];
        this.scelSsrcMap = {};
        this.ExtMapsToIgnore = ['urn:3gpp:video-orientation'];
    }
    get SendTransceivers() {
        return this._sendTransceivers;
    }
    set ActualLocalSDP(sdp) {
        this.actualLocalSDP = sdp;
    }
    set CachedLocalAnswerSDP(sdp) {
        this._cachedLocalAnswerSDP = sdp;
    }
    CheckAndAddSimulcast(sdp) {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsChrome() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
            return this.SDPAddSimulcast(sdp);
        }
        return sdp;
    }
    UseLastAnswerVideoCodecs(sdp) {
        if (!this._cachedLocalAnswerSDP) {
            return sdp;
        }
        const cachedMLines = this._cachedLocalAnswerSDP.split('m=');
        const cachedMVideoLines = cachedMLines.filter((m) => m.startsWith('video'));
        return sdp.split('m=').map((mline) => {
            let newMline = mline;
            if (newMline.startsWith('video') && cachedMVideoLines.length > 0) {
                const cachedMVideoLine = cachedMVideoLines.shift();
                const videoDescLineRegExp = /(video [\d\/]+ [\w\/]+) ([\d ]+)\r\n/;
                const cachedMatch = cachedMVideoLine.match(videoDescLineRegExp);
                const actualMatch = newMline.match(videoDescLineRegExp);
                if (actualMatch?.length > 2 && cachedMatch?.length > 2) {
                    const [actualDesc, actualPortsTransport, actualFmtList] = actualMatch;
                    const cachedFmtList = cachedMatch[2];
                    newMline = newMline.replace(actualDesc, `${actualPortsTransport} ${cachedFmtList}\r\n`);
                    const cachedFmtListArr = cachedFmtList.split(' ');
                    const actualFmtListArr = actualFmtList.split(' ');
                    const extraFmtItems = actualFmtListArr.filter((p) => !cachedFmtListArr.includes(p));
                    extraFmtItems.forEach((item) => {
                        const rtpmap = new RegExp(`a=rtpmap:${item} .*\\r\\n`, 'g');
                        newMline = newMline.replace(rtpmap, '');
                        const fmtp = new RegExp(`a=fmtp:${item} .*\\r\\n`, 'g');
                        newMline = newMline.replace(fmtp, '');
                        const rtcpfb = new RegExp(`a=rtcp-fb:${item} .*\\r\\n`, 'g');
                        newMline = newMline.replace(rtcpfb, '');
                    });
                    const videoOrientationRegExp = /a=extmap:\d+ urn:3gpp:video-orientation\r\n/g;
                    if (cachedMVideoLine.match(videoOrientationRegExp) === null) {
                        newMline = newMline.replace(videoOrientationRegExp, '');
                    }
                    return newMline;
                }
            }
            return mline;
        }).join('m=');
    }
    GetSendTransceiverByMid(mid) {
        return this._sendTransceivers.find((data) => {
            return data.transceiver.mid === mid;
        });
    }
    GetSendTransceiverByTrackId(trackId) {
        return this._sendTransceivers.find((data) => {
            return data.id === trackId || (data.transceiver.sender.track?.id === trackId);
        });
    }
    AddSendTransceiver(transceiver, type) {
        this._sendTransceivers.push({ transceiver, type, index: this._sendTransceivers.length });
    }
    AddSource(pid, source) {
        const id = source.Ssrc[0];
        if (this.mlines.hasOwnProperty(id)) {
            return;
        }
        const trackType = source.Type === 'application' ? 'video' : source.Type;
        this.mlines[id] = {
            id,
            type: trackType,
            sdpSSRC: this._createNewMLineSources(source, pid),
        };
        const transceiverData = this._getFreeTransceiverData(trackType);
        if (transceiverData) {
            transceiverData.sourceId = id;
        }
    }
    RemoveSource(id) {
        let receiveTransceiverData = this._getTransceiverData(id);
        if (receiveTransceiverData.data) {
            receiveTransceiverData.data.sourceId = null;
        }
        switch (this._receiveTransceiverUseType) {
            case RECEIVE_TRANSCEIVERS_USE_TYPE.CREATE_NEW:
                if (receiveTransceiverData.transceiver && typeof receiveTransceiverData.transceiver.stop === 'function') {
                    receiveTransceiverData.transceiver.stop();
                }
                if (receiveTransceiverData.data) {
                    receiveTransceiverData.data.stopped = true;
                }
                break;
            default:
                break;
        }
        delete this.mlines[id];
    }
    SDPAddSimulcast(sdp) {
        return sdp.split('m=').map((mLine) => {
            if (mLine.startsWith('video') && !mLine.includes('a=ssrc-group:SIM')) {
                const msidMatch = mLine.match(/a=msid:.+ (.+)/);
                const midMatch = mLine.match(/a=mid:(.+)/);
                let trackId = '';
                if (midMatch && midMatch.length > 1) {
                    const data = this.GetSendTransceiverByMid(midMatch[1]);
                    trackId = data?.transceiver?.sender?.track?.id;
                }
                if (!trackId && msidMatch && msidMatch.length > 1) {
                    trackId = msidMatch[1];
                }
                const { isSimulcast } = this._localStreamController.GetTrackMediaProperties(trackId);
                if (isSimulcast && trackId) {
                    const firstSsrc = mLine.match(/a=ssrc:(\d+)/);
                    if (firstSsrc && firstSsrc.length > 1) {
                        let simGroup = 'a=ssrc-group:SIM';
                        const ssrc = firstSsrc[1];
                        simGroup += ` ${ssrc}`;
                        const ssrcLinesTemplate = mLine.match(new RegExp(`a=ssrc:${ssrc}(.+)`, 'g'));
                        for (let i = 0; i < (Constants_1.Runnels.length - 1); ++i) {
                            const ssrc1 = generateNewSSRC(sdp);
                            const ssrc2 = generateNewSSRC(sdp);
                            simGroup += ` ${ssrc1}`;
                            mLine += `a=ssrc-group:FID ${ssrc1} ${ssrc2}\r\n`;
                            mLine += ssrcLinesTemplate.join('\r\n')
                                .replace(new RegExp(`a=ssrc:${ssrc}(.+)`, 'g'), `a=ssrc:${ssrc1}$1`) + '\r\n';
                            mLine += ssrcLinesTemplate.join('\r\n')
                                .replace(new RegExp(`a=ssrc:${ssrc}(.+)`, 'g'), `a=ssrc:${ssrc2}$1`) + '\r\n';
                        }
                        mLine += `${simGroup}\r\n`;
                    }
                }
            }
            return mLine;
        }).join('m=');
    }
    _checkMLinePayloads(sdpMLinePart) {
        if (sdpMLinePart.startsWith('audio')) {
            let words = sdpMLinePart.split('\n')?.[0]?.split(' ');
            if (words && words.length < 4) {
                this._logger.LogWarning(() => `There no any audio payloads in remote offer, trying to use previous payloads`);
                return false;
            }
        }
        else if (sdpMLinePart.startsWith('video')) {
            const codecs = ['VP8', 'VP9'];
            let codecRegExp = new RegExp(`a=rtpmap:\\d* ${codecs.join('|')}.*`, 'gi');
            let rtpmaps = sdpMLinePart.match(codecRegExp);
            if (!rtpmaps || rtpmaps.length === 0) {
                this._logger.LogWarning(() => `There no any video codecs in remote offer, trying to use previous payloads`);
                return false;
            }
        }
        return true;
    }
    UpdateMLinesTemplates(sdp) {
        let helper = this;
        sdp.split('m=').forEach((splitRes) => {
            if (splitRes.startsWith('audio')) {
                if (this._checkMLinePayloads(splitRes) || !this.mAudioTemplate) {
                    splitRes = splitRes.replace(/a=extmap:(.*)(?:\r|\n)+/gi, '');
                    this.mAudioTemplate = `m=${splitRes}${helper.audioOfferExtmaps.join('\r\n')}\r\n`;
                }
            }
            else if (splitRes.startsWith('video')) {
                if (this._checkMLinePayloads(splitRes) || !this.mVideoTemplate) {
                    splitRes = splitRes.replace(/a=extmap:(.*)(?:\r|\n)+/gi, '');
                    this.mVideoTemplate = `m=${splitRes}${helper.videoOfferExtmaps.join('\r\n')}\r\n`;
                }
            }
            else {
                this.sdpHeader = splitRes;
            }
        });
    }
    FixLocalScel(scel, localStrCtrl, transmitedStrCtrl) {
        if (scel != null) {
            scel = scel.replace("<bw>0</bw>", `<bw>${transmitedStrCtrl.MaxReceiveBandwidth}</bw>`);
            const scelParser = new DOMParser();
            const scelDom = scelParser.parseFromString(scel, "application/xml");
            const tracksSsrcsMap = {};
            const currentScelSsrcMap = this.scelSsrcMap;
            this.scelSsrcMap = {};
            scelDom.querySelectorAll('src').forEach((srcEl) => {
                const idStr = srcEl.getAttribute('idStr');
                const id = srcEl.getAttribute('id');
                const tr = this.GetSendTransceiverByTrackId(idStr);
                if (tr) {
                    if (!tr.transceiver.sender.track) {
                        srcEl.parentNode.removeChild(srcEl);
                    }
                    else {
                        tracksSsrcsMap[id] = tr.transceiver.sender.track.id;
                        const trackProperties = localStrCtrl.GetTrackMediaProperties(tr.transceiver.sender.track.id);
                        if (trackProperties.mediaType === 'application') {
                            srcEl.setAttribute('type', 'application');
                        }
                        srcEl.setAttribute('name', tr.transceiver.sender.track.label);
                        if (trackProperties.mediaType === 'audio') {
                            if (trackProperties.isDynamic) {
                                srcEl.insertBefore(createSrcPropPausedScelElement(trackProperties.muted), srcEl.firstElementChild);
                            }
                            else {
                                srcEl.setAttribute('dyn', 'false');
                            }
                            if (trackProperties.signalType === Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed) {
                                srcEl.setAttribute('signal', Source_1.SourceSignalType.unprocessed);
                            }
                        }
                        if (trackProperties.mediaType === 'video') {
                            const ssrcMaps = srcEl.querySelectorAll('ssrcMap');
                            transmitedStrCtrl.VideoRids = Array.from(ssrcMaps).map((ssrcMap) => ssrcMap.getAttribute('rid'));
                        }
                        if (!srcEl.hasAttribute('secondaryId') || srcEl.getAttribute('secondaryId') === '0') {
                            let secondaryId = String(tr.index);
                            let rid = '';
                            if (currentScelSsrcMap.hasOwnProperty(id)) {
                                const ssrcData = currentScelSsrcMap[id];
                                rid = ssrcData.rid;
                                secondaryId = ssrcData.secondaryId;
                            }
                            if (rid) {
                                srcEl.querySelector('ssrcMap')?.setAttribute('rid', rid);
                            }
                            srcEl.setAttribute('secondaryId', secondaryId);
                            srcEl.querySelectorAll('ssrc').forEach((ssrc) => {
                                if (ssrc.innerHTML === '0') {
                                    ssrc.innerHTML = secondaryId;
                                }
                            });
                        }
                        this.scelSsrcMap[id] = {
                            secondaryId: srcEl.getAttribute('secondaryId'),
                            rid: srcEl.querySelector('ssrcMap')?.getAttribute('rid')
                        };
                        srcEl.setAttribute('idStr', id);
                    }
                }
            });
            transmitedStrCtrl.UpdateTracksSrrcs(tracksSsrcsMap);
            scel = new XMLSerializer().serializeToString(scelDom);
        }
        return scel;
    }
    FixLocalSDPBeforeScel(sdp, localStrCtrl) {
        const str = localStrCtrl.GetTransmittedStream();
        return sdp
            .split('m=')
            .filter((mline, index) => 0 === index || (!mline.includes('a=mid:R') && mline.includes('a=mid:')))
            .map((mLine, index) => {
            if (index !== 0 && !mLine.includes('a=msid:')) {
                const midLine = /a=mid:(.+)/gi.exec(mLine);
                if (midLine?.length > 1) {
                    const transceiverData = this.GetSendTransceiverByMid(midLine[1]);
                    if (transceiverData?.transceiver.sender.track) {
                        if (transceiverData.id) {
                            mLine += `a=msid:${str.id} ${transceiverData.id}\r\n`;
                        }
                        else {
                            mLine += `a=msid:${str.id} ${transceiverData.transceiver.sender.track.id}\r\n`;
                        }
                    }
                }
            }
            return mLine;
        })
            .join('m=');
    }
    GetActualRemoteSdp(forAnswer = false) {
        let sdp = '';
        let bundleLine = 'a=group:BUNDLE';
        const processedMLinesMap = {};
        let transceiversMLines = {};
        this._pc.getTransceivers().forEach((transceiver) => {
            if (transceiver.mid === null) {
                return;
            }
            let mlinePart = '';
            const type = this._getTransceiverType(transceiver);
            mlinePart = this._getTemplate(type);
            switch (transceiver.direction) {
                case 'recvonly':
                    if (this._receiveTransceivers[transceiver.mid]?.sourceId && this.mlines[this._receiveTransceivers[transceiver.mid]?.sourceId]) {
                        mlinePart += 'a=sendonly\r\n';
                        mlinePart += this.mlines[this._receiveTransceivers[transceiver.mid]?.sourceId].sdpSSRC;
                        processedMLinesMap[this._receiveTransceivers[transceiver.mid]?.sourceId] = true;
                    }
                    else {
                        mlinePart += 'a=inactive\r\n';
                        if (this._receiveTransceivers[transceiver.mid]) {
                            this._receiveTransceivers[transceiver.mid].sourceId = null;
                        }
                    }
                    break;
                case 'sendonly':
                    mlinePart += 'a=recvonly\r\n';
                    const isSimulcast = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()
                        && transceiver.sender
                        && transceiver.sender.track
                        && this._localStreamController.GetTrackMediaProperties(transceiver.sender.track.id).isSimulcast;
                    if (type === 'video' && isSimulcast) {
                        mlinePart = mlinePart.replace(/sendonly.+urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id/, "recvonly urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id");
                        mlinePart = mlinePart.replace(/sendonly.+urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id/, "recvonly urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id");
                        Constants_1.Runnels.forEach(r => {
                            mlinePart += `a=rid:${r} recv\r\n`;
                        });
                        let runnelsStr = Constants_1.Runnels.join(';');
                        mlinePart += `a=simulcast:recv ${runnelsStr}\r\n`;
                    }
                    break;
                case 'inactive':
                    mlinePart += 'a=inactive\r\n';
                    break;
                default:
                    break;
            }
            transceiversMLines[transceiver.mid] = {
                mLine: mlinePart,
                stopped: transceiver.currentDirection === 'stopped'
                    || this._receiveTransceivers[transceiver.mid]?.stopped
                    || this.GetSendTransceiverByMid(transceiver.mid)?.stopped,
                isFree: transceiver.currentDirection === 'inactive' && mlinePart.includes('a=inactive')
            };
        });
        const mids = this.actualLocalSDP.split('m=').slice(1).map((line) => {
            const mid = /a=mid:(.+)/gi.exec(line)?.[1] ?? '';
            return {
                type: line.startsWith('video') ? 'video' : 'audio',
                mid
            };
        });
        const sdpLines = [];
        mids.forEach(({ mid, type }) => {
            const sdpLineData = { isFree: false, midForBundle: '', mLine: '' };
            let mLine = '';
            if (transceiversMLines.hasOwnProperty(mid)) {
                mLine = transceiversMLines[mid].mLine;
                if (!transceiversMLines[mid].stopped) {
                    sdpLineData.midForBundle = mid;
                    mLine += `a=mid:${mid}\r\n`;
                }
                else {
                    mLine = mLine.replace(/(m=video|audio) \d+/, '$1 0');
                    sdpLineData.isFree = transceiversMLines[mid].isFree;
                }
            }
            else {
                mLine = this._getTemplate(type).replace(/(m=video|audio) \d+/, '$1 0');
                mLine += `a=mid:${mid}\r\n`;
                mLine += 'a=inactive\r\n';
                sdpLineData.isFree = true;
            }
            sdpLineData.mLine = mLine;
            sdpLines.push(sdpLineData);
        });
        if (!forAnswer) {
            Object.keys(this.mlines).forEach(key => {
                if (!processedMLinesMap[key]) {
                    const mid = `R${Object.keys(this._receiveTransceivers).length}`;
                    let ml = this.mlines[key];
                    let mlinePart = this._getTemplate(ml.type);
                    mlinePart += 'a=sendonly\r\n';
                    mlinePart += 'a=mid:' + mid + '\r\n';
                    mlinePart += ml.sdpSSRC;
                    this._receiveTransceivers[mid] = {
                        sourceId: key,
                        type: ml.type
                    };
                    const sdpLineData = { isFree: false, midForBundle: mid, mLine: mlinePart };
                    const findFreeTransceiverPlace = sdpLines.find((data) => data.isFree);
                    if (findFreeTransceiverPlace && findFreeTransceiverPlace.mLine.includes('a=inactive')) {
                        Object.assign(findFreeTransceiverPlace, sdpLineData);
                    }
                    else {
                        sdpLines.push(sdpLineData);
                    }
                }
            });
        }
        sdpLines.forEach((data) => {
            bundleLine += data.midForBundle ? ` ${data.midForBundle}` : '';
            sdp += data.mLine;
        });
        sdp = this.sdpHeader + bundleLine + '\r\n' + sdp;
        return sdp;
    }
    OnNewLocalOffer(offerSdp) {
        offerSdp.split('m=').forEach((splitRes) => {
            if (splitRes.startsWith('audio') || splitRes.startsWith('video')) {
                let isAudio = splitRes.startsWith('audio');
                const extmapLines = splitRes.match(/a=extmap:(.*)/gi);
                if (extmapLines != null) {
                    isAudio ? this.audioOfferExtmaps = [] : this.videoOfferExtmaps = [];
                    extmapLines
                        .filter((extmap) => this.ExtMapsToIgnore.indexOf(extmap.split(' ')[1]) === -1)
                        .forEach((extmap) => {
                        isAudio ? this.audioOfferExtmaps.push(extmap) : this.videoOfferExtmaps.push(extmap);
                    });
                }
                const midLine = /a=mid:(.+)/gi.exec(splitRes);
                if (midLine && midLine.length > 1) {
                    const midVal = midLine[1];
                    const transceiver = this.GetSendTransceiverByMid(midVal);
                    if (transceiver) {
                        let idStrLine = /a=ssrc:.+msid:.+ (.+)/.exec(splitRes);
                        if (!(idStrLine && idStrLine.length > 1)) {
                            idStrLine = /a=msid:.+ (.+)/.exec(splitRes);
                        }
                        if (idStrLine && idStrLine.length > 1) {
                            const idStr = idStrLine[1];
                            transceiver.id = idStr;
                        }
                    }
                }
            }
        });
    }
    GetRemoteTrackSsrc(trackId) {
        let ssrc = '';
        const transceiver = this._pc.getTransceivers().find((transceiver) => {
            return transceiver.currentDirection !== 'inactive' && transceiver.receiver.track?.id === trackId;
        });
        if (transceiver && this._receiveTransceivers[transceiver.mid]) {
            ssrc = this._receiveTransceivers[transceiver.mid].sourceId;
        }
        return ssrc;
    }
    _getFreeTransceiverData(type) {
        switch (this._receiveTransceiverUseType) {
            case RECEIVE_TRANSCEIVERS_USE_TYPE.CREATE_NEW:
                return undefined;
            case RECEIVE_TRANSCEIVERS_USE_TYPE.REUSE:
                const mid = Object.keys(this._receiveTransceivers).find((id) => {
                    return this._receiveTransceivers[id].type === type && !this._receiveTransceivers[id].sourceId;
                });
                return this._receiveTransceivers[mid];
            default:
                return undefined;
        }
    }
    _getTransceiverData(sourceId) {
        const mid = Object.keys(this._receiveTransceivers).find((id) => {
            return this._receiveTransceivers[id].sourceId === sourceId;
        });
        const transceiver = this._pc.getTransceivers().find((tr) => tr.mid === mid);
        return { transceiver, data: this._receiveTransceivers[mid] };
    }
    _getTransceiverType(transceiver) {
        if (transceiver.receiver && transceiver.receiver.track) {
            return transceiver.receiver.track.kind;
        }
        else if (transceiver.sender && transceiver.sender.track) {
            return transceiver.sender.track.kind;
        }
        return '';
    }
    _getTemplate(type) {
        switch (type) {
            case 'audio':
                return this.mAudioTemplate;
            case 'video':
                return this.mVideoTemplate;
            default:
                return '';
        }
    }
    _createNewMLineSources(source, pid) {
        let type = source.Type === 'application' ? 'video' : source.Type;
        let mlinesrc = '';
        const SSRCsLineTmpl = (ssrc, objId, pid, label) => {
            let ssrcLine = `a=ssrc:${ssrc} cname:${objId}\r\n`;
            ssrcLine += `a=ssrc:${ssrc} msid:${pid} ${label}\r\n`;
            ssrcLine += `a=ssrc:${ssrc} mslabel:${pid}\r\n`;
            ssrcLine += `a=ssrc:${ssrc} label:${label}\r\n`;
            return ssrcLine;
        };
        if (type === 'audio') {
            mlinesrc += SSRCsLineTmpl(source.Ssrc[0], source.ObjId, pid, source.Ssrc[0]);
        }
        if (type === 'video') {
            if (source.Ssrc.length > 1) {
                mlinesrc += `a=ssrc-group:FID ${source.Ssrc.join(' ')}\r\n`;
            }
            source.Ssrc.forEach((s) => {
                mlinesrc += SSRCsLineTmpl(s, source.ObjId, pid, source.Ssrc[0]);
            });
        }
        return mlinesrc;
    }
}
class MediaSession {
    constructor(_provider, _context, _localStreamController, _remoteStreamController, _transmitedStreamController, _eventDispatcher, _logger, _options) {
        this._provider = _provider;
        this._context = _context;
        this._localStreamController = _localStreamController;
        this._remoteStreamController = _remoteStreamController;
        this._transmitedStreamController = _transmitedStreamController;
        this._eventDispatcher = _eventDispatcher;
        this._logger = _logger;
        this._options = _options;
        this.iceTimeout = 5000;
        this._peerConnectionStateRetryCount = 0;
        this._remoteStreams = {};
        this._sourcesToRemove = new Set();
        this._lastBandwidth = 0;
    }
    AddStream(stream) {
    }
    GetStats() {
        if (this.pc) {
            return this.pc.getStats();
        }
        return Promise.reject();
    }
    GetTrackEncodingParameters(trackId) {
        if (this.pc) {
            const sender = this.pc.getSenders().find((s) => s.track && s.track.id === trackId);
            if (sender) {
                const encodingParameters = sender.getParameters().encodings ?? [];
                return encodingParameters.map((e, i) => ({
                    active: e.active,
                    bandwidth: e.maxBitrate,
                    name: Constants_1.Runnels[i],
                    scaleResolutionDownBy: e.scaleResolutionDownBy
                }));
            }
        }
        return [];
    }
    UpdateMediaStates(renegotiate = false) {
        if (!this._asyncPromise) {
            return;
        }
        this._makeAsyncOperation(async (done) => {
            let needRenegotiate = false;
            const getTrackProps = (trackId) => {
                const props = this._localStreamController.GetTrackMediaProperties(trackId);
                const enabled = this._transmitedStreamController.IsSourceEnabled(trackId);
                let isActive = enabled;
                if (props.bandwidth === 0) {
                    isActive = false;
                }
                return {
                    isActive,
                    bandwidth: props.bandwidth,
                    muted: props.muted,
                    mediaType: props.mediaType
                };
            };
            const updateSenderBandwidth = async (sender, bandwidth, mediaType) => {
                try {
                    const parameters = sender.getParameters();
                    if (!parameters.encodings || parameters.encodings.length === 0) {
                        parameters.encodings = [{}];
                    }
                    if (bandwidth === undefined &&
                        ((this._options.enableVideoSimulcast && mediaType === TrackMetaDataProvider_1.MediaTrackType.Video) ||
                            (this._options.enableScreenShareSimulcast && mediaType === TrackMetaDataProvider_1.MediaTrackType.Application))) {
                        bandwidth = 10000000;
                    }
                    if (typeof bandwidth === 'number' && !isNaN(bandwidth)) {
                        if ((this._options.enableVideoSimulcast && mediaType === TrackMetaDataProvider_1.MediaTrackType.Video)
                            || (this._options.enableScreenShareSimulcast && mediaType === TrackMetaDataProvider_1.MediaTrackType.Application)) {
                            if (this._provider._simplifiedVidyoCore.AdvancedSettings.EnableFixedSimulcastRunnels !== false) {
                                let numberOfRunnels = this._provider._simplifiedVidyoCore.AdvancedSettings.EnableFixedSimulcastRunnels;
                                parameters.encodings.forEach(enc => enc.active = false);
                                for (let i = 0; i < numberOfRunnels; i++) {
                                    parameters.encodings[i].active = true;
                                    parameters.encodings[i].scaleResolutionDownBy = (1 << i);
                                }
                                this._logger.LogDebug(() => `Runnels encodings setting (forced ${numberOfRunnels} runnels): ${JSON.stringify(parameters.encodings)}`);
                            }
                            else {
                                const { runnels, codecName } = this._localStreamController.GetTrackMediaProperties(sender.track.id);
                                if (Object.keys(runnels).some((k) => runnels[k].active)) {
                                    const runnelsArray = Constants_1.Runnels.map((r) => runnels[r]);
                                    for (let i = 0; i < runnelsArray.length; i++) {
                                        parameters.encodings[i].scaleResolutionDownBy = runnelsArray[i].downScaleFactor;
                                        if (runnelsArray[i].bandwidth > 0) {
                                            parameters.encodings[i].maxBitrate = runnelsArray[i].bandwidth;
                                        }
                                        parameters.encodings[i].active = codecName && codecName !== 'VP9' ? runnelsArray[i].active : true;
                                    }
                                    this._logger.LogDebug(() => `Runnels encodings setting ${JSON.stringify(parameters.encodings)}`);
                                }
                                else {
                                    this._logger.LogDebug(() => `Runnels are not configured yet, ignore for now`);
                                }
                            }
                        }
                        else {
                            const mediaType = this._localStreamController.GetTrackMediaProperties(sender.track.id).mediaType;
                            if (mediaType === TrackMetaDataProvider_1.MediaTrackType.Video) {
                                const downScaleFactor = this._localStreamController.GetCameraResolutionDownScaleFactor();
                                if (downScaleFactor) {
                                    this._logger.LogDebug(() => `Setting scaleResolutionDownBy ${downScaleFactor} for ${mediaType}`);
                                    parameters.encodings[0].scaleResolutionDownBy = downScaleFactor;
                                }
                            }
                            parameters.encodings[0].maxBitrate = bandwidth;
                            if (this._lastBandwidth === bandwidth) {
                                return;
                            }
                            this._lastBandwidth = bandwidth;
                            this._logger.LogDebug(() => `Setting maxBitrate ${bandwidth} for ${mediaType}`);
                        }
                        await sender.setParameters(parameters);
                    }
                }
                catch (e) {
                    this._logger.LogWarning(() => `Setting sender encodings failed. ${e}`);
                }
            };
            const updateSenderActiveState = async (sender, isActive) => {
                try {
                    const parameters = sender.getParameters();
                    if (parameters.encodings && parameters.encodings.length > 0 && parameters.encodings[0].active !== isActive) {
                        await sender.setParameters(parameters);
                        needRenegotiate = true;
                    }
                }
                catch (e) { }
            };
            const updateTransceiverMediaState = async (transceiver) => {
                const props = getTrackProps(transceiver.sender.track.id);
                await updateSenderBandwidth(transceiver.sender, props.bandwidth, props.mediaType);
                const trDirection = props.isActive ? 'sendonly' : 'inactive';
                if (transceiver.direction !== 'stopped' && transceiver.direction !== trDirection) {
                    try {
                        transceiver.direction = trDirection;
                    }
                    catch (e) {
                        this._logger.LogWarning(() => `Error changing transceiver direction. transceiver mid: ${transceiver.mid}, message: ${e}`);
                    }
                    needRenegotiate = true;
                }
                if (props.mediaType === TrackMetaDataProvider_1.MediaTrackType.Audio && transceiver.sender.track && transceiver.sender.track.enabled === props.muted) {
                    transceiver.sender.track.enabled = !props.muted;
                    needRenegotiate = true;
                }
            };
            const updateSenderMediaState = async (sender) => {
                const props = getTrackProps(sender.track.id);
                await updateSenderBandwidth(sender, props.bandwidth, props.mediaType);
                await updateSenderActiveState(sender, props.isActive);
            };
            await Promise.all(this._unifiedSDPHelper.SendTransceivers.map(async (data) => {
                if (null !== data.transceiver.mid && data.transceiver.sender.track) {
                    await updateTransceiverMediaState(data.transceiver);
                }
            }));
            if (needRenegotiate || renegotiate) {
                this.resetPeerConnection();
            }
            done();
        });
    }
    UpdateStreamTracks(stream) {
        this._makeAsyncOperation(async (done) => {
            let needrenegotiate = false;
            await Promise.all(this._unifiedSDPHelper.SendTransceivers.map(async (data) => {
                if (data.transceiver.sender.track) {
                    if (!stream.getTracks().find((tr) => tr.id === data.transceiver.sender.track.id)) {
                        needrenegotiate = true;
                        if (data.transceiver.mid !== '0' && data.transceiver.mid !== 'L0') {
                            data.transceiver.sender.track.stop();
                            await data.transceiver.sender.replaceTrack(null);
                            data.transceiver.stop();
                            data.stopped = true;
                        }
                        else {
                            await data.transceiver.sender.replaceTrack(null);
                            data.transceiver.direction = 'inactive';
                        }
                    }
                }
            }));
            await Promise.all(stream.getTracks().map(async (tr) => {
                if (!this._unifiedSDPHelper.SendTransceivers.find((data) => {
                    if (!data.transceiver.sender.track)
                        return false;
                    return data.transceiver.sender.track.id === tr.id;
                })) {
                    let transceiverInit = {
                        direction: 'sendonly',
                        streams: [stream],
                        sendEncodings: []
                    };
                    let transceiver = this.pc.addTransceiver(tr, transceiverInit);
                    this._unifiedSDPHelper.AddSendTransceiver(transceiver, tr.kind);
                    needrenegotiate = true;
                    const { isSimulcast } = this._localStreamController.GetTrackMediaProperties(tr.id);
                    if (tr.kind === 'video' && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox() && isSimulcast) {
                        let parameters = transceiver.sender.getParameters();
                        parameters.encodings = Constants_1.Runnels.map((r, i) => ({ rid: r, active: true, scaleResolutionDownBy: 1 << i }));
                        transceiver.sender.setParameters(parameters);
                    }
                }
            }));
            this._updateMediaTracksContentHints();
            if (needrenegotiate) {
                this.resetPeerConnection();
            }
            this.UpdateMediaStates(needrenegotiate);
            done();
        });
    }
    _initPeerConnection() {
        let turn_port = this._context.turnUri.search('turns:') == -1 ? Constants_1.DefaultTurnPort : Constants_1.DefaultTurnsPort;
        let conf = {
            sdpSemantics: 'unified-plan',
            iceServers: [{ "urls": [this._context.turnUri + `:${turn_port}`], "username": "vidyo", "credential": "tHISiSarEALLYlONGpASSWORD@2037" }],
            bundlePolicy: 'max-bundle'
        };
        let constraint = {
            optional: [
                { googHighStartBitrate: 0 },
                { googPayloadPadding: true },
                { googScreencastMinBitrate: Constants.DefaultContentShareBandwidth / 1000 },
                { googCpuOveruseDetection: true }
            ]
        };
        if (this._options.enableUDPTransport === false) {
            conf.iceTransportPolicy = 'relay';
        }
        else {
            conf.iceTransportPolicy = 'all';
        }
        let session = this;
        this.pc = new RTCPeerConnection(conf, constraint);
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()
            && !Array.isArray(window['__VIDEO_CODEC_BLACK_LIST__'])) {
            window['__VIDEO_CODEC_BLACK_LIST__'] = ['VP9'];
        }
        if ((typeof RTCRtpSender.getCapabilities === 'function')) {
            this._logger.LogDebug(() => `RTCRtpSender.getCapabilities is supported, adjust video codec preference order`);
            this._codecsPreference = RTCRtpSender.getCapabilities('video').codecs;
            this._logger.LogDebug(() => `before ${JSON.stringify(this._codecsPreference)}`);
            this._codecsPreference.sort((a, b) => {
                if (a.mimeType.includes('VP9')) {
                    return !b.mimeType.includes('VP9') ? -1 : 0;
                }
                else if (a.mimeType.includes('VP8')) {
                    return (!b.mimeType.includes('VP8') && !b.mimeType.includes('VP9')) ? -1 : 0;
                }
                else {
                    return 0;
                }
            });
            this._logger.LogDebug(() => `after ${JSON.stringify(this._codecsPreference)}`);
        }
        else if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
            this._codecsPreference = [{ mimeType: 'VP9', clockRate: 90000 }, { mimeType: 'VP8', clockRate: 90000 }];
        }
        this._asyncPromise = Promise.resolve();
        this._asyncPromiseTaskDoneCallback = null;
        this._unifiedSDPHelper = new UnifiedSDPHelper(this.pc, this._localStreamController, this._logger);
        const participantSourcesChanged = TimingProvider_1.TimingProvider.Debounce(() => {
            if (this._lastRemoteCaps) {
                this._setRemoteCapabilities(this._lastRemoteCaps);
            }
            else {
                this._logger.LogWarning(() => `Trying to handle remote ssrc states when there no remote capabilities`);
            }
        }, 0);
        this._eventDispatcher.releaseGroup(MediaSession.MediaSessionEventsListeners);
        this._eventDispatcher.on(ConferenceEvents.Events.ActivateRemoteSource, MediaSession.MediaSessionEventsListeners, (data) => {
            const participant = this._provider._simplifiedVidyoCore
                .GetRemoteParticipants().find((p) => p.Id === data.participantId);
            if (participant) {
                const src = participant.GetSourceBySSrc(data.ssrc);
                if (src) {
                    this._unifiedSDPHelper.AddSource(data.participantId, src);
                    participantSourcesChanged();
                }
            }
        });
        this._eventDispatcher
            .on(ConferenceEvents.Events.DeactivateRemoteSource, MediaSession.MediaSessionEventsListeners, (data) => {
            this._handleRemoteSourceRemoved(data.ssrc);
            this._unifiedSDPHelper.RemoveSource(data.ssrc);
            participantSourcesChanged();
        });
        this._eventDispatcher
            .on(ConferenceEvents.Events.SourceRemoved, MediaSession.MediaSessionEventsListeners, (data) => {
            this._handleRemoteSourceRemoved(data.ssrc);
            this._unifiedSDPHelper.RemoveSource(data.ssrc);
            participantSourcesChanged();
        });
        this._eventDispatcher.on(AdvancedSettingsEvents.Events.EnableFixedSimulcastRunnelsChanged, MediaSession.MediaSessionEventsListeners, () => {
            this.UpdateMediaStates();
        });
        this._eventDispatcher.on(AdvancedSettingsEvents.Events.CameraContentHintChanged, MediaSession.MediaSessionEventsListeners, () => {
            this._updateMediaTracksContentHints();
        });
        this._eventDispatcher.on(AdvancedSettingsEvents.Events.WindowShareContentHintChanged, MediaSession.MediaSessionEventsListeners, () => {
            this._updateMediaTracksContentHints();
        });
        const stream = this._localStreamController.GetTransmittedStream();
        stream.getTracks().forEach((track) => {
            let transceiverInit = {
                direction: 'sendonly',
                streams: [stream],
                sendEncodings: []
            };
            let transceiver = this.pc.addTransceiver(track, transceiverInit);
            this._unifiedSDPHelper.AddSendTransceiver(transceiver, track.kind);
            const { isSimulcast } = this._localStreamController.GetTrackMediaProperties(track.id);
            if (track.kind === 'video' && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox() && isSimulcast) {
                let parameters = transceiver.sender.getParameters();
                parameters.encodings = Constants_1.Runnels.map((r, i) => ({ rid: r, active: true, scaleResolutionDownBy: 1 << i }));
                transceiver.sender.setParameters(parameters);
            }
        });
        ['audio', 'video'].forEach((mediaType) => {
            let found = this.pc.getTransceivers().find((t) => {
                return t.sender && t.sender.track && t.sender.track.kind === mediaType;
            });
            if (!found) {
                const transceiver = this.pc.addTransceiver(mediaType, { direction: 'sendonly', streams: [stream] });
                this._unifiedSDPHelper.AddSendTransceiver(transceiver, mediaType);
            }
        });
        this._updateMediaTracksContentHints();
        const endOfIceCallback = async (done) => {
            this.pc.onicecandidate = undefined;
            if (this.pc.localDescription) {
                let offer = {
                    sdp: this.pc.localDescription.sdp,
                    type: this.pc.localDescription.type
                };
                if (this._options.enableTCPTransport === false) {
                    offer.sdp = disableTCPCandidates(offer.sdp);
                }
                offer.sdp = disableCodecs(offer.sdp);
                const scel = this.SdpToScel(offer.sdp);
                await this._provider._SetLocalCapabilities(scel);
                this._asyncPromiseTaskDoneCallback = done;
            }
            else {
                done();
                this.resetPeerConnection();
            }
        };
        this.pc.ontrack = (event) => {
            if (event.streams && event.streams.length) {
                let stream = event.streams[0];
                this._remoteStreams[stream.id] = stream;
                this._logger.LogDebug(() => 'addStream: ' + stream.id);
                session._eventDispatcher.emitAsync(ConnectionEvents.Events.JingleRemoteStreamAdded, { stream: stream });
                stream.onremovetrack = () => {
                    if (stream.getTracks().length == 0) {
                        delete this._remoteStreams[stream.id];
                        this._logger.LogDebug(() => 'all tracks are removed, remove stream: ' + stream.id);
                        session._eventDispatcher.emit(ConnectionEvents.Events.JingleRemoteStreamRemoved, { stream: stream });
                    }
                };
            }
            this._logger.LogDebug(() => `IOWEBRTC-1317 ${event.track.kind} track ${event.track.id} mute state: ${event.track.muted}`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            event.track.onmute = () => this._logger.LogDebug(() => `IOWEBRTC-1317 ${event.track.kind} track ${event.track.id} muted`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            event.track.onunmute = () => this._logger.LogDebug(() => `IOWEBRTC-1317 ${event.track.kind}  track ${event.track.id} unmuted`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
        };
        this.pc['onremovestream'] = (event) => {
            delete this._remoteStreams[stream.id];
            this._logger.LogDebug(() => 'removeStream: ' + event.stream.id);
            session._eventDispatcher.emit(ConnectionEvents.Events.JingleRemoteStreamRemoved, { stream: event.stream });
        };
        this._makeAsyncOperation(async (done) => {
            try {
                this._logger.LogDebug(() => 'initial createOffer to trigger ICE gathering');
                const offer = await this.pc.createOffer();
                offer.sdp = AddLPrefixToSendMids(offer.sdp);
                offer.sdp = ArrangeVideoCodecByPreferenceList(offer.sdp, this._codecsPreference);
                if (this._options.enableTCPTransport === false) {
                    offer.sdp = disableTCPCandidates(offer.sdp);
                }
                offer.sdp = disableCodecs(offer.sdp);
                if (this._options.enableVideoSimulcast || this._options.enableScreenShareSimulcast) {
                    offer.sdp = this._unifiedSDPHelper.CheckAndAddSimulcast(offer.sdp);
                }
                await this.pc.setLocalDescription(offer);
                this._unifiedSDPHelper.ActualLocalSDP = offer.sdp;
                this._unifiedSDPHelper.OnNewLocalOffer(offer.sdp);
                this.pc.onicecandidate = (event) => {
                    if (this.iceTimer) {
                        clearTimeout(this.iceTimer);
                        this.iceTimer = null;
                    }
                    if (!event.candidate) {
                        this._logger.LogDebug(() => `no more ice candidate`);
                        endOfIceCallback(done);
                    }
                    else {
                        this._logger.LogDebug(() => `ice candidate: ${JSON.stringify(event.candidate)}`);
                        this.iceTimer = setTimeout(() => endOfIceCallback(done), this.iceTimeout);
                    }
                };
            }
            catch (error) {
                this._logger.LogError(error);
                this._eventDispatcher.emit(ConnectionEvents.Events.MediaSessionFailed, ConnectionEvents_1.ConnectionEventsInfo.MediaSessionError);
            }
        });
    }
    resetPeerConnection() {
        if (!this._asyncPromise) {
            return;
        }
        this._makeAsyncOperation(async (done) => {
            try {
                const offer = await this.pc.createOffer();
                offer.sdp = AddLPrefixToSendMids(offer.sdp);
                offer.sdp = ArrangeVideoCodecByPreferenceList(offer.sdp, this._codecsPreference);
                if (this._options.enableTCPTransport === false) {
                    offer.sdp = disableTCPCandidates(offer.sdp);
                }
                offer.sdp = disableCodecs(offer.sdp);
                if (this._options.enableVideoSimulcast || this._options.enableScreenShareSimulcast) {
                    offer.sdp = this._unifiedSDPHelper.CheckAndAddSimulcast(offer.sdp);
                }
                const scel = this.SdpToScel(offer.sdp);
                offer.sdp = this._unifiedSDPHelper.UseLastAnswerVideoCodecs(offer.sdp);
                await this.pc.setLocalDescription(offer);
                this._unifiedSDPHelper.ActualLocalSDP = offer.sdp;
                this._provider._SetLocalCapabilities(scel);
                this._asyncPromiseTaskDoneCallback = done;
            }
            catch (error) {
                done();
                this._logger.LogError(() => `resetPeerConnection ${error}`);
                this._eventDispatcher.emit(ConnectionEvents.Events.MediaSessionFailed, ConnectionEvents_1.ConnectionEventsInfo.MediaSessionError);
            }
        });
    }
    async _SetSessionAnswer(caps) {
        if (this._asyncPromiseTaskDoneCallback) {
            let sdp = this.ScelToSdp(caps, true);
            this._logger.LogDebug(() => "remote answer SDP given to RTCPeerConnection: " + sdp, LogEvents_1.VidyoLogCategory.VidyoSDP);
            if (this.pc.signalingState === 'have-local-offer') {
                let answer = { type: 'answer', sdp: sdp };
                await this.pc.setRemoteDescription(answer);
            }
            else {
                this._logger.LogDebug(() => `Already has remoteCapabilities, ignore`);
            }
            this._removeRemoteStreamTracks();
            this._asyncPromiseTaskDoneCallback();
            this._asyncPromiseTaskDoneCallback = null;
        }
        else {
            this._logger.LogError(() => '_SetSessionAnswer received sessionAnswer without sessionInit');
        }
    }
    _handleRemoteSourceRemoved(ssrc) {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
            this._sourcesToRemove.add(ssrc);
        }
    }
    _removeRemoteStreamTracks() {
        if (this._sourcesToRemove.size) {
            const tracksToRemove = Array.from(this._sourcesToRemove).map((ssrc) => {
                return this._remoteStreamController.GetGeneratedIdBySsrc(ssrc);
            });
            Object.values(this._remoteStreams).forEach((mediaStream) => {
                mediaStream.getTracks().forEach((track) => {
                    if (tracksToRemove.includes(track.id)) {
                        mediaStream.removeTrack(track);
                        mediaStream.dispatchEvent(new Event('removetrack'));
                    }
                });
            });
            this._sourcesToRemove.clear();
        }
    }
    _updateMediaTracksContentHints() {
        const stream = this._localStreamController.GetTransmittedStream();
        stream.getTracks().forEach((track) => {
            if (track.kind === 'video' && 'contentHint' in track) {
                const props = this._localStreamController.GetTrackMediaProperties(track.id);
                switch (props.mediaType) {
                    case "application":
                        track.contentHint = this._provider._simplifiedVidyoCore.AdvancedSettings.WindowShareContentHint;
                        break;
                    case "video":
                        track.contentHint = this._provider._simplifiedVidyoCore.AdvancedSettings.CameraContentHint;
                        break;
                    default:
                        console.warn("unsupported media type " + props.mediaType);
                        break;
                }
            }
        });
    }
    _setRemoteCapabilities(caps) {
        this._makeAsyncOperation(async (done) => {
            let sdp = this.ScelToSdp(caps);
            let answer;
            this._logger.LogDebug(() => "remote offer SDP given to RTCPeerConnection: " + sdp, LogEvents_1.VidyoLogCategory.VidyoSDP);
            try {
                if (this.pc.signalingState === 'stable') {
                    let offer = { type: 'offer', sdp: sdp };
                    await this.pc.setRemoteDescription(offer);
                    answer = await this.pc.createAnswer();
                    let needSendSessionInit = isLocalDescriptionVideoLineChanged(this.pc.currentLocalDescription.sdp, answer.sdp, sdp);
                    if (this._options.enableTCPTransport === false) {
                        answer.sdp = disableTCPCandidates(answer.sdp);
                    }
                    answer.sdp = disableCodecs(answer.sdp);
                    if (this._options.enableVideoSimulcast || this._options.enableScreenShareSimulcast) {
                        answer.sdp = this._unifiedSDPHelper.CheckAndAddSimulcast(answer.sdp);
                    }
                    await this.pc.setLocalDescription(answer);
                    this._unifiedSDPHelper.ActualLocalSDP = answer.sdp;
                    this._unifiedSDPHelper.CachedLocalAnswerSDP = answer.sdp;
                    this._removeRemoteStreamTracks();
                    if (needSendSessionInit) {
                        this._logger.LogDebug(() => 'RTCPeerConnection localDescription changed, send sInit with updated localDescription', LogEvents_1.VidyoLogCategory.VidyoSDP);
                        const scel = this.SdpToScel(answer.sdp);
                        this._provider._SetLocalCapabilities(scel);
                        this._asyncPromiseTaskDoneCallback = done;
                    }
                    else {
                        done();
                    }
                }
                else {
                    this._logger.LogError(() => `pc.signalingState=${this.pc.signalingState}`);
                    done();
                }
                this._peerConnectionStateRetryCount = 0;
            }
            catch (error) {
                if (this.pc.signalingState === 'have-remote-offer' && this._peerConnectionStateRetryCount === 0) {
                    this._logger.LogError(() => `_SetRemoteCapabilities ${error}\ncreated answer:\n${answer?.sdp}, re-trying..`);
                    await this.pc.setRemoteDescription({ type: 'rollback' });
                    this._setRemoteCapabilities(caps);
                    this._peerConnectionStateRetryCount++;
                }
                else {
                    this._logger.LogError(() => `_SetRemoteCapabilities ${error}`);
                    this._eventDispatcher.emit(ConnectionEvents.Events.MediaSessionFailed, ConnectionEvents_1.ConnectionEventsInfo.MediaSessionError);
                }
                done();
            }
        });
    }
    ProcessRemoteOffer(scel) {
        let caps = scel.replace(/caps/g, "capabilities");
        this._lastRemoteCaps = caps;
        this._setRemoteCapabilities(caps);
    }
    Close() {
        if (this._unifiedSDPHelper) {
            this._unifiedSDPHelper.CachedLocalAnswerSDP = '';
        }
        if (this.pc != undefined) {
            this.pc.getTransceivers()
                .filter((transceiver) => !!transceiver.sender?.track)
                .forEach((transceiver) => this.pc.removeTrack(transceiver.sender));
            this.pc.close();
        }
        if (this._eventDispatcher) {
            this._eventDispatcher.releaseGroup(MediaSession.MediaSessionEventsListeners);
        }
    }
    _makeAsyncOperation(operation) {
        if (!this._asyncPromise || !this.pc || this.pc.connectionState === 'closed') {
            return;
        }
        this._asyncPromise = this._asyncPromise.then(() => {
            return new Promise(res => {
                operation(res);
            });
        });
    }
    GetReceiverSsrcByTrackId(id) {
        return this._unifiedSDPHelper?.GetRemoteTrackSsrc(id);
    }
    ScelToSdp(scel, isAnswer = false) {
        this._logger.LogDebug(() => `SCEL to convert ${scel}`, LogEvents_1.VidyoLogCategory.VidyoSDP);
        let sdp = (0, WebRtcSdpScel_1.ScelToSdp)(scel, true);
        this._logger.LogDebug(() => `Converted SDP ${sdp}`, LogEvents_1.VidyoLogCategory.VidyoSDP);
        sdp = fixRemoteSDP(sdp);
        this._unifiedSDPHelper.UpdateMLinesTemplates(sdp);
        sdp = this._unifiedSDPHelper.GetActualRemoteSdp(isAnswer);
        return sdp;
    }
    SdpToScel(sdp) {
        sdp = fixLocalSDP(sdp);
        sdp = this._unifiedSDPHelper.FixLocalSDPBeforeScel(sdp, this._localStreamController);
        this._unifiedSDPHelper.OnNewLocalOffer(sdp);
        this._logger.LogDebug(() => `SDP to convert ${sdp}`, LogEvents_1.VidyoLogCategory.VidyoSDP);
        let scel = (0, WebRtcSdpScel_1.SdpToScel)(sdp, true);
        this._logger.LogDebug(() => `Converted SCEL ${scel}`, LogEvents_1.VidyoLogCategory.VidyoSDP);
        scel = this._unifiedSDPHelper.FixLocalScel(scel, this._localStreamController, this._transmitedStreamController);
        scel = scel.replace(/ xmlns=\"[a-zA-Z0-9\.\/:]+\"/g, '');
        return scel;
    }
}
exports.MediaSession = MediaSession;
MediaSession.MediaSessionEventsListeners = 'MediaSessionEventsListeners';

},{"../../vidyo_simple_api/Devices":184,"../controllers/StreamController/TrackMetaDataProvider":59,"../events/AdvancedSettingsEvents":62,"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/LogEvents":69,"../models/Source":98,"../utils/Constants":138,"../utils/OperatingSystemInfoProvider":154,"../utils/TimingProvider":166,"./WebRtcSdpScel":88}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScipSession = exports.ScipPacketProcessor = exports.GenericAck = exports.GenericCommand = exports.Unsubscribe = exports.SubscribeAck = exports.Subscribe = exports.Terminate = exports.Unregister = exports.RegisterAck = exports.Register = exports.SessionUpdateAck = exports.SessionUpdate = exports.SessionTerminate = exports.SessionReject = exports.SessionAccept = exports.SessionAnswer = exports.SessionInitiate = exports.ScipReply = exports.ScipCommand = exports.EndpointIdTemplate = exports.ToTemplate = exports.FocusFlagTemplate = exports.ExpiresTemplate = exports.ConferenceListTemplate = exports.DisplayTextTemplate = exports.Credentials = exports.CredentialsType = exports.ScipSessionEventType = exports.SessionState = void 0;
const ConnectionEvents = require("../events/ConnectionEvents");
const StreamEvents = require("../events/StreamEvents");
const ConferenceEvents = require("../events/ConferenceEvents");
const CmcpSession_1 = require("./CmcpSession");
const LmiProtocol = require("./LmiProtocol");
const PacketProcessor_1 = require("./PacketProcessor");
const LogEvents_1 = require("../events/LogEvents");
let SCIP_VERSION = 1;
var SessionState;
(function (SessionState) {
    SessionState[SessionState["Idle"] = 1] = "Idle";
    SessionState[SessionState["TransportEstablished"] = 2] = "TransportEstablished";
    SessionState[SessionState["WaitIceComplete"] = 3] = "WaitIceComplete";
    SessionState[SessionState["LocalInitiating"] = 4] = "LocalInitiating";
    SessionState[SessionState["WaitLocalAnswer"] = 5] = "WaitLocalAnswer";
    SessionState[SessionState["Active"] = 6] = "Active";
    SessionState[SessionState["RemoteBooted"] = 7] = "RemoteBooted";
    SessionState[SessionState["Terminated"] = 8] = "Terminated";
})(SessionState = exports.SessionState || (exports.SessionState = {}));
var ScipSessionEventType;
(function (ScipSessionEventType) {
    ScipSessionEventType[ScipSessionEventType["RemoteAccepted"] = 0] = "RemoteAccepted";
    ScipSessionEventType[ScipSessionEventType["RemoteOffered"] = 1] = "RemoteOffered";
    ScipSessionEventType[ScipSessionEventType["ConferenceJoined"] = 2] = "ConferenceJoined";
    ScipSessionEventType[ScipSessionEventType["ProcessConferenceBooted"] = 3] = "ProcessConferenceBooted";
    ScipSessionEventType[ScipSessionEventType["ProcessInitiateCommand"] = 4] = "ProcessInitiateCommand";
    ScipSessionEventType[ScipSessionEventType["ProcessAcceptCommand"] = 5] = "ProcessAcceptCommand";
    ScipSessionEventType[ScipSessionEventType["ProcessTerminateCommand"] = 6] = "ProcessTerminateCommand";
    ScipSessionEventType[ScipSessionEventType["ProcessRejectCommand"] = 7] = "ProcessRejectCommand";
    ScipSessionEventType[ScipSessionEventType["ProcessSessionUpdateCommand"] = 8] = "ProcessSessionUpdateCommand";
    ScipSessionEventType[ScipSessionEventType["ProcessGenericAck"] = 9] = "ProcessGenericAck";
    ScipSessionEventType[ScipSessionEventType["ProcessSessionUpdateAck"] = 10] = "ProcessSessionUpdateAck";
    ScipSessionEventType[ScipSessionEventType["ProcessRegisterAck"] = 11] = "ProcessRegisterAck";
    ScipSessionEventType[ScipSessionEventType["ProcessUpdateAck"] = 12] = "ProcessUpdateAck";
    ScipSessionEventType[ScipSessionEventType["ProcessSubscribeAck"] = 13] = "ProcessSubscribeAck";
    ScipSessionEventType[ScipSessionEventType["Register"] = 14] = "Register";
    ScipSessionEventType[ScipSessionEventType["Unregister"] = 15] = "Unregister";
    ScipSessionEventType[ScipSessionEventType["SessionInitiate"] = 16] = "SessionInitiate";
    ScipSessionEventType[ScipSessionEventType["SessionAccept"] = 17] = "SessionAccept";
    ScipSessionEventType[ScipSessionEventType["SessionAnswer"] = 18] = "SessionAnswer";
    ScipSessionEventType[ScipSessionEventType["SetLocalCapabilities"] = 19] = "SetLocalCapabilities";
    ScipSessionEventType[ScipSessionEventType["InitiateNoAuth"] = 20] = "InitiateNoAuth";
    ScipSessionEventType[ScipSessionEventType["InitiateWithAuth"] = 21] = "InitiateWithAuth";
    ScipSessionEventType[ScipSessionEventType["Accept"] = 22] = "Accept";
    ScipSessionEventType[ScipSessionEventType["ScipTerminate"] = 23] = "ScipTerminate";
    ScipSessionEventType[ScipSessionEventType["DoTerminateCompleted"] = 24] = "DoTerminateCompleted";
    ScipSessionEventType[ScipSessionEventType["TransportConnectionTerminated"] = 25] = "TransportConnectionTerminated";
    ScipSessionEventType[ScipSessionEventType["TransportConnectionEstablished"] = 26] = "TransportConnectionEstablished";
    ScipSessionEventType[ScipSessionEventType["TransportConnectionConnect"] = 27] = "TransportConnectionConnect";
    ScipSessionEventType[ScipSessionEventType["TransportConnectionDisconnect"] = 28] = "TransportConnectionDisconnect";
    ScipSessionEventType[ScipSessionEventType["Terminate"] = 29] = "Terminate";
})(ScipSessionEventType = exports.ScipSessionEventType || (exports.ScipSessionEventType = {}));
var CredentialsType;
(function (CredentialsType) {
    CredentialsType[CredentialsType["password"] = 1] = "password";
    CredentialsType[CredentialsType["accessToken"] = 2] = "accessToken";
    CredentialsType[CredentialsType["refreshToken"] = 3] = "refreshToken";
})(CredentialsType = exports.CredentialsType || (exports.CredentialsType = {}));
class Credentials extends PacketProcessor_1.Element {
    toXml(body) {
        return super.toXml();
    }
}
exports.Credentials = Credentials;
function DisplayTextTemplate(displayText) {
    let template = `<dt>${displayText}</dt>`;
    return template;
}
exports.DisplayTextTemplate = DisplayTextTemplate;
function ConferenceListTemplate(conferenceList) {
    let template = '';
    return template;
}
exports.ConferenceListTemplate = ConferenceListTemplate;
function ExpiresTemplate(expires) {
    let template = '';
    if (expires > 0) {
        template = `<exp>${expires}</exp>`;
    }
    return template;
}
exports.ExpiresTemplate = ExpiresTemplate;
function FocusFlagTemplate(focusFlag) {
    let result = '';
    if (focusFlag) {
        result = '<ff>false</ff>';
    }
    else {
        result = '<ff>false</ff>';
    }
    return result;
}
exports.FocusFlagTemplate = FocusFlagTemplate;
function ToTemplate(to) {
    let template = `<to>${to}</to>`;
    return template;
}
exports.ToTemplate = ToTemplate;
function EndpointIdTemplate(endpointId) {
    let template = `<epId>${endpointId}</epId>`;
    return template;
}
exports.EndpointIdTemplate = EndpointIdTemplate;
function CredentialsTemplate(credentials) {
    return "";
}
class ScipCommand extends PacketProcessor_1.Command {
    constructor(session) {
        super(session.dialogId);
        this.session = session;
    }
    acked(reply) {
        try {
            reply.execute();
        }
        catch (e) {
        }
    }
}
exports.ScipCommand = ScipCommand;
class ScipReply extends PacketProcessor_1.Reply {
    constructor(session) {
        super(session.dialogId);
        this.session = session;
    }
}
exports.ScipReply = ScipReply;
class SessionInitiate extends ScipCommand {
    constructor(session) {
        super(session);
        this.identityList = this.session.identityList;
        this.conferenceList = new Array();
    }
    setDisplayName(displayText) {
        this.displayText = displayText;
    }
    setScel(scel) {
        this.scel = scel;
    }
    execute() {
        if (this.scel && !this.rxsrcObj) {
            let repliesList = new Array();
            let versionMismatch = new LmiProtocol.VersionMismatch();
            let reply = new GenericAck(this.session);
            reply.result = 200;
            reply.type = PacketProcessor_1.MessageType.Local;
            repliesList.push(reply);
            this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
            this.session.ProcessRemoteSessionInitiate(this.scel);
        }
        else {
            let repliesList = new Array();
            let versionMismatch = new LmiProtocol.VersionMismatch();
            let reply = new GenericAck(this.session);
            reply.result = 200;
            reply.type = PacketProcessor_1.MessageType.Local;
            repliesList.push(reply);
            this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
            if (this.rxsrcObj) {
                this.session.ProcessConferenceShow(this.rxsrcObj);
            }
        }
    }
    toXml(commandBody) {
        let displayText = DisplayTextTemplate(this.session._context.displayName);
        let capabilities = this.scel;
        let conferenceList = ConferenceListTemplate(["foo"]);
        let identity = LmiProtocol.IdentityListTemplate(this.identityList);
        let expires = ExpiresTemplate(this.expires);
        let focusFlag = FocusFlagTemplate(this.focusFlag);
        let to = ToTemplate(this.session._context.remoteUri);
        let endpointId = EndpointIdTemplate(this.session._context.endpointId);
        let template;
        if (this.isack) {
            template = `<sInit>${displayText}${expires}</sInit>`;
        }
        else {
            template = `<sInit>${displayText}${capabilities}${conferenceList}${identity}${expires}${focusFlag}${to}${endpointId}</sInit>`;
        }
        return super.toXml(template);
    }
    static fromCmdDOM(session, sInitEl) {
        const obj = new SessionInitiate(session);
        const scel = sInitEl.querySelector('caps')?.outerHTML ?? '';
        const rxsrcEl = sInitEl.querySelector('rxsrc');
        if (rxsrcEl) {
            const sidEl = rxsrcEl.querySelector('sid');
            const enable = rxsrcEl.hasAttribute('enabled') ?
                'false' !== rxsrcEl.getAttribute('enabled') : true;
            const widthEl = rxsrcEl.querySelector('ws w');
            const heightEl = rxsrcEl.querySelector('ws h');
            const minWidthEl = rxsrcEl.querySelector('mws w');
            const minHeightEl = rxsrcEl.querySelector('mws h');
            const pixelRateEl = rxsrcEl.querySelector('pr');
            const bandwidthEl = rxsrcEl.querySelector('bw');
            const minBandwidthEl = rxsrcEl.querySelector('mbw');
            const framerateEL = rxsrcEl.querySelector('fps');
            const minFramerateEL = rxsrcEl.querySelector('mfps');
            const prefEl = rxsrcEl.querySelector('pref');
            obj.rxsrcObj = {
                enable,
                id: sidEl ? sidEl.innerHTML : '',
                params: {
                    bandwidth: bandwidthEl ? bandwidthEl.innerHTML : '',
                    framerate: framerateEL ? framerateEL.innerHTML : '',
                    height: heightEl ? heightEl.innerHTML : '',
                    minBandwidth: minBandwidthEl ? minBandwidthEl.innerHTML : '',
                    minFrameRate: minFramerateEL ? minFramerateEL.innerHTML : '',
                    minHeight: minHeightEl ? minHeightEl.innerHTML : '',
                    minWidth: minWidthEl ? minWidthEl.innerHTML : '',
                    pixelrate: pixelRateEl ? pixelRateEl.innerHTML : '',
                    preference: prefEl ? prefEl.innerHTML : '',
                    width: widthEl ? widthEl.innerHTML : ''
                }
            };
        }
        obj.scel = scel;
        return obj;
    }
}
exports.SessionInitiate = SessionInitiate;
class SessionAnswer extends ScipCommand {
    constructor(session) {
        super(session);
        this.identityList = new Array();
    }
    setScel(scel) {
        this.scel = scel;
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new GenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_1.MessageType.Local;
        reply.transactionId = this.transactionId;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
        if (this.scel) {
            this.session.processSessionAnswer(this.scel);
        }
    }
    toXml(commandBody) {
        let displayText = DisplayTextTemplate(this.session._context.displayName);
        let capabilities = this.scel;
        let identityList = LmiProtocol.IdentityListTemplate(this.identityList);
        let expires = ExpiresTemplate(this.expires);
        let focusFlag = FocusFlagTemplate(this.focusflag);
        let endpointId = EndpointIdTemplate(this.session._context.endpointId);
        let template = `<sAns>${displayText}${capabilities}${identityList}${expires}${focusFlag}${endpointId}</sAns>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, sAnsEl) {
        const obj = new SessionAnswer(session);
        const scel = sAnsEl.querySelector('caps')?.outerHTML ?? '';
        if (scel.length == 0) {
            console.error(`NO CAPS in SessionAnswer`);
        }
        else {
            obj.scel = scel;
        }
        return obj;
    }
}
exports.SessionAnswer = SessionAnswer;
class SessionAccept extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new GenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_1.MessageType.Local;
        reply.transactionId = this.transactionId;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
        this.session.ProcessRemoteSessionAccept();
    }
    toXml(commandBody) {
        let endpointId = EndpointIdTemplate(this.session._context.endpointId);
        let template = `<sAcc>
        ${endpointId}
        </sAcc>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, sAccEl) {
        const obj = new SessionAccept(session);
        obj.endpointId = sAccEl.querySelector('epId')?.innerHTML ?? '';
        return obj;
    }
}
exports.SessionAccept = SessionAccept;
class SessionReject extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new GenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_1.MessageType.Local;
        reply.transactionId = this.transactionId;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    toXml(commandBody) {
        let template = `<sRej></sRej>`;
        return template;
    }
    static fromCmdDOM(session, sRejEl) {
        return new SessionReject(session);
    }
}
exports.SessionReject = SessionReject;
class SessionTerminate extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new GenericAck(this.session);
        reply.result = 200;
        reply.type = PacketProcessor_1.MessageType.Local;
        reply.transactionId = this.transactionId;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    toXml(commandBody) {
        let reasonTemplate = typeof this.reason === 'undefined' ? '' : `<rsn>${this.reason}</rsn>`;
        let template = `<sTerm>${reasonTemplate}</sTerm>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, sTermEl) {
        const obj = new SessionTerminate(session);
        const who = sTermEl.querySelector('who')?.innerHTML ?? '';
        const reason = Number(sTermEl.querySelector('reason')?.innerHTML ?? '');
        obj.who = who;
        obj.reason = reason;
        return obj;
    }
}
exports.SessionTerminate = SessionTerminate;
class SessionUpdate extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let reply = new SessionUpdateAck(this.session);
        reply.type = PacketProcessor_1.MessageType.Remote;
        reply.result = 200;
        reply.transactionId = this.transactionId;
        repliesList.push(reply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    toXml(body) {
        let capabilities = this.scel;
        let template = `<sUpd>
        ${capabilities}
        </sUpd>`;
        return template;
    }
    static fromCmdDOM(session, sUpdEl) {
        const obj = new SessionUpdate(session);
        const scel = sUpdEl.querySelector('caps')?.outerHTML ?? '';
        if (scel.length) {
            obj.scel = scel;
        }
        return obj;
    }
}
exports.SessionUpdate = SessionUpdate;
class SessionUpdateAck extends ScipReply {
    constructor(session) {
        super(session);
    }
    execute() { }
    toXml(replyBody) {
        let capabilities = this.scel;
        let template = `<sUpdAck>
        ${capabilities}
        </sUpdAck>`;
        return super.toXml(template);
    }
    static fromReplyDOM(session, sUpdAckReplyEl) {
        return new SessionUpdateAck(session);
    }
}
exports.SessionUpdateAck = SessionUpdateAck;
class Register extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: Register Execute`);
    }
    toXml(commandBody) {
        let credentials = CredentialsTemplate(this.credentials);
        let template = `<reg>
        ${credentials}
        </reg>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, regCmdEl) {
        return new Register(session);
    }
}
exports.Register = Register;
class RegisterAck extends ScipReply {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: RegisterAck Execute`);
    }
    toXml(replyBody) {
        let template = `<regAck>
        <uid>${this.userId}</uid>
        <atoken>${this.accessToken}</atoken>
        <rtoken>${this.refreshToken}</rtoken>
        </regAck>`;
        return super.toXml(template);
    }
    static fromReplyDOM(session, regAckReplyEl) {
        return new RegisterAck(session);
    }
}
exports.RegisterAck = RegisterAck;
class Unregister extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: Unregister Execute`);
    }
    acked(reply) {
    }
    toXml(commandBody) {
        let template = `<unreg></unreg>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, unregCmdEl) {
        return new Unregister(session);
    }
}
exports.Unregister = Unregister;
class Terminate extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: Terminate Execute`);
    }
    acked(reply) {
    }
    toXml(commandBody) {
        let template = `<term></term>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, termCmdDOM) {
        return new Terminate(session);
    }
}
exports.Terminate = Terminate;
class Subscribe extends ScipCommand {
    constructor(session, pkg, duration) {
        super(session);
        this.package = pkg;
        this.duration = duration;
    }
    SetResource(resource) {
        this.resource = resource;
    }
    SetEndpointId(endpointId) {
        this.endpointId = endpointId;
    }
    execute() {
        throw new Error(`TODO: Terminate Execute`);
    }
    acked(reply) {
    }
    toXml(commandBody) {
        let suppressIfMatch = "";
        if (this.suppressIfMatch) {
            suppressIfMatch = `suppressIfMatch="${this.suppressIfMatch}"`;
        }
        let rsrc = "<rsrc>test</rsrc>";
        if (this.resource) {
            rsrc = `<rsrc>${this.resource}</rsrc>`;
        }
        let endpointId = "";
        if (this.endpointId) {
            endpointId = `<endpoint>${this.endpointId}</endpoint>`;
        }
        let template = `<sub ${suppressIfMatch}>${rsrc}<pkg>${this.package}</pkg><dur>${this.duration}</dur>${endpointId}</sub>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, subCmdEl) {
        const duration = Number(subCmdEl.querySelector('dur')?.innerHTML ?? '');
        const pkg = subCmdEl.querySelector('pkg')?.innerHTML ?? '';
        return new Subscribe(session, pkg, duration);
    }
}
exports.Subscribe = Subscribe;
class SubscribeAck extends ScipReply {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: SubscribeAck Execute`);
    }
    toXml(replyBody) {
        let template = `<subAck></subAck>`;
        return super.toXml(template);
    }
    static fromReplyDOM(session, subAckReplyEl) {
        return new SubscribeAck(session);
    }
}
exports.SubscribeAck = SubscribeAck;
class Unsubscribe extends ScipCommand {
    constructor(session) {
        super(session);
    }
    execute() {
        throw new Error(`TODO: Unsubscribe Execute`);
    }
    acked(reply) {
    }
    toXml(replyBody) {
        let template = `<unsub>
      <rsrc>${this.resource}</rsrc>
      <pkg>${this.package}</pkg>
      <epId>${this.endpointId}</epId>
      </unsub>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, unsubCmdEl) {
        return new Unsubscribe(session);
    }
}
exports.Unsubscribe = Unsubscribe;
class GenericCommand extends ScipCommand {
    constructor(session) {
        super(session);
    }
    setProtocol(protocol) {
        this.protocol = protocol;
    }
    setContent(content) {
        if (typeof content === 'string') {
            this.content = content;
        }
        else {
            this.contentEl = content;
            this.content = content.outerHTML;
        }
    }
    execute() {
        if (this.contentEl) {
            switch (this.protocol) {
                case "CMCP":
                    let cmcpDialogId = 0;
                    const tid = Number(this.contentEl.querySelector('packet request')?.getAttribute('transactionId') ?? '');
                    if (tid === 0) {
                        cmcpDialogId = Number(this.contentEl.querySelector('dialogId local')?.innerHTML);
                    }
                    else {
                        cmcpDialogId = Number(this.contentEl.querySelector('dialogId remote')?.innerHTML);
                    }
                    switch (cmcpDialogId) {
                        case this.session.cmcpSubscribeParticipantSession?.dialogId.local:
                            this.session.cmcpSubscribeParticipantSession.processor.process(this.contentEl.firstElementChild);
                            break;
                        case this.session.cmcpSubscribeReceiveBandwidthSession?.dialogId.local:
                            this.session.cmcpSubscribeReceiveBandwidthSession.processor.process(this.contentEl.firstElementChild);
                            break;
                        case this.session.cmcpSubscribeSelectedParticipantSession?.dialogId.local:
                            this.session.cmcpSubscribeSelectedParticipantSession.processor.process(this.contentEl.firstElementChild);
                            break;
                        default:
                            this.session.cmcpConferenceSession.processor.process(this.contentEl.firstElementChild);
                    }
                    break;
                default:
                    console.log(`Unknown protocol in generic command: "${this.protocol}"`);
                    break;
            }
        }
        let repliesList = new Array();
        let versionMismatch = new LmiProtocol.VersionMismatch();
        let scipReply = new GenericAck(this.session);
        scipReply.result = 200;
        scipReply.type = PacketProcessor_1.MessageType.Local;
        repliesList.push(scipReply);
        this.session.sendReplies(this.transactionId, repliesList, versionMismatch);
    }
    toXml(commandBody) {
        let template = `<genCmd protocol="${this.protocol}"><cnt>${this.content}</cnt></genCmd>`;
        return super.toXml(template);
    }
    static fromCmdDOM(session, genCmdEl) {
        const obj = new GenericCommand(session);
        const contentEl = genCmdEl.querySelector('cnt');
        const protocol = genCmdEl.getAttribute('protocol') ?? '';
        obj.setProtocol(protocol);
        obj.setContent(contentEl);
        return obj;
    }
}
exports.GenericCommand = GenericCommand;
class GenericAck extends ScipReply {
    constructor(session) {
        super(session);
    }
    execute() { }
}
exports.GenericAck = GenericAck;
class ScipPacketProcessor extends PacketProcessor_1.Processor {
    constructor(session, logger) {
        super(logger);
        this.session = session;
        this.logger = logger;
    }
    process(decodedPacket) {
        this.logger.LogReceived(() => `${decodedPacket}`, LogEvents_1.VidyoLogCategory.VidyoSignaling);
        const oParser = new DOMParser();
        const oDOM = oParser.parseFromString(decodedPacket, "application/xml");
        oDOM.querySelectorAll(':root > request').forEach(request => this._processRequest(request));
        oDOM.querySelectorAll(':root > response').forEach(request => this._processResponse(request));
    }
    _processRequest(requestEl) {
        const request_tid = Number(requestEl.getAttribute('transactionId'));
        const commandsEl = requestEl.querySelector(':scope > commands');
        if (request_tid && commandsEl) {
            const commands_atomic = commandsEl.getAttribute('atomic') ?? '';
            const commands_version = commandsEl.getAttribute('version') ?? '';
            const commandsFrom = commandsEl.getAttribute('from') ?? '';
            if (commandsFrom.length > 0) {
                this.session._context.routerId = commandsFrom;
            }
            commandsEl.querySelectorAll(':scope > command').forEach((commandEL) => {
                Array.from(commandEL.children).forEach((cmdPart) => {
                    const command = this._processRequestCommand(cmdPart);
                    if (command != null) {
                        command.transactionId = request_tid;
                        command.version = Number(commands_version);
                        command.type = PacketProcessor_1.MessageType.Remote;
                        command.atomic = (Number(commands_atomic));
                        this.processRemoteCommand(command);
                    }
                });
            });
        }
    }
    _processRequestCommand(cmdElement) {
        let command = null;
        const tagName = cmdElement.tagName;
        switch (tagName) {
            case 'dialogId':
                break;
            case "sInit":
            case "sessionInitiate":
                command = SessionInitiate.fromCmdDOM(this.session, cmdElement);
                break;
            case "sAns":
            case "sessionAnswer":
                command = SessionAnswer.fromCmdDOM(this.session, cmdElement);
                break;
            case "sAcc":
            case "sessionAccept":
                command = SessionAccept.fromCmdDOM(this.session, cmdElement);
                break;
            case "sRej":
            case "sessionReject":
                command = SessionReject.fromCmdDOM(this.session, cmdElement);
                break;
            case "sTerm":
            case "sessionTerminate":
                command = SessionTerminate.fromCmdDOM(this.session, cmdElement);
                break;
            case "sUpd":
            case "sessionUpdate":
                command = SessionUpdate.fromCmdDOM(this.session, cmdElement);
                break;
            case "reg":
            case "register":
                command = Register.fromCmdDOM(this.session, cmdElement);
                break;
            case "unreg":
            case "unregister":
                command = Unregister.fromCmdDOM(this.session, cmdElement);
                break;
            case "term":
            case "terminate":
                command = Terminate.fromCmdDOM(this.session, cmdElement);
                break;
            case "sub":
            case "subscribe":
                command = Subscribe.fromCmdDOM(this.session, cmdElement);
                break;
            case "unsub":
            case "unsubscribe":
                command = Unsubscribe.fromCmdDOM(this.session, cmdElement);
                break;
            case "genCmd":
            case "genericCommand":
                command = GenericCommand.fromCmdDOM(this.session, cmdElement);
                break;
            default:
                console.error(`ERROR: ${tagName}`);
                break;
        }
        return command;
    }
    _processResponse(responseEl) {
        const response_tid = Number(responseEl.getAttribute('transactionId'));
        const repliesEl = responseEl.querySelector(':scope > replies');
        if (response_tid && repliesEl) {
            const replies_version = repliesEl.getAttribute('version') ?? '';
            repliesEl.querySelectorAll(':scope > reply').forEach((replyEl) => {
                const reply_code = Number(replyEl.getAttribute('result') ?? '');
                Array.from(replyEl.children).forEach((replyPart) => {
                    const reply = this._processResponseReply(replyPart);
                    if (reply != null) {
                        reply.result = reply_code;
                        reply.transactionId = response_tid;
                        reply.version = replies_version;
                        reply.session = this.session;
                        reply.type = PacketProcessor_1.MessageType.Remote;
                        this.processRemoteReply(reply);
                    }
                });
            });
        }
    }
    _processResponseReply(replyElement) {
        let reply = null;
        const tagName = replyElement.tagName;
        switch (tagName) {
            case 'dialogId':
                this.session.dialogId.remote = Number(replyElement.querySelector('remote')?.innerHTML ?? '');
                break;
            case "sessionUpdateAck":
            case "sUpdAck":
                reply = SessionUpdateAck.fromReplyDOM(this.session, replyElement);
                break;
            case "registerAck":
            case "regAck":
                reply = RegisterAck.fromReplyDOM(this.session, replyElement);
                break;
            case "subscribeAck":
            case "":
                reply = SubscribeAck.fromReplyDOM(this.session, replyElement);
                break;
            default:
                console.error(`ERROR: ${tagName}`);
                break;
        }
        return reply;
    }
}
exports.ScipPacketProcessor = ScipPacketProcessor;
class ScipSession {
    constructor(_provider, _eventDispatcher, logger, _context) {
        this._provider = _provider;
        this._eventDispatcher = _eventDispatcher;
        this.logger = logger;
        this._context = _context;
        this.iceCandidates = new Array();
        this.state = SessionState.Idle;
        this.dialogId = new LmiProtocol.DialogId();
        this.transactionId = 1;
        this.identityList = [{
                name: 'VidyoTechnology',
                version: '2.3.0.0',
            },
            {
                name: 'Vidyo_WebRTCNative',
                version: '0.0.0.0'
            }
        ];
        this.expires = 0;
        this.focusFlag = false;
        this.localCapabilities = "";
        this.processor = new ScipPacketProcessor(this, logger);
    }
    setLocalCapabilities(caps) {
        this.localCapabilities = caps;
        this.fsm(ScipSessionEventType.SetLocalCapabilities);
    }
    processSessionAnswer(caps) {
        this._provider.ProcessRemoteSessionAnswer(caps);
    }
    sendCommands(commandsList) {
        let atomic = PacketProcessor_1.Atomic.parallel;
        let from = this._context.localUri;
        let to = this._context.remoteUri;
        let srcUri = this._context.localUri;
        let request = new PacketProcessor_1.Request(srcUri, from, to, SCIP_VERSION, this.transactionId++, commandsList);
        let message = request.toXml();
        let packet = new PacketProcessor_1.Packet(this._context.localUri, this._context.remoteUri);
        message = packet.toXml(message);
        let processor = this.processor;
        for (let i = 0; i < commandsList.length; i++) {
            let command = commandsList[i];
            command.transactionId = request.transactionId;
            command.type == PacketProcessor_1.MessageType.Local;
            processor.processLocalCommand(command);
        }
        this.logger.LogSent(() => `${message}`, LogEvents_1.VidyoLogCategory.VidyoSignaling);
        this._provider._connection._send(message.length, message);
    }
    sendReplies(transactionId, repliesList, versionMismatch) {
        let fromUri = this._context.localUri;
        let response = new PacketProcessor_1.Response(transactionId, fromUri, repliesList, versionMismatch);
        let message = response.toXml();
        let packet = new PacketProcessor_1.Packet(this._context.localUri, this._context.remoteUri);
        message = packet.toXml(message);
        let processor = this.processor;
        let session = this;
        for (let i = 0; i < repliesList.length; i++) {
            let reply = repliesList[i];
            reply.transactionId = transactionId;
            processor.processLocalReply(reply);
        }
        this.logger.LogSent(() => `${message}`, LogEvents_1.VidyoLogCategory.VidyoSignaling);
        this._provider._connection._send(message.length, message);
    }
    StartMedia(options) {
        this.fsm(ScipSessionEventType.SessionInitiate);
    }
    SendSessionInitiate(options) {
        let session = this;
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let command = new SessionInitiate(this);
            command.type = PacketProcessor_1.MessageType.Local;
            command.setDisplayName("whatever");
            command.setScel(session.localCapabilities);
            if (options.ack === true) {
                command.isack = true;
            }
            else {
                command.isack = false;
            }
            commandsList.push(command);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    ProcessRemoteSessionInitiate(scel) {
        this._provider.ProcessRemoteSessionInitiate(scel);
        this.fsm(ScipSessionEventType.RemoteOffered);
        this.fsm(ScipSessionEventType.SetLocalCapabilities);
    }
    ProcessRemoteSessionAccept() {
        this.fsm(ScipSessionEventType.RemoteAccepted);
    }
    ProcessConferenceBooted(reason) {
        this.fsm(ScipSessionEventType.ProcessConferenceBooted, { reason: reason });
    }
    ProcessConferenceShow(conferenceShow) {
        this._eventDispatcher.emit(ConnectionEvents.Events.JingleSourceView, { sources: [conferenceShow] });
    }
    SendSessionAnswer() {
        let session = this;
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let command = new SessionAnswer(this);
            command.type = PacketProcessor_1.MessageType.Local;
            command.setScel(session.localCapabilities);
            commandsList.push(command);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    SendSessionAccept() {
        let session = this;
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let command = new SessionAccept(this);
            command.type = PacketProcessor_1.MessageType.Local;
            commandsList.push(command);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    Disconnect() {
        this.fsm(ScipSessionEventType.ScipTerminate);
    }
    SendSessionTerminate() {
        let session = this;
        return new Promise((resolve, reject) => {
            let commandsList = new Array();
            let command = new SessionTerminate(this);
            command.type = PacketProcessor_1.MessageType.Local;
            commandsList.push(command);
            this.sendCommands(commandsList);
            resolve();
        });
    }
    JoinConferenceCompleted() {
        this.fsm(ScipSessionEventType.ConferenceJoined);
    }
    CreateDialogSessionAndSendConferenceJoin(localId) {
        this.cmcpConferenceSession = new CmcpSession_1.CmcpSession(this, localId, this._eventDispatcher, this.logger);
        this.cmcpConferenceSession.SendConferenceJoin(this._context.roomName, this.dialogId.remote);
        return this.cmcpConferenceSession;
    }
    CreateDialogSessionAndSendSubscribe(localId, pkg) {
        switch (pkg) {
            case 'participant':
                this.cmcpSubscribeParticipantSession = new CmcpSession_1.CmcpSession(this, localId, this._eventDispatcher, this.logger);
                this.cmcpSubscribeParticipantSession.SendSubsribeParticipantPackage(pkg);
                return this.cmcpSubscribeParticipantSession;
            case 'receivebw':
                this.cmcpSubscribeReceiveBandwidthSession = new CmcpSession_1.CmcpSession(this, localId, this._eventDispatcher, this.logger);
                this.cmcpSubscribeReceiveBandwidthSession.SendSubscribeReceiveBandwidthPackage(pkg);
                return this.cmcpSubscribeReceiveBandwidthSession;
            case 'selectedparticipant':
                this.cmcpSubscribeSelectedParticipantSession = new CmcpSession_1.CmcpSession(this, localId, this._eventDispatcher, this.logger);
                this.cmcpSubscribeSelectedParticipantSession.SendSubsribeParticipantPackage(pkg);
                return this.cmcpSubscribeSelectedParticipantSession;
            default:
                return null;
        }
    }
    TransportConnectionEstablished() {
        this.fsm(ScipSessionEventType.TransportConnectionEstablished);
    }
    TransportConnectionDisconnected() {
        this.fsm(ScipSessionEventType.TransportConnectionDisconnect);
    }
    fsm(evt, payload) {
        this.logger.LogInfo(() => `Handle event ${ScipSessionEventType[evt]} at state ${SessionState[this.state]}`);
        switch (this.state) {
            case SessionState.Idle:
                switch (evt) {
                    case ScipSessionEventType.TransportConnectionEstablished:
                        this.state = SessionState.TransportEstablished;
                        break;
                    case ScipSessionEventType.SetLocalCapabilities:
                        this.state = SessionState.WaitIceComplete;
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.TransportEstablished:
                switch (evt) {
                    case ScipSessionEventType.SessionInitiate:
                    case ScipSessionEventType.SetLocalCapabilities:
                        if (this.localCapabilities === "") {
                            this.state = SessionState.WaitIceComplete;
                        }
                        else {
                            this.state = SessionState.LocalInitiating;
                            let options = { ack: false };
                            this.SendSessionInitiate(options);
                        }
                        break;
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents.ConnectionEventsInfo.ConferenceFailed);
                        break;
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.SendSessionTerminate();
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.WaitIceComplete:
                switch (evt) {
                    case ScipSessionEventType.TransportConnectionEstablished:
                        this.state = SessionState.LocalInitiating;
                        let options = { ack: false };
                        this.SendSessionInitiate(options);
                        break;
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents.ConnectionEventsInfo.ConferenceFailed);
                        break;
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.SendSessionTerminate();
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.LocalInitiating:
                switch (evt) {
                    case ScipSessionEventType.RemoteAccepted:
                        this.state = SessionState.Active;
                        this._eventDispatcher.emit(ConnectionEvents.Events.MediaSessionStarted);
                        this._eventDispatcher.emit(StreamEvents.Events.MediaEnabled);
                        break;
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents.ConnectionEventsInfo.ConferenceFailed);
                        break;
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.SendSessionTerminate();
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.Active:
                switch (evt) {
                    case ScipSessionEventType.SetLocalCapabilities:
                        this.SendSessionInitiate({ ack: false });
                        break;
                    case ScipSessionEventType.RemoteOffered:
                        this.state = SessionState.WaitLocalAnswer;
                        break;
                    case ScipSessionEventType.ConferenceJoined:
                        this._eventDispatcher.emit(ConferenceEvents.Events.ConferenceAccepted.Scoped(this.cmcpConferenceSession.dialogId.local));
                        this._provider.RequestConferenceState();
                        break;
                    case ScipSessionEventType.ProcessConferenceBooted:
                        this.state = SessionState.RemoteBooted;
                        this._provider.Disconnect();
                        let event;
                        switch (payload.reason) {
                            case CmcpSession_1.ConferenceLeaveReason.Booted:
                                event = ConnectionEvents.ConnectionEventsInfo.Booted;
                                break;
                            case CmcpSession_1.ConferenceLeaveReason.ShuttingDown:
                                event = ConnectionEvents.ConnectionEventsInfo.ServerShuttingDown;
                                break;
                            case CmcpSession_1.ConferenceLeaveReason.ConferenceDestroyed:
                                event = ConnectionEvents.ConnectionEventsInfo.ConferenceDestroyed;
                                break;
                            default:
                                event = ConnectionEvents.ConnectionEventsInfo.Terminated;
                                break;
                        }
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, event);
                        break;
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.cmcpConferenceSession.SendLeaveConference();
                        this.SendSessionTerminate();
                        break;
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents.ConnectionEventsInfo.ConnectionLost);
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.WaitLocalAnswer:
                switch (evt) {
                    case ScipSessionEventType.SetLocalCapabilities:
                        this.state = SessionState.Active;
                        this.SendSessionAnswer();
                        this.SendSessionAccept();
                        break;
                    case ScipSessionEventType.ConferenceJoined:
                        this.state = SessionState.Active;
                        this._eventDispatcher.emit(ConferenceEvents.Events.ConferenceAccepted.Scoped(this.cmcpConferenceSession.dialogId.local));
                        this.state = SessionState.Active;
                        break;
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        this._eventDispatcher.emit(ConnectionEvents.Events.SignallingDisconnected, ConnectionEvents.ConnectionEventsInfo.ConnectionLost);
                        break;
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.SendSessionTerminate();
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.RemoteBooted:
                switch (evt) {
                    case ScipSessionEventType.ScipTerminate:
                        this.state = SessionState.Terminated;
                        this.SendSessionTerminate();
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            case SessionState.Terminated:
                switch (evt) {
                    case ScipSessionEventType.TransportConnectionDisconnect:
                        this.state = SessionState.Idle;
                        break;
                    default:
                        console.log("unsupported ScipSessionEventType " + ScipSessionEventType[evt]);
                        break;
                }
                break;
            default:
                break;
        }
    }
}
exports.ScipSession = ScipSession;

},{"../events/ConferenceEvents":65,"../events/ConnectionEvents":66,"../events/LogEvents":69,"../events/StreamEvents":79,"./CmcpSession":80,"./LmiProtocol":84,"./PacketProcessor":85}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScelToSdp = exports.SdpToScel = void 0;
const moduleFunctions = {
    _sdpToScel: null,
    _scelToSdp: null
};
function SdpToScel(...args) {
    return moduleFunctions._sdpToScel.apply(this, args);
}
exports.SdpToScel = SdpToScel;
function ScelToSdp(...args) {
    return moduleFunctions._scelToSdp.apply(this, args);
}
exports.ScelToSdp = ScelToSdp;
let Module = {
    preRun: [],
    postRun: [],
    print: (function () {
        return function (text) {
            if (arguments.length > 1)
                text = Array.prototype.slice.call(arguments).join(' ');
            console.log(text);
        };
    })(),
    printErr: function (text) {
        if (arguments.length > 1)
            text = Array.prototype.slice.call(arguments).join(' ');
        console.error(text);
    },
    setStatus: function (text) {
        if (!Module.setStatus.last)
            Module.setStatus.last = { time: Date.now(), text: '' };
        if (text === Module.setStatus.last.text)
            return;
        var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
        var now = Date.now();
        if (m && now - Module.setStatus.last.time < 30)
            return;
        Module.setStatus.last.time = now;
        Module.setStatus.last.text = text;
        if (m) {
            text = m[1];
        }
        console.log(text);
    },
    totalDependencies: 0,
    monitorRunDependencies: function (left) {
        this.totalDependencies = Math.max(this.totalDependencies, left);
        Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies - left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
    }
};
(function (Module) {
    Module.setStatus('Downloading...');
    window.onerror = function (event) {
        Module.setStatus('Exception thrown, see JavaScript console');
        Module.setStatus = function (text) {
            if (text)
                Module.printErr('[post-exception status] ' + text);
        };
    };
    moduleFunctions._sdpToScel = function (sdp, isUnified) {
        const SdpToScel_WASM = {
            convert: cwrap('SdpToScel', 'number', [sdpbuffer, scelbuffer, 'number', 'boolean']),
        };
        var resultVal = 999;
        var sdpbuffer = Module._malloc(20000);
        var scelbuffer = Module._malloc(20000);
        stringToUTF8(sdp, sdpbuffer, 20000);
        stringToUTF8(``, scelbuffer, 20000);
        resultVal = SdpToScel_WASM.convert(sdpbuffer, scelbuffer, 20000, isUnified);
        var scel = UTF8ToString(scelbuffer, 20000);
        Module._free(sdpbuffer);
        Module._free(scelbuffer);
        return scel;
    };
    moduleFunctions._scelToSdp = function (scel, isUnified) {
        const ScelToSdp_WASM = {
            convert: cwrap('ScelToSdp', 'number', [scelbuffer, sdpbuffer, 'number', 'boolean']),
        };
        var resultVal = 999;
        var scelbuffer = Module._malloc(20000);
        var sdpbuffer = Module._malloc(20000);
        stringToUTF8(scel, scelbuffer, 20000);
        stringToUTF8(``, sdpbuffer, 20000);
        resultVal = ScelToSdp_WASM.convert(scelbuffer, sdpbuffer, 20000, isUnified);
        var sdp = UTF8ToString(sdpbuffer, 20000);
        Module._free(sdpbuffer);
        Module._free(scelbuffer);
        return sdp;
    };
    const b64toBBinary = (b64Data) => {
        const byteCharacters = atob(b64Data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        return new Uint8Array(byteNumbers);
    };
    Module['wasmBinary'] = b64toBBinary('AGFzbQEAAAAB4gEgYAJ/fwF/YAN/f38AYAJ/fwBgA39/fwF/YAF/AX9gAX8AYAR/f39/AX9gAAF/YAAAYAV/f39/fwF/YAR/f39/AGAFf35+fn4AYAV/f39/fwBgA39+fwF+YAd/f39/f39/AX9gAn98AGACf3wBfGAEf35+fwBgB39/f39/f38AYAZ/fH9/f38Bf2ADf35/AX9gBn9/f39/fwBgC39/f39/f39/f39/AX9gA39/fwF8YAJ+fwF/YAJ8fwF8YAR/f39+AX5gAX8BfmACfn4BfGAEfn5+fgF/YAN+fn4Bf2ABfwF8AtADFANlbnYQX19zdGFja19jaGtfZmFpbAAIA2Vudg1jbG9ja19nZXR0aW1lAAADZW52CGdtdGltZV9yAAADZW52C2xvY2FsdGltZV9yAAADZW52DGdldHRpbWVvZmRheQAAA2VudgtnZXRhZGRyaW5mbwAGA2VudgxnYWlfc3RyZXJyb3IABANlbnYNX19zeXNfZmNudGw2NAADFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UABANlbnYKX19zeXNfb3BlbgADFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAGFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABgNlbnYLX19zeXNfaW9jdGwAAwNlbnYPX19zeXNfcHJsaW1pdDY0AAYDZW52EF9fc3lzX3VnZXRybGltaXQAAANlbnYPX19zeXNfc2V0cmxpbWl0AAADZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAABANlbnYVZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAMDZW52C3NldFRlbXBSZXQwAAUWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrAAkD7QbrBggGBgAAAwIAAwYEBAQOBgQDBAkBBgcIBwcAAgEKAgABAAAFBQAABQYCBQAAAgYFBAABAAUAAAUFBAMGAwkABQEAAAAFAAAABQAABQAAAgEBCgEFBgACBQYAAAQCBgICBgIGBQEBAgcIAAcIBwgHCAcIAgEBAAUFBwgHAAEACAgKFAgDFRIABwgHCAcHCAYDBwgHAAABBwgBBwgFBAACBwcDAwIFAgACBQUCBQUAAgUCBQIFAgUAAAACBQIFCgIFBQACBQIFAgUAAgUAAgUCAgUCAgUCBQUAAAAAAAACAgUCBQUCAgUKAgUCBQIFBQAABAIEAgMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMABAAEAgAEAgAEAgAEAwQDBAMEAwQDBAMCAAQDBAMCAAQDBAMCAAQDBAMEAwQDBAMEAwQEAwQDBAMEAwQEAwQDBAIABAQDBAMEAwQDBAMEAwQDBAMEAwQDBAMHCAcAAAAABQAABQAABQYFAwMDAAADAwgEAwUDBQAGBgYGAwMGCQkOAwUFAwQGCQABBQMAFgcIBQIDAQQABQMABgEEAAUDAAYCBQoPDwIFAAACBQkCBQUCBQIFAgYADAkCBQAAAAIFBAMEAwQDBAMDBAMEAwQDBAIABAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQEAwQDCgoCAQIFAQACAgUAAAUFAAIABQMFAAYCBwgFBQYEBgYGAwAGAwAFBwgHCAcHBAAFAAAFAgcIBAAHCAcHAAECAwUAAwMAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAMAAAAFAAMDAwMDAwUAAAICAgIBAwABAwYGBgIGAAAAAgQAAgMDAwUIAQMAAAUAAAIEAAMAAAAFBAQFAwEABQAFAAEABgMAAAMGBgUXAAUABgAAAAQAAwwKBgAFCQADAAADCgABBAACBAQFBAIGBQABAQAABQUAAwUAAwUBEBAQBwgHBwcHCAcFAAQEAwQEDQMNBgMDCQ4BCgQYDAMTAgQEGQMDAwAAAAMEGgMDBQQLERsFBwQABAQEBAcHBwQLEQIPCxwdHgsLCwIRBAUCBAsfAwMBBAMFBAcFBAQJBAcBcAG5CbkJBQYBAYACgAIGCQF/AUGA68cCCwe1AhQGbWVtb3J5AgARX193YXNtX2NhbGxfY3RvcnMAFAlTY2VsVG9TZHAAFQlTZHBUb1NjZWwAFgZtYWxsb2MA7QYEZnJlZQDuBgRtYWluABgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAEF9fZXJybm9fbG9jYXRpb24A1QYFbnRvaHMA2wYFaHRvbnMA2wYrZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscwCCAQVodG9ubAD9BgtfZ2V0X3R6bmFtZQDcBg1fZ2V0X2RheWxpZ2h0AN0GDV9nZXRfdGltZXpvbmUA3gYJc3RhY2tTYXZlAPoGDHN0YWNrUmVzdG9yZQD7BgpzdGFja0FsbG9jAPwGDGR5bkNhbGxfamlqaQD+BgnFEgEAQQELuAkXpwaoBn+AAYYDhwPUBNUE2ATZBCkqGRobHB0eHh8gICAZIRobHCIjIyAfHyCKBiV9fissLS4vMTIuMyVpfBoayQTKBHp7qQGqAY0BkgGyAZ4BnAGdAZoBmwGjAaQBrAGtAZ8BoAGzAYIBpQGCAYsBjAGBAYIBgwGEAYEBggGFAYYBhwGOAY8BmQGPAaEBogGoAasBrwGwASW2AboBvQHBAcMBvQHFAcMBvQHHAcwBvQHOAcMBvQHRAdUBvQHXAdkBwwG9AdwBwwG9Ad8B4gG9AeUBwwG9AecB8QG9AfMB4gG9AbYBzAG9AfcBzAG9AfcBzAG9AfoBwwH8Af4BwwG9AbkB8AGDAoQCrQKEAq4CrwKwArECgwKEAq4CsgKzArQCrwKwArECuQG4AYMChAKvArACsQKvArACsQKtAoQCrgKvArACsQKvArACsQKDAoQCrgKyArMCtAKvArACsQK1ArYCtwK4AoYCrAK6AoYCrAKFAoYChwKvArACsQKvArACsQKtAoQCrgK1ArYCtwK8AoYCrAK+AoYCrAKIAoYCiQKvArACsQKvArACsQKtAoQCrgKtAoQCrgK1ArYCtwLAAoYCrALCAoYCrAKKAoYCiwK1AsQCxQKIAoYCrAKKAoYCrAK1ArYCtwLGAoYCrALIAoYCrAKMAoYCjQKtAoQCrgKvArACsQKvArACsQKvArACsQK1AsoCywK1ArYCtwLMAoYCrALOAoYCrAKOAoYCjwKtAoQCrgK1AsoCywK1AsQCxQK1AtAC0QKtAoQCrgKtAoQCrgK1ArYCtwLSAoYCrALUAoYCrAKQAoYCkQKvArACsQKtAoQCrgKSAoYCkwKvArACsQKvArACsQKtAoQCrgKSAoYCrAKtAoQCrgKtAoQCrgK1ArYCtwLWAoYCrALYAoYCrAKUAoYClQK1AsQCxQK1ArYCtwLaAoYCrALcAoYCrAKWAoYClwK5AeEBgwKEAoMChAKuAq8CsAKxAq0ChAKuArUCygLLArUCtgK3At4ChgKsAuEChgKsApgChgKZArkB5AGDAoQCrwKwArECrwKwArECtQK2ArcC4wKGAqwC5QKGAqwCmgKGApsCtQLEAsUCrwKwArECrwKwArECsgKzArQCtQLEAsUClgKGAqwCtQLEAsUCtQLEAsUCsgKzArQCgwKEAq4CtQLEAsUCtQK2ArcC5wKGAqwC6gKGAqwCnAKGAp0CsgKzArQCrQKEAq4C7ALtAu4CtQK2ArcC7wKGAqwC8gKGAqwCngKGAp8CrwKwArECrwKwArECtQK2ArcC9AKGAqwC9gKGAqwCoAKGAqECrwKwArECtQK2ArcC+AKGAqwC+gKGAqwCogKGAqMCrwKwArECtQK2ArcC/AKGAqwC/gKGAqwCpAKGAqUCoAKGAqwCogKGAqwCpAKGAqwCrwKwArECpgKGAqcCgAOGAqwCtQLEAsUCqAKGAqkCrwKwArECtQLEAsUCtQLKAssCtQLEAsUCqAKGAqwCrQKEAq4CsgKzArQCsgKzArQCtQK2ArcCggOGAqwChAOGAqwCqgKGAqsCqgKGAqwCuAKGArkCrwKwArECugKGArsCvAKGAr0CrwKwArECvgKGAr8CwAKGAsECrwKwArECwgKGAsMCxgKGAscCrwKwArECyAKGAskCzAKGAs0CrwKwArECzgKGAs8C0gKGAtMCrwKwArEC1AKGAtUC1gKGAtcCrwKwArEC2AKGAtkC2gKGAtsCrwKwArEC3AKGAt0C3wKGAuACrwKwArEC4QKGAuIC4wKGAuQCrwKwArEC5QKGAuYC6AKGAukCrwKwArEC6gKGAusC8AKGAvECrwKwArEC8gKGAvMC9AKGAvUCrwKwArEC9gKGAvcC+AKGAvkCrwKwArEC+gKGAvsC/AKGAv0CrwKwArEC/gKGAv8CgAOGAoEDrwKwArECggOGAoMDrwKwArEChAOGAoUDiAO9A/QG9wHOA70B9wHMAb0B0wPMAb0B1wPDAb0B2gPDAb0B3QPfA70B5QHDAb0B5gPrA70BrwKwArECrwKwArEC/AP9A/4D/AP9A/4DtQK2ArcC/wOGAqwCgQSGAqwC7QOGAu4DrwKwArECtQK2ArcCgwSGAqwChQSGAqwC7wOGAvADrwKwArECtQLEAsUCtQLEAsUCtQK2ArcChwSGAqwCiQSGAqwC8QOGAvIDrQKEAq4CrQKE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IgENAAsMAQsCQAJAAkAgACIGQShtIglBAU0EQAJAQQEgCWsiAUUNACABQQNxIQcgCUF/c0EBakEDTwRAIAFBfHEhDANAIAAgBCkCADcCACAAIARBIGoiASkCADcCICAAIARBGGoiAykCADcCGCAAIARBEGoiBSkCADcCECAAIARBCGoiCCkCADcCCEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQIANwJIIABBQGsgAykCADcCACAAIAUpAgA3AjggACAIKQIANwIwIAAgBCkCADcCKEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQIANwJIIABBQGsgAykCADcCACAAIAUpAgA3AjggACAIKQIANwIwIAAgBCkCADcCKEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQIANwJIIABBQGsgAykCADcCACAAIAUpAgA3AjggACAIKQIANwIwIAAgBCkCADcCKEHsyQdB7MkHKAIAQShqIgA2AgAgDEEEayIMDQALCyAHRQ0AA0AgACAEKQIANwIAIAAgBCkCIDcCICAAIAQpAhg3AhggACAEKQIQNwIQIAAgBCkCCDcCCEHsyQdB7MkHKAIAQShqIgA2AgAgB0EBayIHDQALCyAGRQ0DIAZBKGsiBUEobkEBakEDcSIDDQFBACEBDAILIAlBKGwhCCAJQQFrIgdBKGwhA0EBIgUEQCADIQEDQCAAIAEpAgA3AgAgACABKQIgNwIgIAAgASkCGDcCGCAAIAEpAhA3AhAgACABKQIINwIIQezJB0HsyQcoAgBBKGoiADYCACABQShqIQEgBUEBayIFDQALCyAIIQUgBwRAA0AgBUEoayIFIANBKGsiAykCADcCACAFIAMpAiA3AiAgBSADKQIYNwIYIAUgAykCEDcCECAFIAMpAgg3AgggAw0ACwtBASEFA0AgAiAEKQIANwIAIAIgBCkCIDcCICACIAQpAhg3AhggAiAEKQIQNwIQIAIgBCkCCDcCCCACQShqIQIgBUEBayIFDQALDAILQQAhAQNAIAAgASkCADcCACAAIAEpAiA3AiAgACABKQIYNwIYIAAgASkCEDcCECAAIAEpAgg3AghB7MkHQezJBygCAEEoaiIANgIAIAFBKGohASADQQFrIgMNAAsLIAVB+ABPBEAgCUEobCEDA0AgACABKQIANwIAIAAgASkCIDcCICAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQJINwJIIABBQGsgAUFAaykCADcCACAAIAEpAjg3AjggACABKQIwNwIwIAAgASkCKDcCKEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQJwNwJIIABBQGsgASkCaDcCACAAIAEpAmA3AjggACABKQJYNwIwIAAgASkCUDcCKEHsyQdB7MkHKAIAIgBBKGo2AgAgACABKQKYATcCSCAAQUBrIAEpApABNwIAIAAgASkCiAE3AjggACABKQKAATcCMCAAIAEpAng3AihB7MkHQezJBygCAEEoaiIANgIAIAFBoAFqIgEgA0cNAAsLIAZFDQAgCUEBIAlBAUsbIgBBA3EhBSAAQQFrQQNPBEAgAEF8cSEIA0AgAiAEKQIANwIAIAIgBEEgaiIAKQIANwIgIAIgBEEYaiIBKQIANwIYIAIgBEEQaiIGKQIANwIQIAIgBEEIaiIDKQIANwIIIAIgACkCADcCSCACQUBrIAEpAgA3AgAgAiAGKQIANwI4IAIgAykCADcCMCACIAQpAgA3AiggAiAAKQIANwJwIAIgASkCADcCaCACIAYpAgA3AmAgAiADKQIANwJYIAIgBCkCADcCUCACIAQpAgA3AnggAiADKQIANwKAASACIAYpAgA3AogBIAIgASkCADcCkAEgAiAAKQIANwKYASACQaABaiECIAhBBGsiCA0ACwsgBUUNAANAIAIgBCkCADcCACACIAQpAiA3AiAgAiAEKQIYNwIYIAIgBCkCEDcCECACIAQpAgg3AgggAkEoaiECIAVBAWsiBQ0ACwtBAQwBC0EBIQcDQCAAIAQpAgA3AgAgACAEKQIgNwIgIAAgBCkCGDcCGCAAIAQpAhA3AhAgACAEKQIINwIIIABBKGohACAHQQFrIgcNAAtB7MkHKAIABEADQCAAIAIpAgA3AgAgACACKQIgNwIgIAAgAikCGDcCGCAAIAIpAhA3AhAgACACKQIINwIIIABBKGohACACQShqIgJB7MkHKAIARw0ACwtB6MkHKAIAIgAgAkcEQEHsyQcgAiACIABrQShrQShuQX9zQShsajYCAAsgAARAQeTJBygCACICIABB8MkHKAIAIABrIAIoAgQRAQALQejJByAD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ACgCBCICKAIAIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIEIAIoAggiBCACKAIMEQIAIAMgAygCBCIAQQFrNgIEIABBAUcNACAEIANBCCAEKAIEEQEACyABKAIAIQALIAIgADYCACACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCCAARQ0CIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AggMAQtBACACQZz0AUcNARogABC+ASAAKAIEIgIoAhAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAhQgAigCGCIAIAIoAhwRAgAgAyADKAIEIgRBAWs2AgQgBEEBRw0AIAAgA0EIIAAoAgQRAQALIAEoAgAhAAsgAiAANgIQIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYIABFDQEgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGAtBAQsLswMBBX8gAEEQIAAoAgARAAAiBQRAIAUhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQTwgACgCABEAACIBRQ0AIAEgABDvBRogASAANgI0IAEgAS0AOEH4AXE6ADggAiAAQQggACgCABEAACIENgIAIARFDQAgBEIANwIAIAIgADYCCCACQegANgIMIAIgATYCBCACKAIAIgEEfyABIAEoAgBBAWo2AgAgAigCAAVBAAsiASABKAIEQQFqNgIECwJAIABBGCAAKAIAEQAAIgFFDQAgASAANgIQIAEgAS0AFEH+AXE6ABQgAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQekANgIcIAIgATYCFCACKAIQIgEEfyABIAEoAgBBAWo2AgAgAigCEAVBAAsiASABKAIEQQFqNgIECyACIAA2AiAgAyAAQQggACgCABEAACIBNgIAIAFFDQAgAUIANwIAIAMgADYCCCADQeoANgIMIAMgAjYCBCADKAIAIgAEfyAAIAAoAgBBAWo2AgAgAygCAAVBAAsiACAAKAIEQQFqNgIECwsgBQvGAwECfwJ/AkAgAkHw9wFGBEAgABC+ASAAKAIEIgIo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AyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkHogQJHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC70DAQZ/IABBECAAKAIAEQAAIgYEQCAGIQMCQCAAQSQgACgCABEAACICRQ0AAkAgAEHUACAAKAIAEQAAIgFFDQAgASAANgJMIAEgAS0AUEGAAXE6AFAgAiAAQQggACgCABEAACIENgIAIARFDQAgBEIANwIAIAIgADYCCCACQfQANgIMIAIgATYCBCACKAIAIgEEfyABIAEoAgBBAWo2AgAgAigCAAVBAAsiASABKAIEQQFqNgIECwJAIABBPCAAKAIAEQAAIgFFDQAgAUEANgIAIAFBBGogABDvBRogASAANgI0IAEgAS0AOEH8AXE6ADggAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQfUANgIcIAIgATYCFCACKAIQIgEEQCABIAEoAgBBAWo2AgAgAigCECEFCyAFIAUoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANB9gA2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAGC8YDAQJ/An8CQCACQfCGAkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkG0hgJHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC6EBAQR/AkAgAEEQIAAoAgARAAAiAUUNACAAQRggACgCABEAACICRQ0AIAIgABDvBRogAiAANgIUIAJBADYCECABIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgASAANgIIIAFB9wA2AgwgASACNgIEIAEoAgAiAARAIAAgACgCAEEBajYCACABKAIAIQMLIAMgAygCBEEBajYCBAsgAQtNAQF/IAJB3IcCRgRAIAEoAgQhAiAAENgBIAAoAgQgAhCFBkEARw8LIAJBmIgCRgR/IAEoAgAhAiAAENgBIAAoAgQgAjYCEEEBBSADCwu/AwEFfyAAQRAgACgCABEAACIFBEAgBSEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABB1AAgACgCABEAACIBRQ0AIAEgABDvBRogAUEQaiAAEO8FGiABIAA2AkwgASABLQBQQeABcToAUCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJB+AA2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEYIAAoAgARAAAiAUUNACABIAA2AhAgASABLQAUQf4BcToAFCACIABBCCAA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IARCADcCACACIAA2AhggAkH/ADYCHCACIAE2AhQgAigCECIBBH8gASABKAIAQQFqNgIAIAIoAhAFQQALIgEgASgCBEEBajYCBAsgAiAANgIgIAMgAEEIIAAoAgARAAAiATYCACABRQ0AIAFCADcCACADIAA2AgggA0GAATYCDCADIAI2AgQgAygCACIABH8gACAAKAIAQQFqNgIAIAMoAgAFQQALIgAgACgCBEEBajYCBAsLIAYLxgMBAn8CfwJAIAJB5JICRgRAIAAQvgEgACgCBCICKAIAIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIEIAIoAggiBCACKAIMEQIAIAMgAygCBCIAQQFrNgIEIABBAUcNACAEIANBCCAEKAIEEQEACyABKAIAIQALIAIgADYCACACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCCAARQ0CIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AggMAQtBACACQaiSAkcNARogABC+ASAAKAIEIgIoAhAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAhQgAigCGCIAIAIoAhwRAgAgAyADKAIEIgRBAWs2AgQgBEEBRw0AIAAgA0EIIAAoAgQRAQALIAEoAgAhAAsgAiAANgIQIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYIABFDQEgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGAtBAQsLvgMBBX8gAEEQIAAoAgARAAAiBQRAIAUhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQTggACgCABEAACIBRQ0AIAEgABDvBRogAUEQaiAAEO8FGiABIAA2AjAgASABLQA0Qf4BcToANCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBgQE2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEYIAAoAgARAAAiAUUNACABIAA2AhAgASABLQAUQf4BcToAFCACIABBCCAAKAIAEQAAIgQ2AhAgBEUNACAEQgA3AgAgAiAANgIYIAJBggE2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBgwE2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAFC8YDAQJ/An8CQCACQfiVAkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkG8lQJHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC8EDAQZ/IABBECAAKAIAEQAAIgYEQCAGIQMCQCAAQSQgACgCABEAACICRQ0AAkAgAEGkASAAKAIAEQAAIgFFDQAgASAANgKcASABIAEvAaABQYDgA3E7AaABIAIgAEEIIAAoAgARAAAiBDYCACAERQ0AIARCADcCACACIAA2AgggAkGEATYCDCACIAE2AgQgAigCACIBBH8gASABKAIAQQFqNgIAIAIoAgAFQQALIgEgASgCBEEBajYCBAsCQCAAQTQgACgCABEAACIBRQ0AIAFBADYCACABQQRqIAAQ7wUaIAEgADYCLCABIAEtADBB/AFxOgAwIAIgAEEIIAAoAgARAAAiBDYCECAERQ0AIARCADcCACACIAA2AhggAkGFATYCHCACIAE2AhQgAigCECIBBEAgASABKAIAQQFqNgIAIAIoAhAhBQsgBSAFKAIEQQFqNgIECyACIAA2AiAgAyAAQQggACgCABEAACIBNgIAIAFFDQAgAUIANwIAIAMgADYCCCADQYYBNgIMIAMgAjYCBCADKAIAIgAEfyAAIAAoAgBBAWo2AgAgAygCAAVBAAsiACAAKAIEQQFqNgIECwsgBgvGAwECfwJ/AkAgAkHwnAJGBEAgABC+ASAAKAIEIgIoAgAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAgQgAigCCCIEIAIoAgwRAgAgAyADKAIEIgBBAWs2AgQgAEEBRw0AIAQgA0EIIAQoAgQRAQALIAEoAgAhAAsgAiAANgIAIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIIABFDQIgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCAwBC0EAIAJBtJwCRw0BGiAAEL4BIAAoAgQiAigCECIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCFCACKAIYIgAgAigCHBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgACADQQggACgCBBEBAAsgASgCACEACyACIAA2AhAgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhggAEUNASAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYC0EBCwuxAwEGfyAAQRAgACgCABEAACIGBEAgBiEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABBLCAAKAIAEQAAIgFFDQAgAUEANgIAIAEgADYCJCABIAEtAChB/AFxOgAoIAIgAEEIIAAoAgARAAAiBDYCACAERQ0AIARCADcCACACIAA2AgggAkGHATYCDCACIAE2AgQgAigCACIBBEAgASABKAIAQQFqNgIAIAIoAgAhBQsgBSAFKAIEQQFqNgIECwJAIABBHCAAKAIAEQAAIgFFDQAgASAANgIUIAEgAS0AGEH8AXE6ABggAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQYgBNgIcIAIgATYCFCACKAIQIgEEfyABIAEoAgBBAWo2AgAgAigCEAVBAAsiASABKAIEQQFqNgIECyACIAA2AiAgAyAAQQggACgCABEAACIBNgIAIAFFDQAgAUIANwIAIAMgADYCCCADQYkBNgIMIAMgAjYCBCADKAIAIgAEfyAAIAAoAgBBAWo2AgAgAygCAAVBAAsiACAAKAIEQQFqNgIECwsgBgvGAwECfwJ/AkAgAkHwnwJGBEAgABC+ASAAKAIEIgIoAgAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAgQgAigCCCIEIAIoAgwRAgAgAyADKAIEIgBBAWs2AgQgAEEBRw0AIAQgA0EIIAQoAgQRAQALIAEoAgAhAAsgAiAANgIAIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIIABFDQIgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCAwBC0EAIAJBtJ8CRw0BGiAAEL4BIAAoAgQiAigCECIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCFCACKAIYIgAgAigCHBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgACADQQggACgCBBEBAAsgASgCACEACyACIAA2AhAgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhggAEUNASAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYC0EBCwu7AwEFfyAAQRAgACgCABEAACIFBEAgBSEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABBKCAAKAIAEQAAIgFFDQAgASAAEO8FGiABIAA2AiAgASABLQAkQf4BcToAJCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBigE2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEoIAAoAgARAAAiAUUNACABIAAQ7wUaIAEgADYCICABIAEtACRB/gFxOgAkIAIgAEEIIAAoAgARAAAiBDYCECAERQ0AIARCADcCACACIAA2AhggAkGLATYCHCACIAE2AhQgAigCECIBBH8gASABKAIAQQFqNgIAIAIoAhAFQQALIgEgASgCBEEBajYCBAsgAiAANgIgIAMgAEEIIAAoAgARAAAiATYCACABRQ0AIAFCADcCACADIAA2AgggA0GMATYCDCADIAI2AgQgAygCACIABH8gACAAKAIAQQFqNgIAIAMoAgAFQQALIgAgACgCBEEBajYCBAsLIAULxgMBAn8CfwJAIAJBtKICRgRAIAAQvgEgACgCBCICKAIAIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIEIAIoAggiBCACKAIMEQIAIAMgAygCBCIAQQFrNgIEIABBAUcNACAEIANBCCAEKAIEEQEACyABKAIAIQALIAIgADYCACACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCCAARQ0CIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AggMAQtBACACQfihAkcNARogABC+ASAAKAIEIgIoAhAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAhQgAigCGCIAIAIoAhwRAgAgAyADKAIEIgRBAWs2AgQgBEEBRw0AIAAgA0EIIAAoAgQRAQALIAEoAgAhAAsgAiAANgIQIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYIABFDQEgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGAtBAQsLswMBBX8gAEEQIAAoAgARAAAiBQRAIAUhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQRggACgCABEAACIBRQ0AIAEgADYCECABIAEtABRB/gFxOgAUIAIgAEEIIAAoAgARAAAiBDYCACAERQ0AIARCADcCACACIAA2AgggAkGNATYCDCACIAE2AgQgAigCACIBBH8gASABKAIAQQFqNgIAIAIoAgAFQQALIgEgASgCBEEBajYCBAsCQCAAQSggACgCABEAACIBRQ0AIAEgABDvBRogASAANgIgIAEgAS0AJEH+AXE6ACQgAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQY4BNgIcIAIgATYCFCACKAIQIgEEfyABIAEoAgBBAWo2AgAgAigCEAVBAAsiASABKAIEQQFqNgIECyACIAA2AiAgAyAAQQggACgCABEAACIBNgIAIAFFDQAgAUIANwIAIAMgADYCCCADQY8BNgIMIAMgAjYCBCADKAIAIgAEfyAAIAAoAgBBAWo2AgAgAygCAAVBAAsiACAAKAIEQQFqNgIECwsgBQvGAwECfwJ/AkAgAkG8pAJGBEAgABC+ASAAKAIEIgIoAgAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAgQgAigCCCIEIAIoAgwRAgAgAyADKAIEIgBBAWs2AgQgAEEBRw0AIAQgA0EIIAQoAgQRAQALIAEoAgAhAAsgAiAANgIAIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIIABFDQIgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCAwBC0EAIAJBgKQCRw0BGiAAEL4BIAAoAgQiAigCECIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCFCACKAIYIgAgAigCHBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgACADQQggACgCBBEBAAsgASgCACEACyACIAA2AhAgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhggAEUNASAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYC0EBCwuzAwEFfyAAQRAgACgCABEAACIFBEAgBSEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABBGCAAKAIAEQAAIgFFDQAgASAANgIQIAEgAS0AFEH+AXE6ABQgAiAAQQggACgCABEAACIENgIAIARFDQAgBEIANwIAIAIgADYCCCACQZABNgIMIAIgATYCBCACKAIAIgEEfyABIAEoAgBBAWo2AgAgAigCAAVBAAsiASABKAIEQQFqNgIECwJAIABBKCAAKAIAEQAAIgFFDQAgASAAEO8FGiABIAA2AiAgASABLQAkQf4BcToAJCACIABBCCAAKAIAEQAAIgQ2AhAgBEUNACAEQgA3AgAgAiAANgIYIAJBkQE2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBkgE2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAFC8YDAQJ/An8CQCACQcSmAkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkGIpgJHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC5kBAQR/AkAgAEEQIAAoAgARAAAiAUUNACAAQRggACgCABEAACICRQ0AIAIgADYCFCACQQA2AgAgASAAQQggACgCABEAACIENgIAIARFDQAgBEIANwIAIAEgADYCCCABQZMBNgIMIAEgAjYCBCABKAIAIgAEQCAAIAAoAgBBAWo2AgAgASgCACEDCyADIAMoAgRBAWo2AgQLIAELpQUBAn8gAkGwpwJGBEAgABD7ASAAKAIEIgIoAgAEQAJAIAIoAgQiAEUNACAAIAAoAgAiA0EBazYCACADQQFHDQAgAigCCCACKAIMIgMgAigCEBECACAAIAAoAgQiBEEBazYCBCAEQQFHDQAgAyAAQQggAygCBBEBAAsgAkEANgIACyACIAEoAgAiADYCBCACIAEoAgQ2AgggAiABKAIINgIMIAIgASgCDDYCECAABEAgACAAKAIAQQFqNgIACyACQQE2AgBBAQ8LIAJB7KcCRgRAIAAQ+wEgACgCBCICKAIABEACQCACKAIEIgBFDQAgACAAKAIAIgNBAWs2AgAgA0EBRw0AIAIoAgggAigCDCIEIAIoAhARAgAgACAAKAIEIgNBAWs2AgQgA0EBRw0AIAQgAEEIIAQoAgQRAQALIAJBADYCAAsgAiABKAIAIgA2AgQgAiABKAIENgIIIAIgASgCCDYCDCACIAEoAgw2AhAgAARAIAAgACgCAEEBajYCAAsgAkECNgIAQQEPCyACQaioAkYEQCAAEPsBIAAoAgQiAigCAARAAkAgAigCBCIARQ0AIAAgACgCACIDQQFrNgIAIANBAUcNACACKAIIIAIoAgwiAyACKAIQEQIAIAAgACgCBCIEQQFrNgIEIARBAUcNACADIABBCCADKAIEEQEACyACQQA2AgALIAIgASgCACIANgIEIAIgASgCBDYCCCACIAEoAgg2AgwgAiABKAIMNgIQIAAEQCAAIAAoAgBBAWo2AgALIAJBAzYCAEEBDwsgAkHkqAJGBH8gASgCBCECIAAQ+wEgACgCBCIBKAIABEAgAUEEahDwBSABQQA2AgALIAFBBGogAiABKAIUEPgFIgIEQCABQQQ2AgALIAJBAEcFIAMLC7wCAQV/IABBECAAKAIAEQAAIgQEQAJAIAQhAyAAQSQgACgCABEAACICRQ0AIAJBADYCDCACIAA2AgAgAkIANwIEAkAgAEEYIAAoAgARAAAiAUUNACABIAA2AhAgASABLQAUQf4BcToAFCACIABBCCAAKAIAEQAAIgU2AhAgBUUNACAFQgA3AgAgAiAANgIYIAJBlAE2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAQR/IAFCADcCACADIAA2AgggA0GVATYCDCADIAI2AgQgAygCACIABH8gACAAKAIAQQFqNgIAIAMoAgAFQQALIgAgACgCBEEBajYCBEEABUEACxoLCyAEC4QCAQJ/IAJB+KkCRgRAIAAQ/QEgACgCBCABEMABQQBHDwsgAkG8qQJGBH8gABD9AQJAIAAoAgQiAigCECIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCFCACKAIYIgAgAigCHBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgACADQQggACgCBBEBAAsgASgCACEACyACIAA2AhAgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhggAEUNASAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYC0EBBSADCwutAwEFfyAAQRAgACgCABEAACIFBEAgBSEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABB8AAgACgCABEAACIBRQ0AIAEgADYCaCABIAEvAWxBgPwDcTsBbCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBlgE2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEYIAAoAgARAAAiAUUNACABIAA2AhAgASABLQAUQf4BcToAFCACIABBCCAAKAIAEQAAIgQ2AhAgBEUNACAEQgA3AgAgAiAANgIYIAJBlwE2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBmAE2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAFC8YDAQJ/An8CQCACQbyvAkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkGArwJHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC9ABAQN/AkAgACgCACIDIAEoAgAiAkcEQCADBEAgAyADKAIAIgJBAWs2AgACQCACQQFHDQAgACgCBCAAKAIIIgIgACgCDBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgAiADQQggAigCBBEBAAsgASgCACECCyAAIAI2AgAgACABKAIENgIEIAAgASgCDDYCDCAAIAEoAgg2AgggAkUNASACIAIoAgBBAWo2AgBBAQ8LIAAgASgCBDYCBCAAIAEoAgw2AgwgACABKAIINgIIC0EBCxwAIABBBCAAKAIAEQAAIgAEQCAAQQA2AgALIAALDgAgACABKAIANgIAQQELHwEBfyAAQRAgACgCABEAACIBBEAgASAAEO8FGgsgAQsVACAAEPAFIAEgAEEQIAEoAgQRAQALDAAgACABEPMFQQBHCxwAIABBASAAKAIAEQAAIgAEQCAAQQA6AAALIAALEAAgASAAQQEgASgCBBEBAAsOACAAIAEtAAA6AABBAQssAQF/IABBECAAKAIAEQAAIgEEQCABQQA2AgwgASAANgIAIAFCADcCBAsgAQsVACAAEJYGIAEgAEEQIAEoAgQRAQALVQEBfyAAKAIIIgIgACgCDEYEfyAAIAIgACgCBCICa0EDdUECIAIbEJQGRQRAQQAPCyAAKAIIBSACCyABEPEFRQRAQQAPCyAAIAAoAghBEGo2AghBAQuaAQEEfwJAIABBECAAKAIAEQAAIgFFDQAgAEHkACAAKAIAEQAAIgJFDQAgAiAANgJcIAJBADoAYCABIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgASAANgIIIAFB5gA2AgwgASACNgIEIAEoAgAiAARAIAAgACgCAEEBajYCACABKAIA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IAAoAgRBAWo2AgQLIAELYwEBfyACQbyNAkYEQCAAIAEQ3gFBAEcPCyACQfiNAkYEfyAAEN0BAn8gACgCBCICLQAkIgBBAnEEQCACQRBqIAEQmAYMAQsgAiAAQQJyOgAkIAJBEGogARCVBgtBAEcFIAMLC6EBAQN/AkAgAEEQIAAoAgARAAAiAUUNACAAQRwgACgCABEAACICRQ0AIAIgADYCFCACIAItABhB/AFxOgAYIAEgAEEIIAAoAgARAAAiAzYCACADRQ0AIANCADcCACABIAA2AgggAUH/ADYCDCABIAI2AgQgASgCACIABH8gACAAKAIAQQFqNgIAIAEoAgAFQQALIgAgACgCBEEBajYCBAsgAQvKAQEDfyAAQRAgACgCABEAACIBBEACQCAAQRwgACgCABEAACICRQ0AIAIgADYCFCACIAItABhB/AFxOgAYIAEgAEEIIAAoAgARAAAiAzYCACADRQ0AIANCADcCACABIAA2AgggAUH/ADYCDCABIAI2AgQgASgCACIABH8gACAAKAIAQQFqNgIAIAEoAgAFQQALIgAgACgCBEEBajYCBAsgARDjASABKAIEIgAtABgiAkEBcUUEQCAAIAJBAXI6ABgLIABBAjYCAAsgAQuXAQEBfyACQZSQAkYEQCABKAIAIQEgABDjASAAKAIEIgItABgiAEEBcUUEQCACIABBAXI6ABgLIAIgATYCAEEBDwsgAkG0wAJGBH8gASgCBCEBIAAQ4wECfyAAKAIEIgItABgiAEECcQRAIAJBBGogARCFBgwBCyACIABBAnI6ABggAkEEaiABIAIoAhQQ+AULQQBHBSADCwuvAQEEfwJAIABBECAAKAIAEQAAIgFFDQAgAEE8IAAoAgARAAAiAkUNACACIAAQ7wUaIAJBADYCECACIAA2AjQgAiACLQA4QfwBcToAOCABIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgASAANgIIIAFB/gA2AgwgASACNgIEIAEoAgAiAARAIAAgACgCAEEBajYCACABKAIAIQMLIAMgAygCBEEBajYCBAsgAQvdAQEBfyACQbiQAkYEQCABKAIEIQIgABDgASAAKAIEIAIQhQZBAEcPCyACQfSQAkYEQCABKAIAIQIgABDgASAAKAIEIAI2AhBBAQ8LIAJBsJECRgRAIAAQ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oAELIAIgAToAMEEBDwsgAkHUmAJGBEAgACABEOsBQQBHDwsgAkGQmQJGBEAgACABEOwBQQBHDwsgAkHMmQJGBEAgACABEO0BQQBHDwsgAkGImgJGBEAgACABEO4BQQBHDwsgAkHEmgJGBEAgAS0AACEBIAAQ6QEgACgCBCICLwGgASIAQYACcUUEQCACIABBgAJyOwGgAQsgAiABOgB0QQEPCyACQYCbAkYEQCABKAIAIQEgABDpASAAKAIEIgIvAaABIgBBgARxRQRAIAIgAEGABHI7AaABCyACIAE2AnhBAQ8LIAJBvJsCRgRAIAAgARDvAUEARw8LIAJB+JsCRgR/IAAQ6QECfyAAKAIEIgIvAaABIgBBgBBxBEAgAkGMAWogARCYBgwBCyACIABBgBByOwGgASACQYwBaiABEJUGC0EARwUgAwsLrQMBBX8gAEEQIAAoAgARAAAiBQRAIAUhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQdwAIAAoAgARAAAiAUUNACABIAA2AlQgASABLwFYQYDgA3E7AVggAiAAQQggACgCABEAACIENgIAIARFDQAgBEIANwIAIAIgADYCCCACQY0GNgIMIAIgATYCBCACKAIAIgEEfyABIAEoAgBBAWo2AgAgAigCAAVBAAsiASABKAIEQQFqNgIECwJAIABBGCAAKAIAEQAAIgFFDQAgASAANgIQIAEgAS0AFEH+AXE6ABQgAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQY4GNgIcIAIgATYCFCACKAIQIgEEfyABIAEoAgBBAWo2AgAgAigCEAVBAAsiASABKAIEQQFqNgIECyACIAA2AiAgAyAAQQggACgCABEAACIBNgIAIAFFDQAgAUIANwIAIAMgADYCCCADQY8GNgIMIAMgAjYCBCADKAIAIgAEfyAAIAAoAgBBAWo2AgAgAygCAAVBAAsiACAAKAIEQQFqNgIECwsgBQsUACAAEF4gASAAQRAgASgCBBEBAAsLACAAIAEQX0EARwuhAQEDfwJAIABBECAAKAIAEQAAIgFFDQAgAEEcIAAoAgARAAAiAkUNACACIAA2AhQgAiACLQAYQfwBcToAGCABIABBCCAAKAIAEQAAIgM2AgAgA0UNACADQgA3AgAgASAANgIIIAFBiAE2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AqACQQFqNgKgAgtBACgCACAHKAJcRgRAIAdB4ABqJAAgCA8LEAAAC9wDAQN/IwBB0ARrIgMkACADQQAoAgA2AswEAkAgAUEoakFwcSIFQZACSw0AIANBsAJqQZACEL4DIANBgICAgAI2AsQCIAMgAToAwwIgAyABQQh2OgDCAiADQQA7AcACIANByAJqIAAgARDzBhogASADakGAAToAyAIgA0EgakGQmQNBEBCoA0UEQCADQbACakGQAhC+AwwBCyADQQA2ArACAkAgA0EgaiADQbACaiAFIANBEGoQswNFBEAgA0EgahCgAyADQbACakGQAhC+AwwBCyADQYCAgAg2ArACIANBIGogA0GwAmogBSADELMDRQRAIANBEGpBEBC+AyADQSBqEKADIANBsAJqQZACEL4DDAELIANBIGoQoAMgA0GwAmpBkAIQvgMgA0EgaiADQRBqQRAQqAMhASADQRBqQRAQvgMgAUUEQCADQRAQvgMMAQsCQCADQSBqIAMgAxCpA0UNACACIAMpAwA3AAAgAiADKQMINwAIIANBIGogAyADEKkDRQ0AIAIgAykDADcAECACIAMpAwg3ABggA0EgahCgAyADQRAQvgNBASEEDAILIANBIGoQoAMgA0EQEL4DCwtBACgCACADKALMBEYEQCADQdAEaiQAIAQPCxAAAAuaAwEBfyAAIAAtAA9BAWoiAToADwJAIAFB/wFxIAFGDQAgACAALQAOQQFqIgE6AA4gAUH/AXEgAUYNACAAIAAtAA1BAWoiAToADSABQf8BcSABRg0AIAAgAC0ADEEBaiIBOgAMIAFB/wFxIAFGDQAgACAALQALQQFqIgE6AAsgAUH/AXEgAUYNACAAIAAtAApBAWoiAToACiABQf8BcSABRg0AIAAgAC0ACUEBaiIBOgAJIAFB/wFxIAFGDQAgACAALQAIQQFqIgE6AAggAUH/AXEgAUYNACAAIAAtAAdBAWoiAToAByABQf8BcSABRg0AIAAgAC0ABkEBaiIBOgAGIAFB/wFxIAFGDQAgACAALQAFQQFqIgE6AAUgAUH/AXEgAUYNACAAIAAtAARBAWoiAToABCABQf8BcSABRg0AIAAgAC0AA0EBaiIBOgADIAFB/wFxIAFGDQAgACAALQACQQFqIgE6AAIgAUH/AXEgAUYNACAAIAAtAAFBAWoiAToAASABQf8BcSABRg0AIAAgAC0AAEEBajoAAAsLDwAgABCgAyAAQcACEL4DC4sDAQN/IwBB0ANrIgMkACADQQAoAgA2AswDAn9BACAALQC8AkUNABpBACACQeQASw0AGgJAAkACQAJAIAAtAL0CBEAgACgCtAIiBUUNASAAKAK4AiIEQQFrQfwASw0BIAMgBSAEEPMGGiAAQgA3ArQCDAILIAMQngMiBA0BCyAAELADDAELAkAgAiAEaiIFQYACSw0AIANBoAFqIAMgBBDzBhogAQRAIANBoAFqIARqIAEgAhDzBhoLIANBoAFqIAUgA0GAAWoQrgMhBCADQaABakGAAhC+AyAERQ0AIABBkAJqIgQQrwMgACAEIANBgAFqIANBoANqEKcDBEAgABCgAyAAIANBoANqQRAQqAMNAyAAEKADCyADQYABakEgEL4DCyAAEKADIABBwAIQvgMLQQAMAQsgBCADKQOwAzcAACAEIAMpA7gDNwAIIANBoANqQSAQvgMgA0GAAWpBIBC+AyAAQQE2AqACQQELIQRBACgCACADKALMA0YEQCADQdADaiQAIAQPCxAAAAuSAQECfyMAQRBrIgIkACACQQA6AA8CQEHczActAABFDQBBASEBA0AgAUEBcUUEQEEAIQFBoMoHQQBBABCxA0UNAgtBoMoHIABB9ANBAEEAIAJBD2pBABCtAwRAQQEhAQwCCyACLQAPIgEEQCABRSEBDAELC0GgygcQoANBoMoHQcACEL4DQQAhAQsgAkEQaiQAIAELlAMBAX8gA0EQEL4DIAJFBEBBAQ8LAkADQCADIAMtAAAgASAEai0AAHM6AAAgAyADLQABIAEgBEEBcmotAABzOgABIAMgAy0AAiABIARBAnJqLQAAczoAAiADIAMtAAMgASAEQQNyai0AAHM6AAMgAyADLQAEIAEgBEEEcmotAABzOgAEIAMgAy0ABSABIARBBXJqLQAAczoABSADIAMtAAYgASAEQQZyai0AAHM6AAYgAyADLQAHIAEgBEEHcmotAABzOgAHIAMgAy0ACCABIARBCHJqLQAAczoACCADIAMtAAkgASAEQQlyai0AAHM6AAkgAyADLQAKIAEgBEEKcmotAABzOgAKIAMgAy0ACyABIARBC3JqLQAAczoACyADIAMtAAwgASAEQQxyai0AAHM6AAwg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uM4CaigCACAAQbzOAmooAgAQxANFDQMgASABQcACahDFA0UNAyABIAQQwgNFDQIgASABQcACakEUEMQDBEAgASABQcACahDFA0UNAiABIAEoAtACNgKwAiABIAEpA8gCNwOoAiABIAEpA8ACNwOgAiABQcACakEUEL4DIABBwM4CaigCACABQaACakEUEL8DIQIgARDDAyAEEMMDIAMQwwNBACEAIAJFDQUDQCAAIAFqLQAADQYgASAAQQFyai0AAA0GIAEgAEECcmotAAANBiABIABBA3JqLQAADQYgAEEEaiIAQdwARw0AC0EAIQAgASgCXEF/Rw0FA0AgACADai0AAA0GIAMgAEEBcmotAAANBiADIABBAnJqLQAADQYgAyAAQQNyai0AAA0GIABBBGoiAEHcAEcNAAtBACEAIAEoArwBQX9HDQUDQCAAIARqLQAADQYgBCAAQQFyai0AAA0GIAQgAEECcmotAAANBiAEIABBA3JqLQAADQYgAEEEaiIAQdwARw0ACyABKAKcAkF/Rw0FQQEhACAFQQFqIgVBB0cNAQwGCwsgAUHAAmpBFBC+AwwCCyABQcACakEUEL4DDAELIAFBwAJqQRQQvgMLIAEQwwMgBBDDAyADEMMDC0EAIQALQQAoAgAgASgC3AJGBEAgAUHgAmokACAADAELEAAAC0UNAgJAAkBB9OIGQQNBAUGA4wYQzQNFDQBBoOMGQThBAUHg4wYQzQNFDQBBASEBQYDkBkEKQaCNBkGQ5AYQzQMNAQtBACEBCyABRQ0CAn8jAEGgA2siACQAIABBACgCADYCnAMgAEHwAGohByAAQeABaiEGAkACQAJAAkACQANAAn8gCkEYbCIDQeDfBmooAgAhCyADQeTfBmooAgAhAkEAIQQjAEHAAWsiBSQAIAVBACgCADYCvAECQCAAIgFB8ABqIggQyANFDQACQAJAIAFB4AFqIgkQyAMEQAJAAkAgAkHBAE8EQCAFEMgDRQ0CIAUgCyACEMsDRQRAIAUQygMMAwsgBSAFQfAAahDMAyEEIAUQygMgBEUNAiAFQZABakEgEL4DDAELIAVB8ABqIAsgAhDzBhogBUHwAGogAmpBwAAgAmsQvgMLQQAhBANAIAVB8ABqIARqIgIgAi0AAEE2czoAACAFQfAAaiAEQQFyaiICIAItAABBNnM6AAAg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DQIaCyAAKAIIIgNBLCADKAIAEQAAIgFFDQAgASACKAIANgIAIAItACgiBEEBcQR/IAFBBGogAkEEahDxBRogAi0AKAUgBAtBAnEEQCABQRRqIAJBFGoQ8QUaCyABIAIoAig2AiggASACKAIkNgIkIAAoAgwhBCADQQggAygCABEAACICBEAgAkKAgICAEDcCACACQQE2AgAgACgCDCEFIAAgBDYCDCAAKAIIIQQgACADNgIIIAAoAgQhAyAAIAE2AgQgACgCACEBIAAgAjYCAEEBIAFFDQIaIAEgASgCACIAQQFrNgIAQQEgAEEBRw0CGiADIAQgBRECACABIAEoAgQiAEEBazYCBEEBIABBAUcNAhogBCABQQggBCgCBBEBAA8LIAEtACgiAEEBcQR/IAFBBGoQ8AUgAS0AKAUgAAtBAnEEQCABQRRqEPAFCyADIAFBLCADKAIEEQEAC0EACxoLsgMBBH8CQCABQSQgASgCABEAACIDRQ0AAkAgAUEoIAEoAgARAAAiAkUNACACQQA2AgwgAiABNgIAIAJCADcCBCACIAE2AiAgAiACLQAkQf4BcToAJCADIAFBCCABKAIAEQAAIgU2AgAgBUUNACAFQgA3AgAgAyABNgIIIANBkAY2AgwgAyACNgIEIAMoAgAiAgRAIAIgAigCAEEBajYCACADKAIAIQQLIAQgBCgCBEEBajYCBAsCQCABQSwgASgCABEAACICRQ0AQQAhBCACQQA2AgAgAiABNgIkIAIgAi0AKEH8AXE6ACggAyABQQggASgCABEAACIFNgIQIAVFDQAgBUIANwIAIAMgATYCGCADQZEGNgIcIAMgAjYCFCADKAIQIgIEQCACIAIoAgBBAWo2AgAgAygCECEECyAEIAQoAgRBAWo2AgQLIAMgATYCICAAIAFBCCABKAIAEQAAIgI2AgAgAkUNACACQgA3AgAgACABNgIIIABBkgY2AgwgACADNgIEIAAoAgAiAQR/IAEgASgCAEEBajYCACAAKAIABUEACyIBIAEoAgRBAWo2AgQLC7UDAQN/AkAgA0EkIAMoAgARAAAiBUUNACADQTggAygCABEAACIERQ0AIAQgASADEPgFRQ0AIARBEGogAiADEPgFRQ0AIAQgAzYCMCAEIAQtADRB/gFxOgA0IAUgA0EIIAMoAgARAAAiATYCACAB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AhwgAigCFCIFIAIoAhhGDQEDQCAEIAUoAgAiBjYCACAEIAUoAgQ2AgQgBCAFKAIINgIIIAQgBSgCDDYCDCABIAYEfyAGIAYoAgBBAWo2AgAgASgCGAUgBAtBEGoiBDYCGCAFQRBqIgUgAigCGEcNAAsMAQsgAUEANgIcIAFCADcCFAsCQCACLQBEQQRxRQ0AIAEgAigCICIENgIgIAEgAigCJDYCJCABIAIoAig2AiggASACKAIsNgIsIARFDQAgBCAEKAIAQQFqNgIACyACLQBEQQhxBEAgAUEwaiACQTBqEJUGGgsgASACKAJENgJEIAEgAigCQDYCQCAAKAIMIQEgB0EIIAcoAgARAAAiAgRAIAJCgICAgBA3AgAgAkEBNgIAIAAoAgwhBCAAIAE2AgwgACgCCCEBIAAgBzYCCCAAKAIEIQcgACADNgIEIAAoAgAhAyAAIAI2AgBBASADRQ0CGiADIAMoAgAiAEEBazYCAEEBIABBAUcNAhogByABIAQRAgAgAyADKAIEIgBBAWs2AgRBASAAQQFHDQIaIAEgA0EIIAEoAgQRAQAPCwJ/An8gAy0ARCIAQQFxBEAgAygCCCIAIAMoAgRHBEADQCADIABBEGsiATYCCAJAIAEoAgAiAUUNACABIAEoAgAiAkEBazYCACACQQFHDQAgAEEMaygCACAAQQhrKAIAIgIgAEEEaygCABECACABIAEoAgQiAEEBazYCBCAAQQFHDQAgAiABQQggAigCBBEBAAsgAygCCCIAIAMoAgRHDQALCyAABEAgAygCACIBIAAgAygCDCAAayABKAIEEQEACyADLQBEIQALIABBAnELBEAgAygCGCIAIAMoAhRHBEADQCADIABBEGsiATYCGAJAIAEoAgAiAUUNACABIAEoAgAiAkEBazYCACACQQFHDQAgAEEMaygCACAAQQhrKAIAIgIgAEEEaygCABECACABIAEoAgQiAEEBazYCBCAAQQFHDQAgAiABQQggAigCBBEBAAsgAygCGCIAIAMoAhRHDQALCyAABEAgAygCECIBIAAgAygCHCAAayABKAIEEQEACyADLQBEIQALIABBBHELBH8CQCADKAIgIgBFDQAgACAAKAIAIgFBAWs2AgAgAUEBRw0AIAMoAiQgAygCKCIBIAMoAiwRAgAgACAAKAIEIgJBAWs2AgQg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NgIECwJAIABBKCAAKAIAEQAAIgFFDQAgASAAEO8FGiABIAA2AiAgASABLQAkQf4BcToAJCACIABBCCAAKAIAEQAAIgQ2AhAgBEUNACAEQgA3AgAgAiAANgIYIAJBhQY2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBhgY2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAFC8YDAQJ/An8CQCACQcDoBkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkGE6AZHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC7MDAQV/IABBECAAKAIAEQAAIgUEQCAFIQMCQCAAQSQgACgCABEAACICRQ0AAkAgAEE4IAAoAgARAAAiAUUNACABIAA2AjAgASABLQA0QfgBcToANCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBhwY2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEoIAAoAgARAAAiAUUNACABIAAQ7wUaIAEgADYCICABIAEtACRB/gFxOgAkIAIgAEEIIAAoAgARAAAiBDYCECAERQ0AIARCADcCACACIAA2AhggAkGIBjYCHCACIAE2AhQgAigCECIBBH8gASABKAIAQQFqNgIAIAIoAhAFQQALIgEgASgCBEEBajYCBAsgAiAANgIgIAMgAEEIIAAoAgARAAAiATYCACABRQ0AIAFCADcCACADIAA2AgggA0GJBjYCDCADIAI2AgQgAygCACIABH8gACAAKAIAQQFqNgIAIAMoAgAFQQALIgAgACgCBEEBajYCBAsLIAULxgMBAn8CfwJAIAJBwOsGRgRAIAAQvgEgACgCBCICKAIAIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIEIAIoAggiBCACKAIMEQIAIAMgAygCBCIAQQFrNgIEIABBAUcNACAEIANBCCAEKAIEEQEACyABKAIAIQALIAIgADYCACACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCCAARQ0CIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AggMAQtBACACQYTrBkcNARogABC+ASAAKAIEIgIoAhAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAhQgAigCGCIAIAIoAhwRAgAgAyADKAIEIgRBAWs2AgQgBEEBRw0AIAAgA0EIIAAoAgQRAQALIAEoAgAhAAsgAiAANgIQIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYIABFDQEgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGAtBAQsLsgMBBX8gAEEQIAAoAgARAAAiBQRAIAUhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQSAgACgCABEAACIBRQ0AIAFCADcCACABIAA2AhggASABLQAcQf4BcToAHCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBigY2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEEYIAAoAgARAAAiAUUNACABIAA2AhAgASABLQAUQf4BcToAFCACIABBCCAAKAIAEQAAIgQ2AhAgBEUNACAEQgA3AgAgAiAANgIYIAJBiwY2AhwgAiABNgIUIAIoAhAiAQR/IAEgASgCAEEBajYCACACKAIQBUEACyIBIAEoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBjAY2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAFC8YDAQJ/An8CQCACQZzuBkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkHg7QZHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELC8YDAQJ/An8CQCACQZT1BkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkHY9AZHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELCx4BAX8gAEEQIAAoAgARAAAiAQRAIAEgABDhAwsgAQvGAwECfwJ/AkAgAkH89wZGBEAgABC+ASAAKAIEIgIoAgAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAgQgAigCCCIEIAIoAgwRAgAgAyADKAIEIgBBAWs2AgQgAEEBRw0AIAQgA0EIIAQoAgQRAQALIAEoAgAhAAsgAiAANgIAIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIIABFDQIgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCAwBC0EAIAJBwPcGRw0BGiAAEL4BIAAoAgQiAigCECIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCFCACKAIYIgAgAigCHBECACADIAMoAgQiBEEBazYCBCAEQQFHDQAgACADQQggACgCBBEBAAsgASgCACEACyACIAA2AhAgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhggAEUNASAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYC0EBCwu+AwEFfyAAQRAgACgCABEAACIFBEAgBSEDAkAgAEEkIAAoAgARAAAiAkUNAAJAIABBOCAAKAIAEQAAIgFFDQAgASAAEO8FGiABQRBqIAAQ7wUaIAEgADYCMCABIAEtADRB/gFxOgA0IAIgAEEIIAAoAgARAAAiBDYCACAERQ0AIARCADcCACACIAA2AgggAkGTBjYCDCACIAE2AgQgAigCACIBBH8gASABKAIAQQFqNgIAIAIoAgAFQQALIgEgASgCBEEBajYCBAsCQCAAQRggACgCABEAACIBRQ0AIAEgADYCECABIAEtABRB/gFxOgAUIAIgAEEIIAAoAgARAAAiBDYCECAERQ0AIARCADcCACACIAA2AhggAkGUBjYCHCACIAE2AhQgAigCECIBBH8gASABKAIAQQFqNgIAIAIoAhAFQQALIgEgASgCBEEBajYCBAsgAiAANgIgIAMgAEEIIAAoAgARAAAiATYCACABRQ0AIAFCADcCACADIAA2AgggA0GVBjYCDCADIAI2AgQgAygCACIABH8gACAAKAIAQQFqNgIAIAMoAgAFQQALIgAgACgCBEEBajYCBAsLIAULxgMBAn8CfwJAIAJB1PwGRgRAIAAQvgEgACgCBCICKAIAIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIEIAIoAggiBCACKAIMEQIAIAMgAygCBCIAQQFrNgIEIABBAUcNACAEIANBCCAEKAIEEQEACyABKAIAIQALIAIgADYCACACIAEoAgQ2AgQgAiABKAIMNgIMIAIgASgCCDYCCCAARQ0CIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AggMAQtBACACQZj8BkcNARogABC+ASAAKAIEIgIoAhAiAyABKAIAIgBHBEAgAwRAIAMgAygCACIAQQFrNgIAAkAgAEEBRw0AIAIoAhQgAigCGCIAIAIoAhwRAgAgAyADKAIEIgRBAWs2AgQgBEEBRw0AIAAgA0EIIAAoAgQRAQALIAEoAgAhAAsgAiAANgIQIAIgASgCBDYCFCACIAEoAgw2AhwgAiABKAIINgIYIABFDQEgACAAKAIAQQFqNgIAQQEPCyACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGAtBAQsLvgMBBn8gAEEQIAAoAgARAAAiBgRAIAYhAwJAIABBJCAAKAIAEQAAIgJFDQACQCAAQcgAIAAoAgARAAAiAUUNACABIAA2AkAgASABLQBEQfABcToARCACIABBCCAAKAIAEQAAIgQ2AgAgBEUNACAEQgA3AgAgAiAANgIIIAJBlgY2AgwgAiABNgIEIAIoAgAiAQR/IAEgASgCAEEBajYCACACKAIABUEACyIBIAEoAgRBAWo2AgQLAkAgAEHkACAAKAIAEQAAIgFFDQAgAUEANgIAIAFBKGogABDvBRogASAANgJcIAEgAS0AYEHAAXE6AGAgAiAAQQggACgCABEAACIENgIQIARFDQAgBEIANwIAIAIgADYCGCACQZcGNgIcIAIgATYCFCACKAIQIgEEQCABIAEoAgBBAWo2AgAgAigCECEFCyAFIAUoAgRBAWo2AgQLIAIgADYCICADIABBCCAAKAIAEQAAIgE2AgAgAUUNACABQgA3AgAgAyAANgIIIANBmAY2AgwgAyACNgIEIAMoAgAiAAR/IAAgACgCAEEBajYCACADKAIABUEACyIAIAAoAgRBAWo2AgQLCyAGC8YDAQJ/An8CQCACQez/BkYEQCAAEL4BIAAoAgQiAigCACIDIAEoAgAiAEcEQCADBEAgAyADKAIAIgBBAWs2AgACQCAAQQFHDQAgAigCBCACKAIIIgQgAigCDBECACADIAMoAgQiAEEBazYCBCAAQQFHDQAgBCADQQggBCgCBBEBAAsgASgCACEACyACIAA2AgAgAiABKAIENgIEIAIgASgCDDYCDCACIAEoAgg2AgggAEUNAiAAIAAoAgBBAWo2AgBBAQ8LIAIgASgCBDYCBCACIAEoAgw2AgwgAiABKAIINgIIDAELQQAgAkGw/wZHDQEaIAAQvgEgACgCBCICKAIQIgMgASgCACIARwRAIAMEQCADIAMoAgAiAEEBazYCAAJAIABBAUcNACACKAIUIAIoAhgiACACKAIcEQIAIAMgAygCBCIEQQFrNgIEIARBAUcNACAAIANBCCAAKAIEEQEACyABKAIAIQALIAIgADYCECACIAEoAgQ2AhQgAiABKAIMNgIcIAIgASgCCDYCGCAARQ0BIAAgACgCAEEBajYCAEEBDwsgAiABKAIENgIUIAIgASgCDDYCHCACIAEoAgg2AhgLQQELCxwAIABBCCAAKAIAEQAAIgAEQCAAQgA3AwALIAALEAAgASAAQQggASgCBBEBAAsOACAAIAErAwA5AwBBAQu1AQEDfwJAIABBECAAKAIAEQAAIgFFDQAgAEHIACAAKAIAEQAAIgJFDQAgAiAAEO8FGiACQRBqIAAQ7wUaIAIgADYCQCACIAItAERB+AFxOgBEIAEgAEEI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IAQ2AuABCyADIAQ2AtgBIAQgBjYC5AEgBCADNgLgASABKALYASIFKALcASEGIAEoAuQBIAU2AgAgBSAIKAIANgLgASAFIAEoAuQBNgLkASABIAY2AtgBIAVB3AFqIQcgBgRAIAYgCTYC5AEgBiABNgLgAQsgBSABNgLcASAIIAU2AgAgASAHNgLkASAEIAQoAugBQQFrNgLoASADIAMoAugBQQFqNgLoAQwCCyABKALkASAENgIAIAQgCCgCADYC4AEgBCABKALkATYC5AEgASADNgLYASADBEAgAyAJNgLkASADIAE2AuABCyAEIAE2AtwBIAggBDYCACABIAc2AuQBDAELIAZBAWogBUkEQCADKALcASEHQQAhBkEAIQUgAygC2AEiBARAIAQoAugBIQULIAcEQCAHKALoASEGCyABQdwBaiEJIANB2AFqIQcgBSAGSwRAIAQoAtwBIQUgAygC5AEgBDYCACAEIAMoAuABNgLgASAEIAMoAuQBNgLkASADIAU2AtgBIARB3AFqIQYgBQRAIAUgBzYC5AEgBSADNgLgAQsgBCADNgLcASADIAY2AuQBIAMgBDYC4AEgASgC3AEiBSgC2AEhBiABKALkASAFNgIAIAUgCCgCADYC4AEgBSABKALkATYC5AEgASAGNgLcASAFQdgBaiEHIAYEQCAGIAk2AuQBIAYgATYC4AELIAUgATYC2AEgCCAFNgIAIAEgBzYC5AEgAyADKALoAUEBazYC6AEgBCAEKALoAUEBajYC6AEMAgsgASgC5AEgAzYCACADIAgoAgA2AuABIAMgASgC5AE2AuQBIAEgBDYC3AEgBARAIAQgCTYC5AEgBCABNgLgAQsgAyABNgLYASAIIAM2AgAgASAHNgLkAQwBCyABIAYgBSAFIAZJG0EBajYC6AEgByIBQeABaiEIIAEoAuABIgcNAQwCCwsgASABKALoAUEBazYC6AELIABBAToABCAAIAI2AgALOwEBfyAAKAL4AiICBEAgAiABEKQECyAAKAL8AiICBEAgAiABEKQECyAAEDogASAAQYwDIAEoAgQRAQALKgEBfyAAKAL4AiIBBEAgASAAKAKQAxCkBCAAQQA2AowDIABBADYC+AILC9QIAQd/AkAgAigCACIGIAEoAgAiA0kEQCABKAL4AiIGRQRAIAFB+AJqIQYMAgsg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IAEgA0LtzLP33QB+Qgt8IgNCEIg+AgQgASADQv///////z+DQu3Ms/fdAH5CC3wiA0IQiD4CCCABIANC////////P4NC7cyz990AfkILfCIDQhCIPgIMIAFBEGohASADQu3Ms/fdAH5CC3xC////////P4MhAyACQRBrIgJBA0sNAAsLIAAgAzcDCAsCQCACRQ0AIAAgACkDCCIDQu3Ms/fdAH5CC3xC////////P4M3AwggAkEBayEFIANCEIinIQQgAkEHcSIABEADQCABIAQ6AAAgBEEIdiEEIAFBAWohASACQQFrIQIgAEEBayIADQALCyAFQQdJDQADQCABQQA2AAQgASAEOgAAIAEgBEEYdjoAAyABIARBEHY6AAIgASAEQQh2OgABIAFBCGohAUEAIQQgAkEIayICDQALCwsLACAAIAE2AgAgAAvLAQEDfyAAKAIAIgVFBEBBAA8LIAUtAAAhBAJAAkACQCADBEAgBARAA0AgASAEQRh0QRh1EMgGRQ0DIAAgBUEBaiIDNgIAIAUtAAEhBCADIQUgBA0ACwsgAEEANgIAQQAPCyAERQ0BCyAFIQMDQCABIARBGHRBGHUQyAYNAiAAIANBAWoiBjYCACADLQABIQQgBiEDIAQNAAsLIABBADYCACACQQA6AAAgBQ8LIAIgBDoAACAAKAIAQQA6AAAgACAAKAIAQQFqNgIAIAULJgEBfyMAQRBrIgMkACAAIAEgA0EPaiACEOYFIQAgA0EQaiQAIAALagACQCABAn9BAEHXLiAAEMkGRQ0AGkEBQc0uIAAQyQZFDQAaQQJB6i4gABDJBkUNABpBA0HSMiAAEMkGRQ0AGkEEQewoIAAQyQZFDQAaQQAhAUHrqgEgABDJBg0BQQULNgIAQQEhAQsgAQsjAQF/IABBA00EfyABIABBAnRBuJ0HaigCADYCAEEBBSACCwueAQEFfwJAAkACQAJAIAEtAAAiBkUNAEECIQMgAkECSQ0AIAEhBQNAIAAgBjoAACACIANLIQcgBUEBaiEEIABBAWohACAFLQABIgZFDQIgAiADTQ0CIANBAWohAyAEIQUMAAsACyABIQQgAkUNASACQQFLIQcLIABBADoAACAHDQELIAQhAwNAIAMiBEEBaiEDIAQtAAANAAsLIAQgAWsLggEBAX8jAEEQayIEJAAgBCADNgIE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AigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LIAAgAiADEQIACwtSAQN/AkAgACgCACwAABDaBkUEQAwBCwNAIAAoAgAiAiwAACEDIAAgAkEBajYCACABIANqQTBrIQEgAiwAARDaBkUNASABQQpsIQEMAAsACyABC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBAWsiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQQFrIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQtyAQF/IwBBgAJrIgUkAAJAIARBgMAEcQ0AIAIgA0wNACAFIAFB/wFxIAIgA2siAkGAAiACQYACSSIDGxD0BhogA0UEQANAIAAgBUGAAhC5BiACQYACayICQf8BSw0ACwsgACAFIAIQuQYLIAVBgAJqJAALEQAgACABIAJBtglBtwkQtwYL8BcDEn8CfgF8IwBBsARrIgkkACAJQQA2AiwCQCABvSIYQn9XBEBBASERQccOIRIgAZoiAb0hGAwBCyAEQYAQcQRAQQEhEUHKDiESDAELQc0OQcgOIARBAXEiERshEiARRSEXCwJAIBhCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgwgBEH//3txEL0GIAAgEiARELkGIABBpjNBrdIAIAVBIHEiBhtBrTlBxNMAIAYbIAEgAWIbQQMQuQYgAEEgIAIgDCAEQYDAAHMQvQYMAQsgCUEQaiEQAkACfwJAIAEgCUEsahDDBiIBIAGgIgFEAAAAAAAAAABiBEAgCSAJKAIsIgZBAWs2AiwgBUEgciIVQeEARw0BDAMLIAVBIHIiFUHhAEYNAiAJKAIsIRRBBiADIANBAEgbDAELIAkgBkEdayIUNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAlB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ACAAQSByIAAgAEHBAGtBGkkbCwoAIABBMGtBCkkLEgAgAEEIdCAAQQh2ckH//wNxCwYAQfTmBwsGAEH85gcLBgBBgOcHCxYAIABFBEBBAA8LQfDmByAANgIAQX8LyA8CBX8OfiMAQdACayIFJAAgBEL///////8/gyELIAJC////////P4MhDyACIASFQoCAgICAgICAgH+DIQwgBEIwiKdB//8BcSEGAkACQCACQjCIp0H//wFxIglBAWtB/f8BTQRAIAZBAWtB/v8BSQ0BCyABUCACQv///////////wCDIgpCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEMDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQwgAyEBDAILIAEgCkKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAKhFAEQEKAgICAgIDg//8AIAwgAiADhFAbIQxCACEBDAILIAIgA4RQBEAgDEKAgICAgIDA//8AhCEMQgAhAQwCCyAKQv///////z9YBEAgBUHAAmogASAPIAEgDyAPUCIHG3kgB0EGdK18pyIHQQ9rEOwGQRAgB2shByAFKQPIAiEPIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAsgAyALIAtQIggbeSAIQQZ0rXynIghBD2sQ7AYgByAIakEQayEHIAUpA7gCIQsgBSkDsAIhAwsgBUGgAmogC0KAgICAgIDAAIQiEUIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQ6AYgBUGQAmpCACAFKQOoAn1CACAEQgAQ6AYgBUGAAmogBSkDmAJCAYYgBSkDkAJCP4iEIgRCACACQgAQ6AYgBUHwAWogBEIAQgAgBSkDiAJ9QgAQ6AYgBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQ6AYgBUHQAWogBEIAQgAgBSkD6AF9QgAQ6AYgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQ6AYgBUGwAWogBEIAQgAgBSkDyAF9QgAQ6AYgBUGgAWogAkIAIAUpA7gBQgGGIAUpA7ABQj+IhEIBfSIEQgAQ6AYgBUGQAWogA0IPhkIAIARCABDoBiAFQfAAaiAEQgBCACAFKQOoASAFKQOgASILIAUpA5gBfCICIAtUrXwgAkIBVq18fUIAEOgGIAVBgAFqQgEgAn1CACAEQgAQ6AYgByAJIAZraiEGAn4gBSkDcCINQgGGIg4gBSkDiAEiEkIBhiAFKQOAAUI/iIR8IgpC5+wAfSITQiCIIgIgD0KAgICAgIDAAIQiFUIfiEL/////D4MiBH4iECABQh+IQv////8PgyILIAogE1atIAogDlStIAUpA3hCAYYgDUI/iIQgEkI/iHx8fEIBfSINQiCIIgp+fCIOIBBUrSAOIA1C/////w+DIg0gAUI/iCIXIA9CAYaEQv////8PgyIPfnwiEiAOVK18IAQgCn58IAQgDX4iECAKIA9+fCIOIBBUrUIghiAOQiCIhHwgEiAOQiCGfCIOIBJUrXwgDiANIAFCAYYiFkL+////D4MiEn4iFCATQv////8PgyITIA9+fCIQIBRUrSAQIAIgC358IhQgEFStfHwiECAOVK18IBAgBCATfiIOIAogEn58IgQgCyANfnwiCiACIA9+fCINQiCIIAogDVatIAQgDlStIAQgClatfHxCIIaEfCIEIBBUrXwgBCAUIAIgEn4iAiALIBN+fCILQiCIIAIgC1atQiCGhHwiAiAUVK0gAiANQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAVQgGGIBeEIRUgBUHQAGogAiAEIAMgERDoBiABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQogBkH+/wBqIQZCACABfQwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgERDoBiABQjCGIAUpA2h9IAUpA2AiC0IAUq19IQogBkH//wBqIQYgASEWQgAgC30LIQsgBkH//wFOBEAgDEKAgICAgIDA//8AhCEMQgAhAQwBCwJ+IAZBAU4EQCAKQgGGIAtCP4iEIQogBEL///////8/gyAGrUIwhoQhDSALQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQ4QYgBUEwaiAWIBUgBkHwAGoQ7AYgBUEgaiADIBEgBSkDQCICIAUpA0giDRDoBiAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSEKIAQgAX0LIQQgBUEQaiADIBFCA0IAEOgGIAUgAyARQgVCABDoBiANIAIgAkIBgyIBIAR8IgQgA1YgCiABIARWrXwiASARViABIBFRG618IgMgAlStfCICIAMgAkKAgICAgIDA//8AVCAEIAUpAxBWIAEgBSkDGCICViABIAJRG3GtfCICIANUrXwiAyACIANCgICAgICAwP//AFQgBCAFKQMAViABIAUpAwgiBFYgASAEURtxrXwiASACVK18IAyEIQwLIAAgATcDACAAIAw3AwggBUHQAmokAAtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtkAgF/AX4jAEEQayICJAAgAAJ+IAFFBEBCAAwBCyACIAGtQgAgAWciAUHRAGoQ7AYgAikDCEKAgICAgIDAAIVBnoABIAFrrUIwhnwhAyACKQMACzcDACAAIAM3AwggAkEQaiQAC/oBAgN+An8jAEEQayIFJAACfiABvSIDQv///////////wCDIgJCgICAgICAgAh9Qv/////////v/wBYBEAgAkI8hiEEIAJCBIhCgICAgICAgIA8fAwBCyACQoCAgICAgID4/wBaBEAgA0I8hiEEIANCBIhCgICAgICAwP//AIQMAQsgAlAEQEIADAELIAUgAkIAIAOnZ0EgaiACQiCIp2cgAkKAgICAEFQbIgZBMWoQ7AYgBSkDACEEIAUpAwhCgICAgICAwACFQYz4ACAGa61CMIaECyECIAAgBDcDACAAIAIgA0KAgICAgICAgIB/g4Q3AwggBUEQaiQAC9sJAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCQJAAkAgAUIBfSIKQn9RIAJC////////////AIMiCyABIApWrXxCAX0iCkL///////+///8AViAKQv///////7///wBRG0UEQCADQgF9IgpCf1IgCSADIApWrXxCAX0iCkL///////+///8AVCAKQv///////7///wBRGw0BCyABUCALQoCAgICAgMD//wBUIAtCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASALQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIAlCgICAgICAwP//AIWEUA0BIAEgC4RQBEAgAyAJhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAJhFBFDQAgASEDIAIhBAwBCyADIAEgASADVCAJIAtWIAkgC1EbIgcbIQkgBCACIAcbIgtC////////P4MhCiACIAQgBxsiAkIwiKdB//8BcSEIIAtCMIinQf//AXEiBkUEQCAFQeAAaiAJIAogCSAKIApQIgYbeSAGQQZ0rXynIgZBD2sQ7AYgBSkDaCEKIAUpA2AhCUEQIAZrIQYLIAEgAyAHGyEDIAJC////////P4MhBCAIRQRAIAVB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0EPaxDsBkEQIAdrIQggBSkDWCEEIAUpA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhBCAKQgOGIAlCPYiEIQEgAiALhSEKAn4gA0IDhiIDIAYgCGsiB0UNABogB0H/AEsEQEIAIQRCAQwBCyAFQUBrIAMgBEGAASAHaxDsBiAFQTBqIAMgBCAHEOEGIAUpAzghBCAFKQMwIAUpA0AgBSkDSIRCAFKthAshAyABQoCAgICAgIAEhCEMIAlCA4YhAgJAIApCf1cEQCACIAN9IgEgDCAEfSACIANUrX0iBIRQBEBCACEDQgAhBAwDCyAEQv////////8DVg0BIAVBIGogASAEIAEgBCAEUCIHG3kgB0EGdK18p0EMayIHEOwGIAYgB2shBiAFKQMoIQQgBSkDICEBDAELIAIgA3wiASADVK0gBCAMfHwiBEKAgICAgICACINQDQAgAUIBgyAEQj+GIAFCAYiEhCEBIAZBAWohBiAEQgGIIQQLIAtCgICAgICAgICAf4MhAiAGQf//AU4EQCACQoCAgICAgMD//wCEIQRCACEDDAELIAZBAU4EfiAGrQUgBUEQaiABIAQgBkH/AGoQ7AYgBSABIARBASAGaxDhBiAFKQMAIAUpAxAgBSkDGIRCAFKthCEBIAUpAwghBEIACyEJIARCPYYgAUIDiIQiAyADIAGnQQdxIgZBBEutfCIBVq0gBEIDiEL///////8/gyAJQjCGhCAChHwhBAJAAkAgBkEERwRAIAEhAwwBCyAEIAFCAYMiAiABfCIDIAJUrXwhBAwBCyAGRQ0BCwsgACADNwMAIAAgBDcDCCAFQfAAaiQAC9kDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgJCgICAgICAwIA8fSACQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAiAAQv//////////D4MiAEKBgICAgICAgAhaBEAgAkKBgICAgICAgMAAfCEDDAILIAJCgICAgICAgIBAfSEDIABCgICAgICAgIAIhUIAUg0BIAMgAkIBg3whAwwBCyAAUCACQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQMMAQtCgICAgICAgPj/ACEDIAJC////////v//DAFYNAEIAIQMgAkIwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEOwGIAQgACACQYH4ACAFaxDhBiAEKQMIQgSGIAQpAwAiAkI8iIQhAyAEKQMQIAQpAxiEQgBSrSACQv//////////D4OEIgJCgYCAgICAgIAIWgRAIANCAXwhAwwBCyACQoCAgICAgICACIVCAFINACADQgGDIAN8IQMLIARBIGokACADIAFCgICAgICAgICAf4OEvwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC8QBAgF/An5BfyEDAkAgAEIAUiABQv///////////wCDIgRCgICAgICAwP//AFYgBEKAgICAgIDA//8AURsNAEEAIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQEEAIAEgAlMgASACURsNASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADC3UBAX4gACABIAR+IAIgA358IANCIIgiBCABQiCIIgJ+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAiADfnwiA0IgiHwgASAEfiADQv////8Pg3wiA0IgiHw3AwggACAFQv////8PgyADQiCGhDcDAAtBAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRDkBiAAIAUpAwA3AwAgACAFKQMINwMIIAVBEGokAAueCwIFfw9+IwBB4ABrIgUkACACQiCGIAFCIIiEIQ4gBEIvhiADQhGIhCELIARC////////P4MiDEIPhiADQjGIhCEQIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghESAMQhGIIRIgBEIwiKdB//8BcSEGAkACfyACQjCIp0H//wFxIghBAWtB/f8BTQRAQQAgBkEBa0H+/wFJDQEaCyABUCACQv///////////wCDIg9CgICAgICAwP//AFQgD0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgD0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIA+EIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIA+EUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyAPQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIHG3kgB0EGdK18pyIHQQ9rEOwGIAUpA1giDUIghiAFKQNQIgFCIIiEIQ4gDUIgiCERQRAgB2shBwsgByACQv///////z9WDQAaIAVBQGsgAyAMIAMgDCAMUCIJG3kgCUEGdK18pyIJQQ9rEOwGIAUpA0giAkIPhiAFKQNAIgNCMYiEIRAgAkIvhiADQhGIhCELIAJCEYghEiAHIAlrQRBqCyEHIAtC/////w+DIgIgAUL/////D4MiBH4iEyADQg+GQoCA/v8PgyIBIA5C/////w+DIgN+fCIOQiCGIgwgASAEfnwiCyAMVK0gAiADfiIVIAEgDUL/////D4MiDH58Ig8gEEL/////D4MiDSAEfnwiECAOIBNUrUIghiAOQiCIhHwiEyACIAx+IhYgASARQoCABIQiDn58IhEgAyANfnwiFCASQv////8Hg0KAgICACIQiASAEfnwiEkIghnwiF3whBCAGIAhqIAdqQf//AGshBgJAIAwgDX4iGCACIA5+fCICIBhUrSACIAEgA358IgMgAlStfCADIA8gFVStIA8gEFatfHwiAiADVK18IAEgDn58IAEgDH4iAyANIA5+fCIBIANUrUIghiABQiCIhHwgAiABQiCGfCIBIAJUrXwgASASIBRUrSARIBZUrSARIBRWrXx8QiCGIBJCIIiEfCIDIAFUrXwgAyAQIBNWrSATIBdWrXx8IgIgA1StfCIBQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyABQgGGIAJCP4iEIQEgAkIBhiAEQj+IhCECIAtCAYYhCyADIARCAYaEIQQLIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIIQYABTwRAQgAhAQwDCyAFQTBqIAsgBCAGQf8AaiIGEOwGIAVBIGogAiABIAYQ7AYgBUEQaiALIAQgCBDhBiAFIAIgASAIEOEGIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEEIAUpAwAhAiAFKQMIDAELIAFC////////P4MgBq1CMIaECyAKhCEKIAtQIARCf1UgBEKAgICAgICAgIB/URtFBEAgCiACQgF8IgEgAlStfCEKDAELIAsgBEKAgICAgICAgIB/hYRQRQRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAt/AgJ/AX4jAEEQayIDJAAg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Ec2Ro5r0iqF7T2PxddMAzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc0AqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqoA6OmdD0UjfXhta7qnllx4CLv/GpEAIAkNCiw7OnwA7/zfauXrL6LSdBbV8YTfnCWafHkATG1pUHJvdG9jb2xQcm9wZXJ0eQBTdG9wcGVkIGFuZCBlbXB0eQBFbXB0eQBwcmlvcml0eQBpbmZpbml0eQBMbWlNZW1vcnkATG9nIGNhbGxlZCB3aXRoIHVua25vd24gb3IgdW5pbml0aWFsaXplZCBjYXRlZ29yeQBMbWlUcmFuc3BvcnRBZGRyZXNzQ29uc3RydWN0Q29weQBMbWlIb3N0UmVxdWVzdERlc3Ryb3kAU3RhY2tGcmFtZURlc3Ryb3kARWxlbWVudCAlcyBpcyBtYXJrZWQgYXMgYSBjb21wbGV4IHR5cGUsIGJ1dCBkb2VzIG5vdCBwYXJzZSBwcm9wZXJseQByZWN2b25seQBzZW5kb25seQBydGNwLW11eC1vbmx5AE5vQWRkckluRmFtaWx5AEJhZEZhbWlseQBMbWlDb25kaXRpb25Ob3RpZnkAa2V5AExtaVNjZWxNYXN0ZXJLZXkAYm9keQBMbWlTY2VsQm9keQByZWxheQBydGNwLW11eABydGNwTXV4AHJ0eABzcmZseABwcmZseABMbWlNdXRleABtYXgAJXglMDJ4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAJXgAcHcAbWJ3AG52AHJjdgBzZW5kcmVjdgBFeHBlY3RlZCBvbmx5IDEgY29ubmVjdGlvbiBidXQgZ290ICV6dQAlcy0lbHUARGF0YSB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgYXR0cmlidXRlIDwlcz0lcz4gYXQgbGluZSAlbHUgY29sdW1uICVsdQBEYXRhIHZhbGlkYXRpb24gZmFpbGVkIGZvciBzaW1wbGV0eXBlIDwlcz0lcz4gYXQgbGluZSAlbHUgY29sdW1uICVsdQBQYXJzaW5nIGZhaWxlZCBvbiA8JXM+IGF0IGxpbmUgJWx1IGNvbHVtbiAlbHUAUGFyc2luZyBmYWlsZWQgb24gPC8lcz4gYXQgbGluZSAlbHUgY29sdW1uICVsdQBNYXRjaGVkIHhzOmFueSB0byBlbGVtZW50ICIlcyIgYXQgbGluZSAlbHUgY29sdW1uICVsdQBDYW4ndCB1bmRlcnN0YW5kIHBhcnNlciBmcmFtZSB0eXBlICVsdQAlcyV1AGFwdD0ldQAvbGV2ZWw9JXUAL3BrdG1vZGU9JXUAOiV1ACV1ICVzLyV1ACV1LiV1LiV1LiV1AE1vcmUgdGhhbiB0d28gc3NyYyB2YWx1ZXMgZm9yIHNvdXJjZSAlczogcHJpbWFyeSAldSwgc2Vjb25kYXJ5ICV1LCBzYXcgJXUAIHJhZGRyICVzIHJwb3J0ICV1AFJUWCBoYXMgYXB0IGZvciB1bmtub3duIHB0ICV1AGZtdHAgZm9yIHVua25vd24gcHQgJXUAUkVEIGJpbmRpbmcgZm9yIHVua25vd24gcHQgJXUAcnRjcC1mYiBmb3IgdW5rbm93biBwdCAldQBQYXJzZSBlcnJvciBhdCBvZmZzZXQgJXUARHVwbGljYXRlIHJ0cG1hcCBmb3IgcGF5bG9hZCB0eXBlICV1AE5vIHJ0cG1hcCBhdHRyaWJ1dGUgZm9yIG5vbi1zdGF0aWMgcGF5bG9hZCB0eXBlICV1AEF0dGVtcHRlZCB0byBhZGQgZHVwbGljYXRlIGNvbm5lY3Rpb246ICV1AHRleHQARmlsZSBpbnB1dCBhbmQgb3V0cHV0AHNkcC1pbi1vdXQAc2NlbC1pbi1vdXQAVGVzdCBVc2luZyBMYXJnZXIgVGhhbiBCbG9jay1TaXplIEtleSAtIEhhc2ggS2V5IEZpcnN0AGhvc3QAVW5rbm93bkhvc3QAdGVzdABzaW11bGNhc3QAdHJhbnNwb3J0AExtaVRyYW5zcG9ydE1hbmFnZXJHZXRUcmFuc3BvcnQATG1pVHJhbnNwb3J0TWFuYWdlclJlZ2lzdGVyVHJhbnNwb3J0AExtaVRyYW5zcG9ydAByYWRkciBub3QgZm9sbG93ZWQgYnkgcnBvcnQAcmFkZHIgZm9sbG93ZWQgYnkgJXMsIG5vdCBycG9ydABMbWlIb3N0R2V0TmFtZUFuZFBvcnQAYXB0AHF1b3QAQWxsU3RhY2tGcmFtZUNoZWNrQ2hpbGRDb3VudABmaW5nZXJwcmludABMbWlTY2VsRmluZ2VycHJpbnQATG1pWHNkU2ltcGxlVHlwZV9MbWlVaW50AHRlbGVwaG9uZS1ldmVudABjb21wb25lbnQATG1pU2NlbENvbXBvbmVudABJbiA8YWxsPiwgbWlzc2luZyBlbGVtZW50AEFueUVsZW1lbnRNYXRjaEVsZW1lbnQAUmVndWxhckVsZW1lbnRNYXRjaEVsZW1lbnQAQ29tcGxleFR5cGVNYXRjaEVsZW1lbnQAVGltZXIgbWFuYWdlbWVudABRdWV1ZSBtYW5hZ2VtZW50AEZJRk8gbWFuYWdlbWVudABCYWRSZXN1bHQAZGVmYXVsdAB0aWx0AHNhbHQATG1pVHJhbnNwb3J0T3BlbkZpbGVDb3VudEluaXQATG1pQ29uZGl0aW9uV2FpdABoZWlnaHQAZ3QATG1pSG9zdENvbnN0cnVjdABMbWlIb3N0U2VydmljZURlc3RydWN0AGtleXMAcndzAG13cwBJbnZhbGlkIHF1ZXVlIHN0YXR1cwBhdHRzAHN1cHBvcnRzAFRoZSBsb29wIHRoYXQgbGlzdGVucyBmb3IgbmV0d29yayBldmVudHMAUmVjb3ZlcnkgY29tcGxldGUsIHJlYWR5IHRvIHBhcnNlIGVsZW1lbnRzAEVycm9yIHBhcnNpbmcgU0NFTCB0cmFuc3BvcnQgYWRkcmVzczogY291bGQgbm90IGludGVycHJldCAiJXMiIGFzICVzIGFkZHJlc3MATG1pU2NlbFRyYW5zbGF0ZVRvVHJhbnNwb3J0QWRkcmVzcwBMbWlTY2VsQWRkcmVzcwBzdWNjZXNzAGFjdHBhc3MATG1pUHJvdG9jb2xTaG93UGFyYW1ldGVycwBleHRIZWFkZXJzAG1mcHMAYXBvcwBjb25uZWN0aW9ucwBMbWlTZXNzaW9uQ2FwYWJpbGl0aWVzQWRkQ29ubmVjdGlvbnMAZXh0ZW5zaW9ucwAgeG1sbnMAY2hucwBwYXJhbXMATWVtb3J5IGFsbG9jYXRpb24gdXNpbmcgbWVtb3J5IHBvb2xzAGNoYW5uZWxzAGJpbmRpbmdzAGF0dHJpYnV0ZXMATm9BZGRyZXNzZXMATXV0ZXhlcywgc2VtYXBob3JlcywgYW5kIGNvbmRpdGlvbiB2YXJpYWJsZXMAcHJvcGVydGllcwBFeHRyYWN0TWVkaWFQcm9wZXJ0aWVzAGNhcGFiaWxpdGllcwBMbWlTY2VsQ2FwYWJpbGl0aWVzAGZlZWRiYWNrTWVzc2FnZXMAc291cmNlcwByZWNlaXZlU291cmNlcwBMbWlTZXNzaW9uQ2FwYWJpbGl0aWVzQWRkU291cmNlcwBMb2NhbCBuZXR3b3JrIGFkZHJlc3NlcyBhbmQgaW50ZXJmYWNlcwBibmRzAHVzZU1pZHNSaWRzAEVsZW1lbnRTdGFydEVsZW1lbnROcwBBbGxTdGFydEVsZW1lbnROcwBDb21wbGV4VHlwZVN0YXJ0RWxlbWVudE5zAFN0YWNrRnJhbWVTdGFydEVsZW1lbnROcwBTZXF1ZW5jZVN0YXJ0RWxlbWVudE5zAENob2ljZVN0YXJ0RWxlbWVudE5zAFNpbXBsZVR5cGVFbmRFbGVtZW50TnMAU3RhY2tGcmFtZUVuZEVsZW1lbnROcwAlcyVzPSVzAFJlY2VpdmVkIGVsZW1lbnQgbmFtZSAlcyBzdG9yZWQgYXMgJXM6JXMAJXUgY25hbWU6JXMALyVzACVzIyVzAE5vdCBhYmxlIHRvIGZpbmQgYSBtYXBwaW5nIGZvciB0aGUgbmFtZXNwYWNlIHByZWZpeCAlcwAldSAlcwBDb3VsZCBub3QgcmVnaXN0ZXIgdHJhbnNwb3J0ICVzACV1IElOICVzICVzACVzICV6dSAlcyAldSAlcyAldSB0eXAgJXMAUmVzZXR0aW5nIHRoZSBwYXJzZXIgb24gdGhlIGFycml2YWwgb2YgJXMATm8gdHJhbnNwb3J0IHJlZ2lzdGVyZWQgZm9yIHR5cGUgJXMARkFJTF9GSUxFX1JFQUQ6IGNvdWxkbid0IHJlYWQgJXMATG1pSG9zdENvbnN0cnVjdDogJXMgLT4gJXMARmluZCBSaWQgPSAlcwBGaW5kIE1pZCA9ICVzAEVycm9yIHJlc29sdmluZyBhZGRyZXNzICVzOiAlcwBFcnJvciBjbG9zaW5nIGZpbGUgJXM6ICVzAEVycm9yIG9wZW5pbmcgZmlsZSAlczogJXMAJXM6ICVzOiAlczogJXMAUHVzaGluZyBpdGVtICVwIG9udG8gcXVldWUgJXA6ICVzAEF0dGVtcHRlZCB0byBhZGQgZHVwbGljYXRlIHNvdXJjZTogJXMAQmluZGluZyBub3QgZm91bmQ6ICVzAEZBSUxfRklMRV9PUEVOX0lOUFVUOiAlcwAqICVzAFN0YWNrIER1bXAKJXMAaWRTdHIAbXByAExtaVBvb2xBbGxvY2F0b3IATG1pUHJvY2Vzc29yAFN5bnRheCBlcnJvcgBDYW5ub3QgcmVjb3ZlciBwYXJzZXIgZnJvbSBlcnJvcgBTZW1hbnRpYyBlcnJvcgBTeW50YXggRXJyb3IAdW1yAEF0dHJIZGxyAENoYXJIZGxyAEVuZE9mU3RhcnRFbGVtSGRscgBpcgBwYXJhbWV0ZXIATG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUGFyYW1ldGVyAENhbid0IHJlc29sdmUgdGhlIHByZWZpeCAlcyBmcm9tIHRoZSBwYXJzZXIAQ2FuJ3QgcmVzb2x2ZSB0aGUgZGVmYXVsdCBOUyBmb3IgJXMgZnJvbSB0aGUgcGFyc2VyAExtaVRpbWVyAG90aGVyAHVuc2lnbmVkSW50ZWdlcgBMbWlUcmFuc3BvcnRNYW5hZ2VyAFNlc3Npb24gRGVzY3JpcHRpb24gUHJvdG9jb2wgUGFyc2VyL0VuY29kZXIATG1pQXN5bmNTZW5kZXIATG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlcgBrZHIAcmFkZHIAZGVmYXVsdEFkZHIAY3IAdHlwAHNldHVwAHN1cABzc3JjLWdyb3VwAHNydHAATG1pU2NlbFNydHAAZm10cABMbWlNZWRpYUFkZFJ0eEZtdHAATG1pTWVkaWFBZGRSZWRGbXRwAExtaU1lZGlhTWFwQWRkRm10cABMbWlNZWRpYUFkZFJmYzM1NTVGbXRwAExtaVF1ZXVlU3RvcABMbWlIb3N0U2VydmljZVN0b3AAcHJvcABMbWlRdWV1ZVBvcABjb21wAGFtcABmcABzZHAATG1pRmluZ2VycHJpbnRDb25zdHJ1Y3RGcm9tU2RwAExtaVNvdXJjZXNDb25zdHJ1Y3RGcm9tU2RwAExtaUV4dGVuc2lvbkhlYWRlckNvbnN0cnVjdEZyb21TZHAATG1pQ29ubmVjdGlvbkNvbnN0cnVjdEZyb21TZHAAQWRkRmluZ2VycHJpbnRzRnJvbVNkcABBZGRNZWRpYUZyb21TZHAATG1pU2RwAExtaVNvdXJjZXNDb25zdHJ1Y3RGcm9tUGxhbkJTZHAAcnRjcABleHRtYXAAcnRwbWFwAExtaU1lZGlhQ29uc3RydWN0RnJvbVJ0cG1hcABzc3JjTWFwAExtaVByb3RvY29sU3NyY01hcABQb3BwaW5nIGl0ZW0gZnJvbSBxdWV1ZSAlcDogJXM7ICppdGVtPSVwAFN0b3BwaW5nIHF1ZXVlICVwAERlc3RydWN0aW5nIEhvc3RTZXJ2aWNlICVwAFN0b3BwaW5nIEhvc3RTZXJ2aWNlICVwAHRzdG8Ac28Ac3RyZWFtaW5nIGF1ZGlvAGluZm8ATG1pRmlmbwB2aWRlbwBkeW4AdW5rbm93bgB1bgBMbWlWcDlDb21tb24ATG1pUHJvdG9jb2xSZXNvbHV0aW9uAEFzeW5jaHJvbm91c2UgZXhlY3V0aW9uAFVuYWJsZSB0byBhZGQgY29udGVudCBwb3NzaWJseSBkdWUgdG8gbWVtb3J5IGV4aGF1c3Rpb24AZW5jcnlwdGlvbgBMbWlTY2VsRW5jcnlwdGlvbgBFcnJvciBwYXJzaW5nIFNDRUwgZW5jcnlwdCBkZXNjcmlwdGlvbgBFcnJvciBwYXJzaW5nIFNDRUwgYXV0aCBkZXNjcmlwdGlvbgBJbnZhbGlkIFByb2Nlc3NpbmcgSW5zdHJ1Y3Rpb24AZGlyZWN0aW9uAExtaVNjZWxEaXJlY3Rpb24ATG1pU2NlbENvbm5lY3Rpb24AYWN0aW9uAExtaVByb3RvY29sUmVtb3RlQ29udHJvbEFjdGlvbgBQcm9jZXNzb3IgYW5kIENQVSBpbmZvcm1hdGlvbgBmb3VuZGF0aW9uAE1lbW9yeSBhbGxvY2F0aW9uIGFuZCBkZWFsbG9jYXRpb24AVGVzdCBXaXRoIFRydW5jYXRpb24AYXV0aGVudGljYXRpb24ATG1pU2NlbEF1dGhlbnRpY2F0aW9uAGFwcGxpY2F0aW9uAExtaVNjZWxFeHRlbnNpb24AY29uAGhvbGRjb25uAG1pbgBMbWlGaWxlT3BlbgBTaW11bHRhbmVvdXMgT3BlbgBsZW4AcGFuAG5hbgBCb29sZWFuAHpvb20AL2Rldi91cmFuZG9tAG5tAGFsZ29yaXRobQBMbWlTY2VsQWxnb3JpdGhtABtbNDA7MzdtABtbNDA7MzRtABtbNDA7Mzc7MW0AG1s0MDszNDsxbQAbWzQwOzMyOzFtABtbNDA7MzE7MW0AG1swbQB0bABMbWlQcm90b2NvbFJlbW90ZUNvbnRyb2wATG1pWHNkU2ltcGxlVHlwZV9MbWlCb29sAHhtbABhbGwATG1pQ29uZGl0aW9uTm90aWZ5QWxsAGtsAFNlcnZlckZhaWwAU2VydmVyVGVtcEZhaWwAbGV2ZWwAc2NlbABMbWlIb3N0UmVxdWVzdENhbmNlbAB3ZWJSdGNTZHBTY2VsAGluZm8gYWxsQFdlYlJ0Y1NkcFNjZWwATG1pQ29tcG9uZW50Q29uc3RydWN0RnJvbVNjZWwAV2ViUlRDIFNEUCBTY2VsAHZhbABvcHRpb25hbABzaWduYWwAUHJvY2Vzc2luZyBCPCVzPiBpbiB0aGUgaW50ZXJuYWwgY2FsbGJhY2sAdXJpAGh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaQBta2kAYXV0aABsZW5ndGgAa2V5TGVuZ3RoAHRhZ0xlbmd0aABtZXRoAGJhbmR3aWR0aABtaW5CYW5kd2lkdGgATG1pUXVldWVQdXNoAGVoAC4vTG1pL09zL0xtaUNvbmRpdGlvbklubGluZS5oAGZibXNnAFZwOSBoaWdoLWxldmVsIHN5bnRheCByZWxhdGVkIGxvZwBMbWlMb2cAc3RyaW5nAEZha2VVZHBUcmFuc3BvcnRDb25zdHJ1Y3RBZGRyZXNzRnJvbVN0cmluZwBGYWtlVGNwVHJhbnNwb3J0Q29uc3RydWN0QWRkcmVzc0Zyb21TdHJpbmcATG1pWHNkU2ltcGxlVHlwZV9MbWlTdHJpbmcATG1pWHNkUGFyc2VyR2V0TnNQcmVmaXhNYXBwaW5nAHhtbDpsYW5nAGljZS11ZnJhZwBpbmYAVGhlIGxvZ2dpbmcgc3lzdGVtIGl0c2VsZgB0ZW1wb3JhbFNwYXRpYWxUcmFkZW9mZgBwcmVmACVmAHdpbmRvd1NpemUAcmVwbGF5V2luZG93U2l6ZQBtaW5XaW5kb3dTaXplAGluYWN0aXZlAEFjdGl2ZQByZWxhdGl2ZQBwYXNzaXZlAFBhc3NpdmUAdHJ1ZQBJQ0UgYXR0cmlidXRlICVzIHdpdGhvdXQgdmFsdWUAZm10cCBwYXJhbWV0ZXIgIiVzIiBsYWNrcyBhIHZhbHVlAFN0YWNrRnJhbWVQcm9jZXNzVmFsdWUATG1pUXVldWUAYWJzb2x1dGUAQXR0clNldFByb2Nlc3NBdHRyaWJ1dGUAU2ltcGxlVHlwZVByb2Nlc3NBdHRyaWJ1dGUAbGl0ZQBjYW5kaWRhdGUATG1pVHJhbnNwb3J0QWRkcmVzc0NvbnN0cnVjdEZyb21TZHBDYW5kaWRhdGUATG1pTWVtb3J5QWxsb2NhdGUAa2V5RGVyaXZhdGlvblJhdGUAcGl4ZWxSYXRlAG1pblBpeGVsUmF0ZQBjbG9ja1JhdGUATG1pU2RwU2Vzc2lvblRpbWVDb25zdHJ1Y3RQYXJzZQBMbWlTZHBNZXNzYWdlQ29uc3RydWN0UGFyc2UATG1pRmlsZUNsb3NlAGZhbHNlAFNlYXJjaGluZyBlbGVtZW50ICVzIGluIGJhc2UAY2FwdHVyZQBPdGhlckZhaWx1cmUASGkgVGhlcmUAdGNwdHlwZQB4eHgtaW52YWxpZC10cmFuc3BvcnQtYWRkcmVzcy10eXBlAExtaVhzZFNpbXBsZVR5cGVfQW55VHlwZQBub25lAExtaVNvY2tldEVuZ2luZQBJbnZhbGlkIHN0YXJ0IHRpbWUASW52YWxpZCBzdG9wIHRpbWUAbGlmZVRpbWUAdXNlcm5hbWUATG1pU2NlbFNldHVwUm9sZQBwcm9maWxlAExtaVNjZWxQcm9maWxlAExtaUZpbGUAZG91YmxlAG1lc3NhZ2UATG1pU2NlbEZlZWRiYWNrTWVzc2FnZQBKZWZlAHBhY2tldGl6YXRpb24tbW9kZQBjb25uZWN0aW9uTW9kZQBMbWlTY2VsQ29ubmVjdGlvbk1vZGUATG1pUHJvdG9jb2xTb3VyY2UATG1pU2NlbFJlY2VpdmVTb3VyY2UAcHJlZmVyZW5jZQBJbnZhbGlkIENoYXJhY3RlciBSZWZlcmVuY2UATG1pTmV0d29ya0ludGVyZmFjZQBpY2UtcHdkAGh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZABodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlTY2VsLnhzZABwYXNzd29yZABtZXRob2QAY29tbWFuZABMbWlTY2VsRXh0Q29tbWFuZABtc2lkAHJpZABtaWQAY2lkAHByb2ZpbGUtbGV2ZWwtaWQAcHJvZmlsZS1pZABBbHJlYWR5IEluaXRpYWxpemVkAE5vdCBJbml0aWFsaXplZABIb3N0IHJlcXVlc3QgJXAgKCVzKSBiZWluZyBkZXN0cm95ZWQARW50aXR5IHJlZmVyZW5jZSByZXBsYWNlbWVudCBub3Qgc3VwcG9ydGVkAGljZVJlc3RhcnRTdXBwb3J0ZWQAcmVsYXRlZABGb3JtYXR0ZWQgbG9nIG1lc3NhZ2UgdHJ1bmNhdGVkAHVucGFyc2VkAHJlZABIb3N0U2VydmljZVN0b3AgLSBob3N0IHNlcnZpY2UgYWxyZWFkeSBzdG9wcGVkAFN0b3BwZWQAVW5kZWZpbmVkAEVycm9yIG9wZW5pbmcgZmlsZSAlczogQWxyZWFkeSBvcGVuZWQAQWxsb2NhdGlvbiBvZiAlbHUgYnl0ZXMgZmFpbGVkAFRyYW5zcG9ydCBwbHVnLWluICVzIENvcHlBZGRyZXNzUGx1Z0luRGF0YSBtZXRob2QgZmFpbGVkAEhvc3QgcmVxdWVzdCAlcCAoJXMpIGJlaW5nIGNhbmNlbGVkAGVuYWJsZWQAdW5pZmllZABNYXhpbXVtIHN0YWNrIGRlcHRoIGV4Y2VlZGVkAE1heGltdW0gY29tbWVudCBsZW5ndGggZXhjZWVkZWQATWF4aW11bSBwcm9jZXNzaW5nIGluc3RydWN0aW9uIGxlbmd0aCBleGNlZWRlZABNYXhpbXVtIGF0dHJpYnV0ZSB2YWx1ZSBsZW5ndGggZXhjZWVkZWQATWF4aW11bSBhdHRyaWJ1dGUgbGVuZ3RoIGV4Y2VlZGVkAE1heGltdW0gbmFtZSBsZW5ndGggZXhjZWVkZWQATWF4aW11bSByZWZlcmVuY2UgbmFtZSBsZW5ndGggZXhjZWVkZWQAc2Vjb25kYXJ5SWQAY29ubmVjdGlvbklkAGNvbm5JZABzb3VyY2VJZAAlMDRkLSUwMmQtJTAyZCAlMDJkOiUwMmQ6JTAyZC4lMDNkICVzJTAyZDolMDJkACUwNGQtJTAyZC0lMDJkICUwMmQ6JTAyZDolMDJkLiUwM2QgJXMlMDJkOiUwMmQ6JTAyZAB4PSVwLCB3YWl0ZXJDb3VudD0lZAA6ICVzOiVkAE5vIG1lZGlhIGZvdW5kIGZvciBhc3NvY2lhdGVkIFBUICVkIHdpdGggbWVkaWEgJXMvJWQAJXMldSAlZABFcnJvciBwYXJzaW5nIFNDRUwgdHJhbnNwb3J0IGFkZHJlc3M6IGludmFsaWQgY29ubmVjdGlvbiBtb2RlIGVudW0gdmFsdWUgJWQAcnhzcmMAc3NyYwBMbWlBc3luYwBoYXNoRnVuYwBlbmMATG1pU2RwTWVzc2FnZUNvbnN0cnVjdEZyb21HZW5lcmljAExtaVNjZWxNZWRpYUNvbnN0cnVjdEZyb21HZW5lcmljAGZyYW1lc1BlclNlYwBtaW5GcmFtZXNQZXJTZWMATG1pL09zL0xtaU1lbW9yeS5jAExtaS9UcmFuc3BvcnQvTG1pSG9zdC5jAExtaS9UcmFuc3BvcnQvTG1pVHJhbnNwb3J0LmMARmFrZVRyYW5zcG9ydC5jAExtaS9UcmFuc3BvcnQvTG1pVHJhbnNwb3J0QWRkcmVzcy5jAExtaS9Pcy9MbWlQb29sQWxsb2NhdG9yLmMATG1pL1htbC9MbWlYc2RQYXJzZXIuYwBMbWkvVHJhbnNwb3J0L0xtaVRyYW5zcG9ydE1hbmFnZXIuYwBUcmFuc2xhdGVTZHAuYwBMbWkvU2NlbC9MbWlTY2VsVHJhbnNsYXRpb24uYwBXZWJSdGNTZHBTY2VsLmMATG1pL1NpZ25hbGluZy9MbWlTZXNzaW9uRGlhbG9nLmMATG1pL09zL0xtaVF1ZXVlLmMATG1pL1NkcC9MbWlTZHBQYXJzZS5jAExtaS9Pcy9MbWlGaWxlLmMAd2IAcmIAcnRjcC1mYgBhYgBMbWlNZWRpYU1hcE9yQ29ubmVjdGlvbkFkZFJ0Y3BGYgByd2EAQXN5bmNocm9ub3VzIHNlbmRlciBvZiB0cmFuc3BvcnQgZGF0YQBOZXR3b3JraW5nIGFuZCB0cmFuc3BvcnQgb2YgZGF0YQBUZXN0IFVzaW5nIExhcmdlciBUaGFuIEJsb2NrLVNpemUgS2V5IGFuZCBMYXJnZXIgVGhhbiBPbmUgQmxvY2stU2l6ZSBEYXRhAExtaVNjZWxNZWRpYQByZWNlaXZlTWVkaWEAU3RhY2tEdW1wXwBtYWluXwBMbWlQb29sQWxsb2NhdG9yU3RhdEFkZF8AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXwBBcHBlbmRlZCBbJXNdAFtBVFRSPSVzXQBbU3lzdGVtIHRocmVhZF0AglWKOJpEPA6kzIGYmfIIOoXw+qPlePgHei4/9GcpZlsAJXMlMDJYACUwMlglMDJYJTAyWABNUFYAUENNVQBg5DFZHuC2fw2KJqrL9bd/jgvGITcoxRQFRgQPDuN/VABTRU5UAE1QMlQARVJST1IARU5URVIAQVZQAFJUUABRQ0VMUABVRFAARkFJTF9TQ0VMX1RPX1NEUABTb3VyY2UgJXMgaGFzIG5vIGNvbm5lY3Rpb24gSUQsIGNhbm5vdCBtYXAgdG8gU0RQAFRDUABJTkZPAElOAENOAE5BTgBHU00AU0lNAEZBSUxfU0RQX1RPX1NDRUwARkFUQUwAT0sAREVCVUcARkFJTF9DT05TVFJVQ1RfT1VUUFVUX1NUUklORwBGQUlMX0NPTlNUUlVDVF9JTlBVVF9TVFJJTkcAV0FSTklORwBKUEVHAFVEUC9UTFMvUlRQL1NBVlBGAFJUUC9BVlBGAFJUQ1AvQVZQRgBJTkYATEVBVkUARklEAFJFQ0VJVkVEAEgyNjQtU1ZDAExQQwBMbWlTdHJpbmdDb252WG1sMkMAQ2VsQgBDREFUQQBNUEEAUENNQQB3aGF0IGRvIHlhIHdhbnQgZm9yIG5vdGhpbmc/ADxjYXBhYmlsaXRpZXMgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVNjZWwueHNkIj48Y29ubmVjdGlvbnMgaWQ9IjAiIHR5cGU9ImF1ZGlvIiBwcm9maWxlPSJBVlBGIj48Y29tcG9uZW50IHR5cGU9IlJUUCI+PC9jb21wb25lbnQ+PGNvbXBvbmVudCB0eXBlPSJSVENQL0FWUEYiPjwvY29tcG9uZW50Pjx1c2VybmFtZT5EcjkwPC91c2VybmFtZT48cGFzc3dvcmQ+ZW9Kb21qbjFVRmVHWlFjWmJPVWdqK2lPPC9wYXNzd29yZD48cmVjZWl2ZU1lZGlhIGlkPSIxMTEiIG5hbWU9Im9wdXMiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjQ4MDAwPC9jbG9ja1JhdGU+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+bWlucHRpbWU8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjEwPC92YWx1ZT48L3Byb3BlcnRpZXM+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+dXNlaW5iYW5kZmVjPC9uYW1lPjx2YWx1ZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj4xPC92YWx1ZT48L3Byb3BlcnRpZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+dHJhbnNwb3J0LWNjPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48Y2hhbm5lbHM+MjwvY2hhbm5lbHM+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTAzIiBuYW1lPSJJU0FDIiB0eXBlPSJhdWRpbyI+PGNsb2NrUmF0ZT4xNjAwMDwvY2xvY2tSYXRlPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEwNCIgbmFtZT0iSVNBQyIgdHlwZT0iYXVkaW8iPjxjbG9ja1JhdGU+MzIwMDA8L2Nsb2NrUmF0ZT48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSI5IiBuYW1lPSJHNzIyIiB0eXBlPSJhdWRpbyI+PGNsb2NrUmF0ZT44MDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMCIgbmFtZT0iUENNVSIgdHlwZT0iYXVkaW8iPjxjbG9ja1JhdGU+ODAwMDwvY2xvY2tSYXRlPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjgiIG5hbWU9IlBDTUEiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjgwMDA8L2Nsb2NrUmF0ZT48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSIxMDYiIG5hbWU9IkNOIiB0eXBlPSJhdWRpbyI+PGNsb2NrUmF0ZT4zMjAwMDwvY2xvY2tSYXRlPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEwNSIgbmFtZT0iQ04iIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjE2MDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTMiIG5hbWU9IkNOIiB0eXBlPSJhdWRpbyI+PGNsb2NrUmF0ZT44MDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTEwIiBuYW1lPSJ0ZWxlcGhvbmUtZXZlbnQiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjQ4MDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTEyIiBuYW1lPSJ0ZWxlcGhvbmUtZXZlbnQiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjMyMDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTEzIiBuYW1lPSJ0ZWxlcGhvbmUtZXZlbnQiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjE2MDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTI2IiBuYW1lPSJ0ZWxlcGhvbmUtZXZlbnQiIHR5cGU9ImF1ZGlvIj48Y2xvY2tSYXRlPjgwMDA8L2Nsb2NrUmF0ZT48L3JlY2VpdmVNZWRpYT48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPnVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNzcmMtYXVkaW8tbGV2ZWw8L3VyaT48aWQ+MTwvaWQ+PC9leHRIZWFkZXJzPjxleHRIZWFkZXJzIGRpcmVjdGlvbj0ic2VuZHJlY3YiPjx1cmk+dXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c2RlczptaWQ8L3VyaT48aWQ+OTwvaWQ+PC9leHRIZWFkZXJzPjxleHRIZWFkZXJzIGRpcmVjdGlvbj0ic2VuZHJlY3YiPjx1cmk+dXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c2RlczpydHAtc3RyZWFtLWlkPC91cmk+PGlkPjEzPC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT51cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOnJlcGFpcmVkLXJ0cC1zdHJlYW0taWQ8L3VyaT48aWQ+MTQ8L2lkPjwvZXh0SGVhZGVycz48cnRjcE11eD50cnVlPC9ydGNwTXV4PjxzZXR1cD5hY3RwYXNzPC9zZXR1cD48ZmluZ2VycHJpbnQ+PGhhc2hGdW5jPnNoYS0yNTY8L2hhc2hGdW5jPjxmaW5nZXJwcmludD44NDo2RjozODoyMzozOTo2MDpCRTpCNjpGQzpDQTpBMDpCODo4QjozRDo3Nzo4NDo4OToxMzo3NjoxRTo0MjpDMjpCRTpDNjpGMTpFMTpDOToyMDpCMjo4MTo0Rjo0QjwvZmluZ2VycHJpbnQ+PC9maW5nZXJwcmludD48L2Nvbm5lY3Rpb25zPjxjb25uZWN0aW9ucyBpZD0iMSIgdHlwZT0idmlkZW8iIHByb2ZpbGU9IkFWUEYiPjxjb21wb25lbnQgdHlwZT0iUlRQIj48L2NvbXBvbmVudD48Y29tcG9uZW50IHR5cGU9IlJUQ1AvQVZQRiI+PC9jb21wb25lbnQ+PHVzZXJuYW1lPkRyOTA8L3VzZXJuYW1lPjxwYXNzd29yZD5lb0pvbWpuMVVGZUdaUWNaYk9VZ2oraU88L3Bhc3N3b3JkPjxyZWNlaXZlTWVkaWEgaWQ9Ijk2IiBuYW1lPSJWUDgiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Z29vZy1yZW1iPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT50cmFuc3BvcnQtY2M8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPmNjbSBmaXI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPm5hY2s8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPm5hY2sgcGxpPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSI5NyIgbmFtZT0icnR4IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxhcHQ+OTY8L2FwdD48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSI5OCIgbmFtZT0iVlA5IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxwcm9wZXJ0aWVzPjxuYW1lIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPnByb2ZpbGUtaWQ8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjA8L3ZhbHVlPjwvcHJvcGVydGllcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5nb29nLXJlbWI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPnRyYW5zcG9ydC1jYzwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Y2NtIGZpcjwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjazwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjayBwbGk8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9Ijk5IiBuYW1lPSJydHgiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PGFwdD45ODwvYXB0PjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEwMCIgbmFtZT0iVlA5IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxwcm9wZXJ0aWVzPjxuYW1lIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPnByb2ZpbGUtaWQ8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjI8L3ZhbHVlPjwvcHJvcGVydGllcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5nb29nLXJlbWI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPnRyYW5zcG9ydC1jYzwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Y2NtIGZpcjwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjazwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjayBwbGk8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEwMSIgbmFtZT0icnR4IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxhcHQ+OTg8L2FwdD48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSIxMDIiIG5hbWU9IkgyNjQiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+bGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjE8L3ZhbHVlPjwvcHJvcGVydGllcz48cHJvcGVydGllcz48bmFtZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj5wYWNrZXRpemF0aW9uLW1vZGU8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjE8L3ZhbHVlPjwvcHJvcGVydGllcz48cHJvcGVydGllcz48bmFtZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj5wcm9maWxlLWxldmVsLWlkPC9uYW1lPjx2YWx1ZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj40MjAwMWY8L3ZhbHVlPjwvcHJvcGVydGllcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5nb29nLXJlbWI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPnRyYW5zcG9ydC1jYzwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Y2NtIGZpcjwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjazwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjayBwbGk8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEyMiIgbmFtZT0icnR4IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxhcHQ+MTAyPC9hcHQ+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTI3IiBuYW1lPSJIMjY0IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxwcm9wZXJ0aWVzPjxuYW1lIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPmxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPC9uYW1lPjx2YWx1ZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj4xPC92YWx1ZT48L3Byb3BlcnRpZXM+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+cGFja2V0aXphdGlvbi1tb2RlPC9uYW1lPjx2YWx1ZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj4wPC92YWx1ZT48L3Byb3BlcnRpZXM+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+cHJvZmlsZS1sZXZlbC1pZDwvbmFtZT48dmFsdWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+NDIwMDFmPC92YWx1ZT48L3Byb3BlcnRpZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Z29vZy1yZW1iPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT50cmFuc3BvcnQtY2M8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPmNjbSBmaXI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPm5hY2s8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPm5hY2sgcGxpPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSIxMjEiIG5hbWU9InJ0eCIgdHlwZT0idmlkZW8iPjxjbG9ja1JhdGU+OTAwMDA8L2Nsb2NrUmF0ZT48YXB0PjEwMjwvYXB0PjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEyNSIgbmFtZT0iSDI2NCIgdHlwZT0idmlkZW8iPjxjbG9ja1JhdGU+OTAwMDA8L2Nsb2NrUmF0ZT48cHJvcGVydGllcz48bmFtZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj5sZXZlbC1hc3ltbWV0cnktYWxsb3dlZDwvbmFtZT48dmFsdWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+MTwvdmFsdWU+PC9wcm9wZXJ0aWVzPjxwcm9wZXJ0aWVzPjxuYW1lIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPnBhY2tldGl6YXRpb24tbW9kZTwvbmFtZT48dmFsdWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+MTwvdmFsdWU+PC9wcm9wZXJ0aWVzPjxwcm9wZXJ0aWVzPjxuYW1lIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPnByb2ZpbGUtbGV2ZWwtaWQ8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjQyZTAxZjwvdmFsdWU+PC9wcm9wZXJ0aWVzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPmdvb2ctcmVtYjwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+dHJhbnNwb3J0LWNjPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5jY20gZmlyPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5uYWNrPC9uYW1lPjwvZmVlZGJhY2tNZXNzYWdlcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5uYWNrIHBsaTwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTA3IiBuYW1lPSJydHgiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PGFwdD4xMDI8L2FwdD48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSIxMDgiIG5hbWU9IkgyNjQiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PHByb3BlcnRpZXM+PG5hbWUgeG1sbnM9Imh0dHA6Ly93d3cudmlkeW8uY29tL25zL0xtaVByb3RvY29sLnhzZCI+bGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjE8L3ZhbHVlPjwvcHJvcGVydGllcz48cHJvcGVydGllcz48bmFtZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj5wYWNrZXRpemF0aW9uLW1vZGU8L25hbWU+PHZhbHVlIHhtbG5zPSJodHRwOi8vd3d3LnZpZHlvLmNvbS9ucy9MbWlQcm90b2NvbC54c2QiPjA8L3ZhbHVlPjwvcHJvcGVydGllcz48cHJvcGVydGllcz48bmFtZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj5wcm9maWxlLWxldmVsLWlkPC9uYW1lPjx2YWx1ZSB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIj40MmUwMWY8L3ZhbHVlPjwvcHJvcGVydGllcz48ZmVlZGJhY2tNZXNzYWdlcz48bmFtZT5nb29nLXJlbWI8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjxmZWVkYmFja01lc3NhZ2VzPjxuYW1lPnRyYW5zcG9ydC1jYzwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+Y2NtIGZpcjwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjazwvbmFtZT48L2ZlZWRiYWNrTWVzc2FnZXM+PGZlZWRiYWNrTWVzc2FnZXM+PG5hbWU+bmFjayBwbGk8L25hbWU+PC9mZWVkYmFja01lc3NhZ2VzPjwvcmVjZWl2ZU1lZGlhPjxyZWNlaXZlTWVkaWEgaWQ9IjEwOSIgbmFtZT0icnR4IiB0eXBlPSJ2aWRlbyI+PGNsb2NrUmF0ZT45MDAwMDwvY2xvY2tSYXRlPjxhcHQ+MTAyPC9hcHQ+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTI0IiBuYW1lPSJyZWQiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PC9yZWNlaXZlTWVkaWE+PHJlY2VpdmVNZWRpYSBpZD0iMTIwIiBuYW1lPSJydHgiIHR5cGU9InZpZGVvIj48Y2xvY2tSYXRlPjkwMDAwPC9jbG9ja1JhdGU+PGFwdD4xMjQ8L2FwdD48L3JlY2VpdmVNZWRpYT48cmVjZWl2ZU1lZGlhIGlkPSIxMjMiIG5hbWU9InVscGZlYyIgdHlwZT0idmlkZW8iPjxjbG9ja1JhdGU+OTAwMDA8L2Nsb2NrUmF0ZT48L3JlY2VpdmVNZWRpYT48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPnVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXQ8L3VyaT48aWQ+MjwvaWQ+PC9leHRIZWFkZXJzPjxleHRIZWFkZXJzIGRpcmVjdGlvbj0ic2VuZHJlY3YiPjx1cmk+aHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLXNlbmQtdGltZTwvdXJpPjxpZD4zPC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT51cm46M2dwcDp2aWRlby1vcmllbnRhdGlvbjwvdXJpPjxpZD40PC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT5odHRwOi8vd3d3LmlldGYub3JnL2lkL2RyYWZ0LWhvbG1lci1ybWNhdC10cmFuc3BvcnQtd2lkZS1jYy1leHRlbnNpb25zLTAxPC91cmk+PGlkPjU8L2lkPjwvZXh0SGVhZGVycz48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPmh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L3BsYXlvdXQtZGVsYXk8L3VyaT48aWQ+NjwvaWQ+PC9leHRIZWFkZXJzPjxleHRIZWFkZXJzIGRpcmVjdGlvbj0ic2VuZHJlY3YiPjx1cmk+aHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvdmlkZW8tY29udGVudC10eXBlPC91cmk+PGlkPjc8L2lkPjwvZXh0SGVhZGVycz48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPmh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L3ZpZGVvLXRpbWluZzwvdXJpPjxpZD44PC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT5odHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLWF2dGV4dC1mcmFtZW1hcmtpbmctMDc8L3VyaT48aWQ+MTA8L2lkPjwvZXh0SGVhZGVycz48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPmh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2NvbG9yLXNwYWNlPC91cmk+PGlkPjEyPC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT51cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOm1pZDwvdXJpPjxpZD45PC9pZD48L2V4dEhlYWRlcnM+PGV4dEhlYWRlcnMgZGlyZWN0aW9uPSJzZW5kcmVjdiI+PHVyaT51cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOnJ0cC1zdHJlYW0taWQ8L3VyaT48aWQ+MTM8L2lkPjwvZXh0SGVhZGVycz48ZXh0SGVhZGVycyBkaXJlY3Rpb249InNlbmRyZWN2Ij48dXJpPnVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNkZXM6cmVwYWlyZWQtcnRwLXN0cmVhbS1pZDwvdXJpPjxpZD4xNDwvaWQ+PC9leHRIZWFkZXJzPjxydGNwTXV4PnRydWU8L3J0Y3BNdXg+PHNldHVwPmFjdHBhc3M8L3NldHVwPjxmaW5nZXJwcmludD48aGFzaEZ1bmM+c2hhLTI1NjwvaGFzaEZ1bmM+PGZpbmdlcnByaW50Pjg0OjZGOjM4OjIzOjM5OjYwOkJFOkI2OkZDOkNBOkEwOkI4OjhCOjNEOjc3Ojg0Ojg5OjEzOjc2OjFFOjQyOkMyOkJFOkM2OkYxOkUxOkM5OjIwOkIyOjgxOjRGOjRCPC9maW5nZXJwcmludD48L2ZpbmdlcnByaW50PjwvY29ubmVjdGlvbnM+PHNvdXJjZXMgaWQ9IjQyMzEyMTA3NzkiIGlkU3RyPSIwM2VhMWEyMi04MzkzLTQ5ZjgtODY5Mi1kZTc0MjUxZGY3ZTYiIHR5cGU9ImF1ZGlvIj48c3NyY01hcCB4bWxucz0iaHR0cDovL3d3dy52aWR5by5jb20vbnMvTG1pUHJvdG9jb2wueHNkIiBjb25uSWQ9IjAiIHJpZD0iZGVmYXVsdCI+PHNzcmM+NDIzMTIxMDc3OTwvc3NyYz48c3NyYz4wPC9zc3JjPjwvc3NyY01hcD48L3NvdXJjZXM+PGJhbmR3aWR0aD4wPC9iYW5kd2lkdGg+PGljZVJlc3RhcnRTdXBwb3J0ZWQ+dHJ1ZTwvaWNlUmVzdGFydFN1cHBvcnRlZD48L2NhcGFiaWxpdGllcz4AUHJvY2Vzc2luZyBFPCVzPgA8LyVzPgA8JXMuJWxkPgA8QU5ZLiVsZD4APEFMTC4lbGQ+ADxTRVFVRU5DRS4lbGQ+ADxDSE9JQ0UuJWxkPgB6PQB1PQAvcHJvZmlsZT0ldS9jb25zdHJhaW50cz0AcD0Abz0AbT0Aaz0AaT0AL3Byb2ZpbGU9AGM9AGI9AGE9ACA9ADwAJnF1b3Q7ACZsdDsAJmFwb3M7ACZhbXA7AHhtbG5zOgA6OgBwcmVWUDkAQ29kZWMsVmlkZW8sVlA5AFs6Ol06OQBHNzI5AEc3MjgASVB2NgBJUDYATDE2AElQdjQAcmVsZWFzZS9CUkFOQ0hfMl80AElQNABEVkk0AExtaVhzZFNpbXBsZVR5cGVfTG1pRmxvYXQ2NABIMjY0AEgyNjMARzcyMwAhc2V0MgBvdGhlcjIARzcyMgBGQUlMX1NDRUxfVE9fU0RQIDIAIXNldDEASDI2MQAxMjcuMC4wLjEARkFJTF9TQ0VMX1RPX1NEUCAxACFzZXQwACAwADwvAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8AIC8AQXR0cmlidXRlIFslcz0lc10gbm90IGZvdW5kLiBQcm9jZWVkaW5nIHNpbmNlIHRoZSBwYXJzaW5nIGlzIG5vdCBzdHJpY3QuAFRoZSBtYW5hZ2VyIG9mIHRyYW5zcG9ydCBwbHVnLWlucy4ARmFpbGVkIHRvIGNvbnN0cnVjdCBzZXNzaW9uIGNhcGFiaWxpdGllcy4ARmFpbGVkIHRvIGNvbnN0cnVjdCBTY2VsIGNhcGFiaWxpdGllcy4ARmFpbGVkIHRvIGVuY29kZSBTY2VsIGNhcGFiaWxpdGllcy4ARXJyb3IgcHJvY2Vzc2luZyAlcy4AU3RhcnQ8JXM+OlBhcnNlciBhbHJlYWR5IGluIGVycm9yLgBBdHRyPCVzPjpQYXJzZXIgaXMgaW4gZXJyb3IuAEVuZE9mU3RhcnRFbGVtSGRscjwlcz46UGFyc2VyIGlzIGluIGVycm9yLgBFbmQ8JXM+OlBhcnNlciBpcyBpbiBlcnJvci4AQ2hhckRhdGE8JXM+OlBhcnNlciBpcyBpbiBlcnJvci4AVGhpcyBpcyBhIHRlc3QgdXNpbmcgYSBsYXJnZXIgdGhhbiBibG9jay1zaXplIGtleSBhbmQgYSBsYXJnZXIgdGhhbiBibG9jay1zaXplIGRhdGEuIFRoZSBrZXkgbmVlZHMgdG8gYmUgaGFzaGVkIGJlZm9yZSBiZWluZyB1c2VkIGJ5IHRoZSBITUFDIGFsZ29yaXRobS4AQ2hvaWNlIENvdW50IG1pc21hdGNoLgBBbGwgbWlzbWF0Y2guAEVycm9yIGluIGRhdGEgY29udmVyc2lvbiB0byBzdHJpbmcuAEZhaWxlZCB0byBjb25zdHJ1Y3QgU0RQIG1lc3NhZ2UuAEF0dHJpYnV0ZSBbJXM9JXNdIG5vdCBmb3VuZC4AVHJhbnNwb3J0ICVzIGFscmVhZHkgcmVnaXN0ZXJlZC4ARW5kPCVzPjogU3RyaW5nQ29uc3RydWN0Q29weSBmYWlsZWQuAEhvc3RHZXROYW1lQW5kUG9ydCBmYWlsZWQgLSBjb25zdHJ1Y3QgaG9zdCBuYW1lIHN0cmluZyBmYWlsZWQuAFJlc2V0dGluZyB0aGUgcGFyc2VyIG9uIGF0dHIgJXMuLi4AUmVzZXR0aW5nIHRoZSBwYXJzZXIgb24gZW5kb2ZTdGFydEVsZW0gJXMuLi4AUmVzZXR0aW5nIHRoZSBwYXJzZXIgb24gZW5kICVzLi4uAFJlc2V0dGluZyB0aGUgcGFyc2VyIG9uIGNoYXJEYXRhICVzLi4uAFJlY292ZXJpbmcgZnJvbSBwYXJzaW5nIGZhaWx1cmUuLi4AZ2V0cmxpbWl0KFJMSU1JVF9OT0ZJTEUpIGZhaWxlZDogJXMgKGVycm5vPSVkKS4ALQA1LAA0LAAzLAAyLAAxLAAwLAAgCSwAcisAcmIrAGFiKwBhKwCjthZ0cxAO4G4MeWwpVVUrACoAKHN0YW5kYXJkIG91dCkATWlzc2luZyBlbmQtdGFnKHMpAChzdGFuZGFyZCBlcnJvcikAKHN0YW5kYXJkIGluKQAobnVsbCkAc2V0cmxpbWl0KFJMSU1JVF9OT0ZJTEUsIHtjdXI9JWxsdSwgbWF4PSVsbHV9IGZhaWxlZDogJXMgKGVycm5vPSVkKQBMbWlIb3N0Q29uc3RydWN0IGZhaWxlZC4gKCVzKSBuYW1lOiAlcyBmYW1pbHk6ICVzICglZCkAICgAIyMjQ05BTUUjIyMAIyMjTVNJRCMjIwAgeG1sbnM9IiVzIgAgeG1sbnM6JXM9IiVzIgBCYWQgcHJpb3JpdHkgIiVzIgBFcnJvciBwYXJzaW5nIFNDRUwgdHJhbnNwb3J0IGFkZHJlc3M6IHVua25vd24gdHJhbnNwb3J0ICIlcyIAQmFkIHJwb3J0ICIlcyIAQmFkIHBvcnQgIiVzIgBCYWQgY2hhbm5lbCBjb3VudCAiJXMiAFVuYWJsZSB0byBwYXJzZSBmaW5nZXJwcmludCAiJXMiAEVycm9yIHBhcnNpbmcgU0NFTCB0cmFuc3BvcnQgYWRkcmVzczogaW52YWxpZCByZWxhdGVkIGFkZHJlc3MgIiVzIgBCYWQgcmFkZHIgSVAgQWRkcmVzcyAiJXMiAEJhZCBJUCBBZGRyZXNzICIlcyIAQmFkIGNvbXBvbmVudCBudW1iZXIgIiVzIgBVbmFibGUgdG8gcGFyc2UgZm10cCAiJXMiAFVuYWJsZSB0byBwYXJzZSBleHRtYXAgIiVzIgBVbmFibGUgdG8gcGFyc2UgcnRwbWFwICIlcyIAQmFkIGV4dG1hcCBkaXJlY3Rpb24gIiVzIgBCYWQgc2V0dXAgdmFsdWUgIiVzIgBCYWQgc3NyYyBhdHRyaWJ1dGUgdmFsdWUgIiVzIgBCYWQgY2xvY2sgcmF0ZSAiJXMiAFN1cnByaXNpbmcgY29tcG9uZW50IG51bWJlciAlenUgaW4gY2FuZGlkYXRlICIlcyIAVW5hYmxlIHRvIHBhcnNlIElDRSBjYW5kaWRhdGUgIiVzIgBVbmtub3duIFNDRUwgY29tcG9uZW50IHR5cGUgIiVzIgBFcnJvciBwYXJzaW5nIFNDRUwgdHJhbnNwb3J0IGFkZHJlc3M6IHVua25vd24gdHJhbnNwb3J0IGFkZHJlc3MgdHlwZSAiJXMiAFVua25vd24gdHJhbnNwb3J0IGFkZHJlc3MgdHlwZSAiJXMiAEJhZCBwYXlsb2FkIHR5cGUgIiVzIgBCYWQgUlRQIHBheWxvYWQgdHlwZSAiJXMiAFVua25vd24gdHJhbnNwb3J0IGFkZHJlc3MgY29ubmVjdGlvbiBtb2RlICIlcyIAVW5hYmxlIHRvIHBhcnNlIHJ0Y3AtZmIgIiVzIgBCYWQgZXh0bWFwIElEICIlcyIAIHByaW9yaXR5PSIAIG1heD0iACB0cmFuc3BvcnQ9IgAgJXM9IgAgaWRTdHI9IgAgZGVmYXVsdEFkZHI9IgAgZHluPSIAIGRpcmVjdGlvbj0iACBmb3VuZGF0aW9uPSIAIG1pbj0iACBvcHRpb25hbD0iACBzaWduYWw9IgAgdHlwZT0iACBuYW1lPSIAIHByb2ZpbGU9IgAgbW9kZT0iACBjb25uZWN0aW9uTW9kZT0iACByaWQ9IgAgaWQ9IgAgcmVsYXRlZD0iACB1bnBhcnNlZD0iACBlbmFibGVkPSIAIHNlY29uZGFyeUlkPSIAIGNvbm5JZD0iACAlbGx1ICVsbHUgACV1IABFeHBlY3RpbmcgRW5kLVRhZyAATm8gRW5kLVRhZyBleHBlY3RlZCwgYnV0IGZvdW5kIEVuZC1UYWcgAFVua25vd24gZW50aXR5IHJlZmVyZW5jZSAAWE1MOiAAXyQgAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkAqkrl4VJy0A6VcFY3zoo7Ve1AIRIADAwMDAwMDAwMDAwMDAwMDAwMDAwACwsLCwsLCwsLCwsLCwsLCwsLCwsAJXN8JS04c3wlLTE1LjE1c3wlLTE1LjE1c3wlcwoACSVzCgB2PTAKbz0tIDYzOTczNDk5ODY0ODk1OTYwNTMgMiBJTiBJUDQgMTI3LjAuMC4xCnM9LQp0PTAgMAphPWdyb3VwOkJVTkRMRSAwIDEKYT1tc2lkLXNlbWFudGljOiBXTVMgZGYyZmZmOGQtYjIzNi00MTllLTk4ZTctMTQ4YmQ1ZjgxNWRmCm09YXVkaW8gOSBVRFAvVExTL1JUUC9TQVZQRiAxMTEgMTAzIDEwNCA5IDAgOCAxMDYgMTA1IDEzIDExMCAxMTIgMTEzIDEyNgpjPUlOIElQNCAwLjAuMC4wCmE9cnRjcDo5IElOIElQNCAwLjAuMC4wCmE9aWNlLXVmcmFnOkRyOTAKYT1pY2UtcHdkOmVvSm9tam4xVUZlR1pRY1piT1VnaitpTwphPWljZS1vcHRpb25zOnRyaWNrbGUKYT1maW5nZXJwcmludDpzaGEtMjU2IDg0OjZGOjM4OjIzOjM5OjYwOkJFOkI2OkZDOkNBOkEwOkI4OjhCOjNEOjc3Ojg0Ojg5OjEzOjc2OjFFOjQyOkMyOkJFOkM2OkYxOkUxOkM5OjIwOkIyOjgxOjRGOjRCCmE9c2V0dXA6YWN0cGFzcwphPW1pZDowCmE9ZXh0bWFwOjEgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c3NyYy1hdWRpby1sZXZlbAphPWV4dG1hcDo5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNkZXM6bWlkCmE9ZXh0bWFwOjEzIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNkZXM6cnRwLXN0cmVhbS1pZAphPWV4dG1hcDoxNCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOnJlcGFpcmVkLXJ0cC1zdHJlYW0taWQKYT1zZW5kcmVjdgphPW1zaWQ6ZGYyZmZmOGQtYjIzNi00MTllLTk4ZTctMTQ4YmQ1ZjgxNWRmIDAzZWExYTIyLTgzOTMtNDlmOC04NjkyLWRlNzQyNTFkZjdlNgphPXJ0Y3AtbXV4CmE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzIKYT1ydGNwLWZiOjExMSB0cmFuc3BvcnQtY2MKYT1mbXRwOjExMSBtaW5wdGltZT0xMDt1c2VpbmJhbmRmZWM9MQphPXJ0cG1hcDoxMDMgSVNBQy8xNjAwMAphPXJ0cG1hcDoxMDQgSVNBQy8zMjAwMAphPXJ0cG1hcDo5IEc3MjIvODAwMAphPXJ0cG1hcDowIFBDTVUvODAwMAphPXJ0cG1hcDo4IFBDTUEvODAwMAphPXJ0cG1hcDoxMDYgQ04vMzIwMDAKYT1ydHBtYXA6MTA1IENOLzE2MDAwCmE9cnRwbWFwOjEzIENOLzgwMDAKYT1ydHBtYXA6MTEwIHRlbGVwaG9uZS1ldmVudC80ODAwMAphPXJ0cG1hcDoxMTIgdGVsZXBob25lLWV2ZW50LzMyMDAwCmE9cnRwbWFwOjExMyB0ZWxlcGhvbmUtZXZlbnQvMTYwMDAKYT1ydHBtYXA6MTI2IHRlbGVwaG9uZS1ldmVudC84MDAwCmE9c3NyYzo0MjMxMjEwNzc5IGNuYW1lOmNzQ3BPeGI3N3liR1piUFkKYT1zc3JjOjQyMzEyMTA3NzkgbXNpZDpkZjJmZmY4ZC1iMjM2LTQxOWUtOThlNy0xNDhiZDVmODE1ZGYgMDNlYTFhMjItODM5My00OWY4LTg2OTItZGU3NDI1MWRmN2U2CmE9c3NyYzo0MjMxMjEwNzc5IG1zbGFiZWw6ZGYyZmZmOGQtYjIzNi00MTllLTk4ZTctMTQ4YmQ1ZjgxNWRmCmE9c3NyYzo0MjMxMjEwNzc5IGxhYmVsOjAzZWExYTIyLTgzOTMtNDlmOC04NjkyLWRlNzQyNTFkZjdlNgptPXZpZGVvIDkgVURQL1RMUy9SVFAvU0FWUEYgOTYgOTcgOTggOTkgMTAwIDEwMSAxMDIgMTIyIDEyNyAxMjEgMTI1IDEwNyAxMDggMTA5IDEyNCAxMjAgMTIzCmM9SU4gSVA0IDAuMC4wLjAKYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjAKYT1pY2UtdWZyYWc6RHI5MAphPWljZS1wd2Q6ZW9Kb21qbjFVRmVHWlFjWmJPVWdqK2lPCmE9aWNlLW9wdGlvbnM6dHJpY2tsZQphPWZpbmdlcnByaW50OnNoYS0yNTYgODQ6NkY6Mzg6MjM6Mzk6NjA6QkU6QjY6RkM6Q0E6QTA6Qjg6OEI6M0Q6Nzc6ODQ6ODk6MTM6NzY6MUU6NDI6QzI6QkU6QzY6RjE6RTE6Qzk6MjA6QjI6ODE6NEY6NEIKYT1zZXR1cDphY3RwYXNzCmE9bWlkOjEKYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0CmE9ZXh0bWFwOjMgaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLXNlbmQtdGltZQphPWV4dG1hcDo0IHVybjozZ3BwOnZpZGVvLW9yaWVudGF0aW9uCmE9ZXh0bWFwOjUgaHR0cDovL3d3dy5pZXRmLm9yZy9pZC9kcmFmdC1ob2xtZXItcm1jYXQtdHJhbnNwb3J0LXdpZGUtY2MtZXh0ZW5zaW9ucy0wMQphPWV4dG1hcDo2IGh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L3BsYXlvdXQtZGVsYXkKYT1leHRtYXA6NyBodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC92aWRlby1jb250ZW50LXR5cGUKYT1leHRtYXA6OCBodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC92aWRlby10aW1pbmcKYT1leHRtYXA6MTAgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1hdnRleHQtZnJhbWVtYXJraW5nLTA3CmE9ZXh0bWFwOjEyIGh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2NvbG9yLXNwYWNlCmE9ZXh0bWFwOjkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c2RlczptaWQKYT1leHRtYXA6MTMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c2RlczpydHAtc3RyZWFtLWlkCmE9ZXh0bWFwOjE0IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNkZXM6cmVwYWlyZWQtcnRwLXN0cmVhbS1pZAphPXJlY3Zvbmx5CmE9cnRjcC1tdXgKYT1ydGNwLXJzaXplCmE9cnRwbWFwOjk2IFZQOC85MDAwMAphPXJ0Y3AtZmI6OTYgZ29vZy1yZW1iCmE9cnRjcC1mYjo5NiB0cmFuc3BvcnQtY2MKYT1ydGNwLWZiOjk2IGNjbSBmaXIKYT1ydGNwLWZiOjk2IG5hY2sKYT1ydGNwLWZiOjk2IG5hY2sgcGxpCmE9cnRwbWFwOjk3IHJ0eC85MDAwMAphPWZtdHA6OTcgYXB0PTk2CmE9cnRwbWFwOjk4IFZQOS85MDAwMAphPXJ0Y3AtZmI6OTggZ29vZy1yZW1iCmE9cnRjcC1mYjo5OCB0cmFuc3BvcnQtY2MKYT1ydGNwLWZiOjk4IGNjbSBmaXIKYT1ydGNwLWZiOjk4IG5hY2sKYT1ydGNwLWZiOjk4IG5hY2sgcGxpCmE9Zm10cDo5OCBwcm9maWxlLWlkPTAKYT1ydHBtYXA6OTkgcnR4LzkwMDAwCmE9Zm10cDo5OSBhcHQ9OTgKYT1ydHBtYXA6MTAwIFZQOS85MDAwMAphPXJ0Y3AtZmI6MTAwIGdvb2ctcmVtYgphPXJ0Y3AtZmI6MTAwIHRyYW5zcG9ydC1jYwphPXJ0Y3AtZmI6MTAwIGNjbSBmaXIKYT1ydGNwLWZiOjEwMCBuYWNrCmE9cnRjcC1mYjoxMDAgbmFjayBwbGkKYT1mbXRwOjEwMCBwcm9maWxlLWlkPTIKYT1ydHBtYXA6MTAxIHJ0eC85MDAwMAphPWZtdHA6MTAxIGFwdD0xMDAKYT1ydHBtYXA6MTAyIEgyNjQvOTAwMDAKYT1ydGNwLWZiOjEwMiBnb29nLXJlbWIKYT1ydGNwLWZiOjEwMiB0cmFuc3BvcnQtY2MKYT1ydGNwLWZiOjEwMiBjY20gZmlyCmE9cnRjcC1mYjoxMDIgbmFjawphPXJ0Y3AtZmI6MTAyIG5hY2sgcGxpCmE9Zm10cDoxMDIgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyMDAxZgphPXJ0cG1hcDoxMjIgcnR4LzkwMDAwCmE9Zm10cDoxMjIgYXB0PTEwMgphPXJ0cG1hcDoxMjcgSDI2NC85MDAwMAphPXJ0Y3AtZmI6MTI3IGdvb2ctcmVtYgphPXJ0Y3AtZmI6MTI3IHRyYW5zcG9ydC1jYwphPXJ0Y3AtZmI6MTI3IGNjbSBmaXIKYT1ydGNwLWZiOjEyNyBuYWNrCmE9cnRjcC1mYjoxMjcgbmFjayBwbGkKYT1mbXRwOjEyNyBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0wO3Byb2ZpbGUtbGV2ZWwtaWQ9NDIwMDFmCmE9cnRwbWFwOjEyMSBydHgvOTAwMDAKYT1mbXRwOjEyMSBhcHQ9MTI3CmE9cnRwbWFwOjEyNSBIMjY0LzkwMDAwCmE9cnRjcC1mYjoxMjUgZ29vZy1yZW1iCmE9cnRjcC1mYjoxMjUgdHJhbnNwb3J0LWNjCmE9cnRjcC1mYjoxMjUgY2NtIGZpcgphPXJ0Y3AtZmI6MTI1IG5hY2sKYT1ydGNwLWZiOjEyNSBuYWNrIHBsaQphPWZtdHA6MTI1IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MmUwMWYKYT1ydHBtYXA6MTA3IHJ0eC85MDAwMAphPWZtdHA6MTA3IGFwdD0xMjUKYT1ydHBtYXA6MTA4IEgyNjQvOTAwMDAKYT1ydGNwLWZiOjEwOCBnb29nLXJlbWIKYT1ydGNwLWZiOjEwOCB0cmFuc3BvcnQtY2MKYT1ydGNwLWZiOjEwOCBjY20gZmlyCmE9cnRjcC1mYjoxMDggbmFjawphPXJ0Y3AtZmI6MTA4IG5hY2sgcGxpCmE9Zm10cDoxMDggbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MDtwcm9maWxlLWxldmVsLWlkPTQyZTAxZgphPXJ0cG1hcDoxMDkgcnR4LzkwMDAwCmE9Zm10cDoxMDkgYXB0PTEwOAphPXJ0cG1hcDoxMjQgcmVkLzkwMDAwCmE9cnRwbWFwOjEyMCBydHgvOTAwMDAKYT1mbXRwOjEyMCBhcHQ9MTI0CmE9cnRwbWFwOjEyMyB1bHBmZWMvOTAwMDAKAEZhaWxlZCB0byBj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IyMjIyMlJSUlJiUlJSUlJSUlJyUlJSUlJSUAQeCVBwsZKAApKQAAAAAAKgAAACoqAAAALAAAKyoqKgBBh5YHCxwuAAAtAAAAAAAxAAAvAAAALy8AAAAyAAAwLy8vAEGxlgcLCjQAADMAAAAAADYAQcaWBwsjOAAANQA3NwAAAAAAOTsAADk5AAAAAAAAOjk5OQAAAAAAAD0AQfOWBwsBPABBgpcHCyg/PwAAAAA+AAAAAEFAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAABDAEG0lwcLBkJCAAAARQBByJcHCwdEREQAAABHAEHdlwcLA0ZGRgBB8JcHC6YBFBQUFBQUFBQUEBAUFBAUFBQUFBQUFBQUFBQUFBQUFBQQAwsHFBQAChQUFBQUBAkBEREREREREREREQgCDAUNBhQSEhISEhITExMTExMTExMTExMTExMTExMTEw4UDxQTFBISEhISEhMTExMTExMTExMTExMTExMTExMTFBQUFBQAAMDg+AAAAHIUAACMBAAAjQQAAAAAAAABDAAAShsAAI4EAACPBABBoJkHCy54zAEAAAAAAIjMAQAAAAAAqx8AAJAEAACRBAAAAAAAADpVAABKGwAAkgQAAJMEAEHYmQcLLrDMAQAAAAAAwMwBAAAAAACqGQAAlAQAAJUEAAAAAAAAQRoAAEobAACWBAAAlwQAQZCaBwsu6MwBAAAAAAD4zAEAAAAAAAMcAACYBAAAmQQAAJoEAABgHAAAShsAAJsEAACcBABByJoHCx4gzQEAAAAAADDNAQAAAAAAFh8AAEobAACdBAAAngQAQfCaBwuiAiDNAQAAAAAAWM0BAAAAAAD/////////////////////////////////////////////////////////Pv///z80NTY3ODk6Ozw9/////v///wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZ////////GhscHR4fICEiIyQlJicoKSorLC0uLzAxMjP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VxcAAGoXAABSGQAAsh8AAIUKAEGgnQcLFlcXAABNFwAAahcAAFIZAABsFAAAa1UAQcCdBwsFAQAAAAEAQdCdBwuWAgIAAAADAAAABwAAABEAAAAfAAAAPQAAAH8AAAABAQAA/QEAAP0DAAAFCAAA/Q8AAP8fAAD9PwAAA4AAAAEAAQD//wEAAwAEAP//BwD9/w8A9/8fAP3/PwAJAIAA/f//ACMAAAL7//8DHQAACAMAABD9//8fAwAAQP///3/7////AgAAAAMAAAAHAAAAEQAAAB8AAAA9AAAAfwAAAAEBAAD9AQAA/QMAAAUIAAD9DwAA/x8AAP0/AAADgAAAAQABAP//AQADAAQA//8HAP3/DwD3/x8A/f8/AAkAgAD9//8AIwAAAvv//wMdAAAIAwAAEP3//x8DAABA////f/v///+jBAAApAQAAKUEAACmBAAApwQAAKgEAEHwnwcLH6kEAACqBAAAqwQAAKwEAACtBAAArgQAAAjeAQCg3gEAQbSgBwsCtQQAQdugBwsF//////8AQaChBwsDMN8BAEGwoQcLQREACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABAAkLCwAACQYLAAALAAYRAAAAERERAEGBogcLIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBu6IHCwEMAEHHogcLFQwAAAAADAAAAAAJDAAAAAAADAAADABB9aIHCwEOAEGBowcLFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBr6MHCwEQAEG7owcLHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB8qMHCw4SAAAAEhISAAAAAAAACQBBo6QHCwELAEGvpAcLFQoAAAAACgAAAAAJCwAAAAAACwAACwBB3aQHCwEMAEHppAcLzgEMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUbRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAABkSRDsCPyxHFD0zMAobBkZLRTcPSQ6OFwNAHTxpKzYfSi0cASAlKSEIDBUWIi4QOD4LNDEYZHR1di9BCX85ESNDMkKJiosFBCYoJw0qHjWMBxpIkxOUlQBBwKYHC4oOSWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AQdC0BwsdnGAAACwqAAAOAAAAAAAAAA8AAAAQAAAAEQAAABIAQfy0BwstEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAEG4tQcLigEfAAAAIAAAACEAAAAiAAAAIwAAACQAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAALgAAADQAAAA1AAAAAAAAADYAAAD/////////////////////////////////////VOgBAGAAAABhAAAA//////////+8dwAA4HcAAAR4AAAoeAAATHgAQdC2BwsiqHgAAMx4AADweAAAFHkAADh5AABceQAAgHkAAKR5AADgeQBBgLcHCyLEegAAAHsAADx7AAB4ewAAXHwAAJh8AADUfAAAEH0AAEx9AEGwtwcLJjB+AABsfgAAqH4AAOR+AADIfwAA7H8AABCAAAA0gAAAcIAAAKyAAEHgtwcLIpCBAADMgQAACIIAAESCAACAggAAvIIAAPiCAADcgwAAGIQAQZC4BwsmcIQAAKyEAADohAAAJIUAAGCFAACchQAA2IUAALyGAAD4hgAAFIgAQcC4Bwv3ATiIAAB0iAAAsIgAAOyIAAAIigAARIoAAICKAAAAAAAAZIsAAKCLAADciwAAGIwAAFSMAACQjAAAzIwAAAiNAABEjQAAgI0AALyNAAD4jQAA3I4AAACPAAA8jwAAeI8AAFyQAACAkAAAvJAAAKCRAADEkQAAqJIAAMySAAAAAAAAsJMAAOyTAAAolAAAZJQAAGSVAACglQAA3JUAABiWAABUlgAAkJYAAMyWAAAIlwAARJcAAP////8AAAAAAAAAADCyAQBUsgEAeLIBAJyyAQDAsgEApLMBAMizAQCstAEA0LQBAAy1AQBItQEALLYBAGi2AQCktgEAQcC6BwtniLcBAMS3AQAAuAEAPLgBAHi4AQC0uAEA8LgBACy5AQBouQEApLkBAOC5AQAcugEAALsBACS7AQBIuwEAhLsBAGi8AQCMvAEAsLwBANS8AQD4vAEAHL0BAEC9AQBkvQEAoL0BANy9AQBBsLsHC1nAvgEA/L4BADi/AQB0vwEA/////////////////////////////////////zkEAAA6BAAAOwQAADwEAAD/////nwQAAPBxAACgBAAAoQQAAKIEAAAeVQAABQBBlLwHCwKvBABBrLwHCw6wBAAAsQQAABjrAQAABABBxLwHCwEBAEHTvAcLBQr/////AEGYvQcLCQjeAQAAAAAACQBBrL0HCwKyBABBwL0HCxKzBAAAAAAAALQEAAAo7wEAAAQAQey9BwsE/////wBBsL4HCwEFAEG8vgcLArIEAEHUvgcLC7AEAAC0BAAAMPMBAEHsvgcLAQIAQfu+BwsF//////8AQezABwsDWPMBAEGkwQcLA4D1UQCRhwIEbmFtZQG/3AH/BgAQX19zdGFja19jaGtfZmFpbAENY2xvY2tfZ2V0dGltZQIIZ210aW1lX3IDC2xvY2FsdGltZV9yBAxnZXR0aW1lb2ZkYXkFC2dldGFkZHJpbmZvBgxnYWlfc3RyZXJyb3IHDF9fc3lzY2FsbDIyMQgPX193YXNpX2ZkX2Nsb3NlCQpfX3N5c2NhbGw1Cg5fX3dhc2lfZmRfcmVhZAsPX193YXNpX2ZkX3dyaXRlDAtfX3N5c2NhbGw1NA0MX19zeXNjYWxsMzQwDgxfX3N5c2NhbGwxOTEPC19fc3lzY2FsbDc1EBZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwERVlbXNjcmlwdGVuX21lbWNweV9iaWcSC3NldFRlbXBSZXQwExpsZWdhbGltcG9ydCRfX3dhc2lfZmRfc2VlaxQRX193YXNtX2NhbGxfY3RvcnMVCVNjZWxUb1NkcBYJU2RwVG9TY2VsFwVtYWluXxgEbWFpbhkcRmFrZVRjcFRyYW5zcG9ydENyZWF0ZVNvY2tldBodRmFrZVRjcFRyYW5zcG9ydERlc3Ryb3lTb2NrZXQbJ0Zha2VUY3BUcmFuc3BvcnRDb25zdHJ1Y3REZWZhdWx0QWRkcmVzcxwxRmFrZVRjcFRyYW5zcG9ydENvbnN0cnVjdEFkZHJlc3NGcm9tU29ja2V0QWRkcmVzcx0qRmFrZVRjcFRyYW5zcG9ydENvbnN0cnVjdEFkZHJlc3NGcm9tU3RyaW5nHh5GYWtlVGNwVHJhbnNwb3J0R2V0QWRkcmVzc1R5cGUfGkZha2VUY3BUcmFuc3BvcnRJc1JlbGlhYmxlICBGYWtlVGNwVHJhbnNwb3J0SXNDb25uZWN0aW9ubGVzcyEgRmFrZVVkcFRyYW5zcG9ydENyZWF0ZVNvY2tldFBhaXIiKkZha2VVZHBUcmFuc3BvcnRDb25zdHJ1Y3RBZGRyZXNzRnJvbVN0cmluZyMeRmFrZVVkcFRyYW5zcG9ydEdldEFkZHJlc3NUeXBlJA5GaW5kQXR0cmlidXRlcyUPUGF5bG9hZFR5cGVIYXNoJh9MbWlTZHBNZWRpYUNvbnN0cnVjdEZyb21HZW5lcmljJxRMbWlTZHBNZWRpYUFkZFNvdXJjZSgNQWRkQ2FuZGlkYXRlcykXTG1pSDI2NENvbW1vbkluaXRpYWxpemUqGUxtaUgyNjRDb21tb25VbmluaXRpYWxpemUrGkxtaUgyNjRDb21tb25Jbml0QXZjUGx1Z0luLBpMbWlIMjY0Q29tbW9uSW5pdFN2Y1BsdWdJbi0hTG1pSDI2NEF2Y0NvbXBhcmVGb3JDb21wYXRpYmlsaXR5LhxMbWlIMjY0QXZjR2V0TGV2ZWxQYXJhbWV0ZXJzLx1MbWlIMjY0QXZjQXBwbHlMZXZlbFBhcmFtZXRlcjATQXBwbHlMZXZlbFBhcmFtZXRlcjEORHVtcFBhcmFtZXRlcnMyIUxtaUgyNjRTdmNDb21wYXJlRm9yQ29tcGF0aWJpbGl0eTMdTG1pSDI2NFN2Y0FwcGx5TGV2ZWxQYXJhbWV0ZXI0HUxtaVZlY3Rvcl9MbWlDb21wb25lbnRSZXNlcnZlNRlMbWlDb21wb25lbnRDb25zdHJ1Y3RDb3B5NhtMbWlWZWN0b3JfTG1pQ29tcG9uZW50Q2xlYXI3FExtaUNvbXBvbmVudERlc3RydWN0OB5MbWlWZWN0b3JfTG1pQ29ubmVjdGlvblJlc2VydmU5GkxtaUNvbm5lY3Rpb25Db25zdHJ1Y3RDb3B5OhVMbWlDb25uZWN0aW9uRGVzdHJ1Y3Q7FkxtaU1lZGlhVGFibGVfTm9kZUNvcHk8GExtaU1lZGlhVGFibGVfTm9kZURlbGV0ZT0fTG1pVmVjdG9yX0xtaUNvbm5lY3Rpb25EZXN0cnVjdD4ZTG1pTWFzdGVyS2V5Q29uc3RydWN0Q29weT8jTG1pVmVjdG9yX0xtaU1hc3RlcktleUNvbnN0cnVjdENvcHlAMkxtaVZlY3Rvcl9MbWlVbm9yZGVyZWRCdWNrZXRfTG1pVWludF9fTG1pTWVkaWFTd2FwQSdMbWlVbm9yZGVyZWRfTG1pVWludF9fTG1pTWVkaWFDb25zdHJ1Y3RCJkxtaVVub3JkZXJlZF9MbWlVaW50X19MbWlNZWRpYURlc3RydWN0QyFMbWlVbm9yZGVyZWRfTG1pVWludF9fTG1pTWVkaWFFbmREJ0xtaVVub3JkZXJlZF9MbWlVaW50X19MbWlNZWRpYUZpbmRDb25zdEUkTG1pVW5vcmRlcmVkX0xtaVVpbnRfX0xtaU1lZGlhSW5zZXJ0RhtMbWlWZWN0b3JfTG1pUGF5bG9hZFJlc2VydmVHHExtaVZlY3Rvcl9MbWlQYXlsb2FkRGVzdHJ1Y3RIH0xtaVZlY3Rvcl9MbWlGaW5nZXJwcmludFJlc2VydmVJG0xtaUZpbmdlcnByaW50Q29uc3RydWN0Q29weUoWTG1pRmluZ2VycHJpbnREZXN0cnVjdEsgTG1pVmVjdG9yX0xtaUZpbmdlcnByaW50RGVzdHJ1Y3RMFkxtaUNvbm5lY3Rpb25UeXBlVG9TdHJNFUxtaUNvbXBvbmVudENvbnN0cnVjdE4bTG1pRmluZ2VycHJpbnRDb25zdHJ1Y3RDU3RyTxNMbWlGaW5nZXJwcmludFRvU3RyUBZMbWlDb25uZWN0aW9uQ29uc3RydWN0UR9MbWlDb25uZWN0aW9uR2V0Q29tcG9uZW50QnlUeXBlUhlMbWlNZWRpYVRhYmxlX05vZGVCYWxhbmNlUxhMbWlNZWRpYVRhYmxlX05vZGVJbnNlcnRUIkxtaUNvbm5lY3Rpb25HZXRQYXlsb2FkVHlwZUJ5TWVkaWFVJUxtaUNvbm5lY3Rpb25TZXRNZWRpYVdpdGhQYXlsb2FkVHlwZXNWI0xtaVZlY3Rvcl9MbWlFeHRlbnNpb25IZWFkZXJSZXNlcnZlVyRMbWlWZWN0b3JfTG1pRXh0ZW5zaW9uSGVhZGVyRGVzdHJ1Y3RYHkxtaUV4dGVuc2lvbkhlYWRlclNldERpcmVjdGlvblkjTG1pVmVjdG9yX0xtaUZlZWRiYWNrTWVzc2FnZVJlc2VydmVaKUxtaVZlY3Rvcl9MbWlGZWVkYmFja01lc3NhZ2VDb25zdHJ1Y3RDb3B5WyRMbWlWZWN0b3JfTG1pRmVlZGJhY2tNZXNzYWdlRGVzdHJ1Y3RcGUxtaVZlY3Rvcl9MbWlNZWRpYVJlc2VydmVdFUxtaU1lZGlhQ29uc3RydWN0Q29weV4QTG1pTWVkaWFEZXN0cnVjdF8OTG1pTWVkaWFBc3NpZ25gG0xtaU1lZGlhTGVzc0J5Q29tcGF0aWJpbGl0eWEkTG1pTWFwX0xtaVN0cmluZ19fTG1pVWludF9Ob2RlRGVsZXRlYiRMbWlNYXBfTG1pU3RyaW5nX19MbWlVaW50X05vZGVJbnNlcnRjH0xtaU1hcF9MbWlTdHJpbmdfX0xtaVVpbnRJbnNlcnRkGkxtaU1lZGlhU2V0UHJvZmlsZUFuZExldmVsZRdMbWlNZWRpYUFkZFByb3BlcnR5Q1N0cmYjTG1pU2hhcmVkUHRyX0xtaU1lZGlhSW1wbE1ha2VVbmlxdWVnGkxtaU1lZGlhR2V0UHJvZmlsZUFuZExldmVsaBhMbWlNZWRpYUdldFBhY2tldGl6YXRpb25pKExtaVNoYXJlZFB0cl9MbWlNZWRpYUltcGxEZWZhdWx0RGVsZXRlcl9qFExtaU1lZGlhSW1wbERlc3RydWN0axFMbWlNZWRpYUNvbnN0cnVjdGwuTG1pVmVjdG9yX0xtaU1lZGlhRXF1YWxDb21wX0xtaU1lZGlhQ29tcGF0aWJsZW0VTG1pTWVkaWFHZXRQcm9wZXJ0aWVzbhNMbWlNZWRpYUdldFByb3BlcnR5byRMbWlTZXRfTG1pU2VuZE1lZGlhRm9ybWF0X05vZGVEZWxldGVwIkxtaVNldF9MbWlTZW5kTWVkaWFGb3JtYXRfTm9kZUNvcHlxLExtaVZlY3Rvcl9MbWlTZW5kTWVkaWFTaW11bGNhc3RDb25zdHJ1Y3RDb3B5cjVMbWlNYXBfTG1pU3RyaW5nX19MbWlTZW5kTWVkaWFDYXBhYmlsaXRpZXNfTm9kZURlbGV0ZXMzTG1pTWFwX0xtaVN0cmluZ19fTG1pU2VuZE1lZGlhQ2FwYWJpbGl0aWVzX05vZGVDb3B5dDlMbWlNYXBfTG1pU291cmNlVHlwZV9fTG1pU2VuZE1lZGlhQ2FwYWJpbGl0aWVzX05vZGVEZWxldGV1N0xtaU1hcF9MbWlTb3VyY2VUeXBlX19MbWlTZW5kTWVkaWFDYXBhYmlsaXRpZXNfTm9kZUNvcHl2FExtaVNlbmRNZWRpYURlc3RydWN0dyNMbWlNZWRpYVBsdWdJbk1hbmFnZXJSZWdpc3RlclBsdWdJbngnTG1pTWFwX0xtaVN0cmluZ19fTG1pVm9pZFB0cl9Ob2RlSW5zZXJ0eSdMbWlNYXBfTG1pU3RyaW5nX19MbWlWb2lkUHRyX05vZGVEZWxldGV6H0xtaU1lZGlhUGx1Z0luTWFuYWdlckluaXRpYWxpemV7IUxtaU1lZGlhUGx1Z0luTWFuYWdlclVuaW5pdGlhbGl6ZXwfTG1pTWVkaWFDb21wYXJlRm9yQ29tcGF0aWJpbGl0eX0bTG1pTWVkaWFUcmFuc3BvcnRJbml0aWFsaXplfh1MbWlNZWRpYVRyYW5zcG9ydFVuaW5pdGlhbGl6ZX8PTG1pT3NJbml0aWFsaXplgAERTG1pT3NVbmluaXRpYWxpemWBARRMbWlBbmRyb2lkSW5pdGlhbGl6ZYIBFkxtaUFuZHJvaWRVbmluaXRpYWxpemWDARJMbWlBc3luY0luaXRpYWxpemWEARRMbWlBc3luY1VuaW5pdGlhbGl6ZYUBHExtaUNvbnNvbGVMb2dMaXN0ZW5lckhhbmRsZXKGAQ5Xcml0ZVRvQ29uc29sZYcBFFdyaXRlVG9Db25zb2xlU2ltcGxliAEaTG1pRGlyZWN0b3J5RW50cnlDb25zdHJ1Y3SJAQxMbWlGaWxlQ2xvc2WKAQ9MbWlGaWxlRGVzdHJ1Y3SLARFMbWlGaWxlSW5pdGlhbGl6ZYwBE0xtaUZpbGVVbmluaXRpYWxpemWNARBMbWlMb2dJbml0aWFsaXpljgEZTG93TGV2ZWxBbGxvY2F0b3JBbGxvY2F0ZY8BG0xvd0xldmVsQWxsb2NhdG9yRGVhbGxvY2F0ZZABFkxtaUxvZ1JlZ2lzdGVyQ2F0ZWdvcnmRAQ5MbWlMb2dEZXN0cnVjdJIBEkxtaUxvZ1VuaW5pdGlhbGl6ZZMBEkxtaUxvZ1JlY29yZFdyaXRlX5QBG0xtaUxvZ0xpc3RlbmVyVXBkYXRlQ29tcGF0X5UBJ0xtaUxvZ1VwZGF0ZUxldmVsc0FuZENhdGVnb3JpZXNMaXN0ZW5lZJYBHkxtaUxvZ1JlZ2lzdGVyQ2F0ZWdvcnlXaXRoVGFnc5cBCUxtaUxvZ0RvX5gBEkxtaUxvZ0RvRm9ybWF0dGVkX5kBF01hbGxvY0FsbG9jYXRvckFsbG9jYXRlmgEcTG1pTWFsbG9jQWxsb2NhdG9ySW5pdGlhbGl6ZZsBHkxtaU1hbGxvY0FsbG9jYXRvclVuaW5pdGlhbGl6ZZwBE0xtaU1lbW9yeUluaXRpYWxpemWdARVMbWlNZW1vcnlVbmluaXRpYWxpemWeARJMbWlNdXRleEluaXRpYWxpemWfARpMbWlQb29sQWxsb2NhdG9ySW5pdGlhbGl6ZaABHExtaVBvb2xBbGxvY2F0b3JVbmluaXRpYWxpemWhARxMbWlQcm9jZXNzb3JHZXRUaW1lc1BlckNvcmVfogEVTG1pUHJvY2Vzc29yR2V0VGltZXNfowEWTG1pUHJvY2Vzc29ySW5pdGlhbGl6ZaQBGExtaVByb2Nlc3NvclVuaW5pdGlhbGl6ZaUBEkxtaVF1ZXVlSW5pdGlhbGl6ZaYBC0xtaVF1ZXVlUG9wpwERTG1pUmFuZG9tR2V0Qnl0ZXOoAR9MbWlSYW5kb21TaW11bGF0b3JHZW5lcmF0ZUJ5dGVzqQETTG1pUmFuZG9tSW5pdGlhbGl6ZaoBFUxtaVJhbmRvbVVuaW5pdGlhbGl6ZasBK0xtaUxvY2tlZFBzZXVkb1JhbmRvbVNpbXVsYXRvckdlbmVyYXRlQnl0ZXOsARNMbWlUaHJlYWRJbml0aWFsaXplrQEVTG1pVGhyZWFkVW5pbml0aWFsaXplrgERTG1pVGhyZWFkRGVzdHJ1Y3SvAQd3cmFwcGVysAEVdGhyZWFkUG9vbFdyYXBwZXJGdW5jsQElTG1pR3JlZ29yaWFuVGltZUdldEFzU3RyaW5nV2l0aE9mZnNldLIBEUxtaVRpbWVJbml0aWFsaXplswEZTG1pVGltZXJNYW5hZ2VySW5pdGlhbGl6ZbQBI0xtaUZlZWRiYWNrTWVzc2FnZUNvbnN0cnVjdEZyb21TY2VstQEqTG1pU2NlbEZlZWRiYWNrTWVzc2FnZUNvbnN0cnVjdEZyb21HZW5lcmljtgEwTG1pU2hhcmVkUHRyX0xtaVNjZWxBZGRyZXNzUzBJbXBsRGVmYXVsdERlbGV0ZXJftwErTG1pU2hhcmVkUHRyX0xtaVNjZWxBZGRyZXNzUzBJbXBsTWFrZVVuaXF1ZbgBHkxtaVNjZWxDb25uZWN0aW9uTW9kZUNvbnZYbWwyQ7kBIExtaVNjZWxDb25uZWN0aW9uTW9kZVZhbGlkYXRlWG1sugEzTG1pU2hhcmVkUHRyX0xtaVNjZWxBZGRyZXNzQXR0cnNJbXBsRGVmYXVsdERlbGV0ZXJfuwEfTG1pU2NlbEFkZHJlc3NBdHRyc0ltcGxEZXN0cnVjdLwBLkxtaVNoYXJlZFB0cl9MbWlTY2VsQWRkcmVzc0F0dHJzSW1wbE1ha2VVbmlxdWW9AS5MbWlTaGFyZWRQdHJfTG1pU2NlbEFkZHJlc3NJbXBsRGVmYXVsdERlbGV0ZXJfvgEpTG1pU2hhcmVkUHRyX0xtaVNjZWxBZGRyZXNzSW1wbE1ha2VVbmlxdWW/ASBMbWlWZWN0b3JfTG1pU2NlbEFkZHJlc3NEZXN0cnVjdMABHkxtaVZlY3Rvcl9MbWlTY2VsQWRkcmVzc0Fzc2lnbsEBM0xtaVNoYXJlZFB0cl9MbWlTY2VsRW5jcnlwdGlvblMwSW1wbERlZmF1bHREZWxldGVyX8IBLkxtaVNoYXJlZFB0cl9MbWlTY2VsRW5jcnlwdGlvblMwSW1wbE1ha2VVbmlxdWXDATZMbWlTaGFyZWRQdHJfTG1pU2NlbEVuY3J5cHRpb25BdHRyc0ltcGxEZWZhdWx0RGVsZXRlcl/EATFMbWlTaGFyZWRQdHJfTG1pU2NlbEVuY3J5cHRpb25BdHRyc0ltcGxNYWtlVW5pcXVlxQE3TG1pU2hhcmVkUHRyX0xtaVNjZWxBdXRoZW50aWNhdGlvblMwSW1wbERlZmF1bHREZWxldGVyX8YBMkxtaVNoYXJlZFB0cl9MbWlTY2VsQXV0aGVudGljYXRpb25TMEltcGxNYWtlVW5pcXVlxwEyTG1pU2hhcmVkUHRyX0xtaVNjZWxDb21wb25lbnRTMEltcGxEZWZhdWx0RGVsZXRlcl/IAS1MbWlTaGFyZWRQdHJfTG1pU2NlbENvbXBvbmVudFMwSW1wbE1ha2VVbmlxdWXJARxMbWlTY2VsQ29tcG9uZW50UzBTZXRBZGRyZXNzygEfTG1pU2NlbENvbXBvbmVudFMwU2V0RW5jcnlwdGlvbssBI0xtaVNjZWxDb21wb25lbnRTMFNldEF1dGhlbnRpY2F0aW9uzAE1TG1pU2hhcmVkUHRyX0xtaVNjZWxDb21wb25lbnRBdHRyc0ltcGxEZWZhdWx0RGVsZXRlcl/NATBMbWlTaGFyZWRQdHJfTG1pU2NlbENvbXBvbmVudEF0dHJzSW1wbE1ha2VVbmlxdWXOAThMbWlTaGFyZWRQdHJfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZVMwSW1wbERlZmF1bHREZWxldGVyX88BM0xtaVNoYXJlZFB0cl9MbWlTY2VsRmVlZGJhY2tNZXNzYWdlUzBJbXBsTWFrZVVuaXF1ZdABHUxtaVNjZWxGZWVkYmFja01lc3NhZ2VFbmNvZGVf0QEuTG1pU2hhcmVkUHRyX0xtaVNjZWxNZWRpYVMwSW1wbERlZmF1bHREZWxldGVyX9IBGkxtaVNjZWxNZWRpYVMwSW1wbERlc3RydWN00wEpTG1pU2hhcmVkUHRyX0xtaVNjZWxNZWRpYVMwSW1wbE1ha2VVbmlxdWXUASFMbWlTY2VsTWVkaWFTMFNldEZlZWRiYWNrTWVzc2FnZXPVATFMbWlTaGFyZWRQdHJfTG1pU2NlbE1lZGlhQXR0cnNJbXBsRGVmYXVsdERlbGV0ZXJf1gEsTG1pU2hhcmVkUHRyX0xtaVNjZWxNZWRpYUF0dHJzSW1wbE1ha2VVbmlxdWXXAS5MbWlTaGFyZWRQdHJfTG1pU2NlbE1raURhdGFJbXBsRGVmYXVsdERlbGV0ZXJf2AEpTG1pU2hhcmVkUHRyX0xtaVNjZWxNa2lEYXRhSW1wbE1ha2VVbmlxdWXZATJMbWlTaGFyZWRQdHJfTG1pU2NlbE1hc3RlcktleVMwSW1wbERlZmF1bHREZWxldGVyX9oBLUxtaVNoYXJlZFB0cl9MbWlTY2VsTWFzdGVyS2V5UzBJbXBsTWFrZVVuaXF1ZdsBHExtaVNjZWxNYXN0ZXJLZXlTMFNldE1raURhdGHcAS1MbWlTaGFyZWRQdHJfTG1pU2NlbFNydHBTMEltcGxEZWZhdWx0RGVsZXRlcl/dAShMbWlTaGFyZWRQdHJfTG1pU2NlbFNydHBTMEltcGxNYWtlVW5pcXVl3gEUTG1pU2NlbFNydHBTMFNldEtleXPfATtMbWlTaGFyZWRQdHJfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlclMwSW1wbERlZmF1bHREZWxldGVyX+ABNkxtaVNoYXJlZFB0cl9MbWlTY2VsUnRwRXh0ZW5zaW9uSGVhZGVyUzBJbXBsTWFrZVVuaXF1ZeEBGUxtaVNjZWxEaXJlY3Rpb25Db252WG1sMkPiAT5MbWlTaGFyZWRQdHJfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlckF0dHJzSW1wbERlZmF1bHREZWxldGVyX+MBOUxtaVNoYXJlZFB0cl9MbWlTY2VsUnRwRXh0ZW5zaW9uSGVhZGVyQXR0cnNJbXBsTWFrZVVuaXF1ZeQBGUxtaVNjZWxTZXR1cFJvbGVDb252WG1sMkPlATRMbWlTaGFyZWRQdHJfTG1pU2NlbEZpbmdlcnByaW50UzBJbXBsRGVmYXVsdERlbGV0ZXJf5gEvTG1pU2hhcmVkUHRyX0xtaVNjZWxGaW5nZXJwcmludFMwSW1wbE1ha2VVbmlxdWXnATNMbWlTaGFyZWRQdHJfTG1pU2NlbENvbm5lY3Rpb25TMEltcGxEZWZhdWx0RGVsZXRlcl/oAR9MbWlTY2VsQ29ubmVjdGlvblMwSW1wbERlc3RydWN06QEuTG1pU2hhcmVkUHRyX0xtaVNjZWxDb25uZWN0aW9uUzBJbXBsTWFrZVVuaXF1ZeoBH0xtaVNjZWxDb25uZWN0aW9uUzBTZXRDb21wb25lbnTrASJMbWlTY2VsQ29ubmVjdGlvblMwU2V0UmVjZWl2ZU1lZGlh7AEaTG1pU2NlbENvbm5lY3Rpb25TMFNldFNydHDtASZMbWlTY2VsQ29ubmVjdGlvblMwU2V0RmVlZGJhY2tNZXNzYWdlc+4BIExtaVNjZWxDb25uZWN0aW9uUzBTZXRFeHRIZWFkZXJz7wEhTG1pU2NlbENvbm5lY3Rpb25TMFNldEZpbmdlcnByaW508AEXTG1pU2NlbFByb2ZpbGVDb252WG1sMkPxATZMbWlTaGFyZWRQdHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc0ltcGxEZWZhdWx0RGVsZXRlcl/yATFMbWlTaGFyZWRQdHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc0ltcGxNYWtlVW5pcXVl8wE2TG1pU2hhcmVkUHRyX0xtaVNjZWxSZWNlaXZlU291cmNlUzBJbXBsRGVmYXVsdERlbGV0ZXJf9AExTG1pU2hhcmVkUHRyX0xtaVNjZWxSZWNlaXZlU291cmNlUzBJbXBsTWFrZVVuaXF1ZfUBNExtaVNoYXJlZFB0cl9MbWlTY2VsUmVjZWl2ZVNvdXJjZUF0dHJzSW1wbE1ha2VVbmlxdWX2ARdMbWlTY2VsQm9keUF0dHJzRW5jb2RlX/cBM0xtaVNoYXJlZFB0cl9MbWlTY2VsRXh0Q29tbWFuZFMwSW1wbERlZmF1bHREZWxldGVyX/gBLkxtaVNoYXJlZFB0cl9MbWlTY2VsRXh0Q29tbWFuZFMwSW1wbE1ha2VVbmlxdWX5ARhMbWlTY2VsRXh0Q29tbWFuZEVuY29kZV/6AS9MbWlTaGFyZWRQdHJfTG1pU2NlbENhdGVnb3J5SW1wbERlZmF1bHREZWxldGVyX/sBKkxtaVNoYXJlZFB0cl9MbWlTY2VsQ2F0ZWdvcnlJbXBsTWFrZVVuaXF1ZfwBMExtaVNoYXJlZFB0cl9MbWlTY2VsRXh0ZW5zaW9uSW1wbERlZmF1bHREZWxldGVyX/0BK0xtaVNoYXJlZFB0cl9MbWlTY2VsRXh0ZW5zaW9uSW1wbE1ha2VVbmlxdWX+ATVMbWlTaGFyZWRQdHJfTG1pU2NlbENhcGFiaWxpdGllc1MwSW1wbERlZmF1bHREZWxldGVyX/8BIUxtaVNjZWxDYXBhYmlsaXRpZXNTMEltcGxEZXN0cnVjdIACMExtaVNoYXJlZFB0cl9MbWlTY2VsQ2FwYWJpbGl0aWVzUzBJbXBsTWFrZVVuaXF1ZYECI0xtaVNjZWxDYXBhYmlsaXRpZXNTMFNldENvbm5lY3Rpb25zggIiTG1pU2NlbENhcGFiaWxpdGllc1MwU2V0RXh0ZW5zaW9uc4MCKkxtaVhzZFNpbXBsZVR5cGVfTG1pU2NlbFByb2ZpbGVDcmVhdGVWYWx1ZYQCK0xtaVhzZFNpbXBsZVR5cGVfTG1pU2NlbFByb2ZpbGVEZXN0cm95VmFsdWWFAitMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQWRkcmVzc0NyZWF0ZVZhbHVlhgIsTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEFkZHJlc3NEZXN0cm95VmFsdWWHAitMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQWRkcmVzc1VwZGF0ZVZhbHVliAIuTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEVuY3J5cHRpb25DcmVhdGVWYWx1ZYkCLkxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxFbmNyeXB0aW9uVXBkYXRlVmFsdWWKAjJMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQXV0aGVudGljYXRpb25DcmVhdGVWYWx1ZYsCMkxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxBdXRoZW50aWNhdGlvblVwZGF0ZVZhbHVljAItTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbENvbXBvbmVudENyZWF0ZVZhbHVljQItTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbENvbXBvbmVudFVwZGF0ZVZhbHVljgIzTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZUNyZWF0ZVZhbHVljwIzTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZVVwZGF0ZVZhbHVlkAIpTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbE1lZGlhQ3JlYXRlVmFsdWWRAilMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsTWVkaWFVcGRhdGVWYWx1ZZICKkxtaVhzZENvbXBvc2l0b3JfTG1pU2NlbE1raURhdGFDcmVhdGVWYWx1ZZMCKkxtaVhzZENvbXBvc2l0b3JfTG1pU2NlbE1raURhdGFVcGRhdGVWYWx1ZZQCLUxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxNYXN0ZXJLZXlDcmVhdGVWYWx1ZZUCLUxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxNYXN0ZXJLZXlVcGRhdGVWYWx1ZZYCKExtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxTcnRwQ3JlYXRlVmFsdWWXAihMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsU3J0cFVwZGF0ZVZhbHVlmAI2TG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlckNyZWF0ZVZhbHVlmQI2TG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlclVwZGF0ZVZhbHVlmgIvTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEZpbmdlcnByaW50Q3JlYXRlVmFsdWWbAi9MbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsRmluZ2VycHJpbnRVcGRhdGVWYWx1ZZwCLkxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxDb25uZWN0aW9uQ3JlYXRlVmFsdWWdAi5MbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQ29ubmVjdGlvblVwZGF0ZVZhbHVlngIxTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbFJlY2VpdmVTb3VyY2VDcmVhdGVWYWx1ZZ8CMUxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxSZWNlaXZlU291cmNlVXBkYXRlVmFsdWWgAihMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQm9keUNyZWF0ZVZhbHVloQIoTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEJvZHlVcGRhdGVWYWx1ZaICLkxtaVhzZENvbXBsZXhUeXBlX0xtaVNjZWxFeHRDb21tYW5kQ3JlYXRlVmFsdWWjAi5MbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsRXh0Q29tbWFuZFVwZGF0ZVZhbHVlpAItTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEFsZ29yaXRobUNyZWF0ZVZhbHVlpQItTG1pWHNkQ29tcGxleFR5cGVfTG1pU2NlbEFsZ29yaXRobVVwZGF0ZVZhbHVlpgIrTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsQ2F0ZWdvcnlDcmVhdGVWYWx1ZacCK0xtaVhzZENvbXBvc2l0b3JfTG1pU2NlbENhdGVnb3J5VXBkYXRlVmFsdWWoAi1MbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsRXh0ZW5zaW9uQ3JlYXRlVmFsdWWpAi1MbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsRXh0ZW5zaW9uVXBkYXRlVmFsdWWqAjBMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQ2FwYWJpbGl0aWVzQ3JlYXRlVmFsdWWrAjBMbWlYc2RDb21wbGV4VHlwZV9MbWlTY2VsQ2FwYWJpbGl0aWVzVXBkYXRlVmFsdWWsAixMbWlYc2RFbGVtZW50X0xtaVNjZWxDYXBhYmlsaXRpZXNVcGRhdGVWYWx1Za0CLkxtaVhzZEF0dHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc0lkQ3JlYXRlVmFsdWWuAi5MbWlYc2RBdHRyX0xtaVNjZWxDb25uZWN0aW9uQXR0cnNJZFVwZGF0ZVZhbHVlrwIwTG1pWHNkQXR0cl9MbWlTY2VsQ29ubmVjdGlvbkF0dHJzVHlwZUNyZWF0ZVZhbHVlsAIxTG1pWHNkQXR0cl9MbWlTY2VsQ29ubmVjdGlvbkF0dHJzVHlwZURlc3Ryb3lWYWx1ZbECMExtaVhzZEF0dHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc1R5cGVVcGRhdGVWYWx1ZbICNExtaVhzZEF0dHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc09wdGlvbmFsQ3JlYXRlVmFsdWWzAjVMbWlYc2RBdHRyX0xtaVNjZWxDb25uZWN0aW9uQXR0cnNPcHRpb25hbERlc3Ryb3lWYWx1ZbQCNExtaVhzZEF0dHJfTG1pU2NlbENvbm5lY3Rpb25BdHRyc09wdGlvbmFsVXBkYXRlVmFsdWW1AjFMbWlYc2RFbGVtZW50X0xtaVNjZWxBZGRyZXNzUzBVbnBhcnNlZENyZWF0ZVZhbHVltgIyTG1pWHNkRWxlbWVudF9MbWlTY2VsQWRkcmVzc1MwVW5wYXJzZWREZXN0cm95VmFsdWW3AjFMbWlYc2RFbGVtZW50X0xtaVNjZWxBZGRyZXNzUzBVbnBhcnNlZFVwZGF0ZVZhbHVluAIsTG1pWHNkRWxlbWVudF9MbWlTY2VsQWRkcmVzc0F0dHJzQ3JlYXRlVmFsdWW5AixMbWlYc2RBdHRyU2V0X0xtaVNjZWxBZGRyZXNzQXR0cnNVcGRhdGVWYWx1ZboCKUxtaVhzZEVsZW1lbnRfTG1pU2NlbEFkZHJlc3NTMENyZWF0ZVZhbHVluwIsTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsQWRkcmVzc1MwVXBkYXRlVmFsdWW8Ai9MbWlYc2RFbGVtZW50X0xtaVNjZWxFbmNyeXB0aW9uQXR0cnNDcmVhdGVWYWx1Zb0CL0xtaVhzZEF0dHJTZXRfTG1pU2NlbEVuY3J5cHRpb25BdHRyc1VwZGF0ZVZhbHVlvgIsTG1pWHNkRWxlbWVudF9MbWlTY2VsRW5jcnlwdGlvblMwQ3JlYXRlVmFsdWW/Ai9MbWlYc2RDb21wb3NpdG9yX0xtaVNjZWxFbmNyeXB0aW9uUzBVcGRhdGVWYWx1ZcACM0xtaVhzZEVsZW1lbnRfTG1pU2NlbEF1dGhlbnRpY2F0aW9uQXR0cnNDcmVhdGVWYWx1ZcECM0xtaVhzZEF0dHJTZXRfTG1pU2NlbEF1dGhlbnRpY2F0aW9uQXR0cnNVcGRhdGVWYWx1ZcICMExtaVhzZEVsZW1lbnRfTG1pU2NlbEF1dGhlbnRpY2F0aW9uUzBDcmVhdGVWYWx1ZcMCM0xtaVhzZENvbXBvc2l0b3JfTG1pU2NlbEF1dGhlbnRpY2F0aW9uUzBVcGRhdGVWYWx1ZcQCM0xtaVhzZEVsZW1lbnRfTG1pU2NlbENvbXBvbmVudFMwQWRkcmVzc0Rlc3Ryb3lWYWx1ZcUCMkxtaVhzZEVsZW1lbnRfTG1pU2NlbENvbXBvbmVudFMwQWRkcmVzc1VwZGF0ZVZhbHVlxgIuTG1pWHNkRWxlbWVudF9MbWlTY2VsQ29tcG9uZW50QXR0cnNDcmVhdGVWYWx1ZccCLkxtaVhzZEF0dHJTZXRfTG1pU2NlbENvbXBvbmVudEF0dHJzVXBkYXRlVmFsdWXIAitMbWlYc2RFbGVtZW50X0xtaVNjZWxDb21wb25lbnRTMENyZWF0ZVZhbHVlyQIuTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsQ29tcG9uZW50UzBVcGRhdGVWYWx1ZcoCPExtaVhzZEVsZW1lbnRfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZVMwQXR0cmlidXRlc0Rlc3Ryb3lWYWx1ZcsCO0xtaVhzZEVsZW1lbnRfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZVMwQXR0cmlidXRlc1VwZGF0ZVZhbHVlzAI0TG1pWHNkRWxlbWVudF9MbWlTY2VsRmVlZGJhY2tNZXNzYWdlQXR0cnNDcmVhdGVWYWx1Zc0CNExtaVhzZEF0dHJTZXRfTG1pU2NlbEZlZWRiYWNrTWVzc2FnZUF0dHJzVXBkYXRlVmFsdWXOAjFMbWlYc2RFbGVtZW50X0xtaVNjZWxGZWVkYmFja01lc3NhZ2VTMENyZWF0ZVZhbHVlzwI0TG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsRmVlZGJhY2tNZXNzYWdlUzBVcGRhdGVWYWx1ZdACMExtaVhzZEVsZW1lbnRfTG1pU2NlbE1lZGlhUzBCaW5kaW5nc0Rlc3Ryb3lWYWx1ZdECL0xtaVhzZEVsZW1lbnRfTG1pU2NlbE1lZGlhUzBCaW5kaW5nc1VwZGF0ZVZhbHVl0gIqTG1pWHNkRWxlbWVudF9MbWlTY2VsTWVkaWFBdHRyc0NyZWF0ZVZhbHVl0wIqTG1pWHNkQXR0clNldF9MbWlTY2VsTWVkaWFBdHRyc1VwZGF0ZVZhbHVl1AInTG1pWHNkRWxlbWVudF9MbWlTY2VsTWVkaWFTMENyZWF0ZVZhbHVl1QIqTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsTWVkaWFTMFVwZGF0ZVZhbHVl1gIuTG1pWHNkRWxlbWVudF9MbWlTY2VsTWFzdGVyS2V5QXR0cnNDcmVhdGVWYWx1ZdcCLkxtaVhzZEF0dHJTZXRfTG1pU2NlbE1hc3RlcktleUF0dHJzVXBkYXRlVmFsdWXYAitMbWlYc2RFbGVtZW50X0xtaVNjZWxNYXN0ZXJLZXlTMENyZWF0ZVZhbHVl2QIuTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsTWFzdGVyS2V5UzBVcGRhdGVWYWx1ZdoCKUxtaVhzZEVsZW1lbnRfTG1pU2NlbFNydHBBdHRyc0NyZWF0ZVZhbHVl2wIpTG1pWHNkQXR0clNldF9MbWlTY2VsU3J0cEF0dHJzVXBkYXRlVmFsdWXcAiZMbWlYc2RFbGVtZW50X0xtaVNjZWxTcnRwUzBDcmVhdGVWYWx1Zd0CKUxtaVhzZENvbXBvc2l0b3JfTG1pU2NlbFNydHBTMFVwZGF0ZVZhbHVl3gI3TG1pWHNkRWxlbWVudF9MbWlTY2VsUnRwRXh0ZW5zaW9uSGVhZGVyQXR0cnNDcmVhdGVWYWx1Zd8CN0xtaVhzZEF0dHJTZXRfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlckF0dHJzQ3JlYXRlVmFsdWXgAjdMbWlYc2RBdHRyU2V0X0xtaVNjZWxSdHBFeHRlbnNpb25IZWFkZXJBdHRyc1VwZGF0ZVZhbHVl4QI0TG1pWHNkRWxlbWVudF9MbWlTY2VsUnRwRXh0ZW5zaW9uSGVhZGVyUzBDcmVhdGVWYWx1ZeICN0xtaVhzZENvbXBvc2l0b3JfTG1pU2NlbFJ0cEV4dGVuc2lvbkhlYWRlclMwVXBkYXRlVmFsdWXjAjBMbWlYc2RFbGVtZW50X0xtaVNjZWxGaW5nZXJwcmludEF0dHJzQ3JlYXRlVmFsdWXkAjBMbWlYc2RBdHRyU2V0X0xtaVNjZWxGaW5nZXJwcmludEF0dHJzVXBkYXRlVmFsdWXlAi1MbWlYc2RFbGVtZW50X0xtaVNjZWxGaW5nZXJwcmludFMwQ3JlYXRlVmFsdWXmAjBMbWlYc2RDb21wb3NpdG9yX0xtaVNjZWxGaW5nZXJwcmludFMwVXBkYXRlVmFsdWXnAi9MbWlYc2RFbGVtZW50X0xtaVNjZWxDb25uZWN0aW9uQXR0cnNDcmVhdGVWYWx1ZegCL0xtaVhzZEF0dHJTZXRfTG1pU2NlbENvbm5lY3Rpb25BdHRyc0NyZWF0ZVZhbHVl6QIvTG1pWHNkQXR0clNldF9MbWlTY2VsQ29ubmVjdGlvbkF0dHJzVXBkYXRlVmFsdWXqAixMbWlYc2RFbGVtZW50X0xtaVNjZWxDb25uZWN0aW9uUzBDcmVhdGVWYWx1ZesCL0xtaVhzZENvbXBvc2l0b3JfTG1pU2NlbENvbm5lY3Rpb25TMFVwZGF0ZVZhbHVl7AI1TG1pWHNkRWxlbWVudF9MbWlTY2VsUmVjZWl2ZVNvdXJjZVMwUGFyYW1zQ3JlYXRlVmFsdWXtAjZMbWlYc2RFbGVtZW50X0xtaVNjZWxSZWNlaXZlU291cmNlUzBQYXJhbXNEZXN0cm95VmFsdWXuAjVMbWlYc2RFbGVtZW50X0xtaVNjZWxSZWNlaXZlU291cmNlUzBQYXJhbXNVcGRhdGVWYWx1Ze8CMkxtaVhzZEVsZW1lbnRfTG1pU2NlbFJlY2VpdmVTb3VyY2VBdHRyc0NyZWF0ZVZhbHVl8AIyTG1pWHNkQXR0clNldF9MbWlTY2VsUmVjZWl2ZVNvdXJjZUF0dHJzQ3JlYXRlVmFsdWXxAjJMbWlYc2RBdHRyU2V0X0xtaVNjZWxSZWNlaXZlU291cmNlQXR0cnNVcGRhdGVWYWx1ZfICL0xtaVhzZEVsZW1lbnRfTG1pU2NlbFJlY2VpdmVTb3VyY2VTMENyZWF0ZVZhbHVl8wIyTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsUmVjZWl2ZVNvdXJjZVMwVXBkYXRlVmFsdWX0AilMbWlYc2RFbGVtZW50X0xtaVNjZWxCb2R5QXR0cnNDcmVhdGVWYWx1ZfUCKUxtaVhzZEF0dHJTZXRfTG1pU2NlbEJvZHlBdHRyc1VwZGF0ZVZhbHVl9gImTG1pWHNkRWxlbWVudF9MbWlTY2VsQm9keVMwQ3JlYXRlVmFsdWX3AilMbWlYc2RDb21wb3NpdG9yX0xtaVNjZWxCb2R5UzBVcGRhdGVWYWx1ZfgCL0xtaVhzZEVsZW1lbnRfTG1pU2NlbEV4dENvbW1hbmRBdHRyc0NyZWF0ZVZhbHVl+QIvTG1pWHNkQXR0clNldF9MbWlTY2VsRXh0Q29tbWFuZEF0dHJzVXBkYXRlVmFsdWX6AixMbWlYc2RFbGVtZW50X0xtaVNjZWxFeHRDb21tYW5kUzBDcmVhdGVWYWx1ZfsCL0xtaVhzZENvbXBvc2l0b3JfTG1pU2NlbEV4dENvbW1hbmRTMFVwZGF0ZVZhbHVl/AIuTG1pWHNkRWxlbWVudF9MbWlTY2VsQWxnb3JpdGhtQXR0cnNDcmVhdGVWYWx1Zf0CLkxtaVhzZEF0dHJTZXRfTG1pU2NlbEFsZ29yaXRobUF0dHJzVXBkYXRlVmFsdWX+AitMbWlYc2RFbGVtZW50X0xtaVNjZWxBbGdvcml0aG1TMENyZWF0ZVZhbHVl/wIuTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsQWxnb3JpdGhtUzBVcGRhdGVWYWx1ZYADLkxtaVhzZEVsZW1lbnRfTG1pU2NlbEV4dGVuc2lvbkF0dHJzQ3JlYXRlVmFsdWWBAy5MbWlYc2RBdHRyU2V0X0xtaVNjZWxFeHRlbnNpb25BdHRyc1VwZGF0ZVZhbHVlggMxTG1pWHNkRWxlbWVudF9MbWlTY2VsQ2FwYWJpbGl0aWVzQXR0cnNDcmVhdGVWYWx1ZYMDMUxtaVhzZEF0dHJTZXRfTG1pU2NlbENhcGFiaWxpdGllc0F0dHJzVXBkYXRlVmFsdWWEAy5MbWlYc2RFbGVtZW50X0xtaVNjZWxDYXBhYmlsaXRpZXNTMENyZWF0ZVZhbHVlhQMxTG1pWHNkQ29tcG9zaXRvcl9MbWlTY2VsQ2FwYWJpbGl0aWVzUzBVcGRhdGVWYWx1ZYYDEExtaVNkcEluaXRpYWxpemWHAxJMbWlTZHBVbmluaXRpYWxpemWIAw1MbWlTZHBMb2dJbml0iQMeTG1pVmVjdG9yX0xtaVNkcENvbnRhY3RSZXNlcnZligMaTG1pU2RwQ29udGFjdENvbnN0cnVjdENvcHmLAyFMbWlWZWN0b3JfTG1pU2RwQ29ubmVjdGlvblJlc2VydmWMAx1MbWlTZHBDb25uZWN0aW9uQ29uc3RydWN0Q29weY0DGExtaVNkcENvbm5lY3Rpb25EZXN0cnVjdI4DIExtaVZlY3Rvcl9MbWlTZHBCYW5kd2lkdGhSZXNlcnZljwMcTG1pU2RwQmFuZHdpZHRoQ29uc3RydWN0Q29weZADGUxtaVNkcFNlc3Npb25UaW1lRGVzdHJ1Y3SRAxxMbWlWZWN0b3JfTG1pU2RwTWVkaWFSZXNlcnZlkgMYTG1pU2RwTWVkaWFDb25zdHJ1Y3RDb3B5kwMTTG1pU2RwTWVkaWFEZXN0cnVjdJQDGExtaVNkcEF0dHJpYnV0ZUNvbnN0cnVjdJUDFUxtaVNkcE1lc3NhZ2VEZXN0cnVjdJYDC1JlYWRTZHBMaW5llwMbTG1pU2RwQ29udGFjdENvbnN0cnVjdFBhcnNlmAMdTG1pU2RwQmFuZHdpZHRoQ29uc3RydWN0UGFyc2WZAw1SZWFkVHlwZWRUaW1lmgMVTG1pU2RwTWVzc2FnZVBhcnNlS2V5mwMdTG1pU2RwQXR0cmlidXRlQ29uc3RydWN0UGFyc2WcAx5MbWlIbWFjQ3R4X0xtaVNoYTFDdHhDb25zdHJ1Y3SdAxZMbWlFbnRyb3B5VW5pbml0aWFsaXplngMSTG1pRW50cm9weUdlbmVyYXRlnwMdTG1pQWVzRW5jS2V5U2NoZWRDb25zdHJ1Y3RfQ1+gAxlMbWlBZXNFbmNLZXlTY2hlZERlc3RydWN0oQMbTG1pQWVzRW5jS2V5U2NoZWRFbmNyeXB0X0NfogMUTG1pQWVzQ3RyQ3R4RGVzdHJ1Y3SjAxJMbWlBZXNDdHJDdHhTZXRDdHKkAxpMbWlBZXNDdHJDdHhFbmNyeXB0R0N0cl9DX6UDE0xtaUFlc0N0ckN0eEVuY3J5cHSmAxdMbWlBZXNDdHJDdHhFbmNyeXB0R0N0cqcDG0xtaUFlc0VuY0tleVNjaGVkRW5jcnlwdEN0cqgDGkxtaUFlc0VuY0tleVNjaGVkQ29uc3RydWN0qQMYTG1pQWVzRW5jS2V5U2NoZWRFbmNyeXB0qgMXRG9BZXNFY2JLbm93bkFuc3dlclRlc3SrAxdEb0Flc0N0cktub3duQW5zd2VyVGVzdKwDGkN0ckRyYmdJbnN0YW50aWF0ZUZ1bmN0aW9urQMYQ3RyRHJiZ0dlbmVyYXRlQWxnb3JpdGhtrgMNQmxvY2tDaXBoZXJEZq8DEEluY3JlbWVudENvdW50ZXKwAyBMbWlTZWN1cmVSYW5kb21HZW5lcmF0b3JEZXN0cnVjdLEDFUN0ckRyYmdSZXNlZWRGdW5jdGlvbrIDIExtaVNlY3VyZVJhbmRvbUdlbmVyYXRvckdlbmVyYXRlswMDQkNDtAMVTG1pQWVzR2NtQ3R4Q29uc3RydWN0tQMUTG1pR2hhc2hDdHhDb25zdHJ1Y3S2AxlMbWlHaGFzaEN0eFByb2Nlc3NCbG9ja3NftwMUTG1pQWVzR2NtQ3R4RGVzdHJ1Y3S4AxJMbWlBZXNHY21DdHhBZGRBYWS5AxZMbWlBZXNHY21DdHhHZXRGdWxsVGFnugMXRG9BZXNHY21Lbm93bkFuc3dlclRlc3S7AxVMbWlTZWN1cml0eUluaXRpYWxpemW8AxdMbWlTZWN1cml0eVVuaW5pdGlhbGl6Zb0DDC5MY2FsbF9kdG9yc74DE0xtaVNlY3VyaXR5TWVtQ2xlYXK/AxNMbWlTZWN1cml0eU1lbUVxdWFswAMTTG1pU2hhMUN0eFVwZGF0ZV9DX8EDE0xtaVNoYTFDdHhDb25zdHJ1Y3TCAxdMbWlTaGExQ3R4Q29uc3RydWN0Q29wecMDEkxtaVNoYTFDdHhEZXN0cnVjdMQDEExtaVNoYTFDdHhVcGRhdGXFAw9MbWlTaGExQ3R4RmluYWzGAxVEb1NoYTFLbm93bkFuc3dlclRlc3THAxVMbWlTaGEyNTZDdHhVcGRhdGVfQ1/IAxVMbWlTaGEyNTZDdHhDb25zdHJ1Y3TJAxlMbWlTaGEyNTZDdHhDb25zdHJ1Y3RDb3B5ygMUTG1pU2hhMjU2Q3R4RGVzdHJ1Y3TLAxJMbWlTaGEyNTZDdHhVcGRhdGXMAxFMbWlTaGEyNTZDdHhGaW5hbM0DF0RvU2hhMjU2S25vd25BbnN3ZXJUZXN0zgNGTG1pU2hhcmVkUHRyX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbFBhcmFtZXRlckF0dHJzSW1wbERlZmF1bHREZWxldGVyX88DQUxtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJBdHRyc0ltcGxNYWtlVW5pcXVl0AMqTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUGFyYW1ldGVyQ29uc3RydWN00QMwTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUGFyYW1ldGVyU2V0TWluQXR0cmlidXRl0gMwTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUGFyYW1ldGVyU2V0TWF4QXR0cmlidXRl0wM6TG1pU2hhcmVkUHRyX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbFMwSW1wbERlZmF1bHREZWxldGVyX9QDNUxtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xTMEltcGxNYWtlVW5pcXVl1QMmTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUzBTZXRQYXJhbWV0ZXLWAyNMbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xTMFNldEFjdGlvbtcDN0xtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFJlc29sdXRpb25TMEltcGxEZWZhdWx0RGVsZXRlcl/YAzJMbWlTaGFyZWRQdHJfTG1pUHJvdG9jb2xSZXNvbHV0aW9uUzBJbXBsTWFrZVVuaXF1ZdkDHExtaVByb3RvY29sUmVzb2x1dGlvbkVuY29kZV/aAztMbWlTaGFyZWRQdHJfTG1pUHJvdG9jb2xTaG93UGFyYW1ldGVyc1MwSW1wbERlZmF1bHREZWxldGVyX9sDJ0xtaVByb3RvY29sU2hvd1BhcmFtZXRlcnNTMEltcGxEZXN0cnVjdNwDNkxtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFNob3dQYXJhbWV0ZXJzUzBJbXBsTWFrZVVuaXF1Zd0DNExtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFNzcmNNYXBTMEltcGxEZWZhdWx0RGVsZXRlcl/eAy9MbWlTaGFyZWRQdHJfTG1pUHJvdG9jb2xTc3JjTWFwUzBJbXBsTWFrZVVuaXF1Zd8DN0xtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFNzcmNNYXBBdHRyc0ltcGxEZWZhdWx0RGVsZXRlcl/gAzJMbWlTaGFyZWRQdHJfTG1pUHJvdG9jb2xTc3JjTWFwQXR0cnNJbXBsTWFrZVVuaXF1ZeEDIkxtaVByb3RvY29sU3NyY01hcENvbnN0cnVjdERlZmF1bHTiAxxMbWlQcm90b2NvbFByb3BlcnR5Q29uc3RydWN04wMqTG1pVmVjdG9yX0xtaVByb3RvY29sUHJvcGVydHlDb25zdHJ1Y3RDb3B55AMaTG1pUHJvdG9jb2xQcm9wZXJ0eUVuY29kZV/lAyBMbWlQcm90b2NvbFByb3BlcnR5VmVjdG9yRW5jb2RlX+YDM0xtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFNvdXJjZVMwSW1wbERlZmF1bHREZWxldGVyX+cDLkxtaVNoYXJlZFB0cl9MbWlQcm90b2NvbFNvdXJjZVMwSW1wbE1ha2VVbmlxdWXoAyBMbWlQcm90b2NvbFNvdXJjZVMwU2V0UHJvcGVydGllc+kDHUxtaVByb3RvY29sU291cmNlUzBTZXRTc3JjTWFw6gMYTG1pUHJvdG9jb2xTb3VyY2VTMFNldFJj6wM2TG1pU2hhcmVkUHRyX0xtaVByb3RvY29sU291cmNlQXR0cnNJbXBsRGVmYXVsdERlbGV0ZXJf7AMxTG1pU2hhcmVkUHRyX0xtaVByb3RvY29sU291cmNlQXR0cnNJbXBsTWFrZVVuaXF1Ze0DPkxtaVhzZENvbXBsZXhUeXBlX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbFBhcmFtZXRlckNyZWF0ZVZhbHVl7gM+TG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sUGFyYW1ldGVyVXBkYXRlVmFsdWXvAztMbWlYc2RDb21wbGV4VHlwZV9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBY3Rpb25DcmVhdGVWYWx1ZfADO0xtaVhzZENvbXBsZXhUeXBlX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbEFjdGlvblVwZGF0ZVZhbHVl8QM1TG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xSZW1vdGVDb250cm9sQ3JlYXRlVmFsdWXyAzVMbWlYc2RDb21wbGV4VHlwZV9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xVcGRhdGVWYWx1ZfMDMkxtaVhzZENvbXBsZXhUeXBlX0xtaVByb3RvY29sUmVzb2x1dGlvbkNyZWF0ZVZhbHVl9AMyTG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xSZXNvbHV0aW9uVXBkYXRlVmFsdWX1AzZMbWlYc2RDb21wbGV4VHlwZV9MbWlQcm90b2NvbFNob3dQYXJhbWV0ZXJzVXBkYXRlVmFsdWX2Ay9MbWlYc2RDb21wbGV4VHlwZV9MbWlQcm90b2NvbFNzcmNNYXBDcmVhdGVWYWx1ZfcDL0xtaVhzZENvbXBsZXhUeXBlX0xtaVByb3RvY29sU3NyY01hcFVwZGF0ZVZhbHVl+AMwTG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xQcm9wZXJ0eUNyZWF0ZVZhbHVl+QMwTG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xQcm9wZXJ0eVVwZGF0ZVZhbHVl+gMuTG1pWHNkQ29tcGxleFR5cGVfTG1pUHJvdG9jb2xTb3VyY2VDcmVhdGVWYWx1ZfsDLkxtaVhzZENvbXBsZXhUeXBlX0xtaVByb3RvY29sU291cmNlVXBkYXRlVmFsdWX8Az9MbWlYc2RBdHRyX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbFBhcmFtZXRlckF0dHJzTWluQ3JlYXRlVmFsdWX9A0BMbWlYc2RBdHRyX0xtaVByb3RvY29sUmVtb3RlQ29udHJvbFBhcmFtZXRlckF0dHJzTWluRGVzdHJveVZhbHVl/gM/TG1pWHNkQXR0cl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJBdHRyc01pblVwZGF0ZVZhbHVl/wM/TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJBdHRyc0NyZWF0ZVZhbHVlgAQ/TG1pWHNkQXR0clNldF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJBdHRyc1VwZGF0ZVZhbHVlgQQ8TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJTMENyZWF0ZVZhbHVlggQ/TG1pWHNkQ29tcG9zaXRvcl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xQYXJhbWV0ZXJTMFVwZGF0ZVZhbHVlgwQ8TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBY3Rpb25BdHRyc0NyZWF0ZVZhbHVlhAQ8TG1pWHNkQXR0clNldF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBY3Rpb25BdHRyc1VwZGF0ZVZhbHVlhQQ5TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBY3Rpb25TMENyZWF0ZVZhbHVlhgQ8TG1pWHNkQ29tcG9zaXRvcl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBY3Rpb25TMFVwZGF0ZVZhbHVlhwQ2TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBdHRyc0NyZWF0ZVZhbHVliAQ2TG1pWHNkQXR0clNldF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xBdHRyc1VwZGF0ZVZhbHVliQQzTG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xTMENyZWF0ZVZhbHVligQ2TG1pWHNkQ29tcG9zaXRvcl9MbWlQcm90b2NvbFJlbW90ZUNvbnRyb2xTMFVwZGF0ZVZhbHVliwQzTG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlc29sdXRpb25BdHRyc0NyZWF0ZVZhbHVljAQzTG1pWHNkQXR0clNldF9MbWlQcm90b2NvbFJlc29sdXRpb25BdHRyc1VwZGF0ZVZhbHVljQQwTG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFJlc29sdXRpb25TMENyZWF0ZVZhbHVljgQzTG1pWHNkQ29tcG9zaXRvcl9MbWlQcm90b2NvbFJlc29sdXRpb25TMFVwZGF0ZVZhbHVljwQ3TG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFNob3dQYXJhbWV0ZXJzQXR0cnNDcmVhdGVWYWx1ZZAEN0xtaVhzZEF0dHJTZXRfTG1pUHJvdG9jb2xTaG93UGFyYW1ldGVyc0F0dHJzVXBkYXRlVmFsdWWRBDRMbWlYc2RFbGVtZW50X0xtaVByb3RvY29sU2hvd1BhcmFtZXRlcnNTMENyZWF0ZVZhbHVlkgQ3TG1pWHNkQ29tcG9zaXRvcl9MbWlQcm90b2NvbFNob3dQYXJhbWV0ZXJzUzBVcGRhdGVWYWx1ZZMEMExtaVhzZEVsZW1lbnRfTG1pUHJvdG9jb2xTc3JjTWFwQXR0cnNDcmVhdGVWYWx1ZZQEMExtaVhzZEF0dHJTZXRfTG1pUHJvdG9jb2xTc3JjTWFwQXR0cnNVcGRhdGVWYWx1ZZUELUxtaVhzZEVsZW1lbnRfTG1pUHJvdG9jb2xTc3JjTWFwUzBDcmVhdGVWYWx1ZZYEMExtaVhzZENvbXBvc2l0b3JfTG1pUHJvdG9jb2xTc3JjTWFwUzBVcGRhdGVWYWx1ZZcEMUxtaVhzZEVsZW1lbnRfTG1pUHJvdG9jb2xQcm9wZXJ0eUF0dHJzQ3JlYXRlVmFsdWWYBDFMbWlYc2RBdHRyU2V0X0xtaVByb3RvY29sUHJvcGVydHlBdHRyc1VwZGF0ZVZhbHVlmQQuTG1pWHNkRWxlbWVudF9MbWlQcm90b2NvbFByb3BlcnR5UzBDcmVhdGVWYWx1ZZoEMUxtaVhzZENvbXBvc2l0b3JfTG1pUHJvdG9jb2xQcm9wZXJ0eVMwVXBkYXRlVmFsdWWbBC9MbWlYc2RFbGVtZW50X0xtaVByb3RvY29sU291cmNlQXR0cnNDcmVhdGVWYWx1ZZwEL0xtaVhzZEF0dHJTZXRfTG1pUHJvdG9jb2xTb3VyY2VBdHRyc0NyZWF0ZVZhbHVlnQQvTG1pWHNkQXR0clNldF9MbWlQcm90b2NvbFNvdXJjZUF0dHJzVXBkYXRlVmFsdWWeBCxMbWlYc2RFbGVtZW50X0xtaVByb3RvY29sU291cmNlUzBDcmVhdGVWYWx1ZZ8EL0xtaVhzZENvbXBvc2l0b3JfTG1pUHJvdG9jb2xTb3VyY2VTMFVwZGF0ZVZhbHVloAQVQWRkUGFyYW1ldGVyV2l0aFJhbmdloQQWQWRkUGFyYW1ldGVyV2l0aFNwZWVkc6IEGUxtaVNvdXJjZVRhYmxlX05vZGVEZWxldGWjBBlMbWlTb3VyY2VUYWJsZV9Ob2RlSW5zZXJ0pAQdTG1pQ29ubmVjdGlvblRhYmxlX05vZGVEZWxldGWlBBdMbWlDb25uZWN0aW9uVGFibGVDbGVhcqYEHUxtaUNvbm5lY3Rpb25UYWJsZV9Ob2RlSW5zZXJ0pwQfTG1pU2Vzc2lvbkNhcGFiaWxpdGllc0NvbnN0cnVjdKgEIExtaVNlc3Npb25DYXBhYmlsaXRpZXNBZGRTb3VyY2VzqQQkTG1pU2Vzc2lvbkNhcGFiaWxpdGllc0FkZENvbm5lY3Rpb25zqgQeTG1pU2Vzc2lvbkNhcGFiaWxpdGllc0Rlc3RydWN0qwQaTG1pVmVjdG9yX0xtaVNvdXJjZVJlc2VydmWsBBZMbWlTb3VyY2VDb25zdHJ1Y3RDb3B5rQQRTG1pU291cmNlRGVzdHJ1Y3SuBBtMbWlWZWN0b3JfTG1pU291cmNlRGVzdHJ1Y3SvBBlMbWlWZWN0b3JfTG1pUnVubmVsQXNzaWdusAQbTG1pVmVjdG9yX0xtaVJ1bm5lbFB1c2hCYWNrsQQaTG1pVmVjdG9yX0xtaVJ1bm5lbFJlc2VydmWyBBFMbWlSdW5uZWxEZXN0cnVjdLMEHUxtaVZlY3Rvcl9MbWlSdW5uZWxDb25zdHJ1Y3ROtAQbTG1pVmVjdG9yX0xtaVJ1bm5lbERlc3RydWN0tQQSTG1pUnVubmVsQ29uc3RydWN0tgQSTG1pU291cmNlQ29uc3RydWN0twQYTG1pU291cmNlU2V0Q29ubmVjdGlvbklkuAQRTG1pSG9zdEluaXRpYWxpemW5BBNMbWlIb3N0VW5pbml0aWFsaXplugQSTG1pSG9zdFNlcnZpY2VTdG9wuwQeTG1pSG9zdFJlcXVlc3RSZWZlcmVuY2VSZWxlYXNlvAQUTG1pSG9zdENvbnN0cnVjdENTdHK9BB1MbWlIb3N0UmVxdWVzdFJlc3VsdFN0YXR1c1N0cr4EC1JlYWRBZGRyZXNzvwQNUmVhZFY0QWRkcmVzc8AEHExtaUlwQWRkcmVzc0NvbnN0cnVjdENTdHJFbmTBBBFMbWlJcEFkZHJlc3NBc1N0csIEHUxtaVNvY2tldEFkZHJlc3NDb25zdHJ1Y3RDU3RywwQNUmVhZEFkZHJlc3MuMcQEFUxtaVNvY2tldEFkZHJlc3NBc1N0csUEIUxtaVZlY3Rvcl9MbWlTb2NrZXRBZGRyZXNzUmVzZXJ2ZcYEIkxtaVZlY3Rvcl9MbWlTb2NrZXRBZGRyZXNzRGVzdHJ1Y3THBCRMbWlOZXR3b3JrSW50ZXJmYWNlTWFuYWdlckluaXRpYWxpemXIBCZMbWlOZXR3b3JrSW50ZXJmYWNlTWFuYWdlclVuaW5pdGlhbGl6ZckEFkxtaVRyYW5zcG9ydEluaXRpYWxpemXKBBhMbWlUcmFuc3BvcnRVbmluaXRpYWxpemXLBBNMbWlUcmFuc3BvcnRMb2dJbml0zAQdTG1pVHJhbnNwb3J0T3BlbkZpbGVDb3VudEluaXTNBCBMbWlUcmFuc3BvcnRBZGRyZXNzVHlwZUdldFN0cmluZ84EIkxtaVRyYW5zcG9ydEFkZHJlc3NUeXBlUGFyc2VTdHJpbmfPBBtMbWlUcmFuc3BvcnRBZGRyZXNzRGVzdHJ1Y3TQBCBMbWlUcmFuc3BvcnRBZGRyZXNzQ29uc3RydWN0Q29wedEEJExtaVZlY3Rvcl9MbWlUcmFuc3BvcnRBZGRyZXNzUmVzZXJ2ZdIEJUxtaVZlY3Rvcl9MbWlUcmFuc3BvcnRBZGRyZXNzRGVzdHJ1Y3TTBCRMbWlUcmFuc3BvcnRNYW5hZ2VyUmVnaXN0ZXJUcmFuc3BvcnTUBB1MbWlUcmFuc3BvcnRNYW5hZ2VySW5pdGlhbGl6ZdUEH0xtaVRyYW5zcG9ydE1hbmFnZXJVbmluaXRpYWxpemXWBCxMbWlDYW1lcmFDb250cm9sQ2FwYWJpbGl0aWVzQ29uc3RydWN0RGVmYXVsdNcEKUxtaUNhbWVyYUNvbnRyb2xDYXBhYmlsaXRpZXNDb25zdHJ1Y3RDb3B52AQWTG1pVnA5Q29tbW9uSW5pdGlhbGl6ZdkEGExtaVZwOUNvbW1vblVuaW5pdGlhbGl6ZdoEEExtaVZwOUNvbW1vbkluaXTbBBVMbWlWcDlJbml0TWVkaWFQbHVnSW7cBB1MbWlWcDlDb21wYXJlRm9yQ29tcGF0aWJpbGl0ed0EGUxtaVZwOUFwcGx5TGV2ZWxQYXJhbWV0ZXLeBBRMbWlWcDlEdW1wUGFyYW1ldGVyc98EFkxtaVV0ZjhTdHJlYW1Db25zdHJ1Y3TgBBRMbWlYbWxQYXJzZXJEZXN0cnVjdOEEEUxtaVhtbFBhcnNlclBhcnNl4gQFZXJyb3LjBAV0MDBfYeQEGkxtaVhtbFBhcnNlckNvbnRlbnRBZGRDaGFy5QQFdDAwX2LmBAV0MDBfY+cEBXQwMV9h6AQFdDAxX2LpBAV0MDJfYuoEBXQwM19h6wQFdDAzX2LsBAV0MDRfYe0EBXQwNF9i7gQFdDA0X2PvBAV0MDRfZPAEBXQwNF9l8QQFdDA1X2HyBAV0MDVfYvMEBXQwNl9h9AQFdDA2X2L1BAV0MDZfY/YEBXQwN19i9wQFdDA3X2P4BAV0MDhfYfkEBXQwOF9i+gQFdDA5X2H7BAV0MDlfYvwEBXQxMF9h/QQFdDEwX2L+BAV0MTFfYf8EBXQxMV9igAUFdDExX2OBBQV0MTJfYYIFBXQxM19hgwUFdDEzX2KEBQV0MTRfYYUFBXQxNF9ihgUFdDE1X2GHBQV0MTVfYogFBXQxNV9jiQUFdDE2X2KKBQV0MTdfYosFBXQxN19jjAUFdDE4X2KNBQV0MTlfYY4FBXQxOV9ijwUFdDE5X2OQBQV0MTlfZJEFBXQyMF9hkgUFdDIxX2GTBQV0MjFfYpQFBXQyMV9jlQUFdDIxX2SWBQV0MjJfYpcFBXQyMl9jmAUFdDI0X2KZBQV0MjVfYZoFBXQyNV9imwUFdDI2X2GcBQV0MjZfYp0FBXQyN19ingUFdDI4X2GfBQV0MjhfYqAFDVN0YXJ0RWxlbUhkbHKhBQxFbmRFbGVtZW50TnOiBQhBdHRySGRscqMFCENoYXJIZGxypAUSRW5kT2ZTdGFydEVsZW1IZGxypQUPUGFyc2VyU3RhY2tQb3BfpgUKU3RhY2tEdW1wX6cFIlN0cmluZ0NvcHlXaXRoWG1sU3BlY2lhbENoYXJFc2NhcGWoBRRDaG9pY2VTdGFydEVsZW1lbnROc6kFFlNlcXVlbmNlU3RhcnRFbGVtZW50TnOqBRFBbGxTdGFydEVsZW1lbnROc6sFE0VsZW1lbnRNYXRjaEVsZW1lbnSsBRVFbGVtZW50U3RhcnRFbGVtZW50TnOtBRhTaW1wbGVUeXBlU3RhcnRFbGVtZW50TnOuBRRMbWlYbWxFbGVtZW50RGVzdHJvea8FGExtaVN0cmlwRXNjYXBlU3RyZWFtUmVhZLAFDkxtaVhtbEluZm9SZWFksQUSTG1pU3RyaW5nQ29udlhtbDJDsgUQTG1pVWludENvbnZYbWwyQ7MFE0xtaUZsb2F0NjRDb252WG1sMkO0BRBMbWlCb29sQ29udlhtbDJDtQUhTG1pWHNkUGFyc2VyRW5jb2RlT3BlblRhZ1VuY2xvc2VktgUZTG1pWHNkUGFyc2VyRW5jb2RlT3BlblRhZ7cFGkxtaVhzZFBhcnNlckVuY29kZUNsb3NlVGFnuAUVTG1pWG1sUmF3U3RyaW5nRW5jb2RluQUbTG1pWG1sUmF3U3RyaW5nVmVjdG9yRW5jb2RlugUPTG1pU3RyaW5nRW5jb2RluwUNTG1pVWludEVuY29kZbwFFkxtaVZlY3RvckxtaVVpbnRFbmNvZGW9BRBMbWlGbG9hdDY0RW5jb2RlvgUNTG1pQm9vbEVuY29kZb8FFkxtaVhzZFZhbGlkYXRlX0xtaVVpbnTABRlMbWlYc2RWYWxpZGF0ZV9MbWlGbG9hdDY0wQUWTG1pWHNkVmFsaWRhdGVfTG1pQm9vbMIFGUxtaVhzZENvbnN0cnVjdF9MbWlTdHJpbmfDBRdMbWlYc2RFbGVtZW50SXNPcHRpb25hbMQFG0NvbXBsZXhUeXBlU3RhY2tGcmFtZUNyZWF0ZcUFGUJhc2VFbGVtZW50U3RhcnRFbGVtZW50TnPGBRpDb21wb3NpdG9yU3RhY2tGcmFtZUNyZWF0ZccFGENvbXBvc2l0b3JTdGFydEVsZW1lbnROc8gFF0NvbXBsZXhUeXBlTWF0Y2hFbGVtZW50yQUWTG1pQWxsb2NhdG9yU2V0RGVmYXVsdMoFFExtaUFsbG9jYXRvckRlc3RydWN0ywUYTG1pQmFzZTY0RW5jb2RlVG9TdHJpbmdfzAUXTG1pQmFzZTY0RGVjb2RlVG9TdHJpbmfNBRhMbWlWZWN0b3JfTG1pVWludFJlc2VydmXOBR5MbWlWZWN0b3JfTG1pVWludENvbnN0cnVjdENvcHnPBRlMbWlWZWN0b3JfTG1pVWludERlc3RydWN00AUXTG1pVmVjdG9yX0xtaVVpbnRBc3NpZ27RBRtMbWlWZWN0b3JfTG1pVm9pZFB0clJlc2VydmXSBRlMbWlWZWN0b3JfTG1pVm9pZFB0ckVyYXNl0wUQTG1pQml0c2V0UmVzZXJ2ZdQFDExtaUJpdHNldFNldNUFHUxtaVZlY3Rvcl9MbWlCaXRzZXRJdGVtUmVzaXpl1gUUTG1pQml0c2V0U2V0TXVsdGlwbGXXBQ5MbWlCaXRzZXRDbGVhctgFFkxtaUJpdHNldENsZWFyTXVsdGlwbGXZBRFMbWlCaXRzZXRDbGVhckFsbNoFEExtaUJpdHNldElzRW1wdHnbBRJMbWlCaXRzZXRWYWxpZE1hc2vcBR9MbWlWZWN0b3JfTG1pQml0c2V0SXRlbURlc3RydWN03QUYTG1pSW5pdFRhYmxlSW5pdGlhbGl6ZUV43gUaTG1pSW5pdFRhYmxlVW5pbml0aWFsaXplRXjfBRxMbWlWZWN0b3JfTG1pUHJvcGVydHlSZXNlcnZl4AUTTG1pUHJvcGVydHlEZXN0cnVjdOEFIkxtaVZlY3Rvcl9MbWlQcm9wZXJ0eUNvbnN0cnVjdENvcHniBR1MbWlWZWN0b3JfTG1pUHJvcGVydHlEZXN0cnVjdOMFG0xtaVZlY3Rvcl9MbWlQcm9wZXJ0eUFzc2lnbuQFJUxtaVBzZXVkb1JhbmRvbVNpbXVsYXRvckdlbmVyYXRlQnl0ZXPlBRdMbWlTaW1wbGVMZXhlckNvbnN0cnVjdOYFIkxtaVNpbXBsZUxleGVyR2V0VG9rZW5BbmREZWxpbWl0ZXLnBRZMbWlTaW1wbGVMZXhlckdldFRva2Vu6AUhTG1pU291cmNlVHlwZUdldEZyb21TaWduYWxpbmdDU3Ry6QUZTG1pU291cmNlVHlwZUdldE1lZGlhVHlwZeoFCkxtaVN0ckxDcHnrBQtMbWlTTlByaW50ZuwFDExtaVZTTlByaW50Zu0FDUxtaVN0clRvTG93ZXLuBQ9MbWlTdHJUb0Zsb2F0NjTvBRlMbWlTdHJpbmdDb25zdHJ1Y3REZWZhdWx08AURTG1pU3RyaW5nRGVzdHJ1Y3TxBRZMbWlTdHJpbmdDb25zdHJ1Y3RDb3B58gUZTG1pU3RyaW5nQ29uc3RydWN0Q1N0ckxlbvMFD0xtaVN0cmluZ0Fzc2lnbvQFDkxtaVN0cmluZ0VxdWFs9QUSTG1pU3RyaW5nRXF1YWxDU3Ry9gUXTG1pU3RyaW5nRXF1YWxTdWJzdHJpbmf3BRBMbWlTdHJpbmdDb21wYXJl+AUWTG1pU3RyaW5nQ29uc3RydWN0Q1N0cvkFG0xtaVN0cmluZ0NvbnN0cnVjdFN1YnN0cmluZ/oFF0xtaVN0cmluZ0NvbnN0cnVjdFJhbmdl+wUbTG1pU3RyaW5nQ29uc3RydWN0Rm9ybWF0dGVk/AUQTG1pU3RyaW5nUmVzZXJ2Zf0FDkxtaVN0cmluZ0NsZWFy/gUZU3RyaW5nRG9SZXBsYWNlVkZvcm1hdHRlZP8FD0xtaVN0cmluZ0FwcGVuZIAGDlN0cmluZ0RvQXBwZW5kgQYTTG1pU3RyaW5nQXBwZW5kQ2hhcoIGE0xtaVN0cmluZ0FwcGVuZENTdHKDBhhMbWlTdHJpbmdBcHBlbmRGb3JtYXR0ZWSEBhhMbWlTdHJpbmdBc3NpZ25TdWJzdHJpbmeFBhNMbWlTdHJpbmdBc3NpZ25DU3RyhgYUTG1pU3RyaW5nQXNzaWduUmFuZ2WHBhhMbWlTdHJpbmdGaW5kRmlyc3RPZkNoYXKIBhRMbWlTdHJpbmdGaW5kRnJvbVBvc4kGFkxtaVN0cmluZ1JlbGVhc2VCdWZmZXKKBg1MbWlTdHJpbmdIYXNoiwYSTG1pU3RyaW5nU3RhY2tTaXpljAYRTG1pU3RyaW5nU3RhY2tQb3CNBhFMbWlTdHJpbmdTdGFja1RvcI4GJkxtaU1hcF9MbWlTdHJpbmdfX0xtaVN0cmluZ19Ob2RlRGVsZXRljwYkTG1pTWFwX0xtaVN0cmluZ19fTG1pU3RyaW5nX05vZGVDb3B5kAYjTG1pTWFwX0xtaVN0cmluZ19fTG1pU3RyaW5nRGVzdHJ1Y3SRBiRMbWlNYXBfTG1pU3RyaW5nX19MbWlTdHJpbmdGaW5kQ29uc3SSBiZMbWlNYXBfTG1pU3RyaW5nX19MbWlTdHJpbmdfTm9kZUluc2VydJMGIUxtaU1hcF9MbWlTdHJpbmdfX0xtaVN0cmluZ0luc2VydJQGGkxtaVZlY3Rvcl9MbWlTdHJpbmdSZXNlcnZllQYgTG1pVmVjdG9yX0xtaVN0cmluZ0NvbnN0cnVjdENvcHmWBhtMbWlWZWN0b3JfTG1pU3RyaW5nRGVzdHJ1Y3SXBhhMbWlWZWN0b3JfTG1pU3RyaW5nQ2xlYXKYBhlMbWlWZWN0b3JfTG1pU3RyaW5nQXNzaWdumQYrTG1pVW5vcmRlcmVkX0xtaVN0cmluZ19fTG1pVm9pZFB0ckNvbnN0cnVjdJoGKkxtaVVub3JkZXJlZF9MbWlTdHJpbmdfX0xtaVZvaWRQdHJEZXN0cnVjdJsGJkxtaVVub3JkZXJlZF9MbWlTdHJpbmdfX0xtaVZvaWRQdHJGaW5knAYqTG1pVW5vcmRlcmVkX0xtaVN0cmluZ19fTG1pU3RyaW5nQ29uc3RydWN0nQYpTG1pVW5vcmRlcmVkX0xtaVN0cmluZ19fTG1pU3RyaW5nRGVzdHJ1Y3SeBidMbWlVbm9yZGVyZWRfTG1pU3RyaW5nX19MbWlTdHJpbmdJbnNlcnSfBiNMbWlDb25zdFZlbE1vdGlvblByb2ZpbGVHZXRQb3NpdGlvbqAGJUxtaUNvbnN0QWNjZWxNb3Rpb25Qcm9maWxlR2V0UG9zaXRpb26hBiRMbWlDb25zdEplcmtNb3Rpb25Qcm9maWxlR2V0UG9zaXRpb26iBhtMbWlNb3Rpb25Qcm9maWxlSW5pdGlhbGl6ZV+jBh1MbWlNb3Rpb25Qcm9maWxlVW5pbml0aWFsaXplX6QGJkRlZmF1bHRDb25zdFZlbE1vdGlvblByb2ZpbGVJbml0aWFsaXplpQYoRGVmYXVsdENvbnN0QWNjZWxNb3Rpb25Qcm9maWxlSW5pdGlhbGl6ZaYGJ0RlZmF1bHRDb25zdEplcmtNb3Rpb25Qcm9maWxlSW5pdGlhbGl6ZacGEkxtaVV0aWxzSW5pdGlhbGl6ZagGFExtaVV0aWxzVW5pbml0aWFsaXplqQYTTG1pVXRpbHNJbml0aWFsaXplX6oGFF9fcHRocmVhZF9rZXlfZGVsZXRlqwYFZm9wZW6sBgZmY2xvc2WtBghfX3RvcmVhZK4GBWZyZWFkrwYGZmZsdXNosAYRX19mZmx1c2hfdW5sb2NrZWSxBhhfX2Vtc2NyaXB0ZW5fc3Rkb3V0X3NlZWuyBgxfX3N0ZGlvX3JlYWSzBgxfX3N0ZGlvX3NlZWu0Bgl2c25wcmludGa1Bghzbl93cml0ZbYGDV9fc3RkaW9fd3JpdGW3BhNfX3ZmcHJpbnRmX2ludGVybmFsuAYLcHJpbnRmX2NvcmW5BgNvdXS6Bgdwb3BfYXJnuwYGZ2V0aW50vAYFZm10X3W9BgNwYWS+Bgh2ZnByaW50Zr8GBmZtdF9mcMAGE3BvcF9hcmdfbG9uZ19kb3VibGXBBgRmZW9mwgYNX19zdGRpb19jbG9zZcMGBWZyZXhwxAYHc3RybmNtcMUGB3N0cm5jcHnGBgZtZW1jbXDHBgZzdHJjbXDIBgZzdHJjaHLJBgpzdHJjYXNlY21wygYLc3RybmNhc2VjbXDLBg1fX3N5c2NhbGxfcmV0zAYGc3RydG94zQYHc3RydG91bM4GBnN0cnRvbM8GB19fc2hsaW3QBghfX3NoZ2V0Y9EGCWNvcHlzaWdubNIGB3NjYWxibmzTBgdzY2FuZXhw1AYMZG9fc2V0cmxpbWl01QYQX19lcnJub19sb2NhdGlvbtYGCHN0cmVycm9y1wYGd2N0b21i2AYHaXNzcGFjZdkGB3RvbG93ZXLaBgdpc2RpZ2l02wYFbnRvaHPcBgtfZ2V0X3R6bmFtZd0GDV9nZXRfZGF5bGlnaHTeBg1fZ2V0X3RpbWV6b25l3wYSX193YXNpX3N5c2NhbGxfcmV04AYIX19kaXZ0ZjPhBglfX2xzaHJ0aTPiBg1fX2Zsb2F0dW5zaXRm4wYNX19leHRlbmRkZnRmMuQGCF9fYWRkdGYz5QYMX190cnVuY3RmZGYy5gYHX19sZXRmMucGB19fZ2V0ZjLoBghfX211bHRpM+kGCF9fc3VidGYz6gYIX19tdWx0ZjPrBgtfX2Zsb2F0c2l0ZuwGCV9fYXNobHRpM+0GCGRsbWFsbG9j7gYGZGxmcmVl7wYNZGlzcG9zZV9jaHVua/AGBHNicmvxBgVmbW9kbPIGBnNjYWxibvMGBm1lbWNwefQGBm1lbXNldPUGB21lbW1vdmX2BglfX3Rvd3JpdGX3BglfX2Z3cml0ZXj4BgRwdXRz+QYGc3RybGVu+gYJc3RhY2tTYXZl+wYMc3RhY2tSZXN0b3Jl/AYKc3RhY2tBbGxvY/0GBWh0b25s/gYWbGVnYWxzdHViJGR5bkNhbGxfamlqaQcSAQAPX19zdGFja19wb2ludGVyCbIqmwMABy5yb2RhdGEBCS5yb2RhdGEuMQIJLnJvZGF0YS4yAwkucm9kYXRhLjMECS5yb2RhdGEuNAUJLnJvZGF0YS41Bgkucm9kYXRhLjYHCS5yb2RhdGEuNwgJLnJvZGF0YS44CQkucm9kYXRhLjkKCi5yb2RhdGEuMTALCi5yb2RhdGEuMTEMCi5yb2RhdGEuMTINCi5yb2RhdGEuMTMOCi5yb2RhdGEuMTQPCi5yb2RhdGEuMTUQCi5yb2RhdGEuMTYRCi5yb2RhdGEuMTcSCi5yb2RhdGEuMTgTCi5yb2RhdGEuMTkUCi5yb2RhdGEuMjAVCi5yb2RhdGEuMjEWCi5yb2RhdGEuMjIXCi5yb2RhdGEuMjMYCi5yb2RhdGEuMjQZCi5yb2RhdGEuMjUaCi5yb2RhdGEuMjYbCi5yb2RhdGEuMjccCi5yb2RhdGEuMjgdCi5yb2RhdGEuMjkeCi5yb2RhdGEuMzAfCi5yb2RhdGEuMzEgCi5yb2RhdGEuMzIhCi5yb2RhdGEuMzMiCi5yb2RhdGEuMzQjCi5yb2RhdGEuMzUkCi5yb2RhdGEuMzYlCi5yb2RhdGEuMzcmCi5yb2RhdGEuMzgnCi5yb2RhdGEuMzkoCi5yb2RhdGEuNDApCi5yb2RhdGEuNDEqCi5yb2RhdGEuNDIrCi5yb2RhdGEuNDMsCi5yb2RhdGEuNDQtCi5yb2RhdGEuNDUuCi5yb2RhdGEuNDYvCi5yb2RhdGEuNDcwCi5yb2RhdGEuNDgxCi5yb2RhdGEuNDkyCi5yb2RhdGEuNTAzCi5yb2RhdGEuNTE0Ci5yb2RhdGEuNTI1Ci5yb2RhdGEuNTM2Ci5yb2RhdGEuNTQ3Ci5yb2RhdGEuNTU4Ci5yb2RhdGEuNTY5Ci5yb2RhdGEuNTc6Ci5yb2RhdGEuNTg7Ci5yb2RhdGEuNTk8Ci5yb2RhdGEuNjA9Ci5yb2RhdGEuNjE+Ci5yb2RhdGEuNjI/Ci5yb2RhdGEuNjNACi5yb2RhdGEuNjRBCi5yb2RhdGEuNjVCCi5yb2RhdGEuNjZDCi5yb2RhdGEuNjdECi5yb2RhdGEuNjhFCi5yb2RhdGEuNjlGCi5yb2RhdGEuNzBHCi5yb2RhdGEuNzFICi5yb2RhdGEuNzJJCi5yb2RhdGEuNzNKCi5yb2RhdGEuNzRLCi5yb2RhdGEuNzVMCi5yb2RhdGEuNzZNCi5yb2RhdGEuNzdOCi5yb2RhdGEuNzhPCi5yb2RhdGEuNzlQCi5yb2RhdGEuODBRCi5yb2RhdGEuODFSCi5yb2RhdGEuODJTCi5yb2RhdGEuODNUCi5yb2RhdGEuODRVCi5yb2RhdGEuODVWCi5yb2RhdGEuODZXCi5yb2RhdGEuODdYCi5yb2RhdGEuODhZCi5yb2RhdGEuODlaCi5yb2RhdGEuOTBbCi5yb2RhdGEuOTFcCi5yb2RhdGEuOTJdCi5yb2RhdGEuOTNeCi5yb2RhdGEuOTRfCi5yb2RhdGEuOTVgCi5yb2RhdGEuOTZhCi5yb2RhdGEuOTdiCi5yb2RhdGEuOThjCi5yb2RhdGEuOTlkCy5yb2RhdGEuMTAwZQsucm9kYXRhLjEwMWYLLnJvZGF0YS4xMDJnCy5yb2RhdGEuMTAzaAsucm9kYXRhLjEwNGkLLnJvZGF0YS4xMDVqCy5yb2RhdGEuMTA2awsucm9kYXRhLjEwN2wLLnJvZGF0YS4xMDhtCy5yb2RhdGEuMTA5bgsucm9kYXRhLjExMG8LLnJvZGF0YS4xMTFwCy5yb2RhdGEuMTEycQsucm9kYXRhLjExM3ILLnJvZGF0YS4xMTRzCy5yb2RhdGEuMTE1dAsucm9kYXRhLjExNnULLnJvZGF0YS4xMTd2Cy5yb2RhdGEuMTE4dwsucm9kYXRhLjExOXgLLnJvZGF0YS4xMjB5Cy5yb2RhdGEuMTIxegsucm9kYXRhLjEyMnsLLnJvZGF0YS4xMjN8Cy5yb2RhdGEuMTI0fQsucm9kYXRhLjEyNX4LLnJvZGF0YS4xMjZ/Cy5yb2RhdGEuMTI3gAELLnJvZGF0YS4xMjiBAQsucm9kYXRhLjEyOYIBCy5yb2RhdGEuMTMwgwELLnJvZGF0YS4xMzGEAQsucm9kYXRhLjEzMoUBCy5yb2RhdGEuMTMzhgELLnJvZGF0YS4xMzSHAQsucm9kYXRhLjEzNYgBCy5yb2RhdGEuMTM2iQELLnJvZGF0YS4xMzeKAQsucm9kYXRhLjEzOIsBCy5yb2RhdGEuMTM5jAELLnJvZGF0YS4xNDCNAQsucm9kYXRhLjE0MY4BCy5yb2RhdGEuMTQyjwELLnJvZGF0YS4xNDOQAQsucm9kYXRhLjE0NJEBCy5yb2RhdGEuMTQ1kgELLnJvZGF0YS4xNDaTAQsucm9kYXRhLjE0N5QBCy5yb2RhdGEuMTQ4lQELLnJvZGF0YS4xNDmWAQsucm9kYXRhLjE1MJcBCy5yb2RhdGEuMTUxmAELLnJvZGF0YS4xNTKZAQsucm9kYXRhLjE1M5oBCy5yb2RhdGEuMTU0mwELLnJvZGF0YS4xNTWcAQsucm9kYXRhLjE1Np0BCy5yb2RhdGEuMTU3ngELLnJvZGF0YS4xNTifAQsucm9kYXRhLjE1OaABCy5yb2RhdGEuMTYwoQELLnJvZGF0YS4xNjGiAQsucm9kYXRhLjE2MqMBCy5yb2RhdGEuMTYzpAELLnJvZGF0YS4xNjSlAQsucm9kYXRhLjE2NaYBCy5yb2RhdGEuMTY2pwELLnJvZGF0YS4xNjeoAQsucm9kYXRhLjE2OKkBCy5yb2RhdGEuMTY5qgELLnJvZGF0YS4xNzCrAQsucm9kYXRhLjE3MawBCy5yb2RhdGEuMTcyrQELLnJvZGF0YS4xNzOuAQsucm9kYXRhLjE3NK8BCy5yb2RhdGEuMTc1sAELLnJvZGF0YS4xNzaxAQsucm9kYXRhLjE3N7IBCy5yb2RhdGEuMTc4swELLnJvZGF0YS4xNzm0AQsucm9kYXRhLjE4MLUBCy5yb2RhdGEuMTgxtgELLnJvZGF0YS4xODK3AQsucm9kYXRhLjE4M7gBCy5yb2RhdGEuMTg0uQELLnJvZGF0YS4xODW6AQsucm9kYXRhLjE4NrsBCy5yb2RhdGEuMTg3vAELLnJvZGF0YS4xODi9AQsucm9kYXRhLjE4Ob4BCy5yb2RhdGEuMTkwvwELLnJvZGF0YS4xOTHAAQsucm9kYXRhLjE5MsEBCy5yb2RhdGEuMTkzwgELLnJvZGF0YS4xOTTDAQsucm9kYXRhLjE5NcQBCy5yb2RhdGEuMTk2xQELLnJvZGF0YS4xOTfGAQsucm9kYXRhLjE5OMcBCy5yb2RhdGEuMTk5yAELLnJvZGF0YS4yMDDJAQsucm9kYXRhLjIwMcoBCy5yb2RhdGEuMjAyywELLnJvZGF0YS4yMDPMAQsucm9kYXRhLjIwNM0BCy5yb2RhdGEuMjA1zgELLnJvZGF0YS4yMDbPAQsucm9kYXRhLjIwN9ABCy5yb2RhdGEuMjA40QELLnJvZGF0YS4yMDnSAQsucm9kYXRhLjIxMNMBCy5yb2RhdGEuMjEx1AELLnJvZGF0YS4yMTLVAQsucm9kYXRhLjIxM9YBCy5yb2RhdGEuMjE01wELLnJvZGF0YS4yMTXYAQsucm9kYXRhLjIxNtkBCy5yb2RhdGEuMjE32gELLnJvZGF0YS4yMTjbAQsucm9kYXRhLjIxOdwBCy5yb2RhdGEuMjIw3QELLnJvZGF0YS4yMjHeAQsucm9kYXRhLjIyMt8BCy5yb2RhdGEuMjIz4AELLnJvZGF0YS4yMjThAQsucm9kYXRhLjIyNeIBCy5yb2RhdGEuMjI24wELLnJvZGF0YS4yMjfkAQsucm9kYXRhLjIyOOUBCy5yb2RhdGEuMjI55gELLnJvZGF0YS4yMzDnAQsucm9kYXRhLjIzMegBCy5yb2RhdGEuMjMy6QELLnJvZGF0YS4yMzPqAQsucm9kYXRhLjIzNOsBCy5yb2RhdGEuMjM17AELLnJvZGF0YS4yMzbtAQsucm9kYXRhLjIzN+4BCy5yb2RhdGEuMjM47wELLnJvZGF0YS4yMznwAQsucm9kYXRhLjI0MPEBCy5yb2RhdGEuMjQx8gELLnJvZGF0YS4yNDLzAQsucm9kYXRhLjI0M/QBCy5yb2RhdGEuMjQ09QELLnJvZGF0YS4yNDX2AQsucm9kYXRhLjI0NvcBCy5yb2RhdGEuMjQ3+AELLnJvZGF0YS4yNDj5AQsucm9kYXRhLjI0OfoBCy5yb2RhdGEuMjUw+wELLnJvZGF0YS4yNTH8AQsucm9kYXRhLjI1Mv0BCy5yb2RhdGEuMjUz/gELLnJvZGF0YS4yNTT/AQsucm9kYXRhLjI1NYACCy5yb2RhdGEuMjU2gQILLnJvZGF0YS4yNTeCAgsucm9kYXRhLjI1OIMCCy5yb2RhdGEuMjU5hAILLnJvZGF0YS4yNjCFAgsucm9kYXRhLjI2MYYCCy5yb2RhdGEuMjYyhwILLnJvZGF0YS4yNjOIAgsucm9kYXRhLjI2NIkCCy5yb2RhdGEuMjY1igILLnJvZGF0YS4yNjaLAgsucm9kYXRhLjI2N4wCCy5yb2RhdGEuMjY4jQILLnJvZGF0YS4yNjmOAgsucm9kYXRhLjI3MI8CCy5yb2RhdGEuMjcxkAILLnJvZGF0YS4yNzKRAgsucm9kYXRhLjI3M5ICCy5yb2RhdGEuMjc0kwILLnJvZGF0YS4yNzWUAgsucm9kYXRhLjI3NpUCCy5yb2RhdGEuMjc3lgILLnJvZGF0YS4yNziXAgsucm9kYXRhLjI3OZgCCy5yb2RhdGEuMjgwmQILLnJvZGF0YS4yODGaAgsucm9kYXRhLjI4MpsCCy5yb2RhdGEuMjgznAILLnJvZGF0YS4yODSdAgsucm9kYXRhLjI4NZ4CCy5yb2RhdGEuMjg2nwILLnJvZGF0YS4yODegAgsucm9kYXRhLjI4OKECCy5yb2RhdGEuMjg5ogILLnJvZGF0YS4yOTCjAgsucm9kYXRhLjI5MaQCCy5yb2RhdGEuMjkypQILLnJvZGF0YS4yOTOmAgsucm9kYXRhLjI5NKcCCy5yb2RhdGEuMjk1qAILLnJvZGF0YS4yOTapAgsucm9kYXRhLjI5N6oCCy5yb2RhdGEuMjk4qwILLnJvZGF0YS4yOTmsAgsucm9kYXRhLjMwMK0CCy5yb2RhdGEuMzAxrgILLnJvZGF0YS4zMDKvAgsucm9kYXRhLjMwM7ACCy5yb2RhdGEuMzA0sQILLnJvZGF0YS4zMDWyAgsucm9kYXRhLjMwNrMCCy5yb2RhdGEuMzA3tAILLnJvZGF0YS4zMDi1Agsucm9kYXRhLjMwObYCCy5yb2RhdGEuMzEwtwILLnJvZGF0YS4zMTG4Agsucm9kYXRhLjMxMrkCCy5yb2RhdGEuMzEzugILLnJvZGF0YS4zMTS7Agsucm9kYXRhLjMxNbwCCy5yb2RhdGEuMzE2vQILLnJvZGF0YS4zMTe+Agsucm9kYXRhLjMxOL8CCy5yb2RhdGEuMzE5wAILLnJvZGF0YS4zMjDBAgsucm9kYXRhLjMyMcICCy5yb2RhdGEuMzIywwILLnJvZGF0YS4zMjPEAgsucm9kYXRhLjMyNMUCCy5yb2RhdGEuMzI1xgILLnJvZGF0YS4zMjbHAgsucm9kYXRhLjMyN8gCCy5yb2RhdGEuMzI4yQILLnJvZGF0YS4zMjnKAgsucm9kYXRhLjMzMMsCCy5yb2RhdGEuMzMxzAILLnJvZGF0YS4zMzLNAgsucm9kYXRhLjMzM84CCy5yb2RhdGEuMzM0zwILLnJvZGF0YS4zMzXQAgsucm9kYXRhLjMzNtECCy5yb2RhdGEuMzM30gILLnJvZGF0YS4zMzjTAgsucm9kYXRhLjMzOdQCCy5yb2RhdGEuMzQw1QILLnJvZGF0YS4zNDHWAgsucm9kYXRhLjM0MtcCCy5yb2RhdGEuMzQz2AILLnJvZGF0YS4zNDTZAgsucm9kYXRhLjM0NdoCCy5yb2RhdGEuMzQ22wILLnJvZGF0YS4zNDfcAgsucm9kYXRhLjM0ON0CCy5yb2RhdGEuMzQ53gILLnJvZGF0YS4zNTDfAgsucm9kYXRhLjM1MeACCy5yb2RhdGEuMzUy4QILLnJvZGF0YS4zNTPiAgsucm9kYXRhLjM1NOMCCy5yb2RhdGEuMzU15AILLnJvZGF0YS4zNTblAgsucm9kYXRhLjM1N+YCCy5yb2RhdGEuMzU45wILLnJvZGF0YS4zNTnoAgsucm9kYXRhLjM2MOkCCy5yb2RhdGEuMzYx6gILLnJvZGF0YS4zNjLrAgsucm9kYXRhLjM2M+wCCy5yb2RhdGEuMzY07QILLnJvZGF0YS4zNjXuAgsucm9kYXRhLjM2Nu8CCy5yb2RhdGEuMzY38AILLnJvZGF0YS4zNjjxAgsucm9kYXRhLjM2OfICCy5yb2RhdGEuMzcw8wILLnJvZGF0YS4zNzH0Agsucm9kYXRhLjM3MvUCCy5yb2RhdGEuMzcz9gILLnJvZGF0YS4zNzT3Agsucm9kYXRhLjM3NfgCCy5yb2RhdGEuMzc2+QILLnJvZGF0YS4zNzf6Agsucm9kYXRhLjM3OPsCCy5yb2RhdGEuMzc5/AILLnJvZGF0YS4zODD9Agsucm9kYXRhLjM4Mf4CCy5yb2RhdGEuMzgy/wILLnJvZGF0YS4zODOAAwsucm9kYXRhLjM4NIEDBS5kYXRhggMHLmRhdGEuMYMDBy5kYXRhLjKEAwcuZGF0YS4zhQMHLmRhdGEuNIYDBy5kYXRhLjWHAwcuZGF0YS42iAMHLmRhdGEuN4kDBy5kYXRhLjiKAwcuZGF0YS45iwMILmRhdGEuMTCMAwguZGF0YS4xMY0DCC5kYXRhLjEyjgMILmRhdGEuMTOPAwguZGF0YS4xNJADCC5kYXRhLjE1kQMILmRhdGEuMTaSAwguZGF0YS4xN5MDCC5kYXRhLjE4lAMILmRhdGEuMTmVAwguZGF0YS4yMJYDCC5kYXRhLjIxlwMILmRhdGEuMjKYAwguZGF0YS4yM5kDCC5kYXRhLjI0mgMILmRhdGEuMjUAKBBzb3VyY2VNYXBwaW5nVVJMFldlYlJ0Y1NkcFNjZWwud2FzbS5tYXA=');
     

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


read_ = function shell_read(filename, binary) {
  if (!nodeFS) nodeFS = require('fs');
  if (!nodePath) nodePath = require('path');
  filename = nodePath['normalize'](filename);
  return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
};

readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else
if (ENVIRONMENT_IS_SHELL) {

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document !== 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {

// include: web_or_worker_shell_read.js


  read_ = function(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = function(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = function(title) { document.title = title };
} else
{
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < wasmTable.length; i++) {
      var item = wasmTable.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    wasmTable.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    wasmTable.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {

  return addFunctionWasm(func, sig);
}

// end include: runtime_functions.js
// include: runtime_debug.js


// end include: runtime_debug.js
var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly !== 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((Uint8Array|Array<number>), number)} */
function allocate(slab, allocator) {
  var ret;

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (slab.subarray || slab.slice) {
    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);
  } else {
    HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
}

// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
var wasmBinaryFile;
  wasmBinaryFile = 'WebRtcSdpScel.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch === 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmMemory = Module['asm']['memory'];
    updateGlobalBufferAndViews(wasmMemory.buffer);

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      var result = WebAssembly.instantiate(binary, info);
      return result;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiationResult, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func === 'number') {
          if (callback.arg === undefined) {
            wasmTable.get(func)();
          } else {
            wasmTable.get(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  var runtimeKeepaliveCounter=0;
  function keepRuntimeAlive() {
      return noExitRuntime || runtimeKeepaliveCounter > 0;
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function _atexit(func, arg) {
    }
  function ___cxa_atexit(a0,a1
  ) {
  return _atexit(a0,a1);
  }

  /** @type {function(...*):?} */
  function ___stack_chk_fail(
  ) {
  err('missing function: __stack_chk_fail'); abort(-1);
  }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          // nodejs has crypto support
          return function() { return crypto_module['randomBytes'](1)[0]; };
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("randomDevice"); };
    }
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function mmapAlloc(size) {
      var alignedSize = alignMemory(size, 65536);
      var ptr = _malloc(alignedSize);
      while (size < alignedSize) HEAP8[ptr + size++] = 0;
      return ptr;
    }
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            // We don't currently support location hints for the address of the mapping
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, address, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:function(input, output, error) {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path, allowEmpty) {
        if (path[0] === '/') {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        return low;
      }};
  function ___sys_fcntl64(fd, cmd, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 13:
        case 14:
        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_ioctl(fd, op, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = varargs ? SYSCALLS.get() : 0;
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_prlimit64(pid, resource, new_limit, old_limit) {try {
  
      if (old_limit) { // just report no limits
        HEAP32[((old_limit)>>2)] = -1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(4))>>2)] = -1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(8))>>2)] = -1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(12))>>2)] = -1;  // RLIM_INFINITY
      }
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_setrlimit(varargs) {
      return 0; // no-op
    }

  function ___sys_ugetrlimit(resource, rlim) {try {
  
      HEAP32[((rlim)>>2)] = -1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(4))>>2)] = -1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(8))>>2)] = -1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(12))>>2)] = -1;  // RLIM_INFINITY
      return 0; // just report no limits
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = function() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (typeof dateNow !== 'undefined') {
    _emscripten_get_now = dateNow;
  } else _emscripten_get_now = function() { return performance.now(); }
  ;
  
  var _emscripten_get_now_is_monotonic=true;;
  function _clock_gettime(clk_id, tp) {
      // int clock_gettime(clockid_t clk_id, struct timespec *tp);
      var now;
      if (clk_id === 0) {
        now = Date.now();
      } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
        now = _emscripten_get_now();
      } else {
        setErrNo(28);
        return -1;
      }
      HEAP32[((tp)>>2)] = (now/1000)|0; // seconds
      HEAP32[(((tp)+(4))>>2)] = ((now % 1000)*1000*1000)|0; // nanoseconds
      return 0;
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }

  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_read(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  var GAI_ERRNO_MESSAGES={};
  function _gai_strerror(val) {
      var buflen = 256;
  
      // On first call to gai_strerror we initialise the buffer and populate the error messages.
      if (!_gai_strerror.buffer) {
          _gai_strerror.buffer = _malloc(buflen);
  
          GAI_ERRNO_MESSAGES['0'] = 'Success';
          GAI_ERRNO_MESSAGES['' + -1] = 'Invalid value for \'ai_flags\' field';
          GAI_ERRNO_MESSAGES['' + -2] = 'NAME or SERVICE is unknown';
          GAI_ERRNO_MESSAGES['' + -3] = 'Temporary failure in name resolution';
          GAI_ERRNO_MESSAGES['' + -4] = 'Non-recoverable failure in name res';
          GAI_ERRNO_MESSAGES['' + -6] = '\'ai_family\' not supported';
          GAI_ERRNO_MESSAGES['' + -7] = '\'ai_socktype\' not supported';
          GAI_ERRNO_MESSAGES['' + -8] = 'SERVICE not supported for \'ai_socktype\'';
          GAI_ERRNO_MESSAGES['' + -10] = 'Memory allocation failure';
          GAI_ERRNO_MESSAGES['' + -11] = 'System error returned in \'errno\'';
          GAI_ERRNO_MESSAGES['' + -12] = 'Argument buffer overflow';
      }
  
      var msg = 'Unknown error';
  
      if (val in GAI_ERRNO_MESSAGES) {
        if (GAI_ERRNO_MESSAGES[val].length > buflen - 1) {
          msg = 'Message too long'; // EMSGSIZE message. This should never occur given the GAI_ERRNO_MESSAGES above.
        } else {
          msg = GAI_ERRNO_MESSAGES[val];
        }
      }
  
      writeAsciiToMemory(msg, _gai_strerror.buffer);
      return _gai_strerror.buffer;
    }

  var Sockets={BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};
  
  function inetPton4(str) {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    }
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  function inetPton6(str) {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] === 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    }
  var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name:function (name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },lookup_addr:function (addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      }};
  
  function inetNtop4(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }
  
  function inetNtop6(ints) {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    }
  
  function writeSockaddr(sa, family, addr, port, addrlen) {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          /* Use makeSetValue instead of memset to avoid adding memset dependency for all users of writeSockaddr. */
          
          (tempI64 = [0>>>0,(tempDouble=0,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((sa)+(8))>>2)] = tempI64[0],HEAP32[(((sa)+(12))>>2)] = tempI64[1]);
          break;
        case 10:
          addr = inetPton6(addr);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          HEAP32[(((sa)+(4))>>2)] = 0;
          HEAP32[(((sa)+(24))>>2)] = 0;
          break;
        default:
          return 5;
      }
      return 0;
    }
  function _getaddrinfo(node, service, hint, out) {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;
  
      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var errno;
  
        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          inetNtop6(addr) :
          inetNtop4(addr);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family, addr, port);
        assert(!errno);
  
        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)] = family;
        HEAP32[(((ai)+(8))>>2)] = type;
        HEAP32[(((ai)+(12))>>2)] = proto;
        HEAP32[(((ai)+(24))>>2)] = canon;
        HEAP32[(((ai)+(20))>>2)] = sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)] = 28;
        } else {
          HEAP32[(((ai)+(16))>>2)] = 16;
        }
        HEAP32[(((ai)+(28))>>2)] = 0;
  
        return ai;
      }
  
      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
  
      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
  
      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
  
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
  
        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }
  
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
  
      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = inetPton4(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = inetPton6(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }
  
      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAP32[((out)>>2)] = ai;
      return 0;
    }

  function _gettimeofday(ptr) {
      var now = Date.now();
      HEAP32[((ptr)>>2)] = (now/1000)|0; // seconds
      HEAP32[(((ptr)+(4))>>2)] = ((now % 1000)*1000)|0; // microseconds
      return 0;
    }

  function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      HEAP32[(((tmPtr)+(36))>>2)] = 0;
      HEAP32[(((tmPtr)+(32))>>2)] = 0;
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      // Allocate a string "GMT" for us to point to.
      if (!_gmtime_r.GMTString) _gmtime_r.GMTString = allocateUTF8("GMT");
      HEAP32[(((tmPtr)+(40))>>2)] = _gmtime_r.GMTString;
      return tmPtr;
    }

  function _tzset() {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
      // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST). 
      // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((__get_timezone())>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((__get_daylight())>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        HEAP32[((__get_tzname())>>2)] = winterNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)] = summerNamePtr;
      } else {
        HEAP32[((__get_tzname())>>2)] = summerNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)] = winterNamePtr;
      }
    }
  function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
  
      var zonePtr = HEAP32[(((__get_tzname())+(dst ? 4 : 0))>>2)];
      HEAP32[(((tmPtr)+(40))>>2)] = zonePtr;
  
      return tmPtr;
    }

  /** @type {function(...*):?} */
  function _pthread_attr_getschedpolicy(
  ) {
  err('missing function: pthread_attr_getschedpolicy'); abort(-1);
  }

  /** @type {function(...*):?} */
  function _sched_get_priority_max(
  ) {
  err('missing function: sched_get_priority_max'); abort(-1);
  }

  /** @type {function(...*):?} */
  function _sched_get_priority_min(
  ) {
  err('missing function: sched_get_priority_min'); abort(-1);
  }

  function _setTempRet0(val) {
      setTempRet0(val);
    }

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


var asmLibraryArg = {
  "__cxa_atexit": ___cxa_atexit,
  "__stack_chk_fail": ___stack_chk_fail,
  "__sys_fcntl64": ___sys_fcntl64,
  "__sys_ioctl": ___sys_ioctl,
  "__sys_open": ___sys_open,
  "__sys_prlimit64": ___sys_prlimit64,
  "__sys_setrlimit": ___sys_setrlimit,
  "__sys_ugetrlimit": ___sys_ugetrlimit,
  "clock_gettime": _clock_gettime,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "fd_close": _fd_close,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "gai_strerror": _gai_strerror,
  "getaddrinfo": _getaddrinfo,
  "gettimeofday": _gettimeofday,
  "gmtime_r": _gmtime_r,
  "localtime_r": _localtime_r,
  "pthread_attr_getschedpolicy": _pthread_attr_getschedpolicy,
  "sched_get_priority_max": _sched_get_priority_max,
  "sched_get_priority_min": _sched_get_priority_min,
  "setTempRet0": _setTempRet0
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _ScelToSdp = Module["_ScelToSdp"] = function() {
  return (_ScelToSdp = Module["_ScelToSdp"] = Module["asm"]["ScelToSdp"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _SdpToScel = Module["_SdpToScel"] = function() {
  return (_SdpToScel = Module["_SdpToScel"] = Module["asm"]["SdpToScel"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _main = Module["_main"] = function() {
  return (_main = Module["_main"] = Module["asm"]["main"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = function() {
  return (_ntohs = Module["_ntohs"] = Module["asm"]["ntohs"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _htons = Module["_htons"] = function() {
  return (_htons = Module["_htons"] = Module["asm"]["htons"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
  return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = function() {
  return (_htonl = Module["_htonl"] = Module["asm"]["htonl"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_tzname = Module["__get_tzname"] = function() {
  return (__get_tzname = Module["__get_tzname"] = Module["asm"]["_get_tzname"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_daylight = Module["__get_daylight"] = function() {
  return (__get_daylight = Module["__get_daylight"] = Module["asm"]["_get_daylight"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_timezone = Module["__get_timezone"] = function() {
  return (__get_timezone = Module["__get_timezone"] = Module["asm"]["_get_timezone"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};





// === Auto-generated postamble setup entry stuff ===



var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {

  var entryFunction = Module['_main'];

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as
    // execution is asynchronously handed off to a pthread.
      // if we're not running an evented main loop, it's time to exit
      exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'unwind') {
      // running an evented main loop, don't immediately exit
      return;
    } else {
      var toLog = e;
      if (e && typeof e === 'object' && e.stack) {
        toLog = [e, e.stack];
      }
      err('exception thrown: ' + toLog);
      quit_(1, e);
    }
  } finally {
    calledMain = true;

  }
}

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && keepRuntimeAlive() && status === 0) {
    return;
  }

  if (keepRuntimeAlive()) {
  } else {

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);

    ABORT = true;
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();






    ;
})(Module);

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const LogEvents_1 = require("../events/LogEvents");
class Connection {
    constructor(_logger, ws_connection_string, _scipSession) {
        this._logger = _logger;
        this._scipSession = _scipSession;
        this.ws_connection_string = ws_connection_string;
        this.lmi_framing = true;
    }
    connect() {
        this.socket = new Socket(this, this.ws_connection_string);
    }
    disconnect() {
        if (this.socket.websocket) {
            this.socket.websocket.close(1000, "OK");
        }
        else {
            this._logger.LogError(() => "disconnect received but scip connection is not open", LogEvents_1.VidyoLogCategory.VidyoTransport);
        }
        this._scipSession.TransportConnectionDisconnected();
    }
    _onopen() {
        this._logger.LogDebug(() => 'WebSocket opened', LogEvents_1.VidyoLogCategory.VidyoTransport);
        this._scipSession.TransportConnectionEstablished();
    }
    _onerror(ev) {
        console.error(`WebSocket Error: ${JSON.stringify(ev)}`);
    }
    _onclose(ev) {
        if (!ev.wasClean) {
            this._logger.LogWarning(() => `WebSocket unclean close ${ev.code}: ${ev.reason}`, LogEvents_1.VidyoLogCategory.VidyoTransport);
        }
        else {
            this._logger.LogInfo(() => `WebSocket closed ${ev.code}: ${ev.reason}`, LogEvents_1.VidyoLogCategory.VidyoTransport);
        }
        this._scipSession.TransportConnectionDisconnected();
    }
    _onmessage(ev) {
        if (typeof ev.data === "string") {
            this._textHandler(ev);
        }
        else {
            this._dataHandler(ev.data);
        }
    }
    _textHandler(ev, cb) {
        this._logger.LogReceived(cb, LogEvents_1.VidyoLogCategory.VidyoTransport);
        this._logger.LogReceived(ev.data, LogEvents_1.VidyoLogCategory.VidyoTransport);
    }
    _dataHandler(data, cb_packet) {
        let frame_size = data.size;
        let reader = new FileReader();
        let socket = this.socket;
        let connection = this;
        let packetCallback = function (rawPacket, fin) {
            let dec = new TextDecoder("utf-8");
            let decodedPacket = dec.decode(rawPacket);
            socket.reassemblingPacket = socket.reassemblingPacket.concat(decodedPacket);
            if (fin == true) {
                connection._scipSession.processor.process(socket.reassemblingPacket);
                socket.reassemblingPacket = "";
            }
            connection._logger.LogReceived(decodedPacket, LogEvents_1.VidyoLogCategory.VidyoTransport);
        };
        if (typeof cb_packet === 'undefined') {
            cb_packet = packetCallback;
        }
        let casted_cb_packet = cb_packet;
        reader.onload = function (event) {
            let buffer = reader.result;
            if (connection.lmi_framing === true) {
                let result = connection._readPackets(socket, buffer, buffer.byteLength, casted_cb_packet);
                connection._logger.LogDebug(() => `Lmi Framing Data handler complete: ${result.packets} packets, has partial=${result.has_partial},
          from ${frame_size} bytes`, LogEvents_1.VidyoLogCategory.VidyoTransport);
            }
            else {
                casted_cb_packet(new Uint8Array(buffer), true);
            }
        };
        reader.readAsArrayBuffer(data);
    }
    _readPackets(socket, buffer, frame_size, messageCallback) {
        let result = {
            has_partial: false,
            packets: 0
        };
        let frame = new Uint8Array(buffer, 0);
        let packet_stream_header_size = 8;
        if (socket.unprocessed_size != 0) {
            let new_unprocessed_size = socket.unprocessed_size + frame_size;
            let new_unprocessed = new ArrayBuffer(new_unprocessed_size);
            const uint8 = new Uint8Array(new_unprocessed);
            uint8.set(socket.unprocessed, 0);
            uint8.set(frame, socket.unprocessed_size);
            socket.unprocessed = uint8;
            socket.unprocessed_size = new_unprocessed_size;
        }
        else {
            socket.unprocessed = frame;
            socket.unprocessed_size = frame_size;
        }
        this._logger.LogDebug(() => `Accumulated websocket buffer size=${socket.unprocessed_size}`, LogEvents_1.VidyoLogCategory.VidyoTransport);
        while (socket.unprocessed_size > 0) {
            frame = new Uint8Array(socket.unprocessed, 0);
            if (frame[0] == 0x4C && frame[1] == 0x4D && frame[2] == 0x00) {
                this._logger.LogDebug(() => "HEADER: OK", LogEvents_1.VidyoLogCategory.VidyoTransport);
            }
            else {
                this._logger.LogError(() => `Malformed header, reset unprocessed buffer`, LogEvents_1.VidyoLogCategory.VidyoTransport);
                socket.unprocessed_size = 0;
                break;
            }
            switch (frame[3]) {
                case 0x01:
                    this._logger.LogDebug(() => "FIN: false", LogEvents_1.VidyoLogCategory.VidyoTransport);
                    socket.fin = false;
                    break;
                case 0x00:
                    this._logger.LogDebug(() => "FIN: true", LogEvents_1.VidyoLogCategory.VidyoTransport);
                    socket.fin = true;
                    break;
                default:
                    this._logger.LogError(() => "FIN: BAD", LogEvents_1.VidyoLogCategory.VidyoTransport);
                    break;
            }
            let packet_size = frame[4] << 24 | frame[5] << 16 | frame[6] << 8 | frame[7];
            let packet = frame.subarray(packet_stream_header_size, packet_size + packet_stream_header_size);
            let read_size = packet.length;
            if (read_size < packet_size) {
                result.has_partial = true;
                this._logger.LogDebug(() => `Partial packet detected`, LogEvents_1.VidyoLogCategory.VidyoTransport);
                return result;
            }
            this._logger.LogDebug(() => `Packet complete size=${frame_size}`, LogEvents_1.VidyoLogCategory.VidyoTransport);
            socket.packet = packet;
            result.packets += 1;
            messageCallback(socket.packet, socket.fin);
            socket.unprocessed = socket.unprocessed.subarray(packet_size + packet_stream_header_size);
            socket.unprocessed_size -= packet_size + packet_stream_header_size;
        }
        return result;
    }
    _send(bytes, data) {
        let enc = new TextEncoder();
        let header;
        if (this.lmi_framing === false) {
            header = enc.encode(data);
        }
        else {
            let encoded_data = enc.encode(data);
            bytes = encoded_data.length;
            let buffer = new ArrayBuffer(8 + bytes);
            header = new Uint8Array(buffer);
            header[0] = 0x4C;
            header[1] = 0x4D;
            header[2] = 0x00;
            header[3] = 0x00;
            header[4] = bytes >> 24 & 0xFF;
            header[5] = bytes >> 16 & 0xFF;
            header[6] = bytes >> 8 & 0xFF;
            header[7] = bytes & 0xFF;
            header.set(encoded_data, 8);
        }
        this.socket.websocket.send(header);
        this._logger.LogSent(() => `Sent ${header.length} bytes ${data}`, LogEvents_1.VidyoLogCategory.VidyoTransport);
    }
}
exports.Connection = Connection;
class Socket {
    constructor(connection, ws_connection_string) {
        this.fin = false;
        this.unprocessed_size = 0;
        this.reassemblingPacket = "";
        this.connection = connection;
        this.ws_connection_string = ws_connection_string;
        this.websocket = new WebSocket(ws_connection_string);
        let that = this;
        this.websocket.onopen = function () {
            that.connection._onopen();
        };
        this.websocket.onclose = function (ev) {
            that.connection._onclose(ev);
        };
        this.websocket.onmessage = function (ev) {
            that.connection._onmessage(ev);
        };
        this.websocket.onerror = function (ev) {
            that.connection._onerror(ev);
        };
    }
}

},{"../events/LogEvents":69}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.API = void 0;
var API;
(function (API) {
    API["Simple"] = "Simple";
    API["VidyoConnector"] = "VidyoConnector";
})(API = exports.API || (exports.API = {}));

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CMCPResultCodes = exports.IsSourceNotification = exports.IsLeaveNotification = exports.GhostMode = exports.ViewPolicy = exports.SourceState = exports.SelfViewPolicy = exports.AudioPolicy = void 0;
var AudioPolicy;
(function (AudioPolicy) {
    AudioPolicy.LoudestSpeaker = 'loudestSpeaker';
})(AudioPolicy = exports.AudioPolicy || (exports.AudioPolicy = {}));
var SelfViewPolicy;
(function (SelfViewPolicy) {
    SelfViewPolicy.HideSelf = 'Hide Self';
    SelfViewPolicy.ShowSelf = 'Show Self';
    SelfViewPolicy.ShowSelfIfNoOther = 'Show Self If No Other';
})(SelfViewPolicy = exports.SelfViewPolicy || (exports.SelfViewPolicy = {}));
var SourceState;
(function (SourceState) {
    SourceState.On = 'on';
    SourceState.Off = 'off';
    SourceState.Auto = 'auto';
})(SourceState = exports.SourceState || (exports.SourceState = {}));
var ViewPolicy;
(function (ViewPolicy) {
    ViewPolicy.ShowIfNotStaticallyViewed = 'Show If Not Statically Viewed';
    ViewPolicy.ShowEvenIfStaticallyViewed = 'Show Even If Statically Viewed';
})(ViewPolicy = exports.ViewPolicy || (exports.ViewPolicy = {}));
var GhostMode;
(function (GhostMode) {
    GhostMode["NoSel"] = "noSel";
    GhostMode["NoGen"] = "noGen";
    GhostMode["Gen"] = "gen";
})(GhostMode = exports.GhostMode || (exports.GhostMode = {}));
function IsLeaveNotification(notification) {
    return notification.notify.event
        && notification.notify.event.participantPackageContent
        && notification.notify.event.participantPackageContent.participants
        && notification.notify.event.participantPackageContent.participants.some((participant) => {
            return participant.event === 'leave';
        });
}
exports.IsLeaveNotification = IsLeaveNotification;
function IsSourceNotification(notification) {
    return notification.notify.event
        && notification.notify.event.participantPackageContent
        && notification.notify.event.participantPackageContent.participants
        && notification.notify.event.participantPackageContent.participants.some((participant) => {
            return !!(participant.event === 'update' || participant.event === 'join');
        });
}
exports.IsSourceNotification = IsSourceNotification;
var CMCPResultCodes;
(function (CMCPResultCodes) {
    CMCPResultCodes["LMI_CMCPRESULTCODE_OK"] = "200";
    CMCPResultCodes["LMI_CMCPRESULTCODE_MiscClientError"] = "400";
    CMCPResultCodes["LMI_CMCPRESULTCODE_VersionNotSupported"] = "401";
    CMCPResultCodes["LMI_CMCPRESULTCODE_ProtocolViolation"] = "402";
    CMCPResultCodes["LMI_CMCPRESULTCODE_PermissionDenied"] = "403";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownDialog"] = "404";
    CMCPResultCodes["LMI_CMCPRESULTCODE_DialogTerminating"] = "405";
    CMCPResultCodes["LMI_CMCPRESULTCODE_InvalidState"] = "407";
    CMCPResultCodes["LMI_CMCPRESULTCODE_IntervalTooBrief"] = "408";
    CMCPResultCodes["LMI_CMCPRESULTCODE_NoSession"] = "458";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownSession"] = "459";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownConference"] = "460";
    CMCPResultCodes["LMI_CMCPRESULTCODE_AlreadyInConference"] = "461";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownParticipant"] = "462";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownSource"] = "463";
    CMCPResultCodes["LMI_CMCPRESULTCODE_WrongSourceType"] = "464";
    CMCPResultCodes["LMI_CMCPRESULTCODE_Glare"] = "465";
    CMCPResultCodes["LMI_CMCPRESULTCODE_SessionInUse"] = "466";
    CMCPResultCodes["LMI_CMCPRESULTCODE_SessionNotConnected"] = "467";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownPackage"] = "470";
    CMCPResultCodes["LMI_CMCPRESULTCODE_PackageSyntaxError"] = "471";
    CMCPResultCodes["LMI_CMCPRESULTCODE_UnknownResource"] = "472";
    CMCPResultCodes["LMI_CMCPRESULTCODE_MiscServerError"] = "500";
    CMCPResultCodes["LMI_CMCPRESULTCODE_NotImplemented"] = "501";
    CMCPResultCodes["LMI_CMCPRESULTCODE_ShuttingDown"] = "502";
    CMCPResultCodes["LMI_CMCPRESULTCODE_OutOfResources"] = "503";
    CMCPResultCodes["LMI_CMCPRESULTCODE_NoCryptoSupport"] = "504";
    CMCPResultCodes["LMI_CMCPRESULTCODE_ConferenceFull"] = "560";
    CMCPResultCodes["LMI_CMCPRESULTCODE_ConferenceLocked"] = "561";
})(CMCPResultCodes = exports.CMCPResultCodes || (exports.CMCPResultCodes = {}));

},{}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogIdentity = void 0;
class DialogIdentity {
    constructor(localId) {
        if (typeof localId !== 'undefined') {
            this.LocalId = localId;
        }
    }
    Clone(localId) {
        let clone = new DialogIdentity(localId);
        clone.Session = this.Session;
        clone.Conference = this.Conference;
        clone.Reflector = this.Reflector;
        return clone;
    }
    IsFinalized() {
        return !!(this.LocalId && this.Session && this.Conference && this.Reflector);
    }
    ToObject() {
        let object = {
            Session: this.Session || '',
            Conference: this.Conference || '',
            Reflector: this.Reflector || '',
            LocalId: this.LocalId
        };
        if (this.RemoteId) {
            object.RemoteId = this.RemoteId;
        }
        return object;
    }
    get Session() {
        return this._session;
    }
    set Session(session) {
        this._set('Session', '_session', session);
    }
    get LocalId() {
        return this._localId;
    }
    set LocalId(localId) {
        this._set('LocalId', '_localId', localId);
    }
    get Conference() {
        return this._conference;
    }
    set Conference(conference) {
        this._set('Conference', '_conference', conference);
    }
    get Reflector() {
        return this._reflector;
    }
    set Reflector(reflector) {
        this._set('Reflector', '_reflector', reflector);
    }
    get RemoteId() {
        return this._remoteId;
    }
    set RemoteId(remoteId) {
        this._set('RemoteId', '_remoteId', remoteId);
    }
    _readOnlyError(property) {
        return new Error(`${property} has already been set and is now read-only`);
    }
    _set(prettyName, property, value) {
        if (this[property]) {
            throw this._readOnlyError(prettyName);
        }
        else {
            this[property] = value;
        }
    }
}
exports.DialogIdentity = DialogIdentity;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = exports.SenderType = exports.MessageType = void 0;
const UUID = require("uuid");
var MessageType;
(function (MessageType) {
    MessageType["chat"] = "chat";
    MessageType["mediastart"] = "mediastart";
    MessageType["mediastop"] = "mediastop";
    MessageType["privatechat"] = "privatechat";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
var SenderType;
(function (SenderType) {
    SenderType["user"] = "user";
    SenderType["room"] = "room";
})(SenderType = exports.SenderType || (exports.SenderType = {}));
class Message {
    constructor() {
        this.objId = UUID.v4();
    }
}
exports.Message = Message;

},{"uuid":11}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Participant = exports.ParticipantAppType = exports.VidyoParticipantTrust = exports.ParticipantOrigin = exports.LocalParticipantId = void 0;
const Messages = require("../utils/Messages");
const Source_1 = require("./Source");
const StringUtils_1 = require("../utils/StringUtils");
const UUID = require("uuid");
const PromiseHelper_1 = require("../utils/PromiseHelper");
const ObjectUtils_1 = require("../utils/ObjectUtils");
exports.LocalParticipantId = 'local';
var ParticipantOrigin;
(function (ParticipantOrigin) {
    ParticipantOrigin.Local = 'local';
    ParticipantOrigin.Remote = 'remote';
})(ParticipantOrigin = exports.ParticipantOrigin || (exports.ParticipantOrigin = {}));
var VidyoParticipantTrust;
(function (VidyoParticipantTrust) {
    VidyoParticipantTrust["VIDYO_PARTICIPANTTRUST_Local"] = "VIDYO_PARTICIPANTTRUST_Local";
    VidyoParticipantTrust["VIDYO_PARTICIPANTTRUST_Federated"] = "VIDYO_PARTICIPANTTRUST_Federated";
    VidyoParticipantTrust["VIDYO_PARTICIPANTTRUST_Anonymous"] = "VIDYO_PARTICIPANTTRUST_Anonymous";
})(VidyoParticipantTrust = exports.VidyoParticipantTrust || (exports.VidyoParticipantTrust = {}));
var ParticipantAppType;
(function (ParticipantAppType) {
    ParticipantAppType.Default = 'default';
    ParticipantAppType.Recorder = 'recorder';
    ParticipantAppType.Gateway = 'gateway';
})(ParticipantAppType = exports.ParticipantAppType || (exports.ParticipantAppType = {}));
class Participant {
    constructor(Id, Origin, Name, UserId) {
        this.Id = Id;
        this.Origin = Origin;
        this.Active = false;
        this.CameraTable = {};
        this.Devices = {};
        this.Generation = Infinity;
        this.ObjId = UUID.v4();
        this.Sources = [];
        this.IsControlled = false;
        this.IsSelectable = true;
        this.IsHidden = false;
        this.IsRecording = false;
        this.IsPinned = false;
        this._trust = VidyoParticipantTrust.VIDYO_PARTICIPANTTRUST_Anonymous;
        if (!this.Id || this.Id.length === 0) {
            throw (new Error(Messages.IdCannotBeEmpty));
        }
        if (Name) {
            this.Name = Name;
        }
        if (UserId) {
            this.UserId = UserId;
        }
        this.AppType = ParticipantAppType.Default;
        let { promise: p, resolve: res } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        this._syncPromise = p;
        this._syncPromiseResolve = res;
    }
    AddDevice(ssrc, device) {
        this.Devices[ssrc] = device;
    }
    AudioMuted() {
        return this.Sources.some((source) => source.Type === Source_1.SourceMediaType.Audio && source.Paused);
    }
    CameraTableUpdate(camera) {
        this.CameraTable[camera.Id] = camera;
    }
    CameraTableRemove(cameraId) {
        if (cameraId in this.CameraTable) {
            delete this.CameraTable[cameraId];
        }
    }
    GetApplicationSources() {
        return this.Sources.filter((source) => source.Type === Source_1.SourceMediaType.Application);
    }
    GetCameraId() {
        const [videoSource] = this.GetVideoSources();
        if (videoSource) {
            return videoSource.Ssrc.find((ssrc) => this.GetDevice(ssrc));
        }
    }
    GetCameraTableItems(whereClause) {
        if (whereClause) {
            return ObjectUtils_1.default.Filter(this.CameraTable, whereClause);
        }
        else {
            return Object.values(this.CameraTable);
        }
    }
    GetDevice(ssrc) {
        return this.Devices[ssrc];
    }
    GetDynamicAudioSources() {
        return this.Sources.filter((source) => source.Type === Source_1.SourceMediaType.Audio && source.Dynamic);
    }
    GetSourceBySSrc(ssrc) {
        return this.Sources.find((source) => source.Ssrc[0] === ssrc);
    }
    GetVideoSources() {
        return this.Sources.filter((source) => source.Type === Source_1.SourceMediaType.Video);
    }
    HasAudioSource() {
        return this.Sources.some((source) => source.Type === Source_1.SourceMediaType.Audio);
    }
    HasSource(sourceId) {
        return this.Sources.some((source) => source.Ssrc[0] === sourceId);
    }
    HasVideoSource() {
        return this.Sources.some((source) => source.Type === Source_1.SourceMediaType.Video);
    }
    RemoveDevice(ssrc) {
        if (ssrc in this.Devices) {
            delete this.Devices[ssrc];
        }
    }
    get IsComplete() {
        return !!this.Origin && !!this.UserId && !!this._name;
    }
    get IsRemote() {
        return this.Origin === ParticipantOrigin.Remote;
    }
    get IsLocal() {
        return this.Origin === ParticipantOrigin.Local;
    }
    UpdateSources(sources) {
        this.Sources = sources;
    }
    set Name(name) {
        this._name = StringUtils_1.default.toSecureString(name);
    }
    get Name() {
        return this._name || this.Id;
    }
    set UserId(userId) {
        this._userId = userId;
        if (this._userId) {
            this._trust = this._userId.startsWith('User') ?
                VidyoParticipantTrust.VIDYO_PARTICIPANTTRUST_Local : VidyoParticipantTrust.VIDYO_PARTICIPANTTRUST_Anonymous;
        }
    }
    get UserId() {
        return this._userId;
    }
    set Trust(trust) {
        this._trust = trust;
    }
    get Trust() {
        return this._trust;
    }
    get IsRecorder() {
        return this.AppType == ParticipantAppType.Recorder;
    }
    NotifyJoinedEvent(notifyCb) {
        notifyCb();
        this._syncPromiseResolve();
    }
    NotifyDevicesEvents(notifyCb) {
        this._syncPromise.then(() => notifyCb());
    }
}
exports.Participant = Participant;

},{"../utils/Messages":150,"../utils/ObjectUtils":153,"../utils/PromiseHelper":157,"../utils/StringUtils":164,"./Source":98,"uuid":11}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionType = void 0;
var PermissionType;
(function (PermissionType) {
    PermissionType["camera"] = "VIDYO_PERMISSION_Camera";
    PermissionType["microphone"] = "VIDYO_PERMISSION_Microphone";
    PermissionType["geolocation"] = "VIDYO_PERMISSION_Location";
})(PermissionType = exports.PermissionType || (exports.PermissionType = {}));

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderMode = void 0;
exports.RenderMode = {
    Composite: 'Composite',
    Custom: 'Custom'
};

},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Room = void 0;
class Room {
}
exports.Room = Room;

},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Source = exports.SourceSignalType = exports.SourceType = exports.IsSourceMediaType = exports.SourceMediaType = void 0;
const UUID = require("uuid");
exports.SourceMediaType = {
    Video: 'video',
    Audio: 'audio',
    Application: 'application'
};
function IsSourceMediaType(mediaType) {
    return mediaType === 'video' || mediaType === 'audio';
}
exports.IsSourceMediaType = IsSourceMediaType;
exports.SourceType = {
    Loopback: 'loopback',
    Preview: 'preview',
    Remote: 'remote'
};
var SourceSignalType;
(function (SourceSignalType) {
    SourceSignalType["voice"] = "voice";
    SourceSignalType["unprocessed"] = "unprocessed";
})(SourceSignalType = exports.SourceSignalType || (exports.SourceSignalType = {}));
class Source {
    constructor(ssrc, name, type, Paused = false) {
        this.Paused = Paused;
        this.HasPanAndTilt = false;
        this.HasZoom = false;
        this.Name = name;
        this.Ssrc = ssrc;
        this.Type = type;
        this.ObjId = UUID.v4();
    }
}
exports.Source = Source;

},{"uuid":11}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
class User {
}
exports.User = User;

},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetResolutionFromNominalBitrate = exports.NormalizeResolution = exports.GetPreferredCodec = exports.GetStdOutgoingBandwidth = exports.CalculateRemoteSourceBitrate = exports.CalculateSendBitrate = exports.CalculatePreferredSendBitrate = exports.CalculateNominalSendBitrate = exports.CalculateMinimumSendBitrate = exports.BandwidthPreferred = exports.BandwidthNominal = exports.CodecName = exports.VideoStreamConstraints = exports.VideoResolutionSet = exports.VideoResolution = exports.AspectRatioRatioType = exports.BasicVideoResolution = void 0;
const Constants_1 = require("../utils/Constants");
class BasicVideoResolution {
    constructor(Width = 1280, Height = 720) {
        this.Width = Width;
        this.Height = Height;
    }
    get AspectRatio() { return this.Height === 0 ? 0 : this.Width / this.Height; }
    Clone() {
        return new BasicVideoResolution(this.Width, this.Height);
    }
}
exports.BasicVideoResolution = BasicVideoResolution;
var AspectRatioRatioType;
(function (AspectRatioRatioType) {
    AspectRatioRatioType["Taller"] = "Taller";
    AspectRatioRatioType["Wider"] = "Wider";
})(AspectRatioRatioType = exports.AspectRatioRatioType || (exports.AspectRatioRatioType = {}));
class VideoResolution extends BasicVideoResolution {
    constructor(Id, width, height, ContainerResolution = new BasicVideoResolution()) {
        super(width, height);
        this.Id = Id;
        this.ContainerResolution = ContainerResolution;
        this.IsApplication = false;
        this.IsPinned = false;
    }
    get AspectRatioRatio() { return this.AspectRatio === 0 ? 0 : this.ContainerResolution.AspectRatio / this.AspectRatio; }
    get AspectRatioRatioType() {
        return this.AspectRatioRatio < 1 ? AspectRatioRatioType.Wider : AspectRatioRatioType.Taller;
    }
    Clone() {
        let copyVideoResolution = new VideoResolution(this.Id, this.Width, this.Height, this.ContainerResolution.Clone());
        copyVideoResolution.IsApplication = this.IsApplication;
        copyVideoResolution.IsPinned = this.IsPinned;
        copyVideoResolution.ParticipantId = this.ParticipantId;
        return copyVideoResolution;
    }
}
exports.VideoResolution = VideoResolution;
class VideoResolutionSet {
    constructor() {
        this.ContainerResolution = new BasicVideoResolution();
        this._videoResolutions = {};
        this._fixedVideoResolutions = {};
    }
    AddFixedParticipantResolution(participantId, width, height) {
        const containerResolution = new BasicVideoResolution(width, height);
        const resolution = new VideoResolution(participantId, width, height, containerResolution);
        resolution.ParticipantId = participantId;
        this._fixedVideoResolutions[participantId] = resolution;
    }
    All() {
        return Object.values(this._videoResolutions);
    }
    AllApplications() {
        return Object.values(this._videoResolutions).filter((resolution) => resolution.IsApplication);
    }
    AllVideos() {
        return Object.values(this._videoResolutions).filter((resolution) => !resolution.IsApplication);
    }
    Get(id) {
        return this._videoResolutions[id] || new VideoResolution(id);
    }
    GetVideoByParticipantId(id) {
        return this._fixedVideoResolutions[id] ||
            Object.values(this._videoResolutions)
                .find((resolution) => resolution.ParticipantId === id && !resolution.IsApplication);
    }
    Has(id) {
        return !!this._videoResolutions[id];
    }
    RemoveFixedParticipantResolution(participantId) {
        delete this._fixedVideoResolutions[participantId];
    }
    UpdateVideoResolutions(containerResolution, videoResolutions) {
        this.ContainerResolution = containerResolution.Clone();
        this._videoResolutions = {};
        videoResolutions.forEach((videoResolution) => {
            this._videoResolutions[videoResolution.Id] = videoResolution.Clone();
        });
    }
}
exports.VideoResolutionSet = VideoResolutionSet;
class VideoStreamConstraints extends BasicVideoResolution {
    constructor(width, height, bandwidth) {
        super(width, height);
        this.Bandwidth = bandwidth;
    }
}
exports.VideoStreamConstraints = VideoStreamConstraints;
var CodecName;
(function (CodecName) {
    CodecName["H264"] = "H264";
    CodecName["H265"] = "H265";
    CodecName["VP8"] = "VP8";
    CodecName["VP9"] = "VP9";
})(CodecName = exports.CodecName || (exports.CodecName = {}));
exports.BandwidthNominal = {
    [CodecName[CodecName.H265]]: [
        new VideoStreamConstraints(160, 120, 25000),
        new VideoStreamConstraints(320, 180, 50000),
        new VideoStreamConstraints(320, 240, 50000),
        new VideoStreamConstraints(352, 288, 100000),
        new VideoStreamConstraints(640, 360, 120000),
        new VideoStreamConstraints(640, 480, 160000),
        new VideoStreamConstraints(1280, 720, 500000),
        new VideoStreamConstraints(1920, 1080, 950000)
    ],
    [CodecName[CodecName.VP8]]: [
        new VideoStreamConstraints(160, 120, 50000),
        new VideoStreamConstraints(320, 180, 84000),
        new VideoStreamConstraints(320, 240, 100000),
        new VideoStreamConstraints(352, 288, 200000),
        new VideoStreamConstraints(640, 360, 275000),
        new VideoStreamConstraints(640, 480, 320000),
        new VideoStreamConstraints(1280, 720, 1026000),
        new VideoStreamConstraints(1920, 1080, 2045000)
    ],
    [CodecName[CodecName.VP9]]: [
        new VideoStreamConstraints(160, 120, 40000),
        new VideoStreamConstraints(320, 180, 80000),
        new VideoStreamConstraints(320, 240, 80000),
        new VideoStreamConstraints(352, 288, 160000),
        new VideoStreamConstraints(640, 360, 187000),
        new VideoStreamConstraints(640, 480, 250000),
        new VideoStreamConstraints(1280, 720, 750000),
        new VideoStreamConstraints(1920, 1080, 1400000)
    ]
};
exports.BandwidthPreferred = {
    [CodecName[CodecName.H265]]: [
        new VideoStreamConstraints(160, 120, 230000),
        new VideoStreamConstraints(320, 180, 400000),
        new VideoStreamConstraints(320, 240, 400000),
        new VideoStreamConstraints(352, 288, 500000),
        new VideoStreamConstraints(640, 360, 487000),
        new VideoStreamConstraints(640, 480, 650000),
        new VideoStreamConstraints(1280, 720, 1500000),
        new VideoStreamConstraints(1920, 1080, 3000000)
    ],
    [CodecName[CodecName.VP8]]: [
        new VideoStreamConstraints(160, 120, 230000),
        new VideoStreamConstraints(320, 180, 500000),
        new VideoStreamConstraints(320, 240, 500000),
        new VideoStreamConstraints(352, 288, 670000),
        new VideoStreamConstraints(640, 360, 712000),
        new VideoStreamConstraints(640, 480, 950000),
        new VideoStreamConstraints(1280, 720, 2000000),
        new VideoStreamConstraints(1920, 1080, 4000000)
    ],
    [CodecName[CodecName.VP9]]: [
        new VideoStreamConstraints(160, 120, 230000),
        new VideoStreamConstraints(320, 180, 400000),
        new VideoStreamConstraints(320, 240, 400000),
        new VideoStreamConstraints(352, 288, 500000),
        new VideoStreamConstraints(640, 360, 487000),
        new VideoStreamConstraints(640, 480, 650000),
        new VideoStreamConstraints(1280, 720, 1500000),
        new VideoStreamConstraints(1920, 1080, 3000000)
    ]
};
function CalculateMinimumSendBitrate(codecName, aspectRatio) {
    let bandwidth = exports.BandwidthNominal[codecName].filter((constraint) => (constraint.Width / constraint.Height) == aspectRatio);
    return bandwidth[0].Bandwidth;
}
exports.CalculateMinimumSendBitrate = CalculateMinimumSendBitrate;
function CalculateNominalSendBitrate(width, height, codecName = GetPreferredCodec()) {
    let bandwidth = CalculateSendBitrate(width, height, codecName, true);
    return bandwidth;
}
exports.CalculateNominalSendBitrate = CalculateNominalSendBitrate;
function CalculatePreferredSendBitrate(width, height, codecName = GetPreferredCodec()) {
    let bandwidth = CalculateSendBitrate(width, height, codecName, false);
    return bandwidth;
}
exports.CalculatePreferredSendBitrate = CalculatePreferredSendBitrate;
function CalculateSendBitrate(width, height, codecName = GetPreferredCodec(), nominal = false) {
    const bandwidthList = nominal ? exports.BandwidthNominal[codecName] : exports.BandwidthPreferred[codecName];
    let bandwidth = null;
    if (bandwidthList) {
        let bandwidthByWidth = 0;
        let bandwidthByHeight = 0;
        bandwidthList.forEach((vsc, index) => {
            if ((0 === index || bandwidthList[index - 1].Width < width) && width <= vsc.Width) {
                bandwidthByWidth = vsc.Bandwidth;
            }
            if ((0 === index || bandwidthList[index - 1].Height < height) && height <= vsc.Height) {
                bandwidthByHeight = vsc.Bandwidth;
            }
        });
        if (bandwidthByWidth > 0 && bandwidthByHeight > 0) {
            bandwidth = Math.round((bandwidthByHeight + bandwidthByWidth) / 2);
        }
    }
    return bandwidth;
}
exports.CalculateSendBitrate = CalculateSendBitrate;
function CalculateRemoteSourceBitrate(width, height, codecName) {
    const bandwidthList = exports.BandwidthNominal[codecName];
    let bandwidth = null;
    if (bandwidthList) {
        let bandwidthByWidth = 0;
        let bandwidthByHeight = 0;
        bandwidthList.forEach((vsc, index) => {
            if ((0 === index || bandwidthList[index - 1].Width < width) && width <= vsc.Width) {
                bandwidthByWidth = vsc.Bandwidth;
            }
            if ((0 === index || bandwidthList[index - 1].Height < height) && height <= vsc.Height) {
                bandwidthByHeight = vsc.Bandwidth;
            }
        });
        if (bandwidthByWidth > 0 && bandwidthByHeight > 0) {
            bandwidth = Math.round((bandwidthByHeight + bandwidthByWidth) / 2);
        }
    }
    return bandwidth;
}
exports.CalculateRemoteSourceBitrate = CalculateRemoteSourceBitrate;
function GetStdOutgoingBandwidth(codecName, kBits = false) {
    if (!codecName) {
        codecName = GetPreferredCodec();
    }
    let bandwidth = exports.BandwidthPreferred[codecName].filter((videoStreamConstraints) => videoStreamConstraints.Height === Constants_1.DefaultLocalStreamHeight)[0].Bandwidth;
    if (kBits) {
        return Math.round(bandwidth / Constants_1.KiloCoefficient);
    }
    else {
        return bandwidth;
    }
}
exports.GetStdOutgoingBandwidth = GetStdOutgoingBandwidth;
function GetPreferredCodec() {
    return CodecName.VP8;
}
exports.GetPreferredCodec = GetPreferredCodec;
function NormalizeResolution(w, h, aspectRatio) {
    const isLocalCameraLandscape = aspectRatio >= 1;
    if ((w / h >= 1 && isLocalCameraLandscape) || (w / h < 1 && !isLocalCameraLandscape)) {
        return {
            width: w,
            height: h
        };
    }
    else {
        return {
            width: h,
            height: w
        };
    }
}
exports.NormalizeResolution = NormalizeResolution;
function GetResolutionFromNominalBitrate(codec, bitrate, aspectRatio) {
    let constraintsByBandwidth = !aspectRatio ? exports.BandwidthNominal[codec] :
        exports.BandwidthNominal[codec].filter((constraint) => (aspectRatio < 1) ?
            Math.round(Math.min(constraint.Width, constraint.Height) / Math.max(constraint.Width, constraint.Height) * 100) == Math.round(aspectRatio * 100) :
            Math.round(Math.max(constraint.Width, constraint.Height) / Math.min(constraint.Width, constraint.Height) * 100) == Math.round(aspectRatio * 100));
    let height = constraintsByBandwidth[0].Height;
    let width = constraintsByBandwidth[0].Width;
    constraintsByBandwidth = constraintsByBandwidth.filter((constraint) => (constraint.Bandwidth <= bitrate) && (constraint.Width <= Constants_1.DefaultLocalStreamWidth) && (constraint.Height <= Constants_1.DefaultLocalStreamHeight));
    if (constraintsByBandwidth.length > 0) {
        let preferredConstraint = constraintsByBandwidth[constraintsByBandwidth.length - 1];
        height = preferredConstraint.Height;
        width = preferredConstraint.Width;
    }
    return { width, height };
}
exports.GetResolutionFromNominalBitrate = GetResolutionFromNominalBitrate;

},{"../utils/Constants":138}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeccZoomControl = exports.FeccTiltControl = exports.FeccPanControl = exports.FeccCommand = exports.CameraControlCapabilities = exports.Camera = exports.CameraControl = void 0;
const Device_1 = require("./Device");
var CameraControl;
(function (CameraControl) {
    CameraControl["PanTiltMove"] = "PanTiltMove";
    CameraControl["PanTiltNudge"] = "PanTiltNudge";
    CameraControl["ZoomMove"] = "ZoomMove";
    CameraControl["ZoomNudge"] = "ZoomNudge";
    CameraControl["Visca"] = "Visca";
})(CameraControl = exports.CameraControl || (exports.CameraControl = {}));
class Camera extends Device_1.Device {
    constructor() {
        super(...arguments);
        this._controlCapabilities = new CameraControlCapabilities;
    }
    _getType() { return 'Camera'; }
    set AltId(id) {
        this._altId = id;
    }
    get AltId() {
        return this._altId;
    }
    set AspectRatioConstraints(constraints) {
        this._aspectRatioConstraints = constraints;
    }
    get AspectRatioConstraints() {
        return this._aspectRatioConstraints;
    }
    set MaxConstraints(constraints) {
        this._maxConstraints = constraints;
    }
    get MaxConstraints() {
        return this._maxConstraints;
    }
    set PreviewLabel(label) {
        this._previewLabel = label;
    }
    get PreviewLabel() {
        return this._previewLabel || 'Self View';
    }
    set ControlCapabilities(capabilities) {
        this._controlCapabilities = capabilities;
    }
    get ControlCapabilities() {
        return this._controlCapabilities;
    }
}
exports.Camera = Camera;
class CameraControlCapabilities {
    constructor(cameraControl) {
        this.panTiltHasContinuousMove = false;
        this.panTiltHasNudge = false;
        this.zoomHasContinuousMove = false;
        this.zoomHasNudge = false;
        this.hasVisca = false;
        if (cameraControl) {
            if (cameraControl.includes(CameraControl.Visca)) {
                this.panTiltHasNudge = true;
                this.zoomHasNudge = true;
                this.hasVisca = true;
            }
            else {
                this.panTiltHasContinuousMove = cameraControl.includes(CameraControl.PanTiltMove);
                this.panTiltHasNudge = cameraControl.includes(CameraControl.PanTiltNudge);
                this.zoomHasContinuousMove = cameraControl.includes(CameraControl.ZoomMove);
                this.zoomHasNudge = cameraControl.includes(CameraControl.ZoomNudge);
            }
        }
    }
}
exports.CameraControlCapabilities = CameraControlCapabilities;
var FeccCommand;
(function (FeccCommand) {
    FeccCommand["Nudge"] = "Nudge";
    FeccCommand["Start"] = "Start";
    FeccCommand["Stop"] = "Stop";
})(FeccCommand = exports.FeccCommand || (exports.FeccCommand = {}));
var FeccPanControl;
(function (FeccPanControl) {
    FeccPanControl["Left"] = "Left";
    FeccPanControl["Right"] = "Right";
})(FeccPanControl = exports.FeccPanControl || (exports.FeccPanControl = {}));
var FeccTiltControl;
(function (FeccTiltControl) {
    FeccTiltControl["Up"] = "Up";
    FeccTiltControl["Down"] = "Down";
})(FeccTiltControl = exports.FeccTiltControl || (exports.FeccTiltControl = {}));
var FeccZoomControl;
(function (FeccZoomControl) {
    FeccZoomControl["In"] = "In";
    FeccZoomControl["Out"] = "Out";
})(FeccZoomControl = exports.FeccZoomControl || (exports.FeccZoomControl = {}));

},{"./Device":102}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = void 0;
const UUID = require("uuid");
class Device {
    constructor(Name, Id, ObjId = UUID.v4()) {
        this.Name = Name;
        this.Id = Id;
        this.Type = this._getType();
        this.ObjId = ObjId;
    }
}
exports.Device = Device;

},{"uuid":11}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceList = void 0;
class DeviceList {
    constructor(DeviceClass) {
        this._defaultDevice = null;
        this._deviceList = [];
        this._deviceConstructor = DeviceClass;
    }
    Add(name, id) {
        let index = this._findDeviceIndexByID(id);
        if (index >= 0) {
            return false;
        }
        else {
            let device = new this._deviceConstructor(name, id);
            this._deviceList.push(device);
            return device;
        }
    }
    All() {
        let allDevices = [];
        let i = this._deviceList.length;
        while (i--) {
            allDevices[i] = this._deviceList[i];
        }
        return allDevices;
    }
    Find(id) {
        let index = this._findDeviceIndexByID(id);
        if (index >= 0) {
            return this._deviceList[index];
        }
        else {
            return false;
        }
    }
    GetDefaultDevice() {
        if (!this._defaultDevice) {
            return false;
        }
        else {
            let defaultDevice = this.Find(this._defaultDevice.Id);
            if (defaultDevice) {
                return defaultDevice;
            }
            else {
                throw new Error(DeviceList.notInListMsg);
            }
        }
    }
    GetFirstDevice() {
        return this._deviceList.length > 0 ? this._deviceList[0] : false;
    }
    Next(id) {
        let index = this._findDeviceIndexByID(id);
        if (index >= 0) {
            let nextIndex = (index + 1) % this._deviceList.length;
            return this._deviceList[nextIndex];
        }
        else {
            return false;
        }
    }
    Remove(id) {
        if (this._defaultDevice && this._defaultDevice.Id === id) {
            this._defaultDevice = null;
        }
        let index = this._findDeviceIndexByID(id);
        if (index >= 0) {
            this._deviceList.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    SetDefaultDevice(defaultDevice) {
        if (!defaultDevice) {
            this._defaultDevice = null;
            return;
        }
        const listedDevice = this.Find(defaultDevice.Id);
        if (listedDevice !== false) {
            this._defaultDevice = listedDevice;
            return;
        }
        else {
            throw new Error(DeviceList.notInListMsg);
        }
    }
    _findDeviceIndexByID(id) {
        return this._deviceList.findIndex((device) => device.Id === id);
    }
}
exports.DeviceList = DeviceList;
DeviceList.notInListMsg = 'Default device not in the device list';

},{}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceSelection = exports.SpeakerSelectionInfo = exports.MicrophoneSelectionInfo = exports.CameraSelectionInfo = exports.DeviceSelectionInfo = void 0;
class DeviceSelectionInfo {
    constructor() {
        this.Muted = false;
    }
    get Enabled() {
        return !this.Muted && !!this.Device;
    }
    Simplify() { return this.Device || true; }
}
exports.DeviceSelectionInfo = DeviceSelectionInfo;
class CameraSelectionInfo extends DeviceSelectionInfo {
}
exports.CameraSelectionInfo = CameraSelectionInfo;
class MicrophoneSelectionInfo extends DeviceSelectionInfo {
}
exports.MicrophoneSelectionInfo = MicrophoneSelectionInfo;
class SpeakerSelectionInfo extends DeviceSelectionInfo {
}
exports.SpeakerSelectionInfo = SpeakerSelectionInfo;
class DeviceSelection {
    constructor() {
        this.AudioContent = new MicrophoneSelectionInfo();
        this.Camera = new CameraSelectionInfo();
        this.Microphone = new MicrophoneSelectionInfo();
        this.Speaker = new SpeakerSelectionInfo();
        this.VideoContent = new CameraSelectionInfo();
    }
    SelectAudioContentShare(microphone) {
        this.AudioContent.Device = microphone;
    }
    SelectCamera(camera) {
        this.Camera.Device = camera;
    }
    SelectMicrophone(microphone) {
        this.Microphone.Device = microphone;
    }
    SelectSpeaker(speaker) {
        this.Speaker.Device = speaker;
    }
    SelectVideoContentShare(camera) {
        this.VideoContent.Device = camera;
    }
    get Simplified() {
        return {
            AudioContent: this.AudioContent.Simplify(),
            Camera: this.Camera.Simplify(),
            Microphone: this.Microphone.Simplify(),
            Speaker: this.Speaker.Simplify(),
            VideoContent: this.VideoContent.Simplify()
        };
    }
}
exports.DeviceSelection = DeviceSelection;

},{}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Microphone = void 0;
const Device_1 = require("./Device");
const Devices_1 = require("../../../vidyo_simple_api/Devices");
class Microphone extends Device_1.Device {
    constructor() {
        super(...arguments);
        this._signalType = Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Voice;
    }
    _getType() { return 'Microphone'; }
    set SignalType(signalType) {
        this._signalType = signalType;
    }
    get SignalType() {
        return this._signalType;
    }
}
exports.Microphone = Microphone;

},{"../../../vidyo_simple_api/Devices":184,"./Device":102}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Speaker = void 0;
const Device_1 = require("./Device");
class Speaker extends Device_1.Device {
    _getType() { return 'Speaker'; }
}
exports.Speaker = Speaker;

},{"./Device":102}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowShare = void 0;
const Device_1 = require("./Device");
class WindowShare extends Device_1.Device {
    _getType() { return 'WindowShare'; }
}
exports.WindowShare = WindowShare;

},{"./Device":102}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridLayout = void 0;
const ObjectUtils_1 = require("../../utils/ObjectUtils");
class GridLayout {
    constructor(_columns = 1, _rows = 1, _spaceBefore = []) {
        this._columns = _columns;
        this._rows = _rows;
        this._spaceBefore = _spaceBefore;
    }
    get Cells() { return this._columns * this._rows; }
    get Columns() { return this._columns; }
    get Rows() { return this._rows; }
    get SpaceBefore() { return this._spaceBefore; }
    Update(numberOfVideos, containerAspectRatio, averageVideoAspectRatio, fixedRowColumn) {
        let startingRows = this._rows;
        let startingColumns = this._columns;
        let startingSpaceBefore = this._spaceBefore;
        let rows;
        let columns;
        let spaceBefore = [];
        if (numberOfVideos <= 0) {
            rows = 0;
            columns = 0;
        }
        else {
            const cutoffForRowBasedLayout = 0.7;
            if ((averageVideoAspectRatio / containerAspectRatio) < cutoffForRowBasedLayout) {
                if (fixedRowColumn) {
                    rows = 1;
                }
                else {
                    let decimalRows = Math.sqrt((numberOfVideos * averageVideoAspectRatio) / containerAspectRatio);
                    rows = Math.max(Math.ceil(decimalRows - 1 + cutoffForRowBasedLayout), 1);
                }
                columns = Math.ceil(numberOfVideos / rows);
            }
            else {
                if (fixedRowColumn) {
                    columns = 1;
                }
                else {
                    let decimalColumns = Math.sqrt((numberOfVideos * containerAspectRatio) / averageVideoAspectRatio);
                    let floatColumns = Math.max(decimalColumns - 1 + cutoffForRowBasedLayout, 1);
                    columns = Number.isInteger(Math.sqrt(numberOfVideos))
                        ? Math.round(floatColumns)
                        : Math.ceil(floatColumns);
                }
                rows = Math.ceil(numberOfVideos / columns);
            }
            const extraSpacesInGrid = (rows * columns) - numberOfVideos;
            if (extraSpacesInGrid > 0) {
                spaceBefore.push(1);
            }
            if (extraSpacesInGrid > 1) {
                const firstSpaceOfLastRow = columns * (rows - 1);
                spaceBefore.push(firstSpaceOfLastRow);
            }
        }
        this._rows = rows;
        this._columns = columns;
        this._spaceBefore = spaceBefore;
        return startingRows !== rows
            || startingColumns !== columns
            || ObjectUtils_1.default.IsNotEqual(startingSpaceBefore, spaceBefore);
    }
}
exports.GridLayout = GridLayout;
GridLayout.MinimizedVideoAreaGridRows = 2;
GridLayout.VideoAreaGridCols = 12;
GridLayout.VideoAreaGridRows = 26;

},{"../../utils/ObjectUtils":153}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BandwidthSummaryStatistics = void 0;
class BandwidthSummaryStatistics {
    constructor() {
        this.ActualEncoderBitRate = 0;
        this.AvailableBandwidth = 0;
        this.AvailableRecieveBandwidth = 0;
        this.LeakyBucketDelay = 0;
        this.RetransmitBitRate = 0;
        this.TargetEncoderBitRate = 0;
        this.TotalTransmitBitRate = 0;
    }
}
exports.BandwidthSummaryStatistics = BandwidthSummaryStatistics;

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointStatistics = void 0;
const LogStatistics_1 = require("./LogStatistics");
class EndpointStatistics {
    constructor() {
        this.ApplicationTag = '';
        this.BuildTag = '';
        this.BytesReceivedTcp = 0;
        this.BytesReceivedUdp = 0;
        this.BytesSentTcp = 0;
        this.BytesSentUdp = 0;
        this.ConnectTime = '';
        this.Id = '';
        this.LibraryVersion = '';
        this.LocalCameraStats = [];
        this.LocalMicrophoneStats = [];
        this.LocalMonitorStats = [];
        this.LocalRendererStats = [];
        this.LocalSpeakerStats = [];
        this.LocalWindowShareStats = [];
        this.LoginTimeConsumedMs = 0;
        this.LogStats = new LogStatistics_1.LogStatistics();
        this.MaxBitRate = 0;
        this.MaxEncodePixelRateInitial = 0;
        this.MediaEnableTimeConsumedMs = 0;
        this.MediaRouteAcquireTimeConsumedMs = 0;
        this.NetworkInterfaceStats = [];
        this.OsName = '';
        this.OsVersion = '';
        this.ProcessorBrand = '';
        this.ProcessorLogicalCores = 0;
        this.ProcessorModel = '';
        this.ProcessorPhysicalCores = 0;
        this.ProcessorSpeed = 0;
        this.RoomEnterTimeConsumedMs = 0;
        this.TimeStamp = '';
        this.UserAgent = '';
        this.UserStats = [];
    }
    EmptyBytesCountStatistic() {
        this.BytesSentUdp = 0;
        this.BytesSentTcp = 0;
        this.BytesReceivedUdp = 0;
        this.BytesReceivedTcp = 0;
    }
}
exports.EndpointStatistics = EndpointStatistics;

},{"./LogStatistics":120}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestDataStatistics = void 0;
class LatencyTestDataStatistics {
    constructor() {
        this.Address = '';
        this.LatencyMs = 0;
        this.Latitude = 0;
        this.Longitude = 0;
        this.Name = '';
        this.ResponseReceived = false;
    }
}
exports.LatencyTestDataStatistics = LatencyTestDataStatistics;

},{}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestStatistics = void 0;
class LatencyTestStatistics {
    constructor() {
        this.LatencyTestDataStats = [];
    }
}
exports.LatencyTestStatistics = LatencyTestStatistics;

},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalMicrophoneStatistics = void 0;
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class LocalMicrophoneStatistics {
    constructor() {
        this.AecEchoCoupling = 0;
        this.AgcAverageGain = 0;
        this.AudioLevel = 0;
        this.AudioPacketsLost = 0;
        this.BitsPerSample = 0;
        this.BytesSentUdp = 0;
        this.CodecName = '';
        this.Format = '';
        this.Id = '';
        this.LocalSpeakerStreams = [];
        this.Name = '';
        this.NoiseSuppressionSnr = 0;
        this.NumberOfChannels = 0;
        this.RemoteSpeakerStreams = [];
        this.SampleRateMeasured = 0;
        this.SampleRateSet = 0;
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCOutboundRTPStreamStats(stats, +this.Id, 'Audio');
        if (rtcData) {
            this.BytesSentUdp = rtcData.bytesSent || 0;
            const codecStats = RTCStatsReportHelper_1.default.GetRTCCodecStats(stats, rtcData.codecId);
            if (codecStats) {
                this.CodecName = codecStats.mimeType;
            }
        }
        if (rtcData.hasOwnProperty('mediaSourceId')) {
            const rtcAudioSourceStats = RTCStatsReportHelper_1.default.GetRTCAudioSourceStats(stats, rtcData['mediaSourceId']);
            if (rtcAudioSourceStats) {
                this.AudioLevel = rtcAudioSourceStats.audioLevel || 0;
            }
        }
    }
}
exports.LocalMicrophoneStatistics = LocalMicrophoneStatistics;

},{"../../utils/RTCStatsReportHelper":158}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalRendererStatistics = void 0;
class LocalRendererStatistics {
    constructor() {
        this.Format = '';
        this.FrameIntervalMeasured = 0;
        this.FrameIntervalSet = 0;
        this.Height = 0;
        this.Id = '';
        this.Name = '';
        this.TotalFrames = 0;
        this.TotalPixels = 0;
        this.Width = 0;
    }
}
exports.LocalRendererStatistics = LocalRendererStatistics;

},{}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalRendererStreamStatistics = void 0;
class LocalRendererStreamStatistics {
    constructor() {
        this.BufferDropped = 0;
        this.BufferSize = 0;
        this.Height = 0;
        this.Id = '';
        this.Name = '';
        this.Width = 0;
    }
}
exports.LocalRendererStreamStatistics = LocalRendererStreamStatistics;

},{}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSpeakerStatistics = void 0;
class LocalSpeakerStatistics {
    constructor() {
        this.BitsPerSample = 0;
        this.Format = '';
        this.Id = '';
        this.Name = '';
        this.NumberOfChannels = 0;
        this.SampleRateMeasured = 0;
        this.SampleRateSet = 0;
    }
}
exports.LocalSpeakerStatistics = LocalSpeakerStatistics;

},{}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSpeakerStreamStatistics = void 0;
class LocalSpeakerStreamStatistics {
    constructor() {
        this.BitsPerSample = 0;
        this.Delay = 0;
        this.Format = '';
        this.HighestThreshold = 0;
        this.HighThreshold = 0;
        this.IsActive = false;
        this.LastEnergy = 0;
        this.LastPlayed = 0;
        this.LowestThreshold = 0;
        this.LowThreshold = 0;
        this.MaxThreshold = 0;
        this.Name = '';
        this.NumberOfChannels = 0;
        this.Overrun = 0;
        this.Played = 0;
        this.SampleRate = 0;
        this.Underrun = 0;
    }
}
exports.LocalSpeakerStreamStatistics = LocalSpeakerStreamStatistics;

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalVideoSourceStatistics = void 0;
const Constants_1 = require("../../utils/Constants");
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class LocalVideoSourceStatistics {
    constructor() {
        this.BytesSentUdp = 0;
        this.CodecName = '';
        this.CodecIFrames = 0;
        this.FirsReceived = 0;
        this.Format = '';
        this.FrameIntervalMeasured = 0;
        this.FrameIntervalSet = 0;
        this.Height = 0;
        this.Id = '';
        this.LocalRendererStreams = [];
        this.NacksReceived = 0;
        this.Name = '';
        this.PlisReceived = 0;
        this.QualityLimitationReason = '';
        this.RemoteRendererStreams = [];
        this.Runnels = [];
        this.TargetBitRate = 0;
        this.TotalFrames = 0;
        this.VideoBitRateSent = 0;
        this.VideoEncodeUsagePercent = 0;
        this.VideoFrameRateInput = 0;
        this.VideoFrameRateSent = 0;
        this.VideoFramesEncoded = 0;
        this.VideoPacketsLost = 0;
        this.VideoResolutionLimitedByBandwidth = false;
        this.VideoResolutionLimitedByCPU = false;
        this.VideoRetransimitBitRate = 0;
        this.Width = 0;
        this.QualityLimitationResolutionChanges = 0;
        this.QualityLimitationDurations = undefined;
        this.EncoderImplementation = 'unknown';
        this._lastRTCOutboundRTPStreamStats = null;
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCOutboundRTPStreamStats(stats, +this.Id, 'Video');
        if (rtcData) {
            this._fillFromRTCOutboundRTPStreamStats(rtcData);
            this._calculateFrameRateSent(rtcData);
            this._calculateBitRateSent(rtcData);
            const codecStats = RTCStatsReportHelper_1.default.GetRTCCodecStats(stats, rtcData.codecId);
            if (codecStats) {
                this.CodecName = codecStats.mimeType;
            }
            this._lastRTCOutboundRTPStreamStats = rtcData;
            if ((this.Width === 0 || this.Height === 0) && rtcData.hasOwnProperty('trackId')) {
                const rtcMediaStreamTrackStats = RTCStatsReportHelper_1.default.GetRTCMediaStreamTrackStats(stats, rtcData['trackId']);
                if (rtcMediaStreamTrackStats) {
                    this.Width = rtcMediaStreamTrackStats.frameWidth || 0;
                    this.Height = rtcMediaStreamTrackStats.frameHeight || 0;
                    if ((this.Width === 0 || this.Height === 0) && rtcData.hasOwnProperty('mediaSourceId')) {
                        const rtcVideoSourceStats = RTCStatsReportHelper_1.default.GetRTCVideoSourceStats(stats, rtcData['mediaSourceId']);
                        if (rtcVideoSourceStats) {
                            this.Width = rtcVideoSourceStats.width || 0;
                            this.Height = rtcVideoSourceStats.height || 0;
                        }
                    }
                }
            }
        }
    }
    FillFromTrack(track) {
        if (track) {
            this.Width = track.Settings.width || 0;
            this.Height = track.Settings.height || 0;
            this.FrameIntervalSet = track.Settings.frameRate || 0;
        }
    }
    _calculateBitRateSent(data) {
        if (this._lastRTCOutboundRTPStreamStats) {
            if (data.hasOwnProperty('bytesSent')) {
                let bytesSent = data['bytesSent'] || 0;
                let timestamp = data.timestamp || 0;
                let prevBytesSent = this._lastRTCOutboundRTPStreamStats['bytesSent'] || 0;
                let prevTimestamp = this._lastRTCOutboundRTPStreamStats.timestamp || 0;
                let bitRateSent = (bytesSent - prevBytesSent) / (timestamp - prevTimestamp);
                this.VideoBitRateSent = Math.max(0, Math.round(8 * bitRateSent * Constants_1.SecToMsCoefficient));
            }
            if (data.hasOwnProperty('retransmittedBytesSent')) {
                let retransmittedBytesSent = data['retransmittedBytesSent'] || 0;
                let timestamp = data.timestamp || 0;
                let prevRetransmittedBytesSent = this._lastRTCOutboundRTPStreamStats['retransmittedBytesSent'] || 0;
                let prevTimestamp = this._lastRTCOutboundRTPStreamStats.timestamp || 0;
                let bitRateSent = (retransmittedBytesSent - prevRetransmittedBytesSent) / (timestamp - prevTimestamp);
                this.VideoRetransimitBitRate = Math.max(0, Math.round(8 * bitRateSent * Constants_1.SecToMsCoefficient));
            }
        }
    }
    _calculateFrameRateSent(data) {
        if (data.hasOwnProperty('framesPerSecond')) {
            this.VideoFrameRateSent = Math.round(data['framesPerSecond']);
        }
        else if (data.hasOwnProperty('framerateMean')) {
            this.VideoFrameRateSent = Math.round(data['framerateMean']);
        }
        else if (this._lastRTCOutboundRTPStreamStats) {
            const propName = data.hasOwnProperty('framesSent') ? 'framesSent' :
                data.hasOwnProperty('framesEncoded') ? 'framesEncoded' : '';
            if (propName) {
                let framesSent = data[propName] || 0;
                let timestamp = data.timestamp || 0;
                let prevFramesSent = this._lastRTCOutboundRTPStreamStats[propName] || 0;
                let prevTimestamp = this._lastRTCOutboundRTPStreamStats.timestamp || 0;
                let fpsSent = (framesSent - prevFramesSent) / (timestamp - prevTimestamp);
                this.VideoFrameRateSent = Math.max(0, Math.round(fpsSent * Constants_1.SecToMsCoefficient));
            }
        }
        this.FrameIntervalMeasured = this.VideoFrameRateSent;
    }
    _fillFromRTCOutboundRTPStreamStats(data) {
        this.BytesSentUdp = data.bytesSent || 0;
        this.FirsReceived = data.firCount || 0;
        this.NacksReceived = data.nackCount || 0;
        this.PlisReceived = data.pliCount || 0;
        this.VideoFramesEncoded = data.framesEncoded || 0;
        this.Height = data.frameHeight || 0;
        this.Width = data.frameWidth || 0;
        this.TotalFrames = data.framesSent || data.framesEncoded || 0;
        this.QualityLimitationReason = data.qualityLimitationReason || '';
        this.CodecIFrames = data.keyFramesEncoded;
        this.VideoResolutionLimitedByCPU = this.QualityLimitationReason === 'cpu';
        this.VideoResolutionLimitedByBandwidth = this.QualityLimitationReason === 'bandwidth';
        this.QualityLimitationResolutionChanges = data.qualityLimitationResolutionChanges || 0;
        this.QualityLimitationDurations = data.qualityLimitationDurations || undefined;
        this.EncoderImplementation = data.encoderImplementation || 'unknown';
    }
}
exports.LocalVideoSourceStatistics = LocalVideoSourceStatistics;

},{"../../utils/Constants":138,"../../utils/RTCStatsReportHelper":158}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogDataStatistics = void 0;
class LogDataStatistics {
    constructor() {
        this.Name = '';
        this.Occurances = 0;
    }
}
exports.LogDataStatistics = LogDataStatistics;

},{}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogStatistics = void 0;
class LogStatistics {
    constructor() {
        this.LogErrorDataStats = [];
        this.LogWarningDataStats = [];
    }
}
exports.LogStatistics = LogStatistics;

},{}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaConnectionTransportInformation = void 0;
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class MediaConnectionTransportInformation {
    constructor() {
        this.AddressType = '';
        this.ComponentType = '';
        this.ConnectionId = 0;
        this.ConnectionType = '';
        this.ExternalLocalAddr = '';
        this.ExternalRemoteAddr = '';
        this.InterfaceName = '';
        this.InterfaceType = '';
        this.InternalLocalAddr = '';
        this.InternalRemoteAddr = '';
        this.TotalRoundTripTime = 0;
        this.TransportPlugIn = '';
    }
    FillFromRTCStats(candidatePair, stats) {
        this._fillFromCandidatePair(candidatePair, stats);
        this.ComponentType = 'RTP';
    }
    _fillFromCandidatePair(candidatePair, stats) {
        if (candidatePair) {
            let localCandidate = RTCStatsReportHelper_1.default.GetIceCandidateStats(stats, candidatePair.localCandidateId);
            if (localCandidate) {
                if (localCandidate.candidateType === 'relay') {
                    let relayProtocol = localCandidate.relayProtocol ? localCandidate.relayProtocol : 'unknown';
                    this.TransportPlugIn = `TURN ${localCandidate.protocol}/WebRTC/${relayProtocol}`.toUpperCase();
                }
                else {
                    this.TransportPlugIn = `${localCandidate.protocol}`.toUpperCase();
                }
                let address = localCandidate.address ? localCandidate.address : localCandidate.ip;
                this.InternalLocalAddr = address + ':' + localCandidate.port;
                this.ExternalLocalAddr = this.InternalLocalAddr;
            }
            let remoteCandidate = RTCStatsReportHelper_1.default.GetIceCandidateStats(stats, candidatePair.remoteCandidateId);
            if (remoteCandidate) {
                let address = remoteCandidate.address ? remoteCandidate.address : remoteCandidate.ip;
                this.InternalRemoteAddr = address + ':' + remoteCandidate.port;
                this.ExternalRemoteAddr = this.InternalRemoteAddr;
            }
            if ('totalRoundTripTime' in candidatePair) {
                this.TotalRoundTripTime = candidatePair['totalRoundTripTime'];
            }
        }
    }
}
exports.MediaConnectionTransportInformation = MediaConnectionTransportInformation;

},{"../../utils/RTCStatsReportHelper":158}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkInterfaceStatistics = void 0;
class NetworkInterfaceStatistics {
    constructor() {
        this.IsUp = false;
        this.Name = '';
        this.Type = '';
    }
}
exports.NetworkInterfaceStatistics = NetworkInterfaceStatistics;

},{}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticipantGenerationStatistics = void 0;
class ParticipantGenerationStatistics {
    constructor() {
        this.CameraId = '';
        this.CameraName = '';
        this.Enabled = false;
        this.FrameInterval = 0;
        this.Height = 0;
        this.Id = '';
        this.Name = '';
        this.PixelRate = 0;
        this.Width = 0;
    }
}
exports.ParticipantGenerationStatistics = ParticipantGenerationStatistics;

},{}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticipantStatistic = void 0;
class ParticipantStatistic {
    constructor() {
        this.Id = '';
        this.Name = '';
        this.ParticipantIsActive = false;
        this.RemoteCameraStats = [];
        this.RemoteMicrophoneStats = [];
        this.RemoteWindowShareStats = [];
        this.SSRCs = [];
        this.UserId = '';
    }
}
exports.ParticipantStatistic = ParticipantStatistic;

},{}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateShaperStatistics = void 0;
class RateShaperStatistics {
    constructor() {
        this.DelayNormal = 0;
        this.DelayRetransmit = 0;
        this.DropNormal = 0;
        this.PacketsNormal = 0;
        this.PacketsRetransmit = 0;
    }
}
exports.RateShaperStatistics = RateShaperStatistics;

},{}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteMicrophoneStatistics = void 0;
const OperatingSystemInfoProvider_1 = require("../../utils/OperatingSystemInfoProvider");
const LocalSpeakerStreamStatistics_1 = require("./LocalSpeakerStreamStatistics");
const Constants_1 = require("../../utils/Constants");
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class RemoteMicrophoneStatistics {
    constructor() {
        this.AudioBytesReceived = 0;
        this.AudioDecodingMuted = 0;
        this.AudioDecodingNormal = 0;
        this.BitsPerSample = 0;
        this.CodecDtx = 0;
        this.CodecName = '';
        this.CodecQualitySetting = 0;
        this.Id = '';
        this.LastFrameMs = 0;
        this.LocalSpeakerStreams = [];
        this.Name = '';
        this.NumberOfChannels = 0;
        this.ReceiveNetworkBitRate = 0;
        this.ReceiveNetworkDelay = 0;
        this.ReceiveNetworkDroppedPackets = 0;
        this.ReceiveNetworkJitter = 0;
        this.ReceiveNetworkPacketsConcealed = 0;
        this.ReceiveNetworkPacketsLost = 0;
        this.SampleRateMeasured = 0;
        this.SampleRateSet = 0;
        this._lastAnalyserStats = null;
        this._lastRTCInboundRTPStreamStats = null;
    }
    FillFromAudioAnalyzerStats(data) {
        if (data) {
            this.BitsPerSample = data.sampleSize;
            this.NumberOfChannels = data.channelsCount;
            this.SampleRateSet = data.sampleRate;
            this.SampleRateMeasured = data.sampleRate;
            this.LocalSpeakerStreams.forEach((localSpeakerStreams) => {
                localSpeakerStreams.BitsPerSample = data.sampleSize;
                localSpeakerStreams.NumberOfChannels = data.channelsCount;
                localSpeakerStreams.SampleRate = data.sampleRate;
            });
            this._lastAnalyserStats = data;
        }
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCInboundRTPStreamStats(stats, +this.Id, 'Audio');
        if (rtcData) {
            this.ReceiveNetworkPacketsConcealed = rtcData.concealedSamples || 0;
            this._fillFromRTCInboundRTPStreamStats(rtcData);
            const codecStats = RTCStatsReportHelper_1.default.GetRTCCodecStats(stats, rtcData.codecId);
            if (codecStats) {
                this.CodecName = codecStats.mimeType;
            }
            this._lastRTCInboundRTPStreamStats = rtcData;
        }
        else {
            this.ReceiveNetworkBitRate = 0;
        }
    }
    _calculateBitrate(data) {
        if (this._lastRTCInboundRTPStreamStats) {
            let bytesReceived = data.bytesReceived || 0;
            let timestamp = data.timestamp || 0;
            let prevBytesReceived = this._lastRTCInboundRTPStreamStats.bytesReceived || 0;
            let prevTimestamp = this._lastRTCInboundRTPStreamStats.timestamp || 0;
            let audioBitrate = Constants_1.BitsInByteValue * (bytesReceived - prevBytesReceived) / (timestamp - prevTimestamp);
            this.ReceiveNetworkBitRate = Math.floor(audioBitrate * Constants_1.SecToMsCoefficient);
        }
    }
    _fillFromRTCInboundRTPStreamStats(data) {
        this.ReceiveNetworkJitter = data.jitter || 0;
        this.AudioBytesReceived = data.bytesReceived || 0;
        this.ReceiveNetworkPacketsLost = data.packetsLost || 0;
        this._calculateBitrate(data);
        const localSpeakerStreamStats = new LocalSpeakerStreamStatistics_1.LocalSpeakerStreamStatistics();
        localSpeakerStreamStats.Delay = data.jitterBufferDelay ?? 0;
        localSpeakerStreamStats.LastEnergy = data.audioLevel ?? 0;
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox() && this._lastAnalyserStats) {
            localSpeakerStreamStats.LastEnergy = this._lastAnalyserStats.audioLevel;
        }
        this.LocalSpeakerStreams = [localSpeakerStreamStats];
    }
}
exports.RemoteMicrophoneStatistics = RemoteMicrophoneStatistics;

},{"../../utils/Constants":138,"../../utils/OperatingSystemInfoProvider":154,"../../utils/RTCStatsReportHelper":158,"./LocalSpeakerStreamStatistics":117}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteRendererStreamStatistics = void 0;
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class RemoteRendererStreamStatistics {
    constructor(Id = '', stats) {
        this.Id = Id;
        this.BitRateRequested = 0;
        this.CodecFir = 0;
        this.CodecIFrames = 0;
        this.CodecLayers = 0;
        this.CodecNacks = 0;
        this.CodecName = '';
        this.Fps = 0;
        this.FpsInput = 0;
        this.FpsRequested = 0;
        this.FpsSent = 0;
        this.FramesDropped = 0;
        this.Height = 0;
        this.HeightRequested = 0;
        this.LastHeight = 0;
        this.LastWidth = 0;
        this.Name = '';
        this.PlisReceived = 0;
        this.SendNetworkBitRate = 0;
        this.SendNetworkRtt = 0;
        this.Width = 0;
        this.WidthRequested = 0;
        if (this.Id && stats) {
            this.FillFromRTCStats(stats);
        }
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCOutboundRTPStreamStats(stats, +this.Id, 'Video');
        if (rtcData) {
            this.CodecFir = rtcData.firCount || 0;
            this.CodecIFrames = rtcData.keyFramesEncoded || 0;
            this.CodecNacks = rtcData.nackCount || 0;
            this.PlisReceived = rtcData.pliCount || 0;
            this.Fps = rtcData.framesPerSecond || 0;
            this.Width = rtcData.frameWidth || 0;
            this.Height = rtcData.frameHeight || 0;
            if ((this.Width === 0 || this.Height === 0) && rtcData.hasOwnProperty('trackId')) {
                const rtcMediaStreamTrackStats = RTCStatsReportHelper_1.default.GetRTCMediaStreamTrackStats(stats, rtcData['trackId']);
                if (rtcMediaStreamTrackStats) {
                    this.Width = rtcMediaStreamTrackStats.frameWidth || 0;
                    this.Height = rtcMediaStreamTrackStats.frameHeight || 0;
                    if ((this.Width === 0 || this.Height === 0) && rtcData.hasOwnProperty('mediaSourceId')) {
                        const rtcVideoSourceStats = RTCStatsReportHelper_1.default.GetRTCVideoSourceStats(stats, rtcData['mediaSourceId']);
                        if (rtcVideoSourceStats) {
                            this.Width = rtcVideoSourceStats.width || 0;
                            this.Height = rtcVideoSourceStats.height || 0;
                        }
                    }
                }
            }
            const rtcData2 = RTCStatsReportHelper_1.default.GetRTCRemoteInboundRTPStreamStats(stats, +this.Id, 'Video');
            if (rtcData2) {
                this.SendNetworkRtt = rtcData2.roundTripTime || 0;
            }
        }
    }
}
exports.RemoteRendererStreamStatistics = RemoteRendererStreamStatistics;

},{"../../utils/RTCStatsReportHelper":158}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSpeakerStreamStatistics = void 0;
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class RemoteSpeakerStreamStatistics {
    constructor(Id = '', stats) {
        this.Id = Id;
        this.BitsPerSample = 0;
        this.CodecDtx = 0;
        this.CodecName = '';
        this.CodecQualitySetting = 0;
        this.Name = '';
        this.NumberOfChannels = 0;
        this.SampleRate = 0;
        this.SendNetworkBitRate = 0;
        this.SendNetworkRtt = 0;
        if (this.Id && stats) {
            this.FillFromRTCStats(stats);
        }
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCRemoteInboundRTPStreamStats(stats, +this.Id, 'Audio');
        if (rtcData) {
            this.SendNetworkRtt = rtcData.roundTripTime || 0;
        }
    }
}
exports.RemoteSpeakerStreamStatistics = RemoteSpeakerStreamStatistics;

},{"../../utils/RTCStatsReportHelper":158}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteVideoSourceStatistics = void 0;
const Constants_1 = require("../../utils/Constants");
const RTCStatsReportHelper_1 = require("../../utils/RTCStatsReportHelper");
class RemoteVideoSourceStatistics {
    constructor() {
        this.CodecFir = 0;
        this.CodecIFrames = 0;
        this.CodecLayers = 0;
        this.CodecNacks = 0;
        this.CodecName = '';
        this.DecoderImplementation = 'unknown';
        this.FpsDecoded = 0;
        this.FpsDecoderInput = 0;
        this.FpsRendered = 0;
        this.Height = 0;
        this.Id = '';
        this.JitterBuffer = 0;
        this.LocalRendererStreams = [];
        this.MaxStreamFrameRate = 0;
        this.MaxStreamHeight = 0;
        this.MaxStreamWidth = 0;
        this.Name = '';
        this.PlisSent = 0;
        this.ReceiveNetworkBitRate = 0;
        this.ReceiveNetworkPacketsConcealed = 0;
        this.ReceiveNetworkPacketsLost = 0;
        this.ReceiveNetworkPacketsReordered = 0;
        this.ReceiveNetworkRecoveredWithFec = 0;
        this.ShowFrameRate = 0;
        this.ShowHeight = 0;
        this.ShowPixelRate = 0;
        this.ShowState = '';
        this.ShowWidth = 0;
        this.VideoFrameRateDecoded = 0;
        this.VideoFrameRateOutput = 0;
        this.VideoFrameRateReceived = 0;
        this.VideoFramesDecoded = 0;
        this.VideoPacketsReceived = 0;
        this.Width = 0;
        this._lastPacketsData = [];
        this._lastRTCInboundRTPStreamStats = null;
    }
    get CurrentPacketLost() {
        const Percent100 = 100;
        const currentPacketLost = this._lastPacketsData.reduce((sum, val) => sum + val.packetsLost, 0);
        const currentPacketsReceived = this._lastPacketsData.reduce((sum, val) => sum + val.packetsReceived, 0);
        const allPackets = currentPacketsReceived + currentPacketLost;
        return currentPacketLost * Percent100 / allPackets || 0;
    }
    FillFromRTCStats(stats) {
        const rtcData = RTCStatsReportHelper_1.default.GetRTCInboundRTPStreamStats(stats, +this.Id, 'Video');
        if (rtcData) {
            this._fillFromRTCInboundRTPStreamStats(rtcData);
            this._calculateFPS(rtcData);
            this._calculateBitrate(rtcData);
            const codecStats = RTCStatsReportHelper_1.default.GetRTCCodecStats(stats, rtcData.codecId);
            if (codecStats) {
                this.CodecName = codecStats.mimeType;
            }
            this._lastRTCInboundRTPStreamStats = rtcData;
            this.DecoderImplementation = rtcData.decoderImplementation || 'unknown';
            if ((this.Width === 0 || this.Height === 0) && rtcData.hasOwnProperty('trackId')) {
                const rtcMediaStreamTrackStats = RTCStatsReportHelper_1.default.GetRTCMediaStreamTrackStats(stats, rtcData['trackId']);
                if (rtcMediaStreamTrackStats) {
                    this.Width = rtcMediaStreamTrackStats.frameWidth || 0;
                    this.Height = rtcMediaStreamTrackStats.frameHeight || 0;
                }
            }
        }
        else {
            this.ReceiveNetworkBitRate = 0;
            this.FpsDecoded = 0;
            this.FpsRendered = 0;
            this.VideoFrameRateReceived = 0;
        }
    }
    _calculateBitrate(data) {
        if (data.hasOwnProperty('bitrateMean')) {
            this.ReceiveNetworkBitRate = Math.floor(data['bitrateMean']);
        }
        else if (this._lastRTCInboundRTPStreamStats) {
            let bytesReceived = data.bytesReceived || 0;
            let timestamp = data.timestamp || 0;
            let prevBytesReceived = this._lastRTCInboundRTPStreamStats.bytesReceived || 0;
            let prevTimestamp = this._lastRTCInboundRTPStreamStats.timestamp || 0;
            let videoBitrate = Constants_1.BitsInByteValue * (bytesReceived - prevBytesReceived) / (timestamp - prevTimestamp);
            this.ReceiveNetworkBitRate = Math.max(0, Math.floor(videoBitrate * Constants_1.SecToMsCoefficient));
        }
    }
    _calculateFPS(data) {
        if (data.hasOwnProperty('framesPerSecond')) {
            this.FpsDecoded = Math.round(data['framesPerSecond']);
        }
        else if (data.hasOwnProperty('framerateMean')) {
            this.FpsDecoded = Math.round(data['framerateMean']);
        }
        else if (this._lastRTCInboundRTPStreamStats) {
            const framesDecoded = data.framesDecoded || 0;
            const timestamp = data.timestamp || 0;
            const prevFramesDecoded = this._lastRTCInboundRTPStreamStats.framesDecoded || 0;
            const prevTimestamp = this._lastRTCInboundRTPStreamStats.timestamp || 0;
            const fpsDecoded = (framesDecoded - prevFramesDecoded) / (timestamp - prevTimestamp);
            this.FpsDecoded = Math.max(0, Math.round(fpsDecoded * Constants_1.SecToMsCoefficient));
        }
        this.VideoFrameRateDecoded = this.FpsDecoded;
        if (data.hasOwnProperty('framesReceived') && this._lastRTCInboundRTPStreamStats?.hasOwnProperty('framesReceived')) {
            const framesReceived = data.framesReceived || 0;
            const prevFramesReceived = this._lastRTCInboundRTPStreamStats.framesReceived || 0;
            const timestamp = data.timestamp || 0;
            const prevTimestamp = this._lastRTCInboundRTPStreamStats.timestamp || 0;
            const fpsRendered = (framesReceived - prevFramesReceived) / (timestamp - prevTimestamp);
            this.FpsRendered = Math.max(0, Math.round(fpsRendered * Constants_1.SecToMsCoefficient));
        }
        else {
            this.FpsRendered = this.FpsDecoded;
        }
        this.VideoFrameRateReceived = this.FpsRendered;
    }
    _fillFromRTCInboundRTPStreamStats(data) {
        this.CodecFir = data.firCount || 0;
        this.CodecNacks = data.nackCount || 0;
        this.ReceiveNetworkPacketsLost = data.packetsLost || 0;
        this.VideoPacketsReceived = data.packetsReceived || 0;
        this._lastPacketsData.unshift({
            packetsLost: this.ReceiveNetworkPacketsLost - (this._lastRTCInboundRTPStreamStats ? this._lastRTCInboundRTPStreamStats.packetsLost : 0),
            packetsReceived: this.VideoPacketsReceived - (this._lastRTCInboundRTPStreamStats ? this._lastRTCInboundRTPStreamStats.packetsReceived : 0)
        });
        this._lastPacketsData.length = Math.min(this._lastPacketsData.length, RemoteVideoSourceStatistics.CURRENT_PACKETS_LOST_PERIOD);
        this.PlisSent = data.pliCount || 0;
        this.Width = data.frameWidth || 0;
        this.Height = data.frameHeight || 0;
        this.VideoFramesDecoded = data.framesDecoded || 0;
        this.CodecIFrames = data.keyFramesDecoded || 0;
    }
}
exports.RemoteVideoSourceStatistics = RemoteVideoSourceStatistics;
RemoteVideoSourceStatistics.CURRENT_PACKETS_LOST_PERIOD = 10;

},{"../../utils/Constants":138,"../../utils/RTCStatsReportHelper":158}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomStatistics = void 0;
const BandwidthSummaryStatistics_1 = require("./BandwidthSummaryStatistics");
const RateShaperStatistics_1 = require("./RateShaperStatistics");
class RoomStatistics {
    constructor() {
        this.AvailableDecodeBwPercent = 0;
        this.AvailableDecodeCpuPercent = 0;
        this.AvailableEncodeBwPercent = 0;
        this.AvailableEncodeCpuPercent = 0;
        this.BandwidthApp = new BandwidthSummaryStatistics_1.BandwidthSummaryStatistics();
        this.BandwidthAudio = new BandwidthSummaryStatistics_1.BandwidthSummaryStatistics();
        this.BandwidthVideo = new BandwidthSummaryStatistics_1.BandwidthSummaryStatistics();
        this.CallId = '';
        this.ConferenceId = '';
        this.CpuUsage = 0;
        this.CurrentBandwidthDecodePixelRate = 0;
        this.CurrentBandwidthEncodePixelRate = 0;
        this.CurrentCpuDecodePixelRate = 0;
        this.CurrentCpuEncodePixelRate = 0;
        this.Id = '';
        this.MaxDecodePixelRate = 0;
        this.MaxEncodePixelRate = 0;
        this.MaxVideoSources = 0;
        this.ParticipantGenerationStats = [];
        this.ParticipantStats = [];
        this.RateShaperApp = new RateShaperStatistics_1.RateShaperStatistics();
        this.RateShaperAudio = new RateShaperStatistics_1.RateShaperStatistics();
        this.RateShaperVideo = new RateShaperStatistics_1.RateShaperStatistics();
        this.ReceiveBitRateAvailable = 0;
        this.ReceiveBitRateTotal = 0;
        this.ReflectorId = '';
        this.SendBitRateAvailable = 0;
        this.SendBitRateTotal = 0;
        this.StaticSources = 0;
        this.TransportInformation = [];
    }
}
exports.RoomStatistics = RoomStatistics;

},{"./BandwidthSummaryStatistics":109,"./RateShaperStatistics":125}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestStatistics = exports.LatencyTestDataStatistics = exports.LogStatistics = exports.LogDataStatistics = exports.UserStatistics = exports.RoomStatistics = exports.RemoteVideoSourceStatistics = exports.RemoteSpeakerStreamStatistics = exports.RemoteRendererStreamStatistics = exports.RemoteMicrophoneStatistics = exports.RateShaperStatistics = exports.ParticipantStatistic = exports.ParticipantGenerationStatistics = exports.NetworkInterfaceStatistics = exports.MediaConnectionTransportInformation = exports.LocalVideoSourceStatistics = exports.LocalSpeakerStreamStatistics = exports.LocalSpeakerStatistics = exports.LocalRendererStreamStatistics = exports.LocalRendererStatistics = exports.LocalMicrophoneStatistics = exports.EndpointStatistics = exports.BandwidthSummaryStatistics = exports.ShareStatistics = exports.ParticipantStatistics = exports.CallStatistics = void 0;
const PrettyNumber_1 = require("../../utils/PrettyNumber");
const Collection_1 = require("../../utils/Collection");
const ObjectUtils_1 = require("../../utils/ObjectUtils");
class CallStatistics {
    constructor(Id) {
        this.Id = Id;
        this.AudioBytesSent = new PrettyNumber_1.PrettyNumber();
        this.AudioCodec = '';
        this.AudioLevel = new PrettyNumber_1.PrettyNumber();
        this.AudioPacketsLost = new PrettyNumber_1.PrettyNumber();
        this.AvailableRecieveBandwidth = new PrettyNumber_1.PrettyNumber();
        this.AvailableSendBandwidth = new PrettyNumber_1.PrettyNumber();
        this.EncodeBitrate = new PrettyNumber_1.PrettyNumber();
        this.FirsReceived = new PrettyNumber_1.PrettyNumber();
        this.NacksReceived = new PrettyNumber_1.PrettyNumber();
        this.ParticipantStatistics = new Collection_1.Collection((id) => new ParticipantStatistics(id));
        this.PlisReceived = new PrettyNumber_1.PrettyNumber();
        this.RetransimitBitRate = new PrettyNumber_1.PrettyNumber();
        this.ShareStatistics = new Collection_1.Collection((id) => new ShareStatistics(id));
        this.TargetEncodeBitrate = new PrettyNumber_1.PrettyNumber();
        this.TransmitBitrate = new PrettyNumber_1.PrettyNumber();
        this.VideoBytesSent = new PrettyNumber_1.PrettyNumber();
        this.VideoCodec = '';
        this.VideoCodecIFrames = new PrettyNumber_1.PrettyNumber();
        this.VideoEncodeUsagePercent = new PrettyNumber_1.PrettyNumberWithUnits('%');
        this.VideoFrameRateInput = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateSent = new PrettyNumber_1.PrettyNumber();
        this.VideoFramesEncoded = new PrettyNumber_1.PrettyNumber();
        this.VideoPacketsLost = new PrettyNumber_1.PrettyNumber();
        this.VideoRunnels = '';
        this.VideoResolutionSent = new PrettyNumber_1.PrettyTuple('x');
    }
    get RemoteParticipantAverageFrameRate() {
        const videoFrameRateValues = this._activeParticipantsStatistics.map((p) => p.VideoFrameRateOutput.Value);
        return new PrettyNumber_1.PrettyNumber(ObjectUtils_1.default.MeanValueOfArray(videoFrameRateValues));
    }
    get RemoteParticipantAverageResolution() {
        const widths = this._activeParticipantsStatistics.map((p) => p.VideoResolutionReceived.Values[0]);
        const heights = this._activeParticipantsStatistics.map((p) => p.VideoResolutionReceived.Values[1]);
        const averageWidth = ObjectUtils_1.default.MeanValueOfArray(widths);
        const averageHeight = ObjectUtils_1.default.MeanValueOfArray(heights);
        return new PrettyNumber_1.PrettyTuple('x', averageWidth, averageHeight);
    }
    get RemoteParticipantTotalFirsSent() {
        return this._calculateStatisticsTotalBy('FirsSent');
    }
    get RemoteParticipantTotalNacksSent() {
        return this._calculateStatisticsTotalBy('NacksSent');
    }
    get RemoteParticipantTotalPlisSent() {
        return this._calculateStatisticsTotalBy('PlisSent');
    }
    FillFromBandwidthSummaryStatistics(stats) {
        this.TargetEncodeBitrate.Value = stats.TargetEncoderBitRate;
        this.TransmitBitrate.Value = stats.TotalTransmitBitRate;
        this.EncodeBitrate.Value = stats.ActualEncoderBitRate;
        this.AvailableRecieveBandwidth.Value = stats.AvailableRecieveBandwidth;
        this.AvailableSendBandwidth.Value = stats.AvailableBandwidth;
    }
    FillFromLocalMicrophoneStatistics(stats) {
        this.AudioCodec = stats.CodecName;
        this.AudioBytesSent.Value = stats.BytesSentUdp;
        this.AudioLevel.Value = stats.AudioLevel;
        this.AudioPacketsLost.Value = stats.AudioPacketsLost;
    }
    FillFromLocalVideoSourceStatistics(stats) {
        this.VideoCodec = stats.CodecName;
        this.VideoCodecIFrames.Value = stats.CodecIFrames;
        this.FirsReceived.Value = stats.FirsReceived;
        this.NacksReceived.Value = stats.NacksReceived;
        this.PlisReceived.Value = stats.PlisReceived;
        this.RetransimitBitRate.Value = stats.VideoRetransimitBitRate;
        this.VideoBytesSent.Value = stats.BytesSentUdp;
        this.VideoEncodeUsagePercent.Value = stats.VideoEncodeUsagePercent;
        this.VideoFrameRateInput.Value = stats.VideoFrameRateInput;
        this.VideoFrameRateSent.Value = stats.VideoFrameRateSent;
        this.VideoFramesEncoded.Value = stats.VideoFramesEncoded;
        this.VideoPacketsLost.Value = stats.VideoPacketsLost;
        this.VideoQualityLimitationReason = stats.QualityLimitationReason;
        this.VideoResolutionSent.SetValues(stats.Width, stats.Height);
        this.VideoResolutionLimitedByBandwidth = stats.VideoResolutionLimitedByBandwidth;
        this.VideoResolutionLimitedByCPU = stats.VideoResolutionLimitedByCPU;
        this.VideoRunnels = JSON.stringify(stats.Runnels);
    }
    get _activeParticipantsStatistics() {
        return this.ParticipantStatistics.Where({ ParticipantIsActive: true });
    }
    _calculateStatisticsTotalBy(property) {
        const INITIAL_VALUE = 0;
        const sum = (total, p) => total + p[property].Value;
        return new PrettyNumber_1.PrettyNumber(this.ParticipantStatistics.All().reduce(sum, INITIAL_VALUE));
    }
}
exports.CallStatistics = CallStatistics;
class ParticipantStatistics {
    constructor(Id) {
        this.Id = Id;
        this.ActualTileSize = new PrettyNumber_1.PrettyTuple('x');
        this.AudioBytesReceived = new PrettyNumber_1.PrettyNumber();
        this.AudioCodec = '';
        this.AvailableRecieveBandwidth = new PrettyNumber_1.PrettyNumber();
        this.AvailableSendBandwidth = new PrettyNumber_1.PrettyNumber();
        this.AudioDecodingMuted = new PrettyNumber_1.PrettyNumber();
        this.AudioDecodingNormal = new PrettyNumber_1.PrettyNumber();
        this.FirsSent = new PrettyNumber_1.PrettyNumber();
        this.JitterBuffer = new PrettyNumber_1.PrettyNumber();
        this.NacksSent = new PrettyNumber_1.PrettyNumber();
        this.PlisSent = new PrettyNumber_1.PrettyNumber();
        this.SSRCs = new PrettyNumber_1.PrettyList();
        this.VideoCodec = '';
        this.VideoCodecIFrames = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateDecoded = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateOutput = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateReceived = new PrettyNumber_1.PrettyNumber();
        this.VideoFramesDecoded = new PrettyNumber_1.PrettyNumber();
        this.VideoPacketsLost = new PrettyNumber_1.PrettyNumber();
        this.VideoPacketsReceived = new PrettyNumber_1.PrettyNumber();
        this.VideoReceiveNetworkBitRate = new PrettyNumber_1.PrettyNumber();
        this.VideoResolutionReceived = new PrettyNumber_1.PrettyTuple('x');
        this.VideoResolutionRequested = new PrettyNumber_1.PrettyTuple('x');
    }
    FillFromRemoteMicrophoneStatistics(stats) {
        this.AudioBytesReceived.Value = stats.AudioBytesReceived;
        this.AudioCodec = stats.CodecName;
        this.AudioDecodingMuted.Value = stats.AudioDecodingMuted;
        this.AudioDecodingNormal.Value = stats.AudioDecodingNormal;
    }
    FillFromRemoteVideoSourceStatistics(stats) {
        this.FirsSent.Value = stats.CodecFir;
        this.JitterBuffer.Value = stats.JitterBuffer;
        this.NacksSent.Value = stats.CodecNacks;
        this.PlisSent.Value = stats.PlisSent;
        this.VideoCodec = stats.CodecName;
        this.VideoCodecIFrames.Value = stats.CodecIFrames;
        this.VideoFrameRateDecoded.Value = stats.VideoFrameRateDecoded;
        this.VideoFrameRateOutput.Value = stats.VideoFrameRateOutput;
        this.VideoFrameRateReceived.Value = stats.VideoFrameRateReceived;
        this.VideoFramesDecoded.Value = stats.VideoFramesDecoded;
        this.VideoPacketsLost.Value = stats.ReceiveNetworkPacketsLost;
        this.VideoPacketsReceived.Value = stats.VideoPacketsReceived;
        this.VideoReceiveNetworkBitRate.Value = stats.ReceiveNetworkBitRate;
        this.VideoResolutionReceived.SetValues(stats.Width, stats.Height);
    }
}
exports.ParticipantStatistics = ParticipantStatistics;
class ShareStatistics {
    constructor(Id) {
        this.Id = Id;
        this.ActualTileSize = new PrettyNumber_1.PrettyTuple('x');
        this.FirsSent = new PrettyNumber_1.PrettyNumber();
        this.JitterBuffer = new PrettyNumber_1.PrettyNumber();
        this.NacksSent = new PrettyNumber_1.PrettyNumber();
        this.PlisSent = new PrettyNumber_1.PrettyNumber();
        this.SSRCs = new PrettyNumber_1.PrettyList();
        this.VideoCodec = '';
        this.VideoCodecIFrames = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateDecoded = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateOutput = new PrettyNumber_1.PrettyNumber();
        this.VideoFrameRateReceived = new PrettyNumber_1.PrettyNumber();
        this.VideoFramesDecoded = new PrettyNumber_1.PrettyNumber();
        this.VideoPacketsLost = new PrettyNumber_1.PrettyNumber();
        this.VideoPacketsReceived = new PrettyNumber_1.PrettyNumber();
        this.VideoReceiveNetworkBitRate = new PrettyNumber_1.PrettyNumber();
        this.VideoResolutionReceived = new PrettyNumber_1.PrettyTuple('x');
        this.VideoResolutionRequested = new PrettyNumber_1.PrettyTuple('x');
    }
    FillFromRemoteVideoSourceStatistics(stats) {
        this.FirsSent.Value = stats.CodecFir;
        this.JitterBuffer.Value = stats.JitterBuffer;
        this.NacksSent.Value = stats.CodecNacks;
        this.PlisSent.Value = stats.PlisSent;
        this.VideoCodec = stats.CodecName;
        this.VideoCodecIFrames.Value = stats.CodecIFrames;
        this.VideoFrameRateDecoded.Value = stats.VideoFrameRateDecoded;
        this.VideoFrameRateOutput.Value = stats.VideoFrameRateOutput;
        this.VideoFrameRateReceived.Value = stats.VideoFrameRateReceived;
        this.VideoFramesDecoded.Value = stats.VideoFramesDecoded;
        this.VideoPacketsLost.Value = stats.ReceiveNetworkPacketsLost;
        this.VideoPacketsReceived.Value = stats.VideoPacketsReceived;
        this.VideoReceiveNetworkBitRate.Value = stats.ReceiveNetworkBitRate;
        this.VideoResolutionReceived.SetValues(stats.Width, stats.Height);
    }
}
exports.ShareStatistics = ShareStatistics;
var BandwidthSummaryStatistics_1 = require("./BandwidthSummaryStatistics");
Object.defineProperty(exports, "BandwidthSummaryStatistics", { enumerable: true, get: function () { return BandwidthSummaryStatistics_1.BandwidthSummaryStatistics; } });
var EndpointStatistics_1 = require("./EndpointStatistics");
Object.defineProperty(exports, "EndpointStatistics", { enumerable: true, get: function () { return EndpointStatistics_1.EndpointStatistics; } });
var LocalMicrophoneStatistics_1 = require("./LocalMicrophoneStatistics");
Object.defineProperty(exports, "LocalMicrophoneStatistics", { enumerable: true, get: function () { return LocalMicrophoneStatistics_1.LocalMicrophoneStatistics; } });
var LocalRendererStatistics_1 = require("./LocalRendererStatistics");
Object.defineProperty(exports, "LocalRendererStatistics", { enumerable: true, get: function () { return LocalRendererStatistics_1.LocalRendererStatistics; } });
var LocalRendererStreamStatistics_1 = require("./LocalRendererStreamStatistics");
Object.defineProperty(exports, "LocalRendererStreamStatistics", { enumerable: true, get: function () { return LocalRendererStreamStatistics_1.LocalRendererStreamStatistics; } });
var LocalSpeakerStatistics_1 = require("./LocalSpeakerStatistics");
Object.defineProperty(exports, "LocalSpeakerStatistics", { enumerable: true, get: function () { return LocalSpeakerStatistics_1.LocalSpeakerStatistics; } });
var LocalSpeakerStreamStatistics_1 = require("./LocalSpeakerStreamStatistics");
Object.defineProperty(exports, "LocalSpeakerStreamStatistics", { enumerable: true, get: function () { return LocalSpeakerStreamStatistics_1.LocalSpeakerStreamStatistics; } });
var LocalVideoSourceStatistics_1 = require("./LocalVideoSourceStatistics");
Object.defineProperty(exports, "LocalVideoSourceStatistics", { enumerable: true, get: function () { return LocalVideoSourceStatistics_1.LocalVideoSourceStatistics; } });
var MediaConnectionTransportInformation_1 = require("./MediaConnectionTransportInformation");
Object.defineProperty(exports, "MediaConnectionTransportInformation", { enumerable: true, get: function () { return MediaConnectionTransportInformation_1.MediaConnectionTransportInformation; } });
var NetworkInterfaceStatistics_1 = require("./NetworkInterfaceStatistics");
Object.defineProperty(exports, "NetworkInterfaceStatistics", { enumerable: true, get: function () { return NetworkInterfaceStatistics_1.NetworkInterfaceStatistics; } });
var ParticipantGenerationStatistics_1 = require("./ParticipantGenerationStatistics");
Object.defineProperty(exports, "ParticipantGenerationStatistics", { enumerable: true, get: function () { return ParticipantGenerationStatistics_1.ParticipantGenerationStatistics; } });
var ParticipantStatistic_1 = require("./ParticipantStatistic");
Object.defineProperty(exports, "ParticipantStatistic", { enumerable: true, get: function () { return ParticipantStatistic_1.ParticipantStatistic; } });
var RateShaperStatistics_1 = require("./RateShaperStatistics");
Object.defineProperty(exports, "RateShaperStatistics", { enumerable: true, get: function () { return RateShaperStatistics_1.RateShaperStatistics; } });
var RemoteMicrophoneStatistics_1 = require("./RemoteMicrophoneStatistics");
Object.defineProperty(exports, "RemoteMicrophoneStatistics", { enumerable: true, get: function () { return RemoteMicrophoneStatistics_1.RemoteMicrophoneStatistics; } });
var RemoteRendererStreamStatistics_1 = require("./RemoteRendererStreamStatistics");
Object.defineProperty(exports, "RemoteRendererStreamStatistics", { enumerable: true, get: function () { return RemoteRendererStreamStatistics_1.RemoteRendererStreamStatistics; } });
var RemoteSpeakerStreamStatistics_1 = require("./RemoteSpeakerStreamStatistics");
Object.defineProperty(exports, "RemoteSpeakerStreamStatistics", { enumerable: true, get: function () { return RemoteSpeakerStreamStatistics_1.RemoteSpeakerStreamStatistics; } });
var RemoteVideoSourceStatistics_1 = require("./RemoteVideoSourceStatistics");
Object.defineProperty(exports, "RemoteVideoSourceStatistics", { enumerable: true, get: function () { return RemoteVideoSourceStatistics_1.RemoteVideoSourceStatistics; } });
var RoomStatistics_1 = require("./RoomStatistics");
Object.defineProperty(exports, "RoomStatistics", { enumerable: true, get: function () { return RoomStatistics_1.RoomStatistics; } });
var UserStatistics_1 = require("./UserStatistics");
Object.defineProperty(exports, "UserStatistics", { enumerable: true, get: function () { return UserStatistics_1.UserStatistics; } });
var LogDataStatistics_1 = require("./LogDataStatistics");
Object.defineProperty(exports, "LogDataStatistics", { enumerable: true, get: function () { return LogDataStatistics_1.LogDataStatistics; } });
var LogStatistics_1 = require("./LogStatistics");
Object.defineProperty(exports, "LogStatistics", { enumerable: true, get: function () { return LogStatistics_1.LogStatistics; } });
var LatencyTestDataStatistics_1 = require("./LatencyTestDataStatistics");
Object.defineProperty(exports, "LatencyTestDataStatistics", { enumerable: true, get: function () { return LatencyTestDataStatistics_1.LatencyTestDataStatistics; } });
var LatencyTestStatistics_1 = require("./LatencyTestStatistics");
Object.defineProperty(exports, "LatencyTestStatistics", { enumerable: true, get: function () { return LatencyTestStatistics_1.LatencyTestStatistics; } });

},{"../../utils/Collection":137,"../../utils/ObjectUtils":153,"../../utils/PrettyNumber":156,"./BandwidthSummaryStatistics":109,"./EndpointStatistics":110,"./LatencyTestDataStatistics":111,"./LatencyTestStatistics":112,"./LocalMicrophoneStatistics":113,"./LocalRendererStatistics":114,"./LocalRendererStreamStatistics":115,"./LocalSpeakerStatistics":116,"./LocalSpeakerStreamStatistics":117,"./LocalVideoSourceStatistics":118,"./LogDataStatistics":119,"./LogStatistics":120,"./MediaConnectionTransportInformation":121,"./NetworkInterfaceStatistics":122,"./ParticipantGenerationStatistics":123,"./ParticipantStatistic":124,"./RateShaperStatistics":125,"./RemoteMicrophoneStatistics":126,"./RemoteRendererStreamStatistics":127,"./RemoteSpeakerStreamStatistics":128,"./RemoteVideoSourceStatistics":129,"./RoomStatistics":130,"./UserStatistics":132}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserStatistics = void 0;
const LatencyTestStatistics_1 = require("./LatencyTestStatistics");
class UserStatistics {
    constructor() {
        this.Host = '';
        this.Id = '';
        this.LatencyTestStats = new LatencyTestStatistics_1.LatencyTestStatistics();
        this.Port = 0;
        this.RoomStats = [];
        this.ServiceType = '';
    }
}
exports.UserStatistics = UserStatistics;

},{"./LatencyTestStatistics":112}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadOnlyMediaStream = void 0;
const ReadOnlyMediaTrack_1 = require("./ReadOnlyMediaTrack");
class ReadOnlyMediaStream {
    constructor(_mediaStream) {
        this._mediaStream = _mediaStream;
        this._callbacksToRemove = [];
    }
    GetAudioTracks() {
        return this._mediaStream.getAudioTracks().map((track) => new ReadOnlyMediaTrack_1.ReadOnlyMediaTrack(track));
    }
    GetMediaStream() {
        return this._mediaStream;
    }
    GetTracks() {
        return this._mediaStream.getTracks().map((track) => new ReadOnlyMediaTrack_1.ReadOnlyMediaTrack(track));
    }
    GetVideoTracks() {
        return this._mediaStream.getVideoTracks().map((track) => new ReadOnlyMediaTrack_1.ReadOnlyMediaTrack(track));
    }
    OnTrackAdded(callback) {
        this._mediaStream.addEventListener('addtrack', callback, false, true);
        this._callbacksToRemove.push(new CallbackRecord('addtrack', callback));
    }
    OnTrackEnabledChanged(callback) {
        this._mediaStream.addEventListener('trackenabledchanged', callback, false, true);
        this._callbacksToRemove.push(new CallbackRecord('trackenabledchanged', callback));
    }
    OnTrackRemoved(callback) {
        this._mediaStream.addEventListener('removetrack', callback, false, true);
        this._callbacksToRemove.push(new CallbackRecord('removetrack', callback));
    }
    UnregisterEventListeners() {
        this._callbacksToRemove.forEach((c) => this._mediaStream.removeEventListener(c.EventType, c.Listener));
    }
    get Id() {
        return this._mediaStream.id;
    }
}
exports.ReadOnlyMediaStream = ReadOnlyMediaStream;
class CallbackRecord {
    constructor(EventType, listener) {
        this.EventType = EventType;
        this.Listener = listener;
    }
}

},{"./ReadOnlyMediaTrack":134}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadOnlyMediaTrack = void 0;
const Source_1 = require("../Source");
class ReadOnlyMediaTrack {
    constructor(_mediaTrack) {
        this._mediaTrack = _mediaTrack;
    }
    IsActive() {
        return this.Enabled && !this.Muted;
    }
    get Enabled() {
        return this._mediaTrack.enabled;
    }
    get Id() {
        return this._mediaTrack.id;
    }
    get Kind() {
        let kind = this._mediaTrack.kind;
        if ((0, Source_1.IsSourceMediaType)(kind)) {
            return kind;
        }
        else {
            throw new Error(`Unknown track type: ${kind}`);
        }
    }
    get Label() {
        return this._mediaTrack.label;
    }
    get Muted() {
        return this._mediaTrack.muted;
    }
    get Settings() {
        return this._mediaTrack.getSettings();
    }
}
exports.ReadOnlyMediaTrack = ReadOnlyMediaTrack;

},{"../Source":98}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssignHiddenPropertyValue = void 0;
function AssignHiddenPropertyValue(object, propertyKey, value) {
    Object.defineProperty(object, propertyKey, { get: () => value, configurable: true });
}
exports.AssignHiddenPropertyValue = AssignHiddenPropertyValue;

},{}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAutoProperties = void 0;
function CreateAutoProperties(mixin, thisObject, makeDescriptor) {
    let TemplateClass = mixin(Object);
    let template = new TemplateClass();
    Object.getOwnPropertyNames(template).forEach((property) => Object.defineProperty(thisObject, property, makeDescriptor(property)));
}
exports.CreateAutoProperties = CreateAutoProperties;

},{}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = exports.DataWithId = void 0;
const ObjectUtils_1 = require("./ObjectUtils");
class DataWithId {
    constructor(Id, Data) {
        this.Id = Id;
        this.Data = Data;
    }
}
exports.DataWithId = DataWithId;
class Collection {
    constructor(_createDefaultValue) {
        this._createDefaultValue = _createDefaultValue;
        this._collection = {};
    }
    Add(item) {
        this._collection[item.Id] = item;
    }
    All() {
        return Object.values(this._collection);
    }
    Create(id) {
        let item = this._createDefaultValue(id);
        this._collection[id] = item;
        return item;
    }
    Get(id) {
        if (!this._collection[id]) {
            this.Create(id);
        }
        return this._collection[id];
    }
    Remove(id) {
        delete this._collection[id];
    }
    Where(whereClause) {
        return ObjectUtils_1.default.Filter(this._collection, whereClause);
    }
}
exports.Collection = Collection;

},{"./ObjectUtils":153}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LibVersion = exports.ReflectorPoolsURL = exports.Threshold = exports.MaxBitratePerStream = exports.SubscriptionDialogDuration = exports.StreamMonitoringInterval = exports.ResourceManagerInitializationPeriod = exports.ResourceManagerStatisticsAnalyzingInterval = exports.ResourceManagerStatisticsMeasuringInterval = exports.SendClientStatisticsInterval = exports.StatisticsRefreshInterval = exports.SecToMsCoefficient = exports.ResourceIdDomainSeparator = exports.PreviewParticipantId = exports.MobileParticipantLimit = exports.RestrictedParticipantLimit = exports.ParticipantLimit = exports.NumberOfSelectedAudioSources = exports.Muc = exports.KiloCoefficient = exports.BatchTimeOut = exports.AtomicTimeOut = exports.MinimumLocalStreamWidth = exports.MinimumLocalStreamHeight = exports.GoogleAnalyticsLocalStorageCIDKey = exports.GoogleAnalyticsEventTableKey = exports.GoogleAnalyticsTrackingID = exports.GoogleAnalyticsBaseURL = exports.EventServerConnectingTimeout = exports.DeviceDetectionDalay = exports.DefaultTurnsPort = exports.DefaultTurnPort = exports.DefaultTimeOut = exports.DefaultSelfViewPolicy = exports.DefaultPort = exports.DefaultLocalShareStreamWidth = exports.DefaultLocalShareStreamHeight = exports.DefaultLocalShareStreamFrameRate = exports.DefaultLocalStreamWidth = exports.DefaultLocalStreamHeight = exports.DefaultLocalStreamFrameRate = exports.DefaultSignalingBandwidth = exports.DefaultContentShareBandwidth = exports.DefaultAudioBandwidth = exports.ScreenRefreshRate = exports.ChatMessageSizeLimit = exports.BitsInByteValue = exports.BaseTenRadix = exports.ApplicationName = exports.ApplicationTag = void 0;
exports.VideoMediaTrackContentHints = exports.RoomStatePollingIntervalMs = exports.MinCameraResolutionHeightForSimulcast = exports.MinCameraResolutionWidthForSimulcast = exports.FeccMoveInterval = exports.FeccZoomInterval = exports.FeccNudgeInterval = exports.FeccMoveDurationNs = exports.FeccMoveDurationMs = exports.WindowsMinHardwareConcurency = exports.VideoExcludeCodec = exports.VideoOutboundCodecPreference = exports.VideoInboundCodecPreference = exports.Runnels = exports.LogsPushIntervalMin = exports.LogsPushIntervalMax = exports.LogsPushIntervalDefault = exports.LocationCheckTimeout = exports.LatencyCheckTimeout = exports.MaxDisplayNameLength = exports.LocationConstraint = exports.MediaConstraints = exports.OutgoingBandwidthCalculationInterval = exports.LibBuild = void 0;
const ConferenceCommandParameters_1 = require("../models/ConferenceCommandParameters");
const OperatingSystemInfoProvider_1 = require("./OperatingSystemInfoProvider");
exports.ApplicationTag = 'NativeWebRTC';
exports.ApplicationName = 'VidyoConnectorWebRTC';
exports.BaseTenRadix = 10;
exports.BitsInByteValue = 8;
exports.ChatMessageSizeLimit = 1024;
exports.ScreenRefreshRate = 60;
exports.DefaultAudioBandwidth = 50000;
exports.DefaultContentShareBandwidth = 100000;
exports.DefaultSignalingBandwidth = 150000;
exports.DefaultLocalStreamFrameRate = 30;
exports.DefaultLocalStreamHeight = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice() ? 480 : 720;
exports.DefaultLocalStreamWidth = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice() ? 640 : 1280;
exports.DefaultLocalShareStreamFrameRate = 3;
exports.DefaultLocalShareStreamHeight = 1080;
exports.DefaultLocalShareStreamWidth = 1920;
exports.DefaultPort = 443;
exports.DefaultSelfViewPolicy = ConferenceCommandParameters_1.SelfViewPolicy.HideSelf;
exports.DefaultTimeOut = 60;
exports.DefaultTurnPort = 80;
exports.DefaultTurnsPort = 443;
exports.DeviceDetectionDalay = 3000;
exports.EventServerConnectingTimeout = 5000;
exports.GoogleAnalyticsBaseURL = 'https://www.google-analytics.com';
exports.GoogleAnalyticsTrackingID = 'UA-196387678-1';
exports.GoogleAnalyticsEventTableKey = 'VidyoCore::GA:EventTable';
exports.GoogleAnalyticsLocalStorageCIDKey = 'VidyoCore::GA:ClientID';
exports.MinimumLocalStreamHeight = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice() ? 120 : 180;
exports.MinimumLocalStreamWidth = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice() ? 160 : 320;
exports.AtomicTimeOut = 15;
exports.BatchTimeOut = 30;
exports.KiloCoefficient = 1000;
exports.Muc = '@muc.';
exports.NumberOfSelectedAudioSources = 3;
exports.ParticipantLimit = 8;
exports.RestrictedParticipantLimit = 4;
exports.MobileParticipantLimit = 1;
exports.PreviewParticipantId = '__preview';
exports.ResourceIdDomainSeparator = '_';
exports.SecToMsCoefficient = 1000;
exports.StatisticsRefreshInterval = 1000;
exports.SendClientStatisticsInterval = 10213;
exports.ResourceManagerStatisticsMeasuringInterval = 1000;
exports.ResourceManagerStatisticsAnalyzingInterval = 15000;
exports.ResourceManagerInitializationPeriod = 15000;
exports.StreamMonitoringInterval = 250;
exports.SubscriptionDialogDuration = 3600;
exports.MaxBitratePerStream = 3000000;
exports.Threshold = 0.1;
exports.ReflectorPoolsURL = '/static/poolreflectors.json';
exports.LibVersion = '22.1.0';
exports.LibBuild = '0051';
exports.OutgoingBandwidthCalculationInterval = 10000;
exports.MediaConstraints = { audio: true, video: true };
exports.LocationConstraint = false;
exports.MaxDisplayNameLength = 255;
exports.LatencyCheckTimeout = 1000;
exports.LocationCheckTimeout = exports.LatencyCheckTimeout;
exports.LogsPushIntervalDefault = 1000;
exports.LogsPushIntervalMax = 5000;
exports.LogsPushIntervalMin = 100;
exports.Runnels = ['hi', 'mid', 'lo'];
exports.VideoInboundCodecPreference = ['VP8', 'VP9'];
exports.VideoOutboundCodecPreference = ['preVP9', 'VP8'];
exports.VideoExcludeCodec = 'H264';
exports.WindowsMinHardwareConcurency = 4;
exports.FeccMoveDurationMs = 300;
exports.FeccMoveDurationNs = 300000000;
exports.FeccNudgeInterval = 500;
exports.FeccZoomInterval = 650;
exports.FeccMoveInterval = 150;
exports.MinCameraResolutionWidthForSimulcast = 320;
exports.MinCameraResolutionHeightForSimulcast = 180;
exports.RoomStatePollingIntervalMs = 2000;
exports.VideoMediaTrackContentHints = { motion: 'motion', detail: 'detail', text: 'text', none: '' };

},{"../models/ConferenceCommandParameters":91,"./OperatingSystemInfoProvider":154}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplemented = exports.debounce = void 0;
const Messages_1 = require("./Messages");
function debounce(delay = 0) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        let timeout = null;
        descriptor.value = function (...args) {
            if (timeout) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
                originalMethod.apply(this, args);
                timeout = null;
            }, delay);
        };
        return descriptor;
    };
}
exports.debounce = debounce;
function notImplemented(target, propertyKey, descriptor) {
    descriptor.value = function (...args) {
        throw new Error(Messages_1.NotImplemented);
    };
    return descriptor;
}
exports.notImplemented = notImplemented;

},{"./Messages":150}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointInfoProvider = void 0;
const Constants_1 = require("./Constants");
const OperatingSystemInfoProvider_1 = require("./OperatingSystemInfoProvider");
class EndpointInfoProvider {
    static set ApplicationName(name) {
        EndpointInfoProvider._applicationName = name;
    }
    static get ApplicationName() {
        return EndpointInfoProvider._applicationName;
    }
    static set ApplicationOS(os) {
        EndpointInfoProvider._applicationOS = os;
    }
    static get ApplicationOS() {
        return EndpointInfoProvider._applicationOS;
    }
    static set ApplicationVersion(version) {
        EndpointInfoProvider._applicationVersion = version;
    }
    static get ApplicationVersion() {
        return EndpointInfoProvider._applicationVersion;
    }
    static _getDefaultApplicationOS() {
        const osInfo = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.GetOSInfo();
        let osName = osInfo.OSName;
        if (osName.includes('Mac OS X')) {
            osName = 'macOS';
        }
        const osDetail = `${osName} ${osInfo.OSVersion}`;
        const browserName = OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.BrowserName;
        return `${browserName} ${osDetail}`;
    }
}
exports.EndpointInfoProvider = EndpointInfoProvider;
EndpointInfoProvider._applicationName = Constants_1.ApplicationName;
EndpointInfoProvider._applicationOS = EndpointInfoProvider._getDefaultApplicationOS();
EndpointInfoProvider._applicationVersion = `${Constants_1.LibVersion}.${Constants_1.LibBuild}`;

},{"./Constants":138,"./OperatingSystemInfoProvider":154}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotValidClientError = exports.TimeOutError = exports.DuplicateNameError = void 0;
class DuplicateNameError extends Error {
    constructor(message) {
        super(message);
        this.name = DuplicateNameError.Name;
    }
}
exports.DuplicateNameError = DuplicateNameError;
DuplicateNameError.Name = 'DuplicateNameError';
class TimeOutError extends Error {
    constructor(message) {
        super(message);
        this.name = TimeOutError.Name;
    }
}
exports.TimeOutError = TimeOutError;
TimeOutError.Name = 'TimeOutError';
class NotValidClientError extends Error {
    constructor(message) {
        super(message);
        this.name = NotValidClientError.Name;
    }
}
exports.NotValidClientError = NotValidClientError;
NotValidClientError.Name = 'NotValidClientError';

},{}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateEventList = exports.EventListBase = exports.EventDescriptor = void 0;
class EventDescriptor {
    constructor(name) {
        this.setEventName(name);
    }
    Scoped(scope) {
        return new EventDescriptor(`${this.toString()}:${scope}`);
    }
    setEventName(name) {
        this._name = name || '';
    }
    slice(...args) {
        return this.toString().slice(...args);
    }
    toString() {
        return this._name;
    }
}
exports.EventDescriptor = EventDescriptor;
class EventListBase {
}
exports.EventListBase = EventListBase;
function CreateEventList(namespace, EventMapClass) {
    let eventMap = new EventMapClass();
    for (let key of Object.keys(eventMap)) {
        eventMap[key].setEventName(`${namespace}:${key}`);
    }
    return eventMap;
}
exports.CreateEventList = CreateEventList;

},{}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FiniteStateMachine = void 0;
class FiniteStateMachine {
    constructor(_state, _logger, getTransitions) {
        this._state = _state;
        this._logger = _logger;
        this._transitions = getTransitions(this);
    }
    get State() {
        return this._state;
    }
    set State(state) {
        this._logger.LogDebug(() => `Next state: ${state}`);
        this._state = state;
    }
    dispatch(reconnectAction, ...params) {
        const action = this._transitions[this._state][reconnectAction];
        if (action) {
            this._logger.LogDebug(() => `State: ${this._state}, Handle action: ${reconnectAction}`);
            action(...params);
        }
        else {
            this._logger.LogDebug(() => `State: ${this._state}, Invalid action: ${reconnectAction}`);
        }
    }
}
exports.FiniteStateMachine = FiniteStateMachine;

},{}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleAnalyticsProvider = void 0;
const XmlHttpRequest_1 = require("./XmlHttpRequest");
const Constants_1 = require("./Constants");
class GoogleAnalyticsProvider {
    static SendEvent(options) {
        if (GoogleAnalyticsProvider.isDisabled) {
            return Promise.resolve(false);
        }
        const queryData = {
            v: '1',
            t: 'event',
            tid: options.trackingID,
            ec: options.eventCategory,
            ea: options.eventAction
        };
        if (options.eventLabel) {
            queryData.el = options.eventLabel;
        }
        if (options.clientId) {
            queryData.cid = options.clientId;
        }
        const searchParams = new URLSearchParams(queryData);
        const url = `${GoogleAnalyticsProvider.baseURL}/collect?${searchParams.toString()}`;
        return (0, XmlHttpRequest_1.Get)({ url }).then(() => {
            return Promise.resolve(true);
        }).catch((err) => {
            return Promise.resolve(false);
        });
    }
}
exports.GoogleAnalyticsProvider = GoogleAnalyticsProvider;
GoogleAnalyticsProvider.baseURL = Constants_1.GoogleAnalyticsBaseURL;
GoogleAnalyticsProvider.isDisabled = false;

},{"./Constants":138,"./XmlHttpRequest":173}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function Decorate(constructor) {
    [constructor, constructor.prototype].forEach((target) => {
        const methodNames = Object.getOwnPropertyNames(target)
            .filter((name) => {
            return typeof target[name] === 'function'
                && name !== 'constructor'
                && !name.startsWith('_');
        });
        for (let key of methodNames) {
            let nativeMethod = target[key];
            target[key] = function (...args) {
                validate(target, key, args);
                return nativeMethod.apply(this, args);
            };
        }
    });
}
exports.default = Decorate;
function validate(target, key, args) {
    let className = typeof target === 'function' ? target.name : target.constructor.name;
    if (Arguments[key]) {
        let actualArgs = [...args];
        let expectedArgs = Arguments[key];
        if (Array.isArray(expectedArgs)) {
            actualArgs = [objectify(args)];
            expectedArgs = {
                required: objectify(Arguments[key])
            };
        }
        else if (args.length !== 1 || typeof args[0] !== 'object' || args[0] === null) {
            throw `${className}::${key}: 'Method accepts 1 argument with type of "object"`;
        }
        void function inspect(actualArgs, expectedArgs) {
            let completeArgs = { ...{ required: {}, optional: {} }, ...expectedArgs };
            let flatArgs = { ...completeArgs.required, ...completeArgs.optional };
            let requiredKeys = getObjectKeys(completeArgs.required);
            let optionalKeys = getObjectKeys(completeArgs.optional);
            let actualKeys = getObjectKeys(actualArgs[0]);
            let completeKeys = [...requiredKeys, ...optionalKeys];
            let diff = actualKeys.filter((k) => !completeKeys.includes(k));
            if (diff.length) {
                throw `${className}::${key}: Unexpected propert${diff.length > 1 ? 'ies' : 'y'}: ` +
                    `{ ${diff.toString().replace(/\,/g, ', ')} }`;
            }
            for (let prop in flatArgs) {
                if (prop) {
                    if (typeof flatArgs[prop] === 'object' && flatArgs[prop] !== null) {
                        for (let actualArg of actualArgs) {
                            if (typeof actualArg[prop] === 'object' && actualArg[prop] !== null) {
                                inspect([actualArg[prop]], flatArgs[prop]);
                            }
                            else if (prop in actualArg && completeKeys.includes(prop)) {
                                throw `${className}::${key}: Invalid interface.` +
                                    `\n\nActual: ${JSON.stringify({ [prop]: actualArg[prop] }, null, 2)}` +
                                    `\n\nRequired: ${JSON.stringify({ [prop]: getRequiredNestedInteface(flatArgs[prop]) }, null, 2)}`;
                            }
                        }
                    }
                    else if (actualArgs[0] && !actualArgs[0].hasOwnProperty(prop) && requiredKeys.includes(prop)) {
                        throw `${className}::${key}: Missing property "${prop}": "${flatArgs[prop]}"`;
                    }
                    else if (!flatArgs[prop].split('|').includes(typeOf(actualArgs[0][prop])) && actualArgs[0][prop] !== undefined) {
                        let actualType = actualArgs[0][prop] === null ? 'null' : typeof actualArgs[0][prop];
                        throw `${className}::${key}: Invalid type of property "${prop}".` +
                            `\n\r  Expected type: ${flatArgs[prop]}, but actually got a ${actualType}`;
                    }
                }
            }
        }(actualArgs, expectedArgs);
    }
    else if (args.length) {
        throw `${className}::${key}: Method doesn't accept any arguments`;
    }
}
function typeOf(argument) {
    return typeof argument === 'object' && !argument ? 'null' : typeof argument;
}
function getObjectKeys(o) {
    return o && typeof o === 'object' ? Object.keys(o) : [];
}
function getRequiredNestedInteface(obj) {
    const result = {};
    if (typeof obj === 'object' && obj !== null) {
        for (let key in obj) {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                if (obj[key].required) {
                    result[key] = getRequiredNestedInteface(obj[key].required);
                }
                else if (obj[key].optional) {
                    result[key] = 'object';
                }
                else {
                    return getRequiredNestedInteface(obj[key]);
                }
            }
            else {
                result[key] = obj[key];
            }
        }
    }
    return result;
}
function objectify(array) {
    return array.reduce((a, b, i) => Object.assign(a, { [`argument[${i}]`]: b }), {});
}
const Arguments = Object.freeze({
    AddMessageClass: [
        'string'
    ],
    AnalyticsControlEventAction: {
        required: { eventCategory: 'string', eventAction: 'string', enable: 'boolean' }
    },
    AnalyticsStart: {
        required: { serviceType: 'string', trackingID: 'string' },
        optional: { serverUrl: 'string' }
    },
    AssignViewToCompositeRenderer: {
        required: { remoteParticipants: 'number', viewId: 'string', viewStyle: 'string' }
    },
    AssignViewToLocalCamera: {
        required: { allowZoom: 'boolean', displayCropped: 'boolean', localCamera: 'object', viewId: 'string' }
    },
    AssignViewToLocalMonitor: {
        required: { allowZoom: 'boolean', displayCropped: 'boolean', localMonitor: 'object', viewId: 'string' }
    },
    AssignViewToLocalWindowShare: {
        required: { allowZoom: 'boolean', displayCropped: 'boolean', localWindowShare: 'object', viewId: 'string' }
    },
    AssignViewToRemoteCamera: {
        required: { allowZoom: 'boolean', displayCropped: 'boolean', remoteCamera: 'object', viewId: 'string' }
    },
    AssignViewToRemoteWindowShare: {
        required: { allowZoom: 'boolean', displayCropped: 'boolean', remoteWindowShare: 'object', viewId: 'string' }
    },
    Connect: {
        required: {
            displayName: 'string',
            host: 'string',
            onDisconnected: 'function',
            onFailure: 'function',
            onSuccess: 'function',
            resourceId: 'string',
            token: 'string'
        },
        optional: {
            constraints: 'object'
        }
    },
    ConnectToRoomAsGuest: {
        required: {
            displayName: 'string',
            host: 'string',
            onDisconnected: 'function',
            onFailure: 'function',
            onSuccess: 'function',
            roomKey: 'string'
        },
        optional: {
            constraints: 'object',
            roomPin: 'string',
            token: 'string'
        }
    },
    CreateVidyoConnector: {
        required: {
            logFileFilter: 'string', logFileName: 'string',
            remoteParticipants: 'number', userData: 'number|string', viewId: 'string|null', viewStyle: 'string'
        },
        optional: {
            constraints: {
                optional: {
                    disableGoogleAnalytics: 'boolean',
                    location: 'boolean',
                    mediaConstraints: {
                        required: {
                            audio: 'boolean',
                            video: 'boolean'
                        }
                    }
                }
            }
        }
    },
    EnableDebug: {
        required: { port: 'number', logFilter: 'string' }
    },
    GetAnalyticsEventTable: {
        required: { onGetAnalyticsEventTableCallback: 'function' }
    },
    HideView: {
        required: { viewId: 'string' }
    },
    PinParticipant: {
        required: { participant: 'object', pin: 'boolean' }
    },
    RaiseHand: {
        required: { raiseHandResponse: 'function' },
        optional: { requestId: 'string' }
    },
    RegisterAdvancedSettingsEventListener: {
        optional: {
            onDisableDynamicAudioSources: 'function',
            onDisableStatsChanged: 'function',
            onEnableAudioOnlyModeChanged: 'function',
            onEnableAutoReconnectChanged: 'function',
            onEnableCompositorFixedParticipants: 'function',
            onEnableFixedEncoderBitRate: 'function',
            onEnableSimpleAPILoggingChanged: 'function',
            onEnableScreenShareSimulcastChanged: 'function',
            onEnableVideoSimulcastChanged: 'function',
            onEnableTransportCcChanged: 'function',
            onEnableVidyoConnectorAPILoggingChanged: 'function',
            onMaxReconnectAttemptsChanged: 'function',
            onParticipantLimitChanged: 'function',
            onPinnedParticipantDisplayCroppedChanged: 'function',
            onLogCategoryChanged: 'function',
            onReconnectBackoffChanged: 'function',
            onShowStatisticsOverlayChanged: 'function',
            onStatisticsRefreshIntervalChanged: 'function',
            onCameraContentHintChanged: 'function',
            onWindowShareContentHintChanged: 'function'
        }
    },
    RegisterConferenceModeEventListener: {
        required: { conferenceModeChanged: 'function' }
    },
    RegisterLectureModeEventListener: {
        required: { presenterChanged: 'function', handRaised: 'function' }
    },
    RegisterLocalCameraEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onSelected: 'function', onStateUpdated: 'function' }
    },
    RegisterLocalMicrophoneEnergyListener: {
        required: { onEnergy: 'function' }
    },
    RegisterLocalMicrophoneEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onSelected: 'function', onStateUpdated: 'function' }
    },
    RegisterLocalMonitorEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onSelected: 'function', onStateUpdated: 'function' }
    },
    RegisterLocalSpeakerEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onSelected: 'function', onStateUpdated: 'function' }
    },
    RegisterLocalWindowShareEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onSelected: 'function', onStateUpdated: 'function' }
    },
    RegisterModerationCommandEventListener: {
        required: { onModerationCommandReceived: 'function' }
    },
    RegisterMessageEventListener: {
        required: { onChatMessageReceived: 'function' }, optional: { onChatMessageAcknowledged: 'function' }
    },
    RegisterLocalCameraStreamInterceptor: [
        'function'
    ],
    RegisterLogEventListener: {
        required: { filter: 'string', onLog: 'function' }
    },
    RegisterParticipantEventListener: {
        required: { onDynamicChanged: 'function', onJoined: 'function', onLeft: 'function', onLoudestChanged: 'function' }
    },
    RegisterPermissionEventListener: {
        required: { onPermissionUpdated: 'function' }
    },
    RegisterReconnectEventListener: {
        required: { onReconnecting: 'function', onReconnected: 'function', onConferenceLost: 'function' }
    },
    RegisterRecorderInCallEventListener: {
        required: { onRecorderInCallChanged: 'function' }
    },
    RegisterRemoteCameraEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onStateUpdated: 'function' }
    },
    RegisterRemoteMicrophoneEnergyListener: {
        required: { onEnergy: 'function' }
    },
    RegisterRemoteMicrophoneEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onStateUpdated: 'function' }
    },
    RegisterRemoteSpeakerEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onStateUpdated: 'function' }
    },
    RegisterRemoteWindowShareEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onStateUpdated: 'function' }
    },
    RegisterResourceManagerEventListener: {
        required: { onAvailableResourcesChanged: 'function', onMaxRemoteSourcesChanged: 'function' }
    },
    RegisterUnprocessedAudioEventListener: {
        required: { onUnprocessedAudioSupportChanged: 'function', onUnprocessedAudioStarted: 'function' }
    },
    ReportLocalParticipantOnJoined: {
        required: { reportLocalParticipant: 'boolean' }
    },
    RegisterVideoTileEventListener: {
        required: { onAdded: 'function', onRemoved: 'function', onStateUpdated: 'function' }
    },
    SelectAudioContentShare: {
        required: { localMicrophone: 'object|null' }
    },
    SelectCamera: {
        required: { camera: 'object|null' }
    },
    SelectLocalCamera: {
        required: { localCamera: 'object|null' }
    },
    SelectMicrophone: {
        required: { microphone: 'object|null' }
    },
    SelectLocalMicrophone: {
        required: { localMicrophone: 'object|null' }
    },
    SelectLocalMonitor: {
        required: { localMonitor: 'object|null' }
    },
    SelectSpeaker: {
        required: { speaker: 'object|null' }
    },
    SelectLocalSpeaker: {
        required: { localSpeaker: 'object|null' }
    },
    SelectLocalWindowShare: {
        required: { localWindowShare: 'object|null' }
    },
    SelectVideoContentShare: {
        required: { localCamera: 'object|null' }
    },
    SendChatMessage: {
        required: { message: 'string' }
    },
    SendPrivateChatMessage: {
        required: { participant: 'object', message: 'string' }
    },
    SetAdvancedConfiguration: {
        optional: {
            addLogCategory: 'string',
            disableAudioEnergyMonitor: 'boolean',
            disableStats: 'boolean',
            disableDynamicAudioSources: 'boolean',
            enableAudioOnlyMode: 'boolean',
            enableCompositorFixedParticipants: 'boolean',
            enableSimpleAPILogging: 'boolean',
            enableScreenShareSimulcast: 'boolean',
            enableVideoSimulcast: 'boolean',
            enableTransportCc: 'boolean',
            enableVidyoConnectorAPILogging: 'boolean',
            extData: 'string',
            extDataType: 'string',
            loggerURL: 'string',
            onAnalyticsEventSent: 'function|null',
            participantLimit: 'number|string',
            pinnedParticipantDisplayCropped: 'boolean',
            showStatisticsOverlay: 'boolean',
            statisticsRefreshInterval: 'number',
            enableAutoReconnect: 'boolean',
            maxReconnectAttempts: 'number|string',
            reconnectBackoff: 'number|string',
            cameraContentHint: 'string',
            windowShareContentHint: 'string'
        }
    },
    SetCameraPrivacy: {
        required: { privacy: 'boolean' }
    },
    SetLocation: {
        required: { latitude: 'number', longitude: 'number' }
    },
    SetMaxReceiveBitRate: {
        required: { bitRate: 'number|null' }
    },
    SetMaxSendBitRate: {
        required: { bitRate: 'number|null' }
    },
    SetMicrophonePrivacy: {
        required: { privacy: 'boolean' }
    },
    SetOptions: {
        optional: {
            pushLogs: {
                required: {
                    enabled: 'boolean'
                },
                optional: {
                    pushURL: 'string',
                    pushInterval: 'number',
                    trackingID: 'string'
                }
            }
        }
    },
    SetPool: {
        required: { name: 'string' }
    },
    SetSpeakerPrivacy: {
        required: { privacy: 'boolean' }
    },
    SetTCPTransport: {
        required: { enable: 'boolean' }
    },
    SetUDPTransport: {
        required: { enable: 'boolean' }
    },
    ShowAudioMeters: {
        required: { showMeters: 'boolean', viewId: 'string' }
    },
    ShowPreview: {
        required: { preview: 'boolean' }
    },
    ShowVideoTileControls: {
        required: { showControls: 'boolean', viewId: 'string' }
    },
    ShowViewAt: {
        required: { height: 'number', viewId: 'string', width: 'number', x: 'number', y: 'number' }
    },
    ShowViewLabel: {
        required: { showLabel: 'boolean', viewId: 'string' }
    },
    ShowWindowSharePreview: {
        required: { preview: 'boolean' }
    },
    UnraiseHand: {
        optional: { requestId: 'string' }
    }
});

},{}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageProvider = void 0;
class LocalStorageProvider {
    static Clear() {
        try {
            localStorage.clear();
        }
        catch (e) {
        }
    }
    static Get(property) {
        let value = null;
        try {
            value = localStorage.getItem(property);
        }
        catch (e) {
        }
        return value;
    }
    static Set(property, value) {
        try {
            if (value) {
                localStorage.setItem(property, value);
            }
            else {
                localStorage.removeItem(property);
            }
        }
        catch (e) {
        }
    }
}
exports.LocalStorageProvider = LocalStorageProvider;

},{}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationProvider = void 0;
const Constants = require("./Constants");
class LocationProvider {
    static GetCurrentPosition() {
        let data = LocationProvider._userLocation || LocationProvider._actualLocation;
        if (data) {
            return Promise.resolve(data);
        }
        else if (LocationProvider._isLocationRequestEnabled) {
            return LocationProvider._getPositionAsync();
        }
        else {
            return Promise.reject('Request is rejected');
        }
    }
    static GetCurrentPositionSync() {
        return LocationProvider._userLocation || LocationProvider._actualLocation;
    }
    static HasCurrentPosition() {
        return !!(LocationProvider._userLocation || LocationProvider._actualLocation);
    }
    static Initialize() {
        LocationProvider._setWatch();
    }
    static SetDefaultLocationStatus(status = false) {
        LocationProvider._isLocationRequestEnabled = status;
    }
    static SetLocation(coords) {
        LocationProvider._clearWatch();
        LocationProvider._userLocation = LocationProvider._getMinutes(coords);
    }
    static toMinutes(coords) {
        return LocationProvider._getMinutes(coords);
    }
    static _clearWatch() {
        if (LocationProvider._watchId) {
            navigator.geolocation.clearWatch(LocationProvider._watchId);
            LocationProvider._watchId = null;
        }
    }
    static _getMinutes(coords) {
        let min = 60;
        let location = { latitude: ((coords.latitude * min) | 0), longitude: ((coords.longitude * min) | 0) };
        return location;
    }
    static _getPositionAsync() {
        if (LocationProvider._getPositionAsyncPromise) {
            return LocationProvider._getPositionAsyncPromise;
        }
        LocationProvider._getPositionAsyncPromise = new Promise((resolve, reject) => {
            const success = (position) => {
                LocationProvider._actualLocation = LocationProvider._getMinutes(position.coords);
                LocationProvider._getPositionAsyncPromise = null;
                resolve(LocationProvider.GetCurrentPositionSync());
            };
            const error = (e) => {
                LocationProvider._getPositionAsyncPromise = null;
                if (LocationProvider.HasCurrentPosition()) {
                    resolve(LocationProvider.GetCurrentPositionSync());
                }
                else {
                    reject(e);
                }
            };
            navigator.geolocation.getCurrentPosition(success, error, { timeout: Constants.LocationCheckTimeout });
        });
        return LocationProvider._getPositionAsyncPromise;
    }
    static _setWatch() {
        if (LocationProvider._isLocationRequestEnabled && !LocationProvider._watchId) {
            let success = (position) => {
                LocationProvider._actualLocation = LocationProvider._getMinutes(position.coords);
            };
            let error = (e) => {
                LocationProvider._actualLocation = null;
            };
            LocationProvider._watchId = navigator.geolocation.watchPosition(success, error);
        }
    }
}
exports.LocationProvider = LocationProvider;
LocationProvider._actualLocation = null;
LocationProvider._isLocationRequestEnabled = Constants.LocationConstraint;
LocationProvider._watchId = null;

},{"./Constants":138}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaDevicesProvider = void 0;
class MediaDevicesProvider {
    static GetMediaDevices() {
        return navigator.mediaDevices;
    }
}
exports.MediaDevicesProvider = MediaDevicesProvider;

},{}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const OperatingSystemInfoProvider_1 = require("./OperatingSystemInfoProvider");
(function initWrapper() {
    if (!OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() || MediaStreamTrack.prototype.isWrapped)
        return;
    const tracksMap = {};
    const getClonedTracksList = (id) => {
        if (!tracksMap[id]) {
            tracksMap[id] = [];
        }
        return tracksMap[id];
    };
    const originClone = MediaStreamTrack.prototype.clone;
    MediaStreamTrack.prototype.clone = function () {
        const clonedTrack = originClone.apply(this, arguments);
        const clonedTracksList = getClonedTracksList(this.id);
        clonedTracksList.push(clonedTrack);
        clonedTrack.isClone = true;
        return clonedTrack;
    };
    const originStop = MediaStreamTrack.prototype.stop;
    const stopTrack = (track) => {
        originStop.apply(track);
        getClonedTracksList(track.id).map((tr) => stopTrack(tr));
        delete tracksMap[track.id];
    };
    MediaStreamTrack.prototype.stop = function () {
        if (this.isClone) {
            return;
        }
        stopTrack(this);
    };
    MediaStreamTrack.prototype.isWrapped = true;
})();

},{"./OperatingSystemInfoProvider":154}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerShuttingDown = exports.ConferenceDestroyed = exports.Booted = exports.InvalidDisplayName = exports.ResourceDisabled = exports.ResourceLocked = exports.GuestAccessDisAllowed = exports.AllLinesInUse = exports.NoLicenseAvailable = exports.ResourceFull = exports.ErrorWhileConnecting = exports.ValidationErrorInParentRequiredFieldNameIsNotFound = exports.ValidationErrorInParentRequiredFieldIsNotFound = exports.TheViewStyleViewStyleIsNotSupported = exports.TheElementOfClassDoesntExist = exports.TheElementIdDoesntExist = exports.Terminated = exports.SignallingTransportError = exports.SignallingError = exports.NotImplemented = exports.NoSuchStream = exports.NoSuchParticipant = exports.NoResponse = exports.MiscRemoteError = exports.MiscLocalError = exports.MiscError = exports.MediaSessionTransportError = exports.MediaSessionError = exports.MediaSessionEnded = exports.MediaSessionAddingStreamError = exports.LocalMediaOperationNotPermitted = exports.InvalidToken = exports.IdCannotBeEmpty = exports.GetDisplayMediaIsNotSupported = exports.ErrorInSendTokenQuery = exports.ErrorInFindRoomOnServer = exports.Disconnected = exports.Disconnecting = exports.CouldNotParseString = exports.CouldNotGetWindowShareTrackBecauseUserCancelled = exports.CouldNotGetWindowShareTrack = exports.CouldNotGetVideoTrack = exports.CouldNotGetResponseFromMUC = exports.CouldNotGetAudioTrack = exports.ConnectionTimeout = exports.ConnectionLost = exports.ConnectionController = exports.ConferenceFailed = void 0;
exports.ConferenceFailed = 'Conference failed';
exports.ConnectionController = 'Connection Controller: ';
exports.ConnectionLost = 'Connection lost';
exports.ConnectionTimeout = 'Connection timeout';
exports.CouldNotGetAudioTrack = 'Could not get audio tracks: there were no audio tracks returned by the browser';
exports.CouldNotGetResponseFromMUC = 'Could not get response from MUC';
exports.CouldNotGetVideoTrack = 'Could not get video tracks: there were no video tracks returned by the browser';
exports.CouldNotGetWindowShareTrack = 'Could not get window share tracks: there were no window share tracks returned by the browser';
exports.CouldNotGetWindowShareTrackBecauseUserCancelled = 'Could not get window share tracks: the operation was cancelled by the user';
exports.CouldNotParseString = 'Could not parse "${string}".';
exports.Disconnecting = 'Normal disconnecting';
exports.Disconnected = 'Normal disconnected';
exports.ErrorInFindRoomOnServer = 'Error in FindRoomOnServer';
exports.ErrorInSendTokenQuery = 'Error in SendTokenQuery';
exports.GetDisplayMediaIsNotSupported = 'Window sharing is not supported on your platform';
exports.IdCannotBeEmpty = 'Id cannot be empty';
exports.InvalidToken = 'The token that was provided is unknown to the service or unauthorized to log in.';
exports.LocalMediaOperationNotPermitted = 'Operation Not Permitted: LocalStreamController will not start a ${mediaType} when it is in ${mediaState}';
exports.MediaSessionAddingStreamError = 'Media session adding stream error';
exports.MediaSessionEnded = 'Media session ended';
exports.MediaSessionError = 'Media session error';
exports.MediaSessionTransportError = 'Media session transport error';
exports.MiscError = 'Miscellaneous errors';
exports.MiscLocalError = 'Miscellaneous local errors';
exports.MiscRemoteError = 'Miscellaneous remote errors';
exports.NoResponse = 'No response';
exports.NoSuchParticipant = 'Could not find participant with id "${id}".';
exports.NoSuchStream = 'Could not find stream with id "${id}".';
exports.NotImplemented = 'Not implemented.';
exports.SignallingError = 'Signalling error';
exports.SignallingTransportError = 'Signalling transport error';
exports.Terminated = 'Terminated';
exports.TheElementIdDoesntExist = 'The element "${id}" doesn`t exist.';
exports.TheElementOfClassDoesntExist = 'The element of "${className}" class doesn`t exist.';
exports.TheViewStyleViewStyleIsNotSupported = 'The view style "${viewStyle}" is not supported.';
exports.ValidationErrorInParentRequiredFieldIsNotFound = 'Validation error in "${parent}": required field "${name}" is not found.';
exports.ValidationErrorInParentRequiredFieldNameIsNotFound = 'Validation error in "${parent}": required field "${name}" is not found.';
exports.ErrorWhileConnecting = 'Error while connecting. VidyoConnector now in state - ${state}';
exports.ResourceFull = 'The Room is reached maximum capacity';
exports.NoLicenseAvailable = 'All available licenses are used';
exports.AllLinesInUse = 'An established media connection failed because all lines are in use.';
exports.GuestAccessDisAllowed = 'Guest access are not allowed';
exports.ResourceLocked = 'The Room is locked';
exports.ResourceDisabled = 'The Room is disabled';
exports.InvalidDisplayName = 'Display name is required';
exports.Booted = 'Booted from conference';
exports.ConferenceDestroyed = 'Conference destroyed';
exports.ServerShuttingDown = 'Server is shutting down';

},{}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotEqual = void 0;
function NotEqual(referenceValue, value, deviation) {
    return referenceValue === 0 || Math.abs((referenceValue - value) / referenceValue) > deviation;
}
exports.NotEqual = NotEqual;

},{}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotImplemented = void 0;
const Messages_1 = require("./Messages");
function NotImplemented() {
    throw new Error(Messages_1.NotImplemented);
}
exports.NotImplemented = NotImplemented;

},{"./Messages":150}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ObjectUtils {
    static Copy(object) {
        const copy = object instanceof Array ? [] : {};
        return this.Merge(copy, object);
    }
    static Difference(arr1, arr2) {
        return arr1.filter((elem) => !arr2.includes(elem));
    }
    static Filter(obj, whereClause) {
        const res = [];
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                const elem = obj[key];
                let valid = true;
                for (let whereProp in whereClause) {
                    if (elem[whereProp] !== whereClause[whereProp]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    res.push(elem);
                }
            }
        }
        return res;
    }
    static Flatten(arr) {
        return [].concat.apply([], arr);
    }
    static IsEmpty(obj) {
        return Object.keys(obj).length === 0;
    }
    static IsEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i in arr1) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    }
    static IsNotEmpty(obj) {
        return !this.IsEmpty(obj);
    }
    static IsNotEqual(arr1, arr2) {
        return !this.IsEqual(arr1, arr2);
    }
    static IsObjectsEqual(a, b) {
        const aProps = Object.getOwnPropertyNames(a);
        const bProps = Object.getOwnPropertyNames(b);
        if (aProps.length !== bProps.length) {
            return false;
        }
        return aProps.every((key) => a[key] === b[key]);
    }
    static MapObject(obj, callback) {
        if (obj instanceof Array) {
            return obj.map(callback);
        }
        return Object.values(obj).map(callback);
    }
    static MeanValueOfArray(arr) {
        return arr.reduce((sum, b) => sum + b, 0) / arr.length;
    }
    static Merge(...objects) {
        return objects.reduce((a, b) => this._merge(a, b));
    }
    static _merge(target, source) {
        if (!target || !source) {
            return target || source || {};
        }
        for (let prop in source) {
            if (source.hasOwnProperty(prop) || !(source[prop] instanceof Object)) {
                const value = source[prop];
                if (value instanceof Object && !(value instanceof Function)) {
                    if (value instanceof Array) {
                        target[prop] = [];
                    }
                    else if (!(target[prop] instanceof Object) || target[prop] instanceof Array) {
                        target[prop] = {};
                    }
                    this._merge(target[prop], value);
                }
                else if (typeof value !== 'undefined' || !(prop in target)) {
                    target[prop] = value;
                }
            }
        }
        return target;
    }
    static existValueInEnum(type, value) {
        return Object.keys(type).filter(k => isNaN(Number(k))).filter(k => type[k] === value).length > 0;
    }
}
exports.default = ObjectUtils;

},{}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperatingSystemInfoProvider = void 0;
class OperatingSystemInfoProvider {
    static GetOSInfo() {
        if (!OperatingSystemInfoProvider._osInfo) {
            OperatingSystemInfoProvider._osInfo = OperatingSystemInfoProvider._getOSInfo();
        }
        return OperatingSystemInfoProvider._osInfo;
    }
    static IsAndroid() {
        return this.GetOSInfo().OSName.toLocaleLowerCase().includes('android');
    }
    static IsBrowserVersionNotSupported() {
        const isSafari = OperatingSystemInfoProvider.IsSafari();
        const browserVersion = OperatingSystemInfoProvider.BrowserVersion;
        const browserVersionFloat = parseFloat(browserVersion);
        const lowestSafariVersionSupported = 13;
        return isSafari && browserVersionFloat < lowestSafariVersionSupported;
    }
    static IsChrome() {
        if (OperatingSystemInfoProvider._isChrome === undefined) {
            OperatingSystemInfoProvider._isChrome = navigator.userAgent.includes('Chrome') &&
                !navigator.userAgent.includes('OPR') && !navigator.userAgent.includes('Firefox');
        }
        return OperatingSystemInfoProvider._isChrome;
    }
    static IsElectron() {
        if (OperatingSystemInfoProvider._isElectron === undefined) {
            OperatingSystemInfoProvider._isElectron = navigator.userAgent.includes('Electron') &&
                !navigator.userAgent.includes('OPR') && !navigator.userAgent.includes('Firefox');
        }
        return OperatingSystemInfoProvider._isElectron;
    }
    static IsFirefox() {
        if (OperatingSystemInfoProvider._isFirefox === undefined) {
            OperatingSystemInfoProvider._isFirefox = navigator.userAgent.includes('Firefox') &&
                !navigator.userAgent.includes('OPR') && !navigator.userAgent.includes('Chrome');
        }
        return OperatingSystemInfoProvider._isFirefox;
    }
    static IsIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent);
    }
    static IsIPadOS() {
        const TouchScreenPoints = 2;
        return navigator.maxTouchPoints &&
            navigator.maxTouchPoints > TouchScreenPoints &&
            /Macintosh/.test(navigator.userAgent);
    }
    static IsMobileDevice() {
        return OperatingSystemInfoProvider.IsAndroid() ||
            OperatingSystemInfoProvider.IsIOS() ||
            OperatingSystemInfoProvider.IsIPadOS();
    }
    static IsSafari() {
        if (OperatingSystemInfoProvider._isSafari === undefined) {
            OperatingSystemInfoProvider._isSafari = !navigator.userAgent.includes('Chrome') &&
                navigator.userAgent.includes('Safari');
        }
        return OperatingSystemInfoProvider._isSafari;
    }
    static IsSafariUnifiedPlan() {
        return OperatingSystemInfoProvider.IsSafari()
            && window['RTCRtpTransceiver'] && window['RTCRtpTransceiver'].prototype.hasOwnProperty('currentDirection');
    }
    static IsWindows() {
        this.GetOSInfo();
        return (OperatingSystemInfoProvider._osInfo ? OperatingSystemInfoProvider._osInfo.OSName.toLowerCase().includes('windows') : false);
    }
    static get BrowserName() {
        switch (true) {
            case OperatingSystemInfoProvider.IsChrome():
                return 'Chrome';
            case OperatingSystemInfoProvider.IsSafari():
                return 'Safari';
            case OperatingSystemInfoProvider.IsFirefox():
                return 'Firefox';
            default:
                return null;
        }
    }
    static get BrowserVersion() {
        const getBrowserVersion = (prefix) => {
            const regexp = new RegExp(`${prefix}\\/([\\d+.]+)`);
            const [, version] = navigator.userAgent.match(regexp) || [null, null];
            return version;
        };
        switch (true) {
            case OperatingSystemInfoProvider.IsChrome():
                return getBrowserVersion('Chrome');
            case OperatingSystemInfoProvider.IsSafari():
                return getBrowserVersion('Version');
            case OperatingSystemInfoProvider.IsFirefox():
                return getBrowserVersion('Firefox');
            default:
                return null;
        }
    }
    static get UserAgent() {
        return navigator.userAgent;
    }
    static _getOSInfo() {
        let nVer = navigator.appVersion;
        let nAgt = navigator.userAgent;
        let os = '';
        const clientStrings = [
            { s: 'Windows 3.11', r: /Win16/ },
            { s: 'Windows 95', r: /(Windows 95|Win95|Windows_95)/ },
            { s: 'Windows ME', r: /(Win 9x 4.90|Windows ME)/ },
            { s: 'Windows 98', r: /(Windows 98|Win98)/ },
            { s: 'Windows CE', r: /Windows CE/ },
            { s: 'Windows 2000', r: /(Windows NT 5.0|Windows 2000)/ },
            { s: 'Windows XP', r: /(Windows NT 5.1|Windows XP)/ },
            { s: 'Windows Server 2003', r: /Windows NT 5.2/ },
            { s: 'Windows Vista', r: /Windows NT 6.0/ },
            { s: 'Windows 7', r: /(Windows 7|Windows NT 6.1)/ },
            { s: 'Windows 8.1', r: /(Windows 8.1|Windows NT 6.3)/ },
            { s: 'Windows 8', r: /(Windows 8|Windows NT 6.2)/ },
            { s: 'Windows 10', r: /(Windows 10|Windows NT 10)/ },
            { s: 'Windows NT 4.0', r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },
            { s: 'Windows ME', r: /Windows ME/ },
            { s: 'Android', r: /Android/ },
            { s: 'Open BSD', r: /OpenBSD/ },
            { s: 'Sun OS', r: /SunOS/ },
            { s: 'Linux', r: /(Linux|X11)/ },
            { s: 'iOS', r: /(iPhone|iPad|iPod)/ },
            { s: 'Mac OS X', r: /Mac OS X/ },
            { s: 'Mac OS', r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },
            { s: 'QNX', r: /QNX/ },
            { s: 'UNIX', r: /UNIX/ },
            { s: 'BeOS', r: /BeOS/ },
            { s: 'OS/2', r: /OS\/2/ },
            { s: 'Search Bot', r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/ }
        ];
        const res = clientStrings.find((cs) => cs.r.test(nAgt));
        if (OperatingSystemInfoProvider.IsIPadOS()) {
            os = 'iOS';
        }
        else if (res) {
            os = res.s;
        }
        let osVersion = '';
        if (/Windows/.test(os)) {
            const test = /Windows (.*)/.exec(os);
            if (test && test.length > 1) {
                osVersion = test[1];
            }
            os = 'Windows';
        }
        switch (os) {
            case 'Mac OS X':
                {
                    const res = /Mac OS X (10[\.\_\d]+)/.exec(nAgt);
                    if (res && res.length > 1) {
                        osVersion = res[1].replace(/_/g, '.');
                    }
                }
                break;
            case 'Android':
                {
                    const res = /Android ([\.\_\d]+)/.exec(nAgt);
                    if (res && res.length > 1) {
                        osVersion = res[1];
                    }
                }
                break;
            case 'iOS':
                {
                    const res = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                    if (res && res.length > 1) {
                        const one = 1;
                        const two = 2;
                        const three = 3;
                        osVersion = res[one] + '.' + res[two] + '.' + (res[three] || 0);
                    }
                }
                break;
            default:
                console.log("unsupported platform " + os);
                break;
        }
        return {
            OSName: os,
            OSVersion: osVersion
        };
    }
}
exports.OperatingSystemInfoProvider = OperatingSystemInfoProvider;

},{}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionProvider = void 0;
class PermissionProvider {
    static subscribe(name) {
        if (navigator['permissions']) {
            return navigator.permissions.query({ name });
        }
        return Promise.reject(new Error('Permissions API is not supported in current browser'));
    }
}
exports.PermissionProvider = PermissionProvider;

},{}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrettyTuple = exports.PrettyList = exports.PrettyNumberWithUnits = exports.PrettyNumber = exports.PrettyNumberBase = void 0;
class PrettyNumberBase {
    constructor(Value = 0) {
        this.Value = Value;
    }
}
exports.PrettyNumberBase = PrettyNumberBase;
class PrettyNumber extends PrettyNumberBase {
    toString() {
        const largestNumberThatWillBeAbbreviated = 1000;
        if (this.Value < largestNumberThatWillBeAbbreviated) {
            const cutOffForKeepingOneDecimal = 100;
            const oneOrderOfMagnitude = 10;
            let coefficient;
            if (this.Value < cutOffForKeepingOneDecimal) {
                coefficient = oneOrderOfMagnitude;
            }
            else {
                coefficient = 1;
            }
            return (Math.round(this.Value * coefficient) / coefficient).toString();
        }
        else {
            return this.Value.toString();
        }
    }
}
exports.PrettyNumber = PrettyNumber;
class PrettyNumberWithUnits extends PrettyNumberBase {
    constructor(_unit, value = 0) {
        super(value);
        this._unit = _unit;
    }
    toString() {
        return `${this.Value}${this._unit}`;
    }
}
exports.PrettyNumberWithUnits = PrettyNumberWithUnits;
class PrettyList {
    constructor(Values = []) {
        this.Values = Values;
    }
    Push(values) {
        values.forEach((v) => {
            this.PushIfNew(v);
        });
    }
    PushIfNew(value) {
        if (!this.Values.includes(value)) {
            this.Values.push(value);
        }
    }
    toString() {
        return this.Values.join(', ');
    }
}
exports.PrettyList = PrettyList;
class PrettyTuple {
    constructor(_seperator, _first = 0, _second = 0) {
        this._seperator = _seperator;
        this._first = _first;
        this._second = _second;
    }
    get Values() {
        return [this._first, this._second];
    }
    SetValues(first, second) {
        this._first = first;
        this._second = second;
    }
    toString() {
        return `${Math.round(this._first)} ${this._seperator} ${Math.round(this._second)}`;
    }
}
exports.PrettyTuple = PrettyTuple;

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RaceResolve = exports.ApplyTimeout = exports.PromiseTimeout = exports.MakePromiseWithCallback = void 0;
const Errors = require("./Errors");
function MakePromiseWithCallback() {
    let resolve = undefined;
    let reject = undefined;
    let promise = new Promise((resolveFunction, rejectFunction) => {
        resolve = resolveFunction;
        reject = rejectFunction;
    });
    return { promise, reject, resolve };
}
exports.MakePromiseWithCallback = MakePromiseWithCallback;
class PromiseTimeout {
    constructor(delay, cleanUp) {
        this.timeoutRef = 0;
        this.delay = delay;
        this.cleanUp = cleanUp;
    }
}
exports.PromiseTimeout = PromiseTimeout;
function ApplyTimeout(targetPromise, promiseTimeout) {
    return Promise.race([
        targetPromise,
        new Promise(function (resolve, reject) {
            promiseTimeout.timeoutRef = setTimeout(function () {
                if (promiseTimeout.cleanUp) {
                    promiseTimeout.cleanUp();
                }
                reject(new Errors.TimeOutError('timeout'));
            }, promiseTimeout.delay);
        })
    ]).then(function (result) {
        clearTimeout(promiseTimeout.timeoutRef);
        promiseTimeout.timeoutRef = 0;
        if (promiseTimeout.cleanUp) {
            promiseTimeout.cleanUp();
        }
        return result;
    });
}
exports.ApplyTimeout = ApplyTimeout;
function RaceResolve(iterable) {
    return new Promise((allResolve, allReject) => {
        Promise.all(iterable.map((promise) => {
            return new Promise((resolve, reject) => {
                promise.then(reject).catch(resolve);
            });
        })).then(allReject).catch(allResolve);
    });
}
exports.RaceResolve = RaceResolve;

},{"./Errors":141}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class RTCStatsReportHelper {
    static GetIceCandidateStats(stats, localCandidateId) {
        let localCandidate = stats.get(localCandidateId);
        return localCandidate;
    }
    static GetRTCCodecStats(stats, codecId) {
        let rtcCodecStats = stats.get(codecId);
        return rtcCodecStats;
    }
    static GetRTCInboundRTPStreamStats(stats, ssrc, kind) {
        let rtcInboundRTPStreamStats = stats.get(`RTCInboundRTP${kind}Stream_${ssrc}`);
        if (!rtcInboundRTPStreamStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value && value.type === 'inbound-rtp' && value.ssrc === +ssrc) {
                    return value;
                }
                else {
                }
                element = iter.next();
            }
        }
        return rtcInboundRTPStreamStats;
    }
    static GetRTCOutboundRTPStreamStats(stats, ssrc, kind) {
        let rtcOutboundRTPStreamStats = stats.get(`RTCOutboundRTP${kind}Stream_${ssrc}`);
        if (!rtcOutboundRTPStreamStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'outbound-rtp' && value.ssrc === +ssrc) {
                    return value;
                }
                element = iter.next();
            }
        }
        return rtcOutboundRTPStreamStats;
    }
    static GetRTCRemoteInboundRTPStreamStats(stats, ssrc, kind) {
        let rtcRemoteInboundRTPStreamStats = stats.get(`RTCRemoteInboundRTP${kind}Stream_${ssrc}`);
        if (!rtcRemoteInboundRTPStreamStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'remote-inbound-rtp' && value.ssrc === +ssrc) {
                    return value;
                }
                element = iter.next();
            }
        }
        return rtcRemoteInboundRTPStreamStats;
    }
    static GetRTCMediaStreamTrackStats(stats, id) {
        let rtcMediaStreamTrackStats = stats.get(id);
        if (!rtcMediaStreamTrackStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'track' && value.id === id) {
                    return value;
                }
                element = iter.next();
            }
        }
        return rtcMediaStreamTrackStats;
    }
    static GetRTCVideoSourceStats(stats, id) {
        let rtcVideoSourceStats = stats.get(id);
        if (!rtcVideoSourceStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'media-source' && value.kind === 'video' && value.id === id) {
                    return value;
                }
                element = iter.next();
            }
        }
        return rtcVideoSourceStats;
    }
    static GetRTCAudioSourceStats(stats, id) {
        let rtcAudioSourceStats = stats.get(id);
        if (!rtcAudioSourceStats) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'media-source' && value.kind === 'audio' && value.id === id) {
                    return value;
                }
                element = iter.next();
            }
        }
        return rtcAudioSourceStats;
    }
    static GetSelectedCandidatePairs(stats) {
        let candidatePairs = [];
        let transportStat = stats.get("RTCTransport_0_1");
        if (transportStat && transportStat.hasOwnProperty('selectedCandidatePairId')) {
            let iceCandidatePairStat = stats.get(transportStat['selectedCandidatePairId']);
            if (iceCandidatePairStat) {
                candidatePairs.push(iceCandidatePairStat);
            }
        }
        if (candidatePairs.length == 0) {
            let iter = stats['values']();
            let element = iter.next();
            while (element && element.done === false) {
                let value = element.value;
                if (value.type === 'candidate-pair') {
                    if (value.hasOwnProperty('selected') && value.selected) {
                        candidatePairs.push(value);
                    }
                    else {
                        let transportStats = RTCStatsReportHelper.GetTransportStats(stats, value.transportId);
                        if (transportStats && transportStats.selectedCandidatePairId === value.id) {
                            candidatePairs.push(value);
                        }
                    }
                }
                element = iter.next();
            }
        }
        return candidatePairs;
    }
    static GetTimestamp(stats) {
        try {
            return Array.from(stats)[0][1].timestamp;
        }
        catch (e) {
            return Date.now();
        }
    }
    static GetTransportStats(stats, transportId) {
        let transportStats = stats.get(transportId);
        return transportStats;
    }
}
exports.default = RTCStatsReportHelper;

},{}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReconnectAction = exports.ReconnectState = exports.AutoReconnectStartReasons = void 0;
const VidyoConnector_1 = require("../../vidyo_connector_api/VidyoConnector");
exports.AutoReconnectStartReasons = [
    VidyoConnector_1.VidyoConnectorDisconnectReason.MiscError,
    VidyoConnector_1.VidyoConnectorDisconnectReason.MiscLocalError,
    VidyoConnector_1.VidyoConnectorDisconnectReason.MiscRemoteError,
    VidyoConnector_1.VidyoConnectorDisconnectReason.ConnectionLost,
    VidyoConnector_1.VidyoConnectorFailReason.ConnectionFailed
];
var ReconnectState;
(function (ReconnectState) {
    ReconnectState["Idle"] = "VIDYO_RECONNECTSTATE_Idle";
    ReconnectState["Pending"] = "VIDYO_RECONNECTSTATE_Pending";
    ReconnectState["Connecting"] = "VIDYO_RECONNECTSTATE_Connecting";
    ReconnectState["RoomCreating"] = "VIDYO_RECONNECTSTATE_RoomCreating";
    ReconnectState["RoomEntering"] = "VIDYO_RECONNECTSTATE_RoomEntering";
    ReconnectState["MediaStarting"] = "VIDYO_RECONNECTSTATE_MediaStarting";
})(ReconnectState = exports.ReconnectState || (exports.ReconnectState = {}));
var ReconnectAction;
(function (ReconnectAction) {
    ReconnectAction["Enable"] = "VIDYO_RECONNECTACTION_Enable";
    ReconnectAction["Reject"] = "VIDYO_RECONNECTACTION_Reject";
    ReconnectAction["Disable"] = "VIDYO_RECONNECTACTION_Disable";
    ReconnectAction["Connect"] = "VIDYO_RECONNECTACTION_Connect";
    ReconnectAction["CreateRoom"] = "VIDYO_RECONNECTACTION_CreateRoom";
    ReconnectAction["EnterRoom"] = "VIDYO_RECONNECTACTION_EnterRoom";
    ReconnectAction["StartMedia"] = "VIDYO_RECONNECTACTION_StartMedia";
})(ReconnectAction = exports.ReconnectAction || (exports.ReconnectAction = {}));

},{"../../vidyo_connector_api/VidyoConnector":181}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OrientationType;
(function (OrientationType) {
    OrientationType["PortraitPrimary"] = "portrait-primary";
    OrientationType["PortraitSecondary"] = "portrait-secondary";
    OrientationType["LandscapePrimary"] = "landscape-primary";
    OrientationType["LandscapeSecondary"] = "landscape-secondary";
})(OrientationType || (OrientationType = {}));
class ScreenInfoProvider {
    static get IsPortrait() {
        if (!window.screen.orientation) {
            return window.screen.height > window.screen.width;
        }
        return window.screen.orientation.type === OrientationType.PortraitPrimary
            || window.screen.orientation.type === OrientationType.PortraitSecondary;
    }
}
exports.default = ScreenInfoProvider;

},{}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.update_runnels = exports.find_frame_size_range_in_mb = exports.maximum_frame_size_for_target_bitrate = exports.normalizeAOB = exports.MaxVideoSize = exports.ContentType = void 0;
var Codec;
(function (Codec) {
    Codec["VP8"] = "VP8";
    Codec["VP9"] = "VP9";
})(Codec || (Codec = {}));
const QUALITY_OVER_FRAMESIZE_PREFERENCE = 1.0;
const QUALITY_PREFERENCE_FACTOR = 1.0;
const COMPRESSION_EFFICIENCY_FACTOR_VP8 = 1.1;
const MIN_BITS_PER_MB_VP9 = 10.0;
const MAX_BITS_PER_MB_VP9 = 20.0;
const BITRATE_ESTIMATION_MODEL_FACTOR = 0.85;
var ContentType;
(function (ContentType) {
    ContentType[ContentType["CONFERENCE"] = 0] = "CONFERENCE";
    ContentType[ContentType["STATIC"] = 1] = "STATIC";
    ContentType[ContentType["ACTIVE"] = 2] = "ACTIVE";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
var MAX_AOB;
(function (MAX_AOB) {
    MAX_AOB[MAX_AOB["AOB_720P"] = 3200] = "AOB_720P";
    MAX_AOB[MAX_AOB["AOB_1080P"] = 6000] = "AOB_1080P";
    MAX_AOB[MAX_AOB["AOB_4K"] = 20000] = "AOB_4K";
})(MAX_AOB || (MAX_AOB = {}));
var ContentTypeFactor;
(function (ContentTypeFactor) {
    ContentTypeFactor[ContentTypeFactor["CONFERENCE"] = 1] = "CONFERENCE";
    ContentTypeFactor[ContentTypeFactor["STATIC"] = 0.5] = "STATIC";
    ContentTypeFactor[ContentTypeFactor["ACTIVE"] = 1.5] = "ACTIVE";
})(ContentTypeFactor || (ContentTypeFactor = {}));
var Vp9SpatialLayer;
(function (Vp9SpatialLayer) {
    Vp9SpatialLayer[Vp9SpatialLayer["MinLayerWidth"] = 240] = "MinLayerWidth";
    Vp9SpatialLayer[Vp9SpatialLayer["MinLayerHeight"] = 135] = "MinLayerHeight";
    Vp9SpatialLayer[Vp9SpatialLayer["TwiceMinLayerWidth"] = 480] = "TwiceMinLayerWidth";
    Vp9SpatialLayer[Vp9SpatialLayer["TwiceMinLayerHeight"] = 270] = "TwiceMinLayerHeight";
})(Vp9SpatialLayer || (Vp9SpatialLayer = {}));
var MaxVideoSize;
(function (MaxVideoSize) {
    MaxVideoSize["SIZE_1080P"] = "1080P";
    MaxVideoSize["SIZE_720P"] = "720P";
    MaxVideoSize["SIZE_4K"] = "4K";
})(MaxVideoSize = exports.MaxVideoSize || (exports.MaxVideoSize = {}));
function normalizeAOB(AOB, MAX_VIDEO_SIZE = '720P') {
    if (MAX_VIDEO_SIZE === MaxVideoSize.SIZE_720P) {
        if (AOB > MAX_AOB.AOB_720P)
            AOB = MAX_AOB.AOB_720P;
    }
    else if (MAX_VIDEO_SIZE === MaxVideoSize.SIZE_1080P) {
        if (AOB > MAX_AOB.AOB_1080P)
            AOB = MAX_AOB.AOB_1080P;
    }
    else if (MAX_VIDEO_SIZE === MaxVideoSize.SIZE_4K) {
        if (AOB > MAX_AOB.AOB_4K)
            AOB = MAX_AOB.AOB_4K;
    }
    return AOB;
}
exports.normalizeAOB = normalizeAOB;
function maximum_frame_size_for_target_bitrate(codec_type, content_type, target_br, framerate) {
    let bits_per_mb;
    let maximum_frame_size_target_br;
    if (codec_type === Codec.VP8) {
        bits_per_mb = MIN_BITS_PER_MB_VP9 * COMPRESSION_EFFICIENCY_FACTOR_VP8;
    }
    else if (codec_type === Codec.VP9) {
        bits_per_mb = MIN_BITS_PER_MB_VP9;
    }
    else {
        return -1;
    }
    if (content_type === ContentType.CONFERENCE) {
        bits_per_mb *= ContentTypeFactor.CONFERENCE;
    }
    else if (content_type === ContentType.STATIC) {
        bits_per_mb *= ContentTypeFactor.STATIC;
    }
    else if (content_type === ContentType.ACTIVE) {
        bits_per_mb *= ContentTypeFactor.ACTIVE;
    }
    else {
        return -1;
    }
    bits_per_mb *= QUALITY_PREFERENCE_FACTOR;
    bits_per_mb *= QUALITY_OVER_FRAMESIZE_PREFERENCE;
    if (content_type !== ContentType.STATIC) {
        if (framerate >= 30.0)
            bits_per_mb *= framerate * 0.7;
        else if (framerate >= 15.0)
            bits_per_mb *= framerate * (0.7 + (0.9 - 0.7) * (30.0 - framerate) / (30.0 - 15.0));
        else if (framerate >= 7.5)
            bits_per_mb *= framerate * (0.9 + (1.2 - 0.9) * (15.0 - framerate) / (15.0 - 7.5));
        else if (framerate >= 3.0)
            bits_per_mb *= framerate * (1.2 + (2.0 - 1.2) * (7.5 - framerate) / (7.5 - 3.0));
        else
            bits_per_mb *= framerate * 2.0;
    }
    else {
        if (framerate >= 30.0)
            bits_per_mb *= framerate * 0.56;
        else if (framerate >= 15.0)
            bits_per_mb *= framerate * (0.56 + (0.90 - 0.56) * (30.0 - framerate) / (30.0 - 15.0));
        else if (framerate >= 7.5)
            bits_per_mb *= framerate * (0.90 + (1.45 - 0.90) * (15.0 - framerate) / (15.0 - 7.5));
        else if (framerate >= 3.0)
            bits_per_mb *= framerate * (1.45 + (2.90 - 1.45) * (7.5 - framerate) / (7.5 - 3.0));
        else
            bits_per_mb *= framerate * 2.90;
    }
    if (target_br >= 1000)
        bits_per_mb *= 1.0;
    else if (target_br >= 500)
        bits_per_mb *= 1.0 + (1.4 - 1.0) * (1000 - target_br) / (1000.0 - 500.0);
    else if (target_br >= 200)
        bits_per_mb *= 1.4 + (1.8 - 1.4) * (500 - target_br) / (500.0 - 200.0);
    else
        bits_per_mb *= 1.8;
    maximum_frame_size_target_br = (target_br * 1000 / bits_per_mb);
    return maximum_frame_size_target_br;
}
exports.maximum_frame_size_for_target_bitrate = maximum_frame_size_for_target_bitrate;
function find_frame_size_range_in_mb(show_not_received_yet, show_info, src_info, codec_type, AOB, content_type) {
    let ret = { max_frame_size_mb: 0, max_min_ratio: 0 };
    let max_frame_size_4_target_br;
    if ((src_info.width <= 0) || (src_info.height <= 0)) {
        return;
    }
    ret.max_frame_size_mb = Math.floor(((src_info.width + 15) / 16)) * Math.floor(((src_info.height + 15) / 16));
    if (show_not_received_yet) {
        max_frame_size_4_target_br = maximum_frame_size_for_target_bitrate(codec_type, content_type, AOB, src_info.rate);
        if (max_frame_size_4_target_br <= 0) {
            return;
        }
        if (max_frame_size_4_target_br < ret.max_frame_size_mb) {
            ret.max_frame_size_mb = max_frame_size_4_target_br;
        }
        ret.max_min_ratio = 0.0;
    }
    else {
        let aspect_ratio_show;
        let aspect_ratio_source;
        let min_frame_size_mb;
        let show_frame_size_mb;
        let target_bitrate_max, target_bitrate_min;
        if (show_info.framerate_max > src_info.rate) {
            show_info.framerate_max = src_info.rate;
            if (show_info.framerate_min > show_info.framerate_max) {
                show_info.framerate_min = show_info.framerate_max;
            }
        }
        target_bitrate_max = AOB;
        if ((show_info.bw_max > 0) && (target_bitrate_max > show_info.bw_max)) {
            target_bitrate_max = show_info.bw_max;
        }
        max_frame_size_4_target_br = maximum_frame_size_for_target_bitrate(codec_type, content_type, target_bitrate_max, show_info.framerate_max);
        if (max_frame_size_4_target_br <= 0) {
            return;
        }
        aspect_ratio_source = src_info.height / src_info.width;
        aspect_ratio_show = show_info.height_max / show_info.width_max;
        if (aspect_ratio_show > aspect_ratio_source)
            show_info.height_max = (show_info.width_max * aspect_ratio_source + 0.999);
        else if (aspect_ratio_show < aspect_ratio_source)
            show_info.width_max = (show_info.height_max / aspect_ratio_source + 0.999);
        aspect_ratio_show = show_info.height_min / show_info.width_min;
        if (aspect_ratio_show > aspect_ratio_source)
            show_info.height_min = (show_info.width_min * aspect_ratio_source + 0.999);
        else if (aspect_ratio_show < aspect_ratio_source)
            show_info.width_min = (show_info.height_min / aspect_ratio_source + 0.999);
        show_frame_size_mb = Math.floor(((show_info.width_max + 15) / 16)) * Math.floor(((show_info.height_max + 15) / 16));
        if (ret.max_frame_size_mb > show_frame_size_mb) {
            ret.max_frame_size_mb = show_frame_size_mb;
        }
        if (ret.max_frame_size_mb > max_frame_size_4_target_br) {
            ret.max_frame_size_mb = max_frame_size_4_target_br;
        }
        min_frame_size_mb = Math.floor(((show_info.height_min + 15) / 16)) * Math.floor(((show_info.width_min + 15) / 16));
        if (show_info.bw_min > 0) {
            target_bitrate_min = show_info.bw_min;
            if (target_bitrate_min > target_bitrate_max) {
                target_bitrate_min = target_bitrate_max;
            }
            max_frame_size_4_target_br = maximum_frame_size_for_target_bitrate(codec_type, content_type, target_bitrate_min, show_info.framerate_max);
            if ((max_frame_size_4_target_br > 0) && (max_frame_size_4_target_br < min_frame_size_mb)) {
                min_frame_size_mb = max_frame_size_4_target_br;
            }
        }
        ret.max_min_ratio = ret.max_frame_size_mb / min_frame_size_mb;
        if (ret.max_min_ratio < 1.0)
            ret.max_min_ratio = 1.0;
    }
    return ret;
}
exports.find_frame_size_range_in_mb = find_frame_size_range_in_mb;
function update_runnels(show_info, src_info, codec_type, AOB, max_frame_size_mb, max_min_ratio, runnels) {
    let downsizing_ratio;
    let source_size_in_mb;
    let min_frame_size_mb;
    runnels.frame_width = src_info.width;
    runnels.frame_height = src_info.height;
    runnels.downsizing_ratio[0] = 1;
    source_size_in_mb = Math.floor(((src_info.width + 15) / 16)) * Math.floor(((src_info.height + 15) / 16));
    min_frame_size_mb = (max_frame_size_mb / max_min_ratio + 0.5);
    if (max_frame_size_mb < source_size_in_mb) {
        downsizing_ratio = source_size_in_mb / max_frame_size_mb;
        if (downsizing_ratio > 56.0) {
            runnels.frame_width = src_info.width / 8;
            runnels.frame_height = src_info.height / 8;
            runnels.downsizing_ratio[0] = 8.0;
        }
        else if (downsizing_ratio > 24.0) {
            runnels.frame_width = src_info.width * 3 / 16;
            runnels.frame_height = src_info.height * 3 / 16;
            runnels.downsizing_ratio[0] = 5.33333;
        }
        else if (downsizing_ratio > 12.0) {
            runnels.frame_width = src_info.width / 4;
            runnels.frame_height = src_info.height / 4;
            runnels.downsizing_ratio[0] = 4;
        }
        else if (downsizing_ratio > 6.0) {
            runnels.frame_width = src_info.width * 3 / 8;
            runnels.frame_height = src_info.height * 3 / 8;
            runnels.downsizing_ratio[0] = 2.66666;
        }
        else if (downsizing_ratio > 3.2) {
            runnels.frame_width = src_info.width / 2;
            runnels.frame_height = src_info.height / 2;
            runnels.downsizing_ratio[0] = 2;
        }
        else if (downsizing_ratio > 1.5) {
            runnels.frame_width = src_info.width * 3 / 4;
            runnels.frame_height = src_info.height * 3 / 4;
            runnels.downsizing_ratio[0] = 1.33333;
        }
        if ((codec_type === Codec.VP9) &&
            ((runnels.frame_width < Vp9SpatialLayer.TwiceMinLayerWidth) || (runnels.frame_height < Vp9SpatialLayer.TwiceMinLayerHeight))) {
            if ((src_info.width >= Vp9SpatialLayer.TwiceMinLayerWidth) && (src_info.height >= Vp9SpatialLayer.TwiceMinLayerHeight)) {
                let ratio_to_min_width = runnels.frame_width / Vp9SpatialLayer.TwiceMinLayerWidth;
                let ratio_to_min_height = runnels.frame_height / Vp9SpatialLayer.TwiceMinLayerHeight;
                let ratio_to_min_min;
                ratio_to_min_min = ratio_to_min_width;
                if (ratio_to_min_min > ratio_to_min_height) {
                    ratio_to_min_min = ratio_to_min_height;
                }
                if (ratio_to_min_min > 0.8) {
                    runnels.frame_width = (runnels.frame_width / ratio_to_min_min + 0.5);
                    runnels.frame_height = (runnels.frame_height / ratio_to_min_min + 0.5);
                    runnels.downsizing_ratio[0] *= ratio_to_min_min;
                }
            }
        }
        max_frame_size_mb = Math.floor(((runnels.frame_width + 15) / 16)) * Math.floor(((runnels.frame_height + 15) / 16));
    }
    if (max_min_ratio === 0.0) {
        runnels.frame_rate = src_info.rate;
        if (max_frame_size_mb >= 2025) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 4.0;
        }
        else if ((codec_type !== Codec.VP9) && (max_frame_size_mb >= 900)) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 2.66666;
        }
        else if (max_frame_size_mb >= 500) {
            runnels.num_runnels = 2;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 2.0;
        }
        else if ((codec_type !== Codec.VP9) && (max_frame_size_mb >= 225)) {
            runnels.num_runnels = 2;
            runnels.downsizing_ratio[1] = 1.33333;
            runnels.downsizing_ratio[2] = 1.33333;
        }
        else {
            runnels.num_runnels = 1;
            runnels.downsizing_ratio[1] = 1.0;
            runnels.downsizing_ratio[2] = 1.0;
        }
    }
    else {
        runnels.frame_rate = show_info.framerate_max;
        max_min_ratio = max_frame_size_mb / min_frame_size_mb;
        if (max_min_ratio > 40.0) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 8.0;
        }
        else if ((codec_type !== Codec.VP9) && (max_min_ratio > 20.0)) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 5.33333;
        }
        else if (max_min_ratio > 10.0) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 4.0;
        }
        else if (max_min_ratio > 5.0) {
            runnels.num_runnels = 3;
            runnels.downsizing_ratio[1] = 2.0;
            if (codec_type !== Codec.VP9)
                runnels.downsizing_ratio[2] = 2.66666;
            else
                runnels.downsizing_ratio[2] = 4;
        }
        else if (max_min_ratio > 1.2) {
            runnels.num_runnels = 2;
            runnels.downsizing_ratio[1] = 2.0;
            runnels.downsizing_ratio[2] = 2.0;
        }
        else {
            runnels.num_runnels = 1;
            runnels.downsizing_ratio[1] = 1.0;
            runnels.downsizing_ratio[2] = 1.0;
        }
    }
    runnels.downsizing_ratio[1] *= runnels.downsizing_ratio[0];
    runnels.downsizing_ratio[2] *= runnels.downsizing_ratio[0];
    runnels.target_bitrate[0] = 0;
    runnels.target_bitrate[1] = 0;
    runnels.target_bitrate[2] = 0;
    if ((runnels.num_runnels >= 1) && (runnels.num_runnels <= 3)) {
        let weight = [], total_weight, max_bitrate_kbps;
        total_weight = 0.0;
        for (let i = 0; i < runnels.num_runnels; i++) {
            weight[i] = Math.pow(runnels.downsizing_ratio[0] / runnels.downsizing_ratio[i], 2.0 * BITRATE_ESTIMATION_MODEL_FACTOR);
            total_weight += weight[i];
        }
        runnels.target_bitrate[0] = (weight[0] / total_weight * AOB);
        if (runnels.target_bitrate[0] > (show_info.bw_max * 0.95)) {
            runnels.target_bitrate[0] = (show_info.bw_max * 0.95);
        }
        max_bitrate_kbps = (MAX_BITS_PER_MB_VP9 * QUALITY_PREFERENCE_FACTOR * 108);
        max_bitrate_kbps = (max_bitrate_kbps * Math.pow(max_frame_size_mb / 3600.0, BITRATE_ESTIMATION_MODEL_FACTOR));
        if (codec_type === Codec.VP8) {
            max_bitrate_kbps = (max_bitrate_kbps * COMPRESSION_EFFICIENCY_FACTOR_VP8);
        }
        if (runnels.target_bitrate[0] > max_bitrate_kbps) {
            runnels.target_bitrate[0] = max_bitrate_kbps;
        }
        for (let i = 1; i < runnels.num_runnels; i++) {
            runnels.target_bitrate[i] = (weight[i] * runnels.target_bitrate[0]);
        }
        if (runnels.target_bitrate[runnels.num_runnels - 1] > show_info.bw_min) {
            runnels.target_bitrate[runnels.num_runnels - 1] = show_info.bw_min;
        }
    }
    return 0;
}
exports.update_runnels = update_runnels;

},{}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SizeObserver = void 0;
const TimingProvider_1 = require("./TimingProvider");
class SizeObserver {
    static Start(element, callback) {
        let size = { height: -1, width: -1 };
        TimingProvider_1.TimingProvider.BeforeEachRepaint(() => {
            if (size.height !== element.clientHeight || size.width !== element.clientWidth) {
                size = { height: element.clientHeight, width: element.clientWidth };
                callback(size);
            }
        });
    }
}
exports.SizeObserver = SizeObserver;

},{"./TimingProvider":166}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatisticsExtention = void 0;
const Constants = require("../utils/Constants");
const Statistics_1 = require("../models/statistics/Statistics");
const LocalStreamController_1 = require("../controllers/StreamController/LocalStreamController");
class StatisticsExtention {
    static catchConnectTime() {
        StatisticsExtention.EndpointStatistic.ConnectTime = StatisticsExtention.getISODate(new Date());
    }
    static fillLocalCameraStatistics(localCameraStat, camera) {
        const localStreamController = StatisticsExtention._vidyoCore.Controllers.LocalStreamController;
        const currentResolution = localStreamController.GetLocalStreamVideoConstraints();
        const track = localStreamController.GetTransmittedTrack(LocalStreamController_1.TrackType.Camera);
        localCameraStat.Name = localCameraStat.Name || camera.Name || '';
        localCameraStat.Height = localCameraStat.Height || currentResolution.height;
        localCameraStat.Width = localCameraStat.Width || currentResolution.width;
        localCameraStat.Format = localCameraStat.Format || 'VIDYO_MEDIAFORMAT_MJPG';
        if (this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast && track) {
            localCameraStat.Runnels = this._vidyoCore.HunterProvider.GetTrackEncodingParameters(track.id);
        }
    }
    static fillLocalMicrophoneStatistics(localMicrophoneStat, microphone) {
        localMicrophoneStat.Name = microphone.Name || '';
        localMicrophoneStat.CodecName = localMicrophoneStat.CodecName || 'OPUS';
        localMicrophoneStat.NumberOfChannels = localMicrophoneStat.NumberOfChannels || 1;
        localMicrophoneStat.BitsPerSample = localMicrophoneStat.BitsPerSample || 32;
        localMicrophoneStat.SampleRateSet = localMicrophoneStat.SampleRateSet || 32000;
        const remoteSpeakerStreamStat = new Statistics_1.RemoteSpeakerStreamStatistics();
        remoteSpeakerStreamStat.Name = microphone.Name || '';
        remoteSpeakerStreamStat.CodecName = localMicrophoneStat.CodecName;
        remoteSpeakerStreamStat.SampleRate = localMicrophoneStat.SampleRateSet;
        remoteSpeakerStreamStat.NumberOfChannels = localMicrophoneStat.NumberOfChannels;
        remoteSpeakerStreamStat.BitsPerSample = localMicrophoneStat.BitsPerSample;
        localMicrophoneStat.RemoteSpeakerStreams = [remoteSpeakerStreamStat];
    }
    static getISODate(date) {
        date.setTime(date.getTime());
        return date.toISOString().replace(/\T/, ' ').replace(/\Z/, '');
    }
    static getParticipantsGenerationStats() {
        let statExt = StatisticsExtention;
        let participantSts = statExt.RoomStatistics.ParticipantStats;
        let participants = statExt._vidyoCore.Controllers.ParticipantController.GetParticipants()
            .filter((p) => p.Origin === 'remote')
            .sort((a, b) => a.Generation - b.Generation);
        let participantsGenerationStats = [];
        participants.forEach((p) => {
            let participantGenerationStats = new Statistics_1.ParticipantGenerationStatistics();
            let o = participantSts.find((x) => x.Id === p.Id);
            let participant = {};
            Object.assign(participant, p, o);
            participantGenerationStats.Id = participant.Id;
            participantGenerationStats.Name = participant.Name;
            if (participant.RemoteCameraStats && participant.RemoteCameraStats.length > 0) {
                participantGenerationStats.CameraName = participant.RemoteCameraStats[0].Name || 'Unknown';
                participantGenerationStats.FrameInterval = participant.RemoteCameraStats[0].FpsRendered;
                participantGenerationStats.Width = participant.RemoteCameraStats[0].Width;
                participantGenerationStats.Height = participant.RemoteCameraStats[0].Height;
            }
            participantsGenerationStats.push(participantGenerationStats);
        });
        return participantsGenerationStats;
    }
    static Initialize(vidyoCore) {
        StatisticsExtention._vidyoCore = vidyoCore;
        StatisticsExtention.EndpointStatistic = vidyoCore.Controllers.StatisticsController.EndpointStatistic;
        StatisticsExtention.RoomStatistics = vidyoCore.Controllers.StatisticsController.RoomStatistics;
        StatisticsExtention.TransportInformation = vidyoCore.Controllers.StatisticsController.TransportInformation;
        StatisticsExtention.UserStatistic = vidyoCore.Controllers.StatisticsController.UserStatistic;
    }
    static supplementClientStatistics() {
        StatisticsExtention.supplementEndpointStatistics();
        StatisticsExtention.supplementRoomStatistics();
    }
    static supplementEndpointStatistics() {
        let localParticipant = StatisticsExtention._vidyoCore.Controllers.ParticipantController.GetLocalParticipant();
        StatisticsExtention.EndpointStatistic.ApplicationTag = Constants.ApplicationTag;
        StatisticsExtention.EndpointStatistic.BuildTag = Constants.LibBuild;
        StatisticsExtention.EndpointStatistic.Id = localParticipant ? localParticipant.ObjId : 'Unknown';
        StatisticsExtention.EndpointStatistic.LibraryVersion = Constants.LibVersion || 'Unknown';
        StatisticsExtention.EndpointStatistic.ProcessorModel = 'Unknown';
        StatisticsExtention.EndpointStatistic.ProcessorBrand = 'Unknown';
        StatisticsExtention.EndpointStatistic.ProcessorLogicalCores = 2;
        StatisticsExtention.EndpointStatistic.ProcessorPhysicalCores = navigator.hardwareConcurrency;
        StatisticsExtention.EndpointStatistic.NetworkInterfaceStats = [
            { IsUp: true, Name: 'Unknown name', Type: 'Unknown type' }
        ];
        StatisticsExtention.EndpointStatistic.LogStats = {
            LogErrorDataStats: [{ Name: 'Unknown error', Occurances: 1 }],
            LogWarningDataStats: [{ Name: 'Unknown warning', Occurances: 2 }]
        };
        StatisticsExtention.UserStatistic.Id = `guest_${StatisticsExtention.EndpointStatistic.Id}`;
    }
    static supplementRoomStatistics() {
        let cpuUsage = 15;
        let pixelRate = 100;
        let availableCpuPercent = 100;
        StatisticsExtention.RoomStatistics.AvailableDecodeCpuPercent = availableCpuPercent;
        StatisticsExtention.RoomStatistics.AvailableEncodeCpuPercent = availableCpuPercent;
        StatisticsExtention.RoomStatistics.CpuUsage = cpuUsage;
        StatisticsExtention.RoomStatistics.CurrentBandwidthDecodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.CurrentBandwidthEncodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.CurrentCpuDecodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.CurrentCpuEncodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.MaxDecodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.MaxEncodePixelRate = pixelRate;
        StatisticsExtention.RoomStatistics.ParticipantGenerationStats = StatisticsExtention.getParticipantsGenerationStats();
    }
}
exports.StatisticsExtention = StatisticsExtention;

},{"../controllers/StreamController/LocalStreamController":56,"../models/statistics/Statistics":131,"../utils/Constants":138}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class StringUtils {
    static Format(template, values) {
        let res = template;
        for (let key in values) {
            if (values.hasOwnProperty(key)) {
                const placeholders = new RegExp(`(<%=\\s?${key}\\s?%>)|(\\$\\{${key}\\})`, 'gm');
                res = res.replace(placeholders, String(values[key]));
            }
        }
        return res;
    }
    static encodeXML(xml) {
        return xml.replace(/[<>&'"]/g, (c) => {
            switch (c) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                case '\'': return '&apos;';
                case '"': return '&quot;';
                default:
                    console.log("unsupported XML encoding " + c);
                    break;
            }
        });
    }
    static generateRandomString() {
        const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let array = new Uint16Array(30);
        window.crypto.getRandomValues(array);
        array = array.map((x) => validChars.charCodeAt(x % validChars.length));
        return String.fromCharCode.apply(null, array);
    }
    static isValidURL(url) {
        return /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/]+$/gm.test(url);
    }
    static toSecureString(str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    static fromSecureString(str) {
        return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
    }
    static parseJwt(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }
        catch (e) {
            return null;
        }
    }
    static toStringDate(date, withTZOffset) {
        let tzp = date.toTimeString().match(/[\+|\-][0-9]{4}/);
        let tz = '+00:00';
        if (withTZOffset === true && tzp && tzp.length > 0) {
            tz = tzp[0];
            tz = tz.substr(0, 3) + ':' + tz.substr(3, 2);
        }
        return date.toISOString().replace('T', ' ').replace('Z', '') + ' ' + tz;
    }
}
exports.default = StringUtils;

},{}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.synchronized = void 0;
const promisedQueues = {};
const DEFAULT_TAG = 'DEFAULT_TAG';
function synchronized(tagName = DEFAULT_TAG) {
    if (!promisedQueues.hasOwnProperty(tagName)) {
        promisedQueues[tagName] = Promise.resolve();
    }
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const newFunc = async function (...args) {
            return new Promise((res, rej) => {
                promisedQueues[tagName] = promisedQueues[tagName].then(() => {
                    return new Promise(async (queueRes) => {
                        try {
                            res(await originalMethod.apply(this, args));
                        }
                        catch (e) {
                            rej(e);
                        }
                        finally {
                            queueRes();
                        }
                    });
                });
            });
        };
        descriptor.value = newFunc;
    };
}
exports.synchronized = synchronized;

},{}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimingProvider = void 0;
class TimingProvider {
    static BeforeEachRepaint(callback) {
        function beforeEachRepaint() {
            window.requestAnimationFrame(beforeEachRepaint);
            callback();
        }
        window.requestAnimationFrame(beforeEachRepaint);
    }
    static ClearInterval(handle) {
        clearInterval(handle);
    }
    static Debounce(callback, wait = 0) {
        let timeout = null;
        return () => {
            if (timeout) {
                clearTimeout(timeout);
            }
            const delayedCallback = () => {
                callback();
                timeout = null;
            };
            timeout = setTimeout(delayedCallback, wait);
        };
    }
    static Interval(delay, callback, startImmediately) {
        if (startImmediately) {
            callback();
        }
        return setInterval(callback, delay);
    }
}
exports.TimingProvider = TimingProvider;

},{}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecodeUserName = void 0;
function DecodeUserName(token) {
    let decoded_name = '';
    try {
        let parts = atob(token).split('\0');
        decoded_name = parts[1].replace('@', '_').toLowerCase();
    }
    catch (e) { }
    return decoded_name;
}
exports.DecodeUserName = DecodeUserName;

},{}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserMediaProvider = void 0;
const Constants = require("./Constants");
const Messages = require("./Messages");
const Camera_1 = require("../models/device/Camera");
const MediaDevicesProvider_1 = require("./MediaDevicesProvider");
const Microphone_1 = require("../models/device/Microphone");
const OperatingSystemInfoProvider_1 = require("./OperatingSystemInfoProvider");
const Devices_1 = require("../../vidyo_simple_api/Devices");
require("./MediaStreamTrackWrapper");
class UserMediaProvider {
    constructor(_vidyoCore) {
        this._vidyoCore = _vidyoCore;
        this._windowShareQueue = [];
        this._videoStreamInterceptor = null;
    }
    static get Constraints() {
        return UserMediaProvider._constraints;
    }
    static get DefaultCameraDeviceId() {
        return UserMediaProvider.defaultCameraDeviceID;
    }
    GetAudioTrack(selection = true) {
        let constraints = { audio: UserMediaProvider._constraints.audio };
        if (UserMediaProvider._constraints.audio && selection instanceof Microphone_1.Microphone && selection.Id) {
            constraints.audio = {
                deviceId: {
                    exact: selection.Id
                }
            };
            if (selection.SignalType === Devices_1.VidyoDeviceAudioSignalType.VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed) {
                constraints.audio.autoGainControl = false;
                constraints.audio.echoCancellation = false;
                constraints.audio.noiseSuppression = false;
            }
        }
        return MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices().getUserMedia(constraints).then((stream) => {
            let track = stream.getAudioTracks()[0];
            if (!track) {
                throw Messages.CouldNotGetAudioTrack;
            }
            return track;
        }).catch(() => {
            return null;
        });
    }
    GetVideoTrack(selection = true, constraints) {
        let video = constraints ? constraints : {
            width: Constants.DefaultLocalStreamWidth,
            height: Constants.DefaultLocalStreamHeight,
            frameRate: Constants.DefaultLocalStreamFrameRate
        };
        let videoConstraints = UserMediaProvider._constraints.video ? { video } : { video: false };
        let retryCounter = 0;
        if (UserMediaProvider._constraints.video && selection instanceof Camera_1.Camera && selection.Id) {
            videoConstraints.video = Object.assign({}, video, {
                deviceId: {
                    exact: selection.Id
                }
            });
        }
        const getVideoTrack = (videoConstraints) => {
            return MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices().getUserMedia(videoConstraints)
                .then((stream) => {
                if (this._videoStreamInterceptor) {
                    try {
                        return this._videoStreamInterceptor(stream).then((modifiedStream) => {
                            this._vidyoCore.Controllers.LogController.LogWarning(() => 'Use modified stream');
                            return Promise.resolve(modifiedStream);
                        }).catch((err) => {
                            this._vidyoCore.Controllers.LogController.LogError(() => `${err}. Fallback to the original stream`);
                            return Promise.resolve(stream);
                        });
                    }
                    catch (err) {
                        this._vidyoCore.Controllers.LogController.LogError(() => `${err}. Fallback to the original stream`);
                        return Promise.resolve(stream);
                    }
                }
                return Promise.resolve(stream);
            })
                .then((stream) => {
                let track = stream.getVideoTracks()[0];
                if (!track) {
                    throw Messages.CouldNotGetVideoTrack;
                }
                return track;
            }).catch((err) => {
                this._logger.LogError(() => `GetVideoTrack failed with ${err.name}: ${err.message}`);
                if (err.name === "NotReadableError" && retryCounter < UserMediaProvider.getVideoTrackRetriesLimit) {
                    ++retryCounter;
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            this._logger.LogDebug(() => `Retry GetVideoTrack - attempt ${retryCounter}/${UserMediaProvider.getVideoTrackRetriesLimit}`);
                            getVideoTrack(videoConstraints).then(resolve).catch(reject);
                        }, UserMediaProvider.getVideoTrackRetryDelayMs);
                    });
                }
                return null;
            });
        };
        return getVideoTrack(videoConstraints);
    }
    GetWindowShareTrack() {
        if ('getDisplayMedia' in MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices()) {
            return this._getDisplayMediaTrack();
        }
        return Promise.reject(Messages.GetDisplayMediaIsNotSupported);
    }
    Initialize(logger) {
        const mediaDevices = MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices();
        const { audio: isAudioRequired, video: isVideoRequired } = UserMediaProvider._constraints;
        this._logger = logger;
        return mediaDevices.enumerateDevices().then((devices) => {
            const hasDeviceKind = (kind) => devices.some(device => device.kind === kind);
            const constraints = {
                audio: isAudioRequired && hasDeviceKind('audioinput'),
                video: isVideoRequired && hasDeviceKind('videoinput')
            };
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice() && isVideoRequired && hasDeviceKind('videoinput')) {
                constraints.video = { facingMode: 'user' };
            }
            return mediaDevices.getUserMedia(constraints).then((stream) => {
                stream.getTracks().forEach((track) => {
                    try {
                        if (track.kind === 'video') {
                            const caps = track.getCapabilities();
                            UserMediaProvider.defaultCameraDeviceID = caps.deviceId;
                        }
                    }
                    catch (e) { }
                    finally {
                        track.stop();
                    }
                });
                return Promise.resolve(true);
            });
        }).catch(() => Promise.resolve(false));
    }
    RegisterLocalCameraStreamInterceptor(interceptor) {
        if (typeof interceptor === 'function') {
            this._videoStreamInterceptor = interceptor;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    UnregisterLocalCameraStreamInterceptor() {
        if (this._videoStreamInterceptor) {
            this._videoStreamInterceptor = null;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    _getDisplayMediaTrack() {
        return new Promise((resolve, reject) => {
            let constraints = {
                video: {
                    width: Constants.DefaultLocalShareStreamWidth,
                    height: Constants.DefaultLocalShareStreamHeight,
                    frameRate: Constants.DefaultLocalShareStreamFrameRate
                }
            };
            const mediaDevices = MediaDevicesProvider_1.MediaDevicesProvider.GetMediaDevices();
            if ('getDisplayMedia' in mediaDevices) {
                mediaDevices.getDisplayMedia(constraints).then((stream) => {
                    let track = stream.getVideoTracks()[0];
                    if (track) {
                        resolve(track);
                    }
                    else {
                        reject(Messages.CouldNotGetWindowShareTrack);
                    }
                }).catch(reject);
            }
            else {
                reject(Messages.CouldNotGetWindowShareTrack);
            }
        });
    }
    static SetAudioAndVideoConstraints({ audio = false, video = false } = {}) {
        UserMediaProvider._constraints.audio = audio;
        UserMediaProvider._constraints.video = video;
    }
}
exports.UserMediaProvider = UserMediaProvider;
UserMediaProvider._constraints = Constants.MediaConstraints;
UserMediaProvider.defaultCameraDeviceID = '';
UserMediaProvider.getVideoTrackRetriesLimit = 2;
UserMediaProvider.getVideoTrackRetryDelayMs = 500;

},{"../../vidyo_simple_api/Devices":184,"../models/device/Camera":101,"../models/device/Microphone":105,"./Constants":138,"./MediaDevicesProvider":148,"./MediaStreamTrackWrapper":149,"./Messages":150,"./OperatingSystemInfoProvider":154}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoPlaceholderTrack = void 0;
const svgNativeWidthAndHeight = 500;
class VideoPlaceholderTrack {
    constructor() {
        this._height = svgNativeWidthAndHeight;
        this._width = svgNativeWidthAndHeight;
        let canvas = this._createCanvas();
        if (canvas) {
            this._canvas = canvas;
            let context = this._canvas.getContext('2d');
            if (!context) {
                throw new Error('Could not get canvas context when creating placeholder track');
            }
            this._canvasContext = context;
            const maxFrameRate = 30;
            let stream = this._canvas.captureStream(maxFrameRate);
            let profileImage = this._createProfileImage();
            if (profileImage) {
                this._profileImage = profileImage;
                this._drawImageOnCanvas();
                this.Track = stream.getVideoTracks()[0];
            }
        }
    }
    Resize(width, height) {
        this._width = width;
        this._height = height;
        this._drawImageOnCanvas();
    }
    _createCanvas() {
        let canvas = document.createElement('canvas');
        if (canvas.captureStream) {
            return canvas;
        }
        else {
            return false;
        }
    }
    _createProfileImage() {
        let image = new Image();
        image.src = `data:image/svg+xml;utf8,
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
         viewBox="0 0 500 500" preserveAspectRatio="xMidYMid meet" style="enable-background:new 0 0 500 500;" xml:space="preserve">
      <style type="text/css">
        .st0{fill:#C5DBDE;}
      </style>
      <path class="st0" d="M349.5,150.8c0,55.1-44.7,99.8-99.8,99.8S150,205.8,150,150.8S194.7,51,249.8,51S349.5,95.7,349.5,150.8z
         M405.6,337L405.6,337c-98-49-213.3-49.1-311.4-0.2l-0.4,0.2c-26.6,13.3-43.4,40.5-43.4,70.2V500H449v-92.8
        C449,377.5,432.2,350.3,405.6,337z"/>
      </svg>
      `.replace(/\n/g, '');
        return image;
    }
    _drawImageOnCanvas() {
        this._canvas.width = this._width;
        this._canvas.height = this._height;
        this._canvasContext.fillStyle = '#202020';
        this._canvasContext.fillRect(0, 0, this._width, this._height);
        let canvasTallerThanImage = this._width / this._height < 1;
        let widthAndHeight = canvasTallerThanImage ? this._width : this._height;
        const half = 2;
        let startX = canvasTallerThanImage ? 0 : (this._width - widthAndHeight) / half;
        let startY = canvasTallerThanImage ? (this._height - widthAndHeight) / half : 0;
        this._canvasContext.drawImage(this._profileImage, startX, startY, widthAndHeight, widthAndHeight);
    }
}
exports.VideoPlaceholderTrack = VideoPlaceholderTrack;

},{}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoDebugger = void 0;
const AdvancedSettingsEvents_1 = require("../events/AdvancedSettingsEvents");
class VidyoDebugger {
    static Debug(obj, api, path) {
        const propertyNames = Object.getOwnPropertyNames(obj.constructor.prototype);
        for (let key of propertyNames) {
            if (typeof obj[key] === 'function' && !key.startsWith('_')) {
                let oldMethod = obj[key];
                obj[key] = (...args) => {
                    if (VidyoDebugger.isEnabledAPI[api] && VidyoDebugger.log) {
                        let fileName = VidyoDebugger.getFileName(path || '<filename>');
                        VidyoDebugger.log.LogDebug(() => `${api} API: ${fileName}: ${key} method was called`);
                    }
                    return oldMethod.apply(obj, args);
                };
            }
        }
    }
    static Initialize(core) {
        VidyoDebugger._vidyoCore = core;
        VidyoDebugger.log = core.Controllers.LogController;
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents_1.Events.EnableSimpleAPILoggingChanged, (payload) => {
            VidyoDebugger.isEnabledSimpleAPI = payload;
        });
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents_1.Events.EnableVidyoConnectorAPILoggingChanged, (payload) => {
            VidyoDebugger.isEnabledVidyoConnectorAPI = payload;
        });
    }
    static getFileName(path) {
        let filePath = path.split('\\');
        return filePath[filePath.length - 1];
    }
    static set isEnabledSimpleAPI(payload) {
        VidyoDebugger.isEnabledAPI.Simple = payload;
    }
    static get isEnabledSimpleAPI() {
        return VidyoDebugger.isEnabledAPI.Simple;
    }
    static set isEnabledVidyoConnectorAPI(payload) {
        VidyoDebugger.isEnabledAPI.VidyoConnector = payload;
    }
    static get isEnabledVidyoConnectorAPI() {
        return VidyoDebugger.isEnabledAPI.VidyoConnector;
    }
}
exports.VidyoDebugger = VidyoDebugger;
VidyoDebugger.isEnabledAPI = {
    Simple: false,
    VidyoConnector: false
};

},{"../events/AdvancedSettingsEvents":62}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoInsightsProvider = void 0;
const LogController_1 = require("../controllers/LogController/LogController");
class VidyoInsightsProvider {
    constructor(_url, _trackingID) {
        this._url = _url;
        this._trackingID = _trackingID;
    }
    push(stream, logRecords, keepAlive) {
        if (!logRecords.length) {
            return Promise.resolve(false);
        }
        const json = this._getJSON(stream, logRecords);
        return this._sendRequest(json, keepAlive);
    }
    _getJSON(stream, logRecords) {
        if (!stream.TrackingId && this._trackingID) {
            stream.TrackingId = this._trackingID;
        }
        return JSON.stringify({
            streams: [{
                    stream,
                    values: this._transformLogRecords(logRecords)
                }]
        });
    }
    _sendRequest(json, keepAlive) {
        return fetch(this._url, {
            method: 'POST',
            headers: {
                'Accept': 'application/json, text/plain, */*',
                'Content-Type': 'application/json'
            },
            keepalive: keepAlive,
            body: json
        });
    }
    _transformLogRecords(logRecords) {
        return logRecords.map((record) => {
            return [`${record.eventTime}000000`, LogController_1.LogRecord.toLogString(record)];
        });
    }
}
exports.VidyoInsightsProvider = VidyoInsightsProvider;

},{"../controllers/LogController/LogController":44}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SOAPActions = void 0;
const getTemplate = (body) => `<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:gues="http://portal.vidyo.com/guest">
    <soapenv:Header/>
    <soapenv:Body>
      ${body}
    </soapenv:Body>
  </soapenv:Envelope>`;
var SOAPActions;
(function (SOAPActions) {
    SOAPActions["raiseHand"] = "raiseHand";
    SOAPActions["unraiseHand"] = "unraiseHand";
})(SOAPActions = exports.SOAPActions || (exports.SOAPActions = {}));
class VidyoPortalGuestService {
    constructor(_portal, _guestId, _userName) {
        this._portal = _portal;
        this._guestId = _guestId;
        this._userName = _userName;
    }
    get _url() {
        return `https://${this._portal}/services/VidyoPortalGuestService/`;
    }
    _request(SOAPAction, body) {
        const headers = {
            'Accept-Encoding': 'gzip,deflate',
            'Content-Type': 'text/xml;charset=UTF-8',
            'SOAPAction': SOAPAction
        };
        const options = { method: 'POST', headers, body };
        return fetch(this._url, options).then(response => response.text());
    }
    RaiseHand() {
        const body = getTemplate(`<gues:RaiseHandRequest>
        <gues:guestID>${this._guestId}</gues:guestID>
        <gues:username>${this._userName}</gues:username>
      </gues:RaiseHandRequest>`);
        return this._request(SOAPActions.raiseHand, body).then((response) => {
            const parser = new DOMParser();
            const dom = parser.parseFromString(response, "application/xml");
            const data = dom.querySelector('RaiseHandResponse');
            return data?.textContent === 'OK';
        }).catch(() => {
            return false;
        });
    }
    UnraiseHand() {
        const body = getTemplate(`<gues:UnraiseHandRequest>
        <gues:guestID>${this._guestId}</gues:guestID>
        <gues:username>${this._userName}</gues:username>
      </gues:UnraiseHandRequest>`);
        return this._request(SOAPActions.unraiseHand, body).then((response) => {
            const parser = new DOMParser();
            const dom = parser.parseFromString(response, "application/xml");
            const data = dom.querySelector('UnraiseHandResponse');
            return data?.textContent === 'OK';
        }).catch(() => {
            return false;
        });
    }
}
exports.default = VidyoPortalGuestService;

},{}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Get = void 0;
var CodeStatus;
(function (CodeStatus) {
    CodeStatus[CodeStatus["OK"] = 200] = "OK";
})(CodeStatus || (CodeStatus = {}));
function Get({ url, headers, timeout, validResponseCodesRange }) {
    return new Promise((resolve, reject) => {
        let request = new XMLHttpRequest();
        request.open('GET', url);
        if (headers) {
            headers.forEach((header) => {
                request.setRequestHeader(header.name, header.value);
            });
        }
        if (timeout) {
            request.timeout = timeout;
        }
        request.ontimeout = () => {
            request.abort();
            reject(new Error('Timed out in ' + request.timeout + 'ms.'));
        };
        request.onreadystatechange = () => {
            if (request.readyState === XMLHttpRequest.DONE) {
                if (request.status === CodeStatus.OK ||
                    (validResponseCodesRange &&
                        validResponseCodesRange.begin <= request.status && request.status <= validResponseCodesRange.end)) {
                    resolve(request.responseText);
                }
                else {
                    reject(new Error(`${request.response} - response code: ${request.status}`));
                }
            }
        };
        request.send(null);
    });
}
exports.Get = Get;

},{}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoClientLib = void 0;
const VidyoSimple_1 = require("./vidyo_simple_api/VidyoSimple");
const VidyoConnector_1 = require("./vidyo_connector_api/VidyoConnector");
var VidyoClientLib;
(function (VidyoClientLib) {
    class VidyoClient {
        constructor(name, callback) {
            setTimeout(() => {
                callback({ state: 'READY', description: 'Native WebRTC' });
            });
            return VidyoConnector_1.VidyoConnector;
        }
    }
    VidyoClientLib.VidyoClient = VidyoClient;
    void VidyoSimple_1.VidyoSimple;
})(VidyoClientLib = exports.VidyoClientLib || (exports.VidyoClientLib = {}));
window['VCState'] = 'READY';
window['VidyoClientLib'] = {
    VidyoClient: VidyoClientLib.VidyoClient
};

},{"./vidyo_connector_api/VidyoConnector":181,"./vidyo_simple_api/VidyoSimple":192}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RendererBase = void 0;
const AdvancedSettingsEvents = require("../core/events/AdvancedSettingsEvents");
const EventDispatcher = require("../core/events/EventDispatcher");
const ConnectionEvents = require("../core/events/ConnectionEvents");
const AnalyticsEvents = require("../core/events/AnalyticsEvents");
const DeviceEvents = require("../core/events/DeviceEvents");
const MicrophoneEnergyEvents = require("../core/events/MicrophoneEnergyEvents");
const RenderEvents = require("../core/events/RenderEvents");
const Templates = require("./Templates");
const VideoResolution_1 = require("../core/models/VideoResolution");
const NotImplemented_1 = require("../core/utils/NotImplemented");
const SizeObserver_1 = require("../core/utils/SizeObserver");
const StringUtils_1 = require("../core/utils/StringUtils");
const Participant_1 = require("../core/models/Participant");
const async_1 = require("async");
const OperatingSystemInfoProvider_1 = require("../core/utils/OperatingSystemInfoProvider");
const LogEvents_1 = require("../core/events/LogEvents");
const RendererTypes_1 = require("../core/models/RendererTypes");
const Constants_1 = require("../core/utils/Constants");
const FeccControlsView_1 = require("./components/FeccControlsView");
const Devices_1 = require("../vidyo_simple_api/Devices");
const TimingProvider_1 = require("../core/utils/TimingProvider");
const AspectRatioTooHighClassName = 'aspectRatioTooHigh';
const AspectRatioTooWideClassName = 'aspectRatioTooWide';
const AspectRatioInversedClassName = 'aspectRatioInversed';
window.customElements.define('fecc-controls-view', FeccControlsView_1.default);
class RendererBase {
    constructor(vidyoCore) {
        this.audioLevelMaxThreshold = -20;
        this.audioLevelDynamicRange = 70;
        this._streamPopups = {};
        this._energyLevelCanvasContext = {};
        this._participantsAudios = {};
        this._vidyoCore = vidyoCore;
        window.addEventListener('unload', () => {
            try {
                Object.keys(this._streamPopups).forEach((key) => {
                    this._closeStreamPopup(key);
                });
            }
            catch (e) { }
        });
        this._actionsQueue = (0, async_1.queue)((action, next) => {
            action().then(next).catch(next);
        });
    }
    CreateView(viewId) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher.RenderListeners);
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.DisableAudioEnergyMonitorChanged, EventDispatcher.RenderListeners, (payload) => this._onDisableAudioEnergyMonitorChanged(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.SpeakerSelected, EventDispatcher.RenderListeners, (payload) => this._onSpeakerSelected(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.SpeakerPrivacyChanged, EventDispatcher.RenderListeners, (payload) => this._onSpeakerPrivacyChanged(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.VideoCropSettingsChanged, EventDispatcher.RenderListeners, (payload) => this._onVideoCropSettingsChanged(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.RecheckEachVideoSize, EventDispatcher.RenderListeners, () => this._onRecheckEachVideoSize());
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.StatisticsUpdate, EventDispatcher.RenderListeners, () => {
            requestAnimationFrame(() => this._onStatisticsUpdate());
        });
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateLocalViewLabel, EventDispatcher.RenderListeners, () => this._updateLocalViewLabel());
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateWindowShareViewLabel, EventDispatcher.RenderListeners, () => this._updateShareWindowLocalViewLabel('window'));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateMonitorShareViewLabel, EventDispatcher.RenderListeners, () => this._updateShareWindowLocalViewLabel('monitor'));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateCameraControl, EventDispatcher.RenderListeners, (payload) => this._onUpdateCameraControl(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateSource, EventDispatcher.RenderListeners, (streamId) => this._onUpdateStreamSource(streamId));
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraListChanged, EventDispatcher.RenderListeners, (payload) => this._onCameraListChanged(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Connected, EventDispatcher.RenderListeners, () => this._onConnected());
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ShowStatisticsOverlayChanged, EventDispatcher.RenderListeners, () => this._showStatisticsOverlayChanged());
        this._vidyoCore.EventDispatcher.on(MicrophoneEnergyEvents.Events.MicrophoneEnergyLevelUpdate, EventDispatcher.RenderListeners, (payload) => this._onMicrophoneEnergyLevelUpdate(payload));
        this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.PinnedParticipantDisplayCroppedChanged, EventDispatcher.RenderListeners, (payload) => this._updatePinnedDisplayCropped(payload));
        this._vidyoCore.EventDispatcher.emit(AnalyticsEvents.Events.CreateView);
        this._onRecheckEachVideoSizeRef = this._onRecheckEachVideoSize.bind(this);
        this._parent = this._createParent(viewId);
        if (this._parent) {
            SizeObserver_1.SizeObserver.Start(this._parent, () => this._onRecheckEachVideoSize());
        }
    }
    Destroy() {
        this._destroyAudioElements();
    }
    _addVideoElement(template, container, options, stream, participantId, isLocal, isApplication, isPinned = false) {
        let streamId = stream.Id;
        const isRearCamera = stream.GetVideoTracks()[0] && stream.GetVideoTracks()[0].Settings.facingMode === 'environment';
        let name = options.name || '';
        let htmlEntityAsFirstSymbol = name.match(/^&#?[a-z0-9]{2,7};/gi);
        let placeholderLetter = htmlEntityAsFirstSymbol ? htmlEntityAsFirstSymbol[0] : (name[0] || '');
        let templateOptions = {
            name: name,
            placeholderLetter: placeholderLetter,
            updateGeneration: (options.updateGeneration || Infinity).toString(),
            participantId: `${participantId}`,
            streamId: `${streamId}`,
            cellId: `${streamId}`,
            trackId: `${streamId}-track`,
            trackType: isLocal ? 'local-track' : 'remote-track',
            displayCroppedText: options.displayCropped ? 'displayCropped' : '',
            allowZoomText: options.allowZoom ? 'allowZoom' : ''
        };
        let div = document.createElement('div');
        div.innerHTML = StringUtils_1.default.Format(template, templateOptions);
        let element = div.firstElementChild;
        if (element && container) {
            const typeClass = isApplication ? 'application-type' : 'video-type';
            element.classList.add(typeClass);
            if (isPinned) {
                element.classList.add('pinned-video');
            }
            this._attachDragEventsToElement(element);
            let statsOverlay = document.getElementById('vidyo-global-stats-overlay');
            if (statsOverlay) {
                container.insertBefore(element, statsOverlay);
            }
            else {
                container.appendChild(element);
            }
            if (isApplication) {
                let placeholder = element.querySelector('.video-placeholder');
                if (placeholder) {
                    placeholder.classList.add('hide');
                }
                this._initApplicationPopup(container, element, stream, options.name, participantId, streamId);
            }
            else {
                this._initPinParticipantHandler(element, participantId);
            }
            let videoElement = document.getElementById(templateOptions.trackId);
            if (videoElement) {
                videoElement.autoplay = true;
                let mediaStream = stream.GetMediaStream();
                videoElement.srcObject = mediaStream;
                setTimeout(() => videoElement.ended && videoElement.load(), 0);
                videoElement.addEventListener('resize', this._onRecheckEachVideoSizeRef);
                videoElement.addEventListener('leavepictureinpicture', () => {
                    videoElement.load();
                });
                if (navigator.userAgent.includes('iPhone') && navigator.userAgent.includes('Safari') &&
                    !navigator.userAgent.includes('Chrome')) {
                    videoElement.setAttribute('playsinline', 'true');
                }
                if (isLocal && isRearCamera && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
                    videoElement.classList.add('flip-back-video');
                }
                videoElement.classList.add('video-loading');
                videoElement.addEventListener('play', () => {
                    videoElement.classList.remove('video-loading');
                });
                videoElement.addEventListener('loadstart', () => {
                    videoElement.classList.add('video-loading');
                });
                let videoState = false;
                if (!isLocal) {
                    let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
                    if (participant) {
                        videoState = participant.HasVideoSource() || isApplication;
                        if (participant.HasVideoSource()) {
                            this._initFeccHandler(element, participant);
                        }
                    }
                }
                let audioEnabled = false;
                let videoEnabled = videoState
                    || !!(isLocal && stream.GetVideoTracks().length && stream.GetVideoTracks()[0].IsActive());
                element.classList.toggle('video-muted', !videoEnabled);
                let canvas = element.querySelector('.volume-indicator');
                if (canvas && !isApplication) {
                    let audioMuted = false;
                    let audioStream;
                    if (isLocal) {
                        audioStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
                        audioMuted = this._vidyoCore.Controllers.DeviceController.GetAudioMuteState();
                    }
                    else {
                        const roStream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantAudioStream(participantId);
                        if (roStream) {
                            audioStream = roStream.GetMediaStream();
                        }
                        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
                        if (participant) {
                            audioMuted = !participant.HasAudioSource() || participant.AudioMuted();
                        }
                    }
                    if (audioStream && !audioMuted) {
                        const canvasContextId = isLocal ? audioStream.Id : participantId;
                        this._createEnergyLevelCanvasContext(canvasContextId, canvas);
                        audioEnabled = true;
                    }
                }
                this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileAdded, {
                    element,
                    isApplication,
                    isLocal,
                    isPinned,
                    participantId,
                    audioEnabled,
                    videoEnabled
                });
            }
        }
        return element;
    }
    _updatePinnedDisplayCropped(displayCropped) {
        const participantElements = this._parent.querySelectorAll(`.video-container.pinned-video`);
        Array.prototype.forEach.call(participantElements, (container) => {
            if (displayCropped) {
                container.classList.add('displayCropped');
            }
            else {
                container.classList.remove('displayCropped');
            }
        });
    }
    _attachDragEventsToElement(element) {
        let dragInProcess = false;
        let dragData;
        let videoElement;
        let container;
        let maxDeltaX = 0;
        let maxDeltaY = 0;
        let mouseDown = () => {
            let isApplication = !!element.closest('.application-grid');
            if (isApplication) {
                return;
            }
            dragInProcess = new Promise((resolve, reject) => {
                videoElement = element.querySelector('video');
                if (!videoElement) {
                    reject('Failed to find video element');
                    return;
                }
                setTimeout(() => {
                    if (videoElement) {
                        setTimeout(() => {
                            if (!videoElement) {
                                reject('Failed to find video element');
                                return;
                            }
                            container = videoElement.closest('.video-container');
                            if (!container) {
                                reject('Failed to find parent container');
                                return;
                            }
                            let { height: containerHeight, width: containerWidth } = container.getBoundingClientRect();
                            let { height: elementHeight, width: elementWidth } = videoElement.getBoundingClientRect();
                            const half = 2;
                            maxDeltaX = Math.abs((elementWidth - containerWidth) / half);
                            maxDeltaY = Math.abs((elementHeight - containerHeight) / half);
                            resolve();
                        });
                    }
                });
            }).then(() => {
                dragInProcess = true;
            });
        };
        let mouseUp = () => {
            dragInProcess = false;
            dragData = undefined;
        };
        let mouseMove = (event) => {
            if (!dragInProcess) {
                return;
            }
            let handleEvent = () => {
                if (!dragData) {
                    const baseTen = 10;
                    if (!videoElement) {
                        return;
                    }
                    let marginTop = parseInt(videoElement.style.marginTop, baseTen);
                    let elementTop = isNaN(marginTop) ? 0 : marginTop;
                    let marginLeft = parseInt(videoElement.style.marginLeft, baseTen);
                    let elementLeft = isNaN(marginLeft) ? 0 : marginLeft;
                    dragData = { dragStartTop: event.clientY, dragStartLeft: event.clientX, elementTop, elementLeft };
                }
                let deltaX = -1 * (dragData.dragStartLeft - event.clientX) + dragData.elementLeft;
                let deltaY = -1 * (dragData.dragStartTop - event.clientY) + dragData.elementTop;
                deltaX = deltaX === 0 ? 0
                    : Math.abs(deltaX) < maxDeltaX ? deltaX : (deltaX / Math.abs(deltaX)) * maxDeltaX;
                deltaY = deltaY === 0 ? 0
                    : Math.abs(deltaY) < maxDeltaY ? deltaY : (deltaY / Math.abs(deltaY)) * maxDeltaY;
                if (!videoElement) {
                    return;
                }
                videoElement.style.marginLeft = deltaX === 0 ? '' : deltaX.toString() + 'px';
                videoElement.style.marginTop = deltaY === 0 ? '' : deltaY.toString() + 'px';
            };
            if (dragInProcess !== true && dragInProcess.then) {
                dragInProcess.then(handleEvent);
            }
            else {
                handleEvent();
            }
        };
        element.addEventListener('mousedown', mouseDown);
        element.addEventListener('mouseleave', mouseUp);
        element.addEventListener('mouseup', mouseUp);
        element.addEventListener('mousemove', mouseMove);
    }
    _closeStreamPopup(id) {
        if (this._streamPopups[id]) {
            this._streamPopups[id].popup.onbeforeunload = () => { };
            this._streamPopups[id].popup.close();
            delete this._streamPopups[id];
        }
    }
    _createParent(viewId) {
        return (0, NotImplemented_1.NotImplemented)();
    }
    _createEnergyLevelCanvasContext(canvasContextId, canvas) {
        const canvasContext = canvas.getContext('2d');
        canvasContext.fillStyle = 'green';
        this._energyLevelCanvasContext[canvasContextId] = {
            canvas,
            canvasContext
        };
    }
    _deleteEnergyLevelCanvasContext(canvasContextId) {
        delete this._energyLevelCanvasContext[canvasContextId];
    }
    _destroyAudioElements() {
        Object.keys(this._participantsAudios).forEach((key) => {
            this._participantsAudios[key].srcObject = null;
            delete this._participantsAudios[key];
        });
    }
    _eachVideoElement(callback) {
        if (this._parent) {
            const videoContainers = this._parent.querySelectorAll('.vidyo-rendering-container .video-container');
            Array.prototype.forEach.call(videoContainers, callback);
        }
    }
    _elementsApplicationForParticipant(id) {
        let elements = document.querySelectorAll(`.vidyo-rendering-container .application-type.video-container[data-participant-id='${id}']`);
        return Array.from(elements);
    }
    _elementsForParticipant(id) {
        let elements = document.querySelectorAll(`.vidyo-rendering-container .video-container[data-participant-id='${id}']`);
        return Array.from(elements);
    }
    _elementsVideoForParticipant(id) {
        let elements = document.querySelectorAll(`.vidyo-rendering-container .video-grid .video-type.video-container[data-participant-id='${id}']`);
        return Array.from(elements);
    }
    _getVideoMediaResolution(video) {
        return {
            width: video.videoWidth,
            height: video.videoHeight
        };
    }
    _getVideoTileByDataParticipantId(id, className) {
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
            return this._parent.querySelector(`[data-participant-id='${id}']${className}`);
        }
        else {
            return this._parent.querySelector(`${className} [data-participant-id='${id}']`);
        }
    }
    _isAudioMeterDisabled(participantId) {
        return false;
    }
    _onConnected() {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
            const audio = new Audio();
            audio.load();
        }
    }
    _onRecheckEachVideoSize() {
    }
    _onVideoCropSettingsChanged(videoResolution) {
        const participantElements = this._parent.querySelectorAll(`[data-participant-id='${videoResolution.Id}']`);
        Array.prototype.forEach.call(participantElements, (container) => {
            this._setAspectRatioClassToContainer(container, videoResolution);
        });
    }
    _safelyRemoveAllMediaElement(id) {
        this._safelyRemoveVideoElement(id);
        this._safelyRemoveApplicationElement(id);
    }
    _safelyRemoveApplicationElement(id) {
        this._elementsApplicationForParticipant(id).forEach((toRemove) => {
            this._removeVideoElements(toRemove);
            this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileRemoved, {
                element: toRemove,
                isApplication: true,
                participantId: id
            });
        });
        for (let [key, value] of Object.entries(this._streamPopups)) {
            if (value.participantId === id) {
                this._closeStreamPopup(key);
            }
        }
    }
    _safelyRemoveVideoElement(id) {
        this._deleteEnergyLevelCanvasContext(id);
        this._elementsVideoForParticipant(id).forEach((toRemove) => {
            this._removeVideoElements(toRemove);
            this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileRemoved, {
                element: toRemove,
                isApplication: false,
                participantId: id
            });
        });
    }
    _setAspectRatioClassToContainer(container, videoResolution) {
        let video = container.querySelector('video');
        if (videoResolution.AspectRatio < 1) {
            if (container.classList.contains(AspectRatioTooWideClassName)) {
                container.classList.remove(AspectRatioTooWideClassName);
            }
            if (container.classList.contains(AspectRatioTooHighClassName)) {
                container.classList.remove(AspectRatioTooHighClassName);
            }
            if (!container.classList.contains(AspectRatioInversedClassName)) {
                container.classList.add(AspectRatioInversedClassName);
            }
        }
        else if (videoResolution.AspectRatioRatioType === VideoResolution_1.AspectRatioRatioType.Taller) {
            if (container.classList.contains(AspectRatioInversedClassName)) {
                container.classList.remove(AspectRatioInversedClassName);
            }
            if (container.classList.contains(AspectRatioTooWideClassName)) {
                container.classList.remove(AspectRatioTooWideClassName);
            }
            if (!container.classList.contains(AspectRatioTooHighClassName)) {
                container.classList.add(AspectRatioTooHighClassName);
            }
            if (video) {
                video.style.marginLeft = '';
            }
        }
        else {
            if (container.classList.contains(AspectRatioInversedClassName)) {
                container.classList.remove(AspectRatioInversedClassName);
            }
            if (container.classList.contains(AspectRatioTooHighClassName)) {
                container.classList.remove(AspectRatioTooHighClassName);
            }
            if (!container.classList.contains(AspectRatioTooWideClassName)) {
                container.classList.add(AspectRatioTooWideClassName);
            }
            if (video) {
                video.style.marginTop = '';
            }
        }
    }
    _setSinkId(element, sinkId) {
        return this._pushToAsyncQueue(() => {
            if (!('setSinkId' in element)) {
                element['sinkId'] = sinkId;
                return Promise.resolve(undefined);
            }
            else {
                if (!OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsChrome() && sinkId === 'default') {
                    return Promise.resolve(undefined);
                }
                return element['setSinkId'](sinkId).catch((reason) => {
                    const ignoredErrors = [
                        'AbortError: The operation could not be performed and was aborted'
                    ];
                    if (ignoredErrors.indexOf(reason.toString()) < 0) {
                        throw (new Error(`Failed to set speaker for ${element.id}. ${reason}`));
                    }
                });
            }
        });
    }
    _updateAudioStreams() {
        const allParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: 'remote' });
        const allParticipantsIds = allParticipants.map((participant) => participant.Id);
        const audioStreamIds = [];
        allParticipantsIds.forEach((participantId) => {
            let audioStream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantAudioStream(participantId);
            if (audioStream) {
                audioStreamIds.push(audioStream.Id);
                this._updateParticipantAudioStream(audioStream);
            }
        });
        Object.keys(this._participantsAudios).forEach((key) => {
            if (-1 === audioStreamIds.indexOf(key)) {
                this._participantsAudios[key].srcObject = null;
                delete this._participantsAudios[key];
            }
        });
    }
    _updateAudioStreamSource(audioStream) {
        this._updateParticipantAudioStream(audioStream);
    }
    _updateCameraControl(videoTile, cameraId, show) {
        const controls = videoTile.querySelector(`fecc-controls-view`);
        if (cameraId) {
            this._vidyoCore.Controllers.DeviceController.GetCameraControlCapabilities(cameraId).then((capabilities) => {
                const isControllable = capabilities.panTiltHasContinuousMove
                    || capabilities.zoomHasContinuousMove
                    || capabilities.panTiltHasNudge
                    || capabilities.zoomHasNudge;
                if (isControllable && show) {
                    let intervalHandler = null;
                    let isMoveStarted = false;
                    const ptzStart = (direction, interval = Constants_1.FeccMoveInterval) => {
                        isMoveStarted = true;
                        intervalHandler = TimingProvider_1.TimingProvider.Interval(interval, () => {
                            this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZStart(cameraId, {
                                timeout: Constants_1.FeccMoveDurationNs,
                                direction
                            });
                        }, true);
                    };
                    const ptzNudge = (options) => {
                        const delay = capabilities.hasVisca ? Constants_1.FeccMoveInterval : Constants_1.FeccNudgeInterval;
                        intervalHandler = TimingProvider_1.TimingProvider.Interval(delay, () => {
                            this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZNudge(cameraId, options);
                        }, true);
                    };
                    const ptzStop = () => {
                        clearInterval(intervalHandler);
                        if (isMoveStarted) {
                            this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZStop(cameraId);
                            isMoveStarted = false;
                        }
                    };
                    controls.handleAction = (event) => {
                        clearInterval(intervalHandler);
                        this._vidyoCore.Controllers.LogController.LogDebug(() => `Handle FECC action: ${event.detail}`);
                        switch (event.detail) {
                            case FeccControlsView_1.FeccControlAction.PANLEFT:
                                if (capabilities.panTiltHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_PanLeft);
                                }
                                else if (capabilities.panTiltHasNudge) {
                                    ptzNudge({ pan: -1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.PANRIGHT:
                                if (capabilities.panTiltHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_PanRight);
                                }
                                else if (capabilities.panTiltHasNudge) {
                                    ptzNudge({ pan: 1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.TILTUP:
                                if (capabilities.panTiltHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_TiltUp);
                                }
                                else if (capabilities.panTiltHasNudge) {
                                    ptzNudge({ tilt: 1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.TILTDOWN:
                                if (capabilities.panTiltHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_TiltDown);
                                }
                                else if (capabilities.panTiltHasNudge) {
                                    ptzNudge({ tilt: -1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.ZOOMIN:
                                if (capabilities.zoomHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_ZoomIn, Constants_1.FeccZoomInterval);
                                }
                                else if (capabilities.zoomHasNudge) {
                                    ptzNudge({ zoom: 1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.ZOOMOUT:
                                if (capabilities.zoomHasContinuousMove) {
                                    ptzStart(Devices_1.VidyoCameraControlDirection.VIDYO_CAMERACONTROLDIRECTION_ZoomOut, Constants_1.FeccZoomInterval);
                                }
                                else if (capabilities.zoomHasNudge) {
                                    ptzNudge({ zoom: -1 });
                                }
                                break;
                            case FeccControlsView_1.FeccControlAction.STOP:
                            default:
                                ptzStop();
                        }
                    };
                    controls.classList.remove('hide');
                }
                else {
                    controls.classList.add('hide');
                    controls.handleAction = null;
                }
            });
        }
        else {
            controls.classList.add('hide');
            controls.handleAction = null;
        }
    }
    _updateParticipantAudioStream(audioStream) {
        const speaker = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Speaker;
        const speakerMuted = this._vidyoCore.Controllers.DeviceController.GetSpeakerMuteState();
        let audioElement = this._participantsAudios[audioStream.Id];
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            if (!speakerMuted && typeof speaker !== 'boolean' && speaker.Id) {
                if (!audioElement) {
                    audioElement = this._createParticipantAudio(audioStream);
                    this._participantsAudios[audioStream.Id] = audioElement;
                }
                this._setSinkId(audioElement, speaker.Id);
                audioElement.ended && audioElement.load();
            }
            else if (audioElement) {
                audioElement.srcObject = null;
                delete this._participantsAudios[audioStream.Id];
            }
        }
        else {
            if (!audioElement) {
                audioElement = this._createParticipantAudio(audioStream);
                this._participantsAudios[audioStream.Id] = audioElement;
            }
            if (typeof speaker !== 'boolean' && speaker.Id) {
                audioElement.muted = speakerMuted;
                this._setSinkId(audioElement, speaker.Id);
            }
            else {
                audioElement.muted = true;
            }
            audioElement.ended && audioElement.load();
        }
    }
    _createParticipantAudio(audioStream) {
        const audioMediaStream = audioStream.GetMediaStream();
        const audioElement = new Audio();
        audioElement.id = audioStream.Id;
        audioElement.autoplay = true;
        audioElement.srcObject = audioMediaStream;
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsChrome()) {
            audioMediaStream.addEventListener('addtrack', () => {
                audioElement.load();
            });
        }
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIOS() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIPadOS()) {
            audioElement.addEventListener('pause', () => {
                this._vidyoCore.Controllers.LogController.LogDebug(() => `Force reload paused <audio id=${audioElement.id}>`);
                audioElement.load();
            });
        }
        audioElement.addEventListener('loadedmetadata', () => audioElement.ended && audioElement.load());
        if (this._vidyoCore.Controllers.LogController.IsLevelAndCategoryEnabled(LogEvents_1.VidyoLogLevel.debug, LogEvents_1.VidyoLogCategory.VidyoDevelopment)) {
            let track = audioMediaStream.getTracks()[0];
            let trackId = '-1';
            if (track) {
                trackId = track.id;
                track.onmute = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned ${track.kind} track ${trackId} muted`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
                track.onunmute = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned ${track.kind} track ${trackId} unmuted`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            }
            audioElement.onplaying = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} playing`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onwaiting = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} waiting`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onseeking = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} seeking`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onseeked = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} seeked`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onended = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} ended`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onloadeddata = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} loadeddata`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.oncanplay = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} canplay`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.oncanplaythrough = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} canplaythrough`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.ondurationchange = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} durationchange`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.ontimeupdate = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} timeupdate`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onplay = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} play`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onpause = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} pause`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onratechange = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} ratechange`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onvolumechange = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} volumechange`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onsuspend = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} suspend`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onemptied = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} emptied`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onstalled = () => this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} stalled`, LogEvents_1.VidyoLogCategory.VidyoDevelopment);
            audioElement.onloadedmetadata = () => { this._vidyoCore.Controllers.LogController.LogDebug(() => `IOWEBRTC-1317 cloned audio track ${trackId} loadedmetadata`, LogEvents_1.VidyoLogCategory.VidyoDevelopment); audioElement.ended && audioElement.load(); };
        }
        return audioElement;
    }
    _createApplicationPopup(container, element, stream, name) {
        let applicationWindow = window
            .open('', '', 'width=1280,height=720,status=0,menubar=0,toolbar=0,location=0');
        if (applicationWindow) {
            const participantId = element.getAttribute('data-participant-id');
            const undockedElement = element.cloneNode(true);
            const title = document.createElement('title');
            title.innerHTML = name;
            applicationWindow.document.head.appendChild(title);
            const style = document.createElement('style');
            style.innerHTML = Templates.streamPopupStyle;
            applicationWindow.document.head.appendChild(style);
            const videoElement = undockedElement.querySelector('video');
            applicationWindow.document.body.appendChild(undockedElement);
            const dockImg = undockedElement.querySelector('.popup-application');
            dockImg.src = Templates.dockSVGImage;
            const statsOverlay = undockedElement.querySelector('.stats-overlay');
            const closeSafely = () => {
                applicationWindow && applicationWindow.close();
            };
            const onStatsUpdate = () => {
                const showStatsOverlay = this._vidyoCore.Controllers.AdvancedSettingsController.ShowStatisticsOverlay;
                if (!showStatsOverlay) {
                    return;
                }
                const stats = this._vidyoCore.Controllers.StatisticsController.GetCallStats();
                const shareStatistics = stats.ShareStatistics.Get(participantId);
                if (shareStatistics && statsOverlay) {
                    shareStatistics.ActualTileSize.SetValues(videoElement.clientWidth, videoElement.clientHeight);
                    statsOverlay.style.display = showStatsOverlay ? 'block' : 'none';
                    const excludeStatisticTypes = [
                        'AudioDecodingMuted',
                        'AudioDecodingNormal',
                        'ParticipantIsActive',
                        'SSRCs',
                    ];
                    const formattedStatisticLines = this._statisticsToFormattedHTML(shareStatistics, excludeStatisticTypes);
                    statsOverlay.innerHTML = StringUtils_1.default.Format(Templates.statisticsBlock, { lines: formattedStatisticLines });
                }
            };
            const notifyTileAdded = (element, isUndocked) => {
                this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileAdded, {
                    element,
                    participantId,
                    audioEnabled: false,
                    videoEnabled: !element.classList.contains('video-muted'),
                    isLocal: element.classList.contains('local-track'),
                    isApplication: true,
                    isPinned: false,
                    isUndocked
                });
            };
            const notifyTileRemoved = (element) => {
                this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileRemoved, {
                    element,
                    isApplication: true,
                    participantId
                });
            };
            const onLoadHandler = () => {
                notifyTileAdded(undockedElement, true);
                this._onRecheckEachVideoSize();
                this._vidyoCore.EventDispatcher.on(RenderEvents.Events.StatisticsUpdate, EventDispatcher.RenderListeners, onStatsUpdate);
                this._vidyoCore.EventDispatcher.once(ConnectionEvents.Events.Disconnecting, EventDispatcher.RenderListeners, closeSafely);
            };
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                setTimeout(() => void onLoadHandler());
            }
            else {
                applicationWindow.onload = onLoadHandler;
            }
            dockImg.onclick = closeSafely;
            setTimeout(() => {
                videoElement.srcObject = stream.GetMediaStream();
            }, 0);
            container.removeChild(element);
            notifyTileRemoved(element);
            const onHideHandler = () => {
                applicationWindow.onbeforeunload = null;
                applicationWindow.onpagehide = null;
                this._vidyoCore.EventDispatcher.off(RenderEvents.Events.StatisticsUpdate, onStatsUpdate);
                notifyTileRemoved(undockedElement);
                if (this._vidyoCore.Controllers.CallStateController.MediaState.ShouldTransmitMedia) {
                    container.appendChild(element);
                    notifyTileAdded(element, false);
                    let video = element.querySelector('video');
                    if (video) {
                        video.play();
                    }
                    this._onRecheckEachVideoSize();
                }
            };
            applicationWindow.onbeforeunload = onHideHandler;
            applicationWindow.onpagehide = onHideHandler;
        }
        return applicationWindow;
    }
    _initApplicationPopup(container, element, stream, name, participantId, streamId) {
        let popupApplication = element.querySelector('.popup-application');
        if (popupApplication) {
            popupApplication.classList.remove('hide');
            popupApplication.addEventListener('click', () => {
                let applicationPopup = this._createApplicationPopup(container, element, stream, name);
                if (applicationPopup) {
                    this._onRecheckEachVideoSize();
                    this._streamPopups[streamId] = {
                        element,
                        participantId: participantId,
                        popup: applicationPopup
                    };
                }
            });
        }
    }
    _initPinParticipantHandler(element, participantId) {
        let pinButton = element.querySelector('.pin-participant');
        if (pinButton) {
            pinButton.classList.remove('hide');
            pinButton.addEventListener('click', () => {
                this._vidyoCore.Controllers.ParticipantController.TogglePinParticipant(participantId);
            });
        }
    }
    _initFeccHandler(videoTile, participant) {
        const controlButton = videoTile.querySelector('.control-participant');
        const controls = videoTile.querySelector('fecc-controls-view');
        const cameraId = participant.GetCameraId();
        if (controlButton) {
            if (cameraId) {
                this._vidyoCore.Controllers.DeviceController.IsRemoteCameraControllable(cameraId).then((isControllable) => {
                    controlButton.classList.toggle('hide', !isControllable);
                    if (controls && isControllable) {
                        this._updateCameraControl(videoTile, cameraId, participant.IsControlled);
                        controlButton.ondblclick = (event) => event.stopPropagation();
                        controlButton.onclick = (event) => {
                            participant.IsControlled = !participant.IsControlled;
                            if (!participant.IsPinned) {
                                this._vidyoCore.Controllers.ParticipantController.PinParticipant(participant.Id, true);
                            }
                            this._updateCameraControl(videoTile, cameraId, participant.IsControlled);
                            event.stopPropagation();
                        };
                    }
                });
            }
            else {
                this._updateCameraControl(videoTile, null, false);
                controlButton.onclick = null;
                controlButton.classList.add('hide');
                participant.IsControlled = false;
            }
        }
    }
    _onCameraListChanged(payload) {
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(payload.participantUri);
        const videoTile = this._getVideoTileByDataParticipantId(payload.participantUri, '.video-type');
        if (participant && videoTile) {
            this._initFeccHandler(videoTile, participant);
        }
    }
    _onMicrophoneEnergyLevelUpdate(payload) {
        const participantId = payload.isLocal ? Participant_1.LocalParticipantId : payload.participant.Id;
        if (this._isAudioMeterDisabled(participantId)) {
            return;
        }
        if (payload.isLocal) {
            const audioStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
            if (audioStream) {
                this._updateEnergyLevel(audioStream.Id, payload.audioLevel);
            }
        }
        else if (payload.participant) {
            this._updateEnergyLevel(payload.participant.Id, payload.audioLevel);
        }
    }
    _onUpdateCameraControl(payload) {
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(payload.participantId);
        if (participant) {
            const videoTile = this._getVideoTileByDataParticipantId(participant.Id, '.video-type');
            if (videoTile) {
                const cameraId = participant.GetCameraId();
                this._updateCameraControl(videoTile, cameraId, payload.show);
            }
        }
    }
    _onSpeakerPrivacyChanged(muted) {
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            if (muted) {
                this._destroyAudioElements();
            }
            else {
                this._updateAudioStreams();
            }
        }
        else {
            const speaker = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Speaker;
            Object.keys(this._participantsAudios).forEach((key) => {
                const audioElement = this._participantsAudios[key];
                if (!muted && typeof speaker !== 'boolean' && speaker.Id) {
                    audioElement.muted = false;
                    this._setSinkId(audioElement, speaker.Id);
                    audioElement.ended && audioElement.load();
                }
                else {
                    audioElement.muted = true;
                }
            });
        }
    }
    _onSpeakerSelected(payload) {
        const speakerMuted = this._vidyoCore.Controllers.DeviceController.GetSpeakerMuteState();
        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
            if (!speakerMuted) {
                this._updateAudioStreams();
            }
        }
        else {
            Object.keys(this._participantsAudios).forEach((key) => {
                const audioElement = this._participantsAudios[key];
                if (payload.speakerId) {
                    audioElement.muted = speakerMuted;
                    this._setSinkId(audioElement, payload.speakerId);
                }
                else {
                    audioElement.muted = true;
                }
            });
        }
    }
    _onStatisticsUpdate() {
        const showStatsOverlay = this._vidyoCore.Controllers.AdvancedSettingsController.ShowStatisticsOverlay;
        if (!showStatsOverlay) {
            return;
        }
        let stats = this._vidyoCore.Controllers.StatisticsController.GetCallStats();
        let orphanStreamStats = [];
        const getStatsOverlay = (id, className) => {
            const videoTile = this._getVideoTileByDataParticipantId(id, className);
            if (videoTile) {
                return { videoTile, statsOverlay: videoTile.querySelector('.stats-overlay') };
            }
            return {};
        };
        stats.ParticipantStatistics.All().forEach((participantStatistic) => {
            const { videoTile, statsOverlay } = getStatsOverlay(participantStatistic.Id, '.video-type');
            if (statsOverlay) {
                this._setElementVisible(statsOverlay, showStatsOverlay);
                participantStatistic.ActualTileSize.SetValues(videoTile?.clientWidth, videoTile?.clientHeight);
                const excludeStatisticTypes = [
                    'AudioDecodingMuted',
                    'AudioDecodingNormal',
                    'ParticipantIsActive',
                    'SSRCs',
                ];
                const formattedStatisticLines = this._statisticsToFormattedHTML(participantStatistic, excludeStatisticTypes);
                statsOverlay.innerHTML = StringUtils_1.default.Format(Templates.statisticsBlock, { lines: formattedStatisticLines });
            }
            else {
                let audioText = `${participantStatistic.AudioBytesReceived} audio bytes`;
                let videoText = `${participantStatistic.VideoPacketsReceived} video packets`;
                orphanStreamStats.push([`Orphaned stream '${participantStatistic.Id}'`, `${audioText}, ${videoText}`]);
            }
        });
        stats.ShareStatistics.All().forEach((shareStatistics) => {
            const { videoTile, statsOverlay } = getStatsOverlay(shareStatistics.Id, '.application-type');
            shareStatistics.ActualTileSize.SetValues(videoTile?.clientWidth, videoTile?.clientHeight);
            if (statsOverlay) {
                this._setElementVisible(statsOverlay, showStatsOverlay);
                const excludeStatisticTypes = [
                    'AudioDecodingMuted',
                    'AudioDecodingNormal',
                    'ParticipantIsActive',
                    'SSRCs',
                ];
                const formattedStatisticLines = this._statisticsToFormattedHTML(shareStatistics, excludeStatisticTypes);
                statsOverlay.innerHTML = StringUtils_1.default.Format(Templates.statisticsBlock, { lines: formattedStatisticLines });
            }
            else {
                let videoText = `${shareStatistics.VideoPacketsReceived} video packets`;
                orphanStreamStats.push([`Orphaned stream '${shareStatistics.Id}'`, `${videoText}`]);
            }
        });
        let previewStream = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
        let overlay = this._parent.querySelectorAll(`[data-participant-id='${previewStream.Id}'] .stats-overlay`)[0];
        if (overlay) {
            this._setElementVisible(overlay, showStatsOverlay);
            if (showStatsOverlay) {
                const excludeStatisticTypes = [
                    'ShareStatistics',
                    'ParticipantStatistics',
                    'FillFromBandwidthSummaryStatistics',
                    'FillFromLocalMicrophoneStatistics',
                    'FillFromLocalVideoSourceStatistics',
                    '_activeParticipantsStatistics',
                    '_calculateStatisticsTotalBy'
                ];
                const formattedStatisticLines = this._statisticsToFormattedHTML(stats, excludeStatisticTypes);
                const formattedOrphanStreamStats = this._statisticsToFormattedHTML(orphanStreamStats);
                const lines = `${formattedStatisticLines}\n${formattedOrphanStreamStats}`;
                overlay.innerHTML = StringUtils_1.default.Format(Templates.statisticsBlock, { lines });
            }
            else {
                overlay.innerHTML = '';
            }
        }
    }
    _onUpdateStreamSource(participantId) {
        const participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
        const videoTile = this._getVideoTileByDataParticipantId(participantId, '.video-type');
        if (participant && videoTile) {
            this._initFeccHandler(videoTile, participant);
        }
    }
    _pushToAsyncQueue(action) {
        return new Promise((resolve, reject) => {
            this._actionsQueue.push(action, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    _removeVideoElement(video) {
        video.removeEventListener('resize', this._onRecheckEachVideoSizeRef);
        if (!video.pause) {
            return;
        }
        video.pause();
        video.src = '';
        video.srcObject = null;
        video.load();
    }
    _removeVideoElements(toRemove) {
        const parent = toRemove.parentElement;
        if (parent) {
            let videos = toRemove.getElementsByTagName('video');
            Array.prototype.forEach.call(videos, (video) => {
                this._removeVideoElement(video);
            });
            parent.removeChild(toRemove);
        }
    }
    _setElementVisible(element, isVisible) {
        if (isVisible) {
            element.classList.remove('hide');
        }
        else {
            element.classList.add('hide');
        }
    }
    _statisticsToArray(object, except = []) {
        let statsTuples = [];
        for (let key in object) {
            if (except.indexOf(key) < 0) {
                statsTuples.push([key, object[key].toString()]);
            }
        }
        return statsTuples;
    }
    _statisticsToFormattedHTML(object, except = []) {
        const statisticLines = this._statisticsToArray(object, except);
        const formattedStatisticLines = statisticLines.map((line) => {
            let [statKey, statValue] = this._transformStatisticsOutputLine(line);
            return StringUtils_1.default.Format(Templates.statisticsBlockLine, { statKey, statValue });
        }).join('\n');
        return formattedStatisticLines;
    }
    _transformStatisticsOutputLine([key, value]) {
        const transformBitrate = (value) => {
            let bitrate = parseFloat(value);
            let extraUnits = ['Kbit/s', 'Mbit/s', 'Gbit/s'];
            let result = `${bitrate} bit/s`;
            for (let unit of extraUnits) {
                if (bitrate >= 1000) {
                    bitrate = bitrate / 1000;
                    result = `${Math.round(bitrate * 100) / 100} ${unit}`;
                }
                else {
                    break;
                }
            }
            return result;
        };
        const transforms = {
            AvailableRecieveBandwidth: transformBitrate,
            AvailableSendBandwidth: transformBitrate,
            TransmitBitrate: transformBitrate
        };
        if (typeof transforms[key] === 'function') {
            value = transforms[key](value);
        }
        return [key, value];
    }
    _updateEnergyLevel(contextId, audioLevel) {
        if (this._energyLevelCanvasContext[contextId]) {
            const { canvas, canvasContext } = this._energyLevelCanvasContext[contextId];
            if (canvas && canvasContext) {
                const volume = 1 + (audioLevel - this.audioLevelMaxThreshold) / this.audioLevelDynamicRange;
                canvasContext.clearRect(0, 0, canvas.width, canvas.height);
                canvasContext.fillRect(0, 0, canvas.width * volume, canvas.height);
            }
        }
    }
    _updateLocalViewLabel() {
        const preview = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
        const container = this._parent.querySelector(`[data-stream-id='${preview.Id}']`);
        const selectedCamera = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Camera;
        let previewLabel = 'Self View';
        if (typeof selectedCamera !== 'boolean') {
            previewLabel = selectedCamera.PreviewLabel;
        }
        if (container) {
            const label = container.querySelector(`.video-display-name span`);
            if (label) {
                label.innerHTML = StringUtils_1.default.toSecureString(previewLabel);
            }
            const placeholder = container.querySelector(`div.text`);
            if (placeholder) {
                placeholder.innerHTML = StringUtils_1.default.toSecureString(previewLabel)[0];
            }
        }
    }
    _updateShareWindowLocalViewLabel(type) {
        let preview;
        let selectedWindowShareLabel;
        if (type === 'window') {
            preview = this._vidyoCore.Controllers.LocalStreamController.WindowShareStream;
            selectedWindowShareLabel = this._vidyoCore.Controllers.DeviceController.GetWindowSharePreviewLabel();
        }
        else {
            preview = this._vidyoCore.Controllers.LocalStreamController.MonitorShareStream;
            selectedWindowShareLabel = this._vidyoCore.Controllers.DeviceController.GetMonitorSharePreviewLabel();
        }
        const container = this._parent.querySelector(`[data-stream-id='${preview.Id}']`);
        if (container) {
            const label = container.querySelector(`.video-display-name span`);
            if (label) {
                label.innerHTML = StringUtils_1.default.toSecureString(selectedWindowShareLabel);
            }
            const placeholder = container.querySelector(`div.text`);
            if (placeholder) {
                placeholder.innerHTML = StringUtils_1.default.toSecureString(selectedWindowShareLabel)[0];
            }
        }
    }
    _onDisableAudioEnergyMonitorChanged(val) {
        if (val) {
            this._vidyoCore.Controllers.LogController.LogDebug(() => 'Stopping audio energy monitoring for renderer');
            this._eachVideoElement((element) => {
                let canvas = element.querySelector('.volume-indicator');
                if (canvas) {
                    let canvasContext = canvas.getContext('2d');
                    if (canvasContext) {
                        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
            });
        }
        else {
            this._vidyoCore.Controllers.LogController.LogDebug(() => 'Start audio energy monitoring for renderer');
        }
    }
    _showStatisticsOverlayChanged() {
        const showStatsOverlay = this._vidyoCore.Controllers.AdvancedSettingsController.ShowStatisticsOverlay;
        this._parent?.querySelectorAll(`.stats-overlay`).forEach((el) => {
            this._setElementVisible(el, showStatsOverlay);
        });
    }
}
exports.RendererBase = RendererBase;

},{"../core/events/AdvancedSettingsEvents":62,"../core/events/AnalyticsEvents":63,"../core/events/ConnectionEvents":66,"../core/events/DeviceEvents":67,"../core/events/EventDispatcher":68,"../core/events/LogEvents":69,"../core/events/MicrophoneEnergyEvents":71,"../core/events/RenderEvents":75,"../core/models/Participant":94,"../core/models/RendererTypes":96,"../core/models/VideoResolution":100,"../core/utils/Constants":138,"../core/utils/NotImplemented":152,"../core/utils/OperatingSystemInfoProvider":154,"../core/utils/SizeObserver":162,"../core/utils/StringUtils":164,"../core/utils/TimingProvider":166,"../vidyo_simple_api/Devices":184,"./Templates":177,"./components/FeccControlsView":178,"async":1}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.CreateRenderer = void 0;
const CompositeRenderer = require("./composite/VidyoRenderer");
const CustomRenderer = require("./custom/CustomVidyoRenderer");
const Messages = require("../core/utils/Messages");
const RendererTypes_1 = require("../core/models/RendererTypes");
const RendererBase_1 = require("./RendererBase");
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return RendererBase_1.RendererBase; } });
const StringUtils_1 = require("../core/utils/StringUtils");
let renderers = {};
renderers[RendererTypes_1.RenderMode.Composite] = CompositeRenderer.VidyoRenderer;
renderers[RendererTypes_1.RenderMode.Custom] = CustomRenderer.CustomVidyoRenderer;
function CreateRenderer(viewId, viewStyle, vidyoCore) {
    vidyoCore.Controllers.RendererController.RenderMode = viewId ? RendererTypes_1.RenderMode.Composite : RendererTypes_1.RenderMode.Custom;
    vidyoCore.Controllers.LogController.LogInfo(() => `Render mode - ${vidyoCore.Controllers.RendererController.RenderMode}`);
    if (renderers[vidyoCore.Controllers.RendererController.RenderMode]) {
        let renderer = new renderers[vidyoCore.Controllers.RendererController.RenderMode](vidyoCore);
        renderer.CreateView(viewId);
        return renderer;
    }
    let error = new Error(StringUtils_1.default.Format(Messages.TheViewStyleViewStyleIsNotSupported, { viewStyle }));
    vidyoCore.Controllers.LogController.LogError(error);
    throw (error);
}
exports.CreateRenderer = CreateRenderer;

},{"../core/models/RendererTypes":96,"../core/utils/Messages":150,"../core/utils/StringUtils":164,"./RendererBase":175,"./composite/VidyoRenderer":179,"./custom/CustomVidyoRenderer":180}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamPopupStyle = exports.compositeLayoutGridSplitStyle = exports.compositeLayoutStyleSpaceBeforeVideo = exports.compositeLayoutStyle = exports.compositeLayoutDefaultStyle = exports.statisticsBlockLine = exports.statisticsBlock = exports.customTrackTemplate = exports.trackTemplate = exports.feccSVGImage = exports.pinPNGIcon = exports.undockSVGImage = exports.dockSVGImage = exports.containerTemplate = void 0;
exports.containerTemplate = `<div class='vidyo-rendering-container'>
  <style></style>
  <div class='media-grid video-grid'></div>
  <div class='media-grid application-grid'></div>
 </div>`;
exports.dockSVGImage = `data:image/svg+xml;utf8,
  <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     viewBox="0 0 1000 1000" style="enable-background:new 0 0 1000 1000;" xml:space="preserve">
  <filter id="shadow">
    <feDropShadow stdDeviation="55"/>
  </filter>
  <style type="text/css">
    .st0{fill:%23FFFFFF; filter:url(%23shadow);}
  </style>
  <path class="st0" d="M688.4,248.8H311.6c-34.6,0-62.8,28.2-62.8,62.8v376.8c0,34.6,28.2,62.8,62.8,62.8h376.8
    c34.6,0,62.8-28.2,62.8-62.8V311.6C751.2,277,723,248.8,688.4,248.8z M311.6,688.4l94.2-125.6l63.8,85.1l93.3-116.5l125.6,157H311.6
    L311.6,688.4z M820,100h-80H260h-80c-44,0-80,36-80,80v80v480v80c0,44,36,80,80,80h80h480h80c44,0,80-36,80-80v-80V260v-80
    C900,136,864,100,820,100z M820,740v80h-80H260h-80v-80V260v-80h80h480h80v80V740z"/>
  </svg>
`;
exports.undockSVGImage = `data:image/svg+xml;utf8,
  <svg version="1.1" id="Layer_3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     viewBox="0 -75 1100 1075" style="enable-background:new 0 0 1100 1100;" xml:space="preserve">
  <filter id="shadow">
    <feDropShadow stdDeviation="55"/>
  </filter>
  <style type="text/css">
    .st0{fill:%23FFFFFF; filter:url(%23shadow);}
  </style>
  <path class="st0" d="M820,686.2V820H180V180h133.8v-80H180c-44,0-80,36-80,80v640c0,44,36,80,80,80h640c44,0,80-36,80-80V686.2H820z
     M937.2,25H560.4c-34.6,0-62.8,28.2-62.8,62.8v376.8c0,34.6,28.2,62.8,62.8,62.8h376.8c34.6,0,62.8-28.2,62.8-62.8V87.8
    C1000,53.2,971.8,25,937.2,25z M560.4,464.6L654.6,339l63.8,85.1l93.3-116.5l125.6,157H560.4z"/>
  </svg>
`;
exports.pinPNGIcon = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABmJLR0QA/wD/AP+gvaeTAAAEm0lEQVRIiaWWW0wjZRTH/zOd6bTQ4SK4uIrsegnrRmR5YJNN2BAiMT7ywAvwQLI1G01IVp/wwQuJDxooi8QHLkYSMei6BnUlkJANRh9IfGgktEoI2c3ayqVUehnu3dJ2fOj56Mcw1IInOZl25pvzO7fvfCPg9CKQGn8z0Q1qKuIZwPy7FgDS5NeTKgArABmARPdFUqNjZxKBAyoAHACKQ6HQr8vLy28AKAFQCCCPnGAOHIOfJWIB6ahkADaCl6oOdWhpaamV/ueRYxIy5TgCzxXMXmTps3DQIr/ff0fX9WTZubJPPR5PK4ACgluzwbPBRByFyWSwBMBFADWLi4tDkXBkx+PxfBUJR/a1qJbwznvfB1AJ4Bw5pyCT9pyALKUKADsAFcCTAC4AqPF6vZ9rUU3XopoeDof33G7395FQJMbBnwdQikzND+ttDJ1PCQMzlSl1dgAFXq/3zYpnK27yLyeTydiDhw/uV75Y+bpoEaWV5ZX3qqqrxgDsAIgBSABIgQyeFLEMQJmenn66uqraKYriK/FEPOrz+X6zWq0XjFAAsFgstvLy8tqJyYm+husNV0WIxZStGKU6SfZ1wQBkKlFk9mAwOKpYldd4wOra6i9FatEL+Wp+BX8/9jim9fX1jfT09DwEsA4gCCAEIApgH0Cc4LrFBGwhsA2AQ5Ikb+3V2muSJJWyhQVqwXOBYMAPQLfZbA4AiMViO7f7bn/rcrnWAGwB2CbdBfCY0pwgE4dgFjkrPmsox+zsbL6maX/UXa+rscrWYgYvKiwqC6wG1gSLkAKgu3pd3/X29q4A0ChCjcB7BD4A1dcMbDaZ1Lm5ufxgMPhXfV39S4pNURm8+IniEt8j36OBoYGZ/v7+VQJuAAhzYJbiBLj5bbavdO6aoqvo9/uTi0uLC5va5j/84kuXL70sSVKM0hsmjdJ/Ps3M1olgXlIAko2NjanRL0dba67UXBsYGrivRbUNtkAQBLGxobEER1O8ifQW2kc6xUkYTiszMD/U9fr6eoyMjLylFqgVg8ODX3R3d6/feufWj9qmFjx8QRb3KULWVLtIb6EDijbJRXwMzA8OCwCpra3Nfvebux858hyXx8bGPu7q6vIB0CYmJjY6OzvvbG9tr+q6nnK73X8SbBeZZopzUOPZfKS5GNAKwOZ0Ogt7Pun5TLbJVfd+uvduR0fHOnl9ACC+sLCwG1gPzJ1/6vzfN5w3fkemrjs4oa4MykfJ9q8MQGlqanIMDw6PyIp8ZWpq6u329vYQ55SMzIGvU0q3AURI2RY6MAEfOmA87hQA9vn5+VfLnyn/cObnmQ9aWlrW6RkzwCYbAycoxTsU8R4yc9kUCorCOLFkRVE2m5ubfxgfH9+iF+JkbA/pTmVXvq5s67CG4pvp2LeX8SRip4+NlB3iCYLz04d1foqUPWejMSuYP53YwGAQga4snQkDmDeqI929bNtkhRrBzHs2yA+PMEMURjAPZw78pzAwi5Z3QOCeMYP8OmMkJzaSmfAfYCKO1pyvoZlzZsaP7ddcwLwDZsbMIswmOYP5e6c2dNp1xmhPI7k6khWcK/x/wXj5F4IH7ICtzs6lAAAAAElFTkSuQmCC`;
exports.feccSVGImage = `
  <svg width="26px" height="26px" viewBox="-2 -2 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch -->
    <title>fecc_icon_desktop_tile</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="fecc_icon_desktop_tile" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
      <g id="icon">
          <path d="M9.99949179,0 C4.48543985,0 0,4.48645627 0,9.99949179 C0,15.5145601 4.48543985,20 9.99949179,20 C15.5135437,20 20,15.5145601 20,9.99949179 C20,4.48645627 15.5135437,0 9.99949179,0" id="Path" fill="#13253B"></path>
          <path d="M9.99955532,1.25 C5.17475987,1.25 1.25,5.17564924 1.25,9.99955532 C1.25,14.8252401 5.17475987,18.75 9.99955532,18.75 C14.8243508,18.75 18.75,14.8252401 18.75,9.99955532 C18.75,5.17564924 14.8243508,1.25 9.99955532,1.25 M9.99957765,20 C4.48621025,20 1.65911729e-12,15.5137898 1.65911729e-12,9.99957765 C1.65911729e-12,4.48621025 4.48621025,6.75015599e-14 9.99957765,6.75015599e-14 C15.5137898,6.75015599e-14 20,4.48621025 20,9.99957765 C20,15.5137898 15.5137898,20 9.99957765,20" id="Fill" fill="#F0EFF0"></path>
          <polygon id="arrow" fill="#F0EFF0" transform="translate(10.000000, 15.230800) rotate(-180.000000) translate(-10.000000, -15.230800) " points="11.3704 17 10 15.5296 8.6296 17 7.6656 15.9656 10 13.4616 12.3344 15.9656"></polygon>
          <polygon id="arrow" fill="#F0EFF0" transform="translate(15.230800, 10.000000) rotate(-270.000000) translate(-15.230800, -10.000000) " points="16.6012 11.7692 15.2308 10.2988 13.8604 11.7692 12.8964 10.7348 15.2308 8.2308 17.5652 10.7348"></polygon>
          <polygon id="arrow" fill="#F0EFF0" transform="translate(4.769200, 10.000000) rotate(-90.000000) translate(-4.769200, -10.000000) " points="6.1396 11.7692 4.7692 10.2988 3.3988 11.7692 2.4348 10.7348 4.7692 8.2308 7.1036 10.7348"></polygon>
          <polygon id="arrow" fill="#F0EFF0" points="11.3704 6.5384 10 5.068 8.6296 6.5384 7.6656 5.504 10 3 12.3344 5.504"></polygon>
      </g>
    </g>
  </svg>
`;
exports.trackTemplate = `<div
  id='<%= cellId %>'
  data-participant-id='<%= participantId %>'
  data-stream-id='<%= streamId %>'
  class='video-container <%= trackType %> <%= displayCroppedText %> <%= allowZoomText %>'>
    <div class='video-overlay'>
      <div class='video-control-views-wrapper'>
        <div class='tile-control-view stats-overlay hide'></div>
        <fecc-controls-view class='tile-control-view fecc-controls hide'></fecc-controls-view>
      </div>
      <div class='video-display-name-wrapper'>
        <div class='video-display-name'>
          <span><%= name %></span>
        </div>
        <div class='video-tile-controls'>
          <div class='tile-control pin-participant hide'><img src='${exports.pinPNGIcon}'/></div>
          <div class='tile-control control-participant hide'>${exports.feccSVGImage}</div>
        </div>
        <canvas class='volume-indicator'></canvas>
      </div>
    </div>
    <div class="video-wrapper-container">
      <div class='video-wrapper'>
        <video id='<%= trackId %>' autoplay muted playsinline>
        </video>
        <div class='video-placeholder'><div class='text'><%= placeholderLetter %></div></div>
        <img src='${exports.undockSVGImage}' class='popup-application hide' />
      </div>
    </div>
 </div>`;
exports.customTrackTemplate = `<div class='vidyo-rendering-container-custom'>
  ${exports.trackTemplate}
</div>`;
exports.statisticsBlock = `<ul class='statistics-list'>
<%= lines %>
</ul>
`;
exports.statisticsBlockLine = `<li class='statistics-line'>
  <span class='statistics-key'><%= statKey %></span>: <span class='statistics-value'><%= statValue %></span>
</li>`;
exports.compositeLayoutDefaultStyle = `
.media-grid {
  grid-template-columns: 1fr, 1fr;
  grid-template-rows: 1fr;
}`;
exports.compositeLayoutStyle = `
.media-grid<%= scope %> {
  grid-template-columns: repeat(calc(<%= columns %> * 2), 1fr);
  grid-template-rows: repeat(<%= rows %>, 1fr);
}`;
exports.compositeLayoutStyleSpaceBeforeVideo = `
.media-grid<%= scope %> .video-container:nth-of-type(<%= index %>) {
  grid-column-start: 2;
}`;
const compositeLayoutGridSplitStyle = (splitType, videoGridLayoutColumns) => {
    switch (splitType) {
        case "VideoOnly":
            return `
.vidyo-rendering-container {
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  grid-template-areas: "video";
}`;
        case "HorizontalSplit":
            return `
.vidyo-rendering-container {
  grid-template-columns: ` + (videoGridLayoutColumns > 1 ? '7fr 3fr;' : '4fr 1fr;') + `
  grid-template-rows: 1fr;
  grid-template-areas: "application video";
}`;
        case "VerticalSplit":
            return `
.vidyo-rendering-container {
  grid-template-columns: 1fr;
  grid-template-rows: 4fr 1fr;
  grid-template-areas:
    "application"
    "video";
}`;
        case "ApplicatonOnly":
            return `
        .vidyo-rendering-container {
          grid-template-columns: 1fr;
          grid-template-rows: 1fr;
          grid-template-areas: "application";
        }`;
        default:
            console.warn("unsupported GridSplitTypes");
            break;
    }
};
exports.compositeLayoutGridSplitStyle = compositeLayoutGridSplitStyle;
exports.streamPopupStyle = `
body {
  height: 100%;
  background-color: #000000;
  margin: 0;
  padding: 0;
  position: relative;
  font-family: 'robotolight', 'Open Sans', 'Helvetica', 'Arial', sans-serif;
}

video {
  position: absolute;
  width: 100%;
  height: 100%;
}

.dock-icon {
  bottom: 60px;
  left: 60px;
  position: absolute;
  width: 50px;
  height: 50px;
}

.video-overlay {
  position: absolute;
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-rows: auto min-content;
  pointer-events: none;
  z-index: 1;
}

.stats-overlay {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 3em;
  overflow-y: auto;
  z-index: 10;
}

.stats-overlay .statistics-list {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.stats-overlay .statistics-line {
  background: white;
  display: inline;
  padding: 0.1em;
  opacity: 0.5;
}

.stats-overlay .statistics-line:after {
  content: '\\A';
  white-space: pre;
}

.stats-overlay .statistics-key {
  font-weight: bold;
}

.video-control-views-wrapper {
  position: relative;
}

.tile-control-view {
  pointer-events: all;
}

.video-tile-controls {
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  margin: 3px 0px 12px 0px;
  padding: 0 6px;
  box-sizing: border-box;
  align-items: center;
  min-width: 3%;
  pointer-events: all;
  z-index: 3;
}

.tile-control {
  justify-content: center;
  align-items: center;
  min-height: 22px;
  min-width: 22px;
  width: 1.65vw;
  height: 1.65vw;
  cursor: pointer;
  opacity: 0.5;
  -webkit-tap-highlight-color: transparent;
  outline: none;
}

.tile-control:hover {
  opacity: 0.8;
}

.tile-control.pin-participant,
.tile-control.control-participant {
  display: none;
}

.video-display-name-wrapper {
  display: flex;
  flex-direction: row;
  align-items: center;
  background: #0000003F;
}

.video-display-name {
  width: 100%;
  justify-content: left;
  word-break: break-all;
  color: white;
  opacity: 0.25;
  z-index: 2;
}

.video-display-name span {
  display: flex;
  align-items: center;
  min-height: 22pt;
  font-size: 1.65vw;
  margin: 3px 3% 12px 3%;
  word-break: break-all;
}

.video-wrapper {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

.video-placeholder {
  width: 100%;
  height: 100%;
  background: #202020;
  display: flex;
  align-items: center;
  justify-content: center;
}

.video-placeholder .text {
  height: 11rem;
  width: 11rem;
  border-radius: 50%;
  font-size: 8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #202020;
  background-color: grey;
  font-weight: bold;
}

:not(.video-muted) div.video-placeholder {
  display: none;
}

.popup-application {
  bottom: 60px;
  left: 60px;
  position: absolute;
  width: 50px;
  height: 50px;
  z-index: 10;
}

.volume-indicator {
  display: none;
}

.fecc-controls {
  display: none;
}

[hidden], .hide {
  display: none;
}
`;

},{}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeccControlAction = void 0;
var FeccControlAction;
(function (FeccControlAction) {
    FeccControlAction["PANLEFT"] = "PANLEFT";
    FeccControlAction["PANRIGHT"] = "PANRIGHT";
    FeccControlAction["TILTUP"] = "TILTUP";
    FeccControlAction["TILTDOWN"] = "TILTDOWN";
    FeccControlAction["ZOOMIN"] = "ZOOMIN";
    FeccControlAction["ZOOMOUT"] = "ZOOMOUT";
    FeccControlAction["STOP"] = "STOP";
})(FeccControlAction = exports.FeccControlAction || (exports.FeccControlAction = {}));
const template = document.createElement('template');
template.innerHTML = `
  <style>
    .fecc-control {
      width: inherit;
      height: inherit;
      min-width: inherit;
      min-height: inherit;
      display: grid;
      grid-template-columns: 1fr auto;
      padding-left: 30px;
      position: relative;
      font-size: 12px;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    .fecc-pan-tilt {
      width: 100%;
      height: 100%;
      display: grid;
      grid-row: auto auto;
      grid-template-columns: 1fr 1fr;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.25);
      transform: rotate(-45deg);
    }
    .fecc-pan-tilt-button {
      display: grid;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-sizing: border-box;
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }
    .fecc-pan-left {
      border-radius: 100% 0px 10%;
    }
    .fecc-tilt-up {
      border-radius: 0px 100% 0px 10%;
    }
    .fecc-tilt-down {
      border-radius: 0px 10% 0px 100%;
    }
    .fecc-pan-right {
      border-radius: 10% 0px 100%;
    }
    .fecc-pan-tilt-button:active {
      background-color: rgba(0, 0, 0, 0.5);
    }
    .fecc-pan-left .fecc-arrow {
      transform: rotate(-45deg);
    }
    .fecc-tilt-up .fecc-arrow {
      transform: rotate(45deg);
    }
    .fecc-tilt-down .fecc-arrow {
      transform: rotate(-135deg)
    }
    .fecc-pan-right .fecc-arrow {
      transform: rotate(135deg)
    }
    .fecc-arrow {
      width: 100%;
      height: 100%;
      position: relative;
      display: grid;
      justify-content: center;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .fecc-arrow:before {
      content: '\\25B2';
      color: rgba(255, 255, 255, 0.75);
      align-self: center;
      width: fit-content;
    }
    .fecc-pan-tilt-button:active .fecc-arrow {
      border-bottom-color: rgba(255, 255, 255, 0.75);
    }
    .fecc-zoom {
      width: 22px;
      height: 100%;
      display: grid;
      grid-template-rows: 1fr 1fr;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background-color: rgba(0, 0, 0, 0.25);
      color: rgba(255, 255, 255, 0.75);
      border-radius: 25px;
      margin-right: 5px;
      overflow: hidden;
      position: absolute;
      cursor: pointer;
    }
    .fecc-zoom > div {
      width: 100%;
      display: grid;
      align-items: center;
      justify-items: center;
      font-weight: bold;
      line-height: 18px;
      font-size: 18px;
      user-select: none;
      -webkit-user-select: none;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-sizing: border-box;
    }
    .fecc-zoom div:active {
      background-color: rgba(0, 0, 0, 0.5);
      color: rgba(255, 255, 255, 0.75);
    }
    .fecc-zoom > .fecc-zoom-in {
      border-radius: 18px 18px 0px 0px ;
    }
    .fecc-zoom > .fecc-zoom-out {
      border-radius: 0px 0px 18px 18px;
    }
  </style>
  <div id="container" class="fecc-control">
    <div class="fecc-zoom">
      <div id="zoom-in" data-action="${FeccControlAction.ZOOMIN}" class="fecc-zoom-in">+</div>
      <div id="zoom-out" data-action="${FeccControlAction.ZOOMOUT}" class="fecc-zoom-out">-</div>
    </div>
    <div class="fecc-pan-tilt">
      <div id="pan-left" data-action="${FeccControlAction.PANLEFT}" class="fecc-pan-tilt-button fecc-pan-left">
        <div class="fecc-arrow"></div>
      </div>
      <div id="tilt-up" data-action="${FeccControlAction.TILTUP}" class="fecc-pan-tilt-button fecc-tilt-up">
        <div class="fecc-arrow"></div>
      </div>
      <div id="tilt-down" data-action="${FeccControlAction.TILTDOWN}" class="fecc-pan-tilt-button fecc-tilt-down">
        <div class="fecc-arrow"></div>
      </div>
      <div id="pan-right" data-action="${FeccControlAction.PANRIGHT}" class="fecc-pan-tilt-button fecc-pan-right">
        <div class="fecc-arrow"></div>
      </div>
    </div>
  </div>
`;
class FeccControlsView extends HTMLElement {
    constructor() {
        super();
        this._shadow = this.attachShadow({ mode: 'open' });
        this._container = null;
        this._controls = {};
        this._needStop = false;
        this._shadow.appendChild(template.content.cloneNode(true));
        this._container = this._shadow.getElementById('container');
        this._controls = {
            panLeft: this._shadow.getElementById('pan-left'),
            panRight: this._shadow.getElementById('pan-right'),
            tiltDown: this._shadow.getElementById('tilt-down'),
            tiltUp: this._shadow.getElementById('tilt-up'),
            zoomIn: this._shadow.getElementById('zoom-in'),
            zoomOut: this._shadow.getElementById('zoom-out')
        };
        this._onAction = this._onAction.bind(this);
        this._onStop = this._onStop.bind(this);
        this._needStop = false;
    }
    connectedCallback() {
        if (this.isConnected) {
            for (let control of Object.values(this._controls)) {
                control.onmousedown = this._onAction;
                control.ontouchstart = this._onAction;
                control.onmouseup = this._onStop;
                control.onmouseleave = this._onStop;
                control.onmouseout = this._onStop;
                control.ontouchend = this._onStop;
            }
            if (this._container) {
                this._container.ondblclick = (event) => {
                    event.stopPropagation();
                };
            }
        }
    }
    _onAction(event) {
        event.stopPropagation();
        const customEvent = new CustomEvent('action', { detail: event.target.getAttribute('data-action') });
        this.dispatchEvent(customEvent);
        if (typeof this.handleAction === 'function') {
            this.handleAction(customEvent);
        }
        this._needStop = true;
    }
    _onStop() {
        if (this._needStop) {
            const customEvent = new CustomEvent('action', { detail: FeccControlAction.STOP });
            this.dispatchEvent(customEvent);
            if (typeof this.handleAction === 'function') {
                this.handleAction(customEvent);
            }
        }
        this._needStop = false;
    }
}
exports.default = FeccControlsView;

},{}],179:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoRenderer = void 0;
const EventDispatcher = require("../../core/events/EventDispatcher");
const Messages = require("../../core/utils/Messages");
const RenderEvents = require("../../core/events/RenderEvents");
const Templates = require("../Templates");
const Participant_1 = require("../../core/models/Participant");
const RendererBase_1 = require("../RendererBase");
const ObjectUtils_1 = require("../../core/utils/ObjectUtils");
const StringUtils_1 = require("../../core/utils/StringUtils");
const VideoResolution_1 = require("../../core/models/VideoResolution");
const ConnectionEvents = require("../../core/events/ConnectionEvents");
const OperatingSystemInfoProvider_1 = require("../../core/utils/OperatingSystemInfoProvider");
const Source_1 = require("../../core/models/Source");
const TrackMetaDataProvider_1 = require("../../core/controllers/StreamController/TrackMetaDataProvider");
const Constants = require("../../core/utils/Constants");
const Decorators_1 = require("../../core/utils/Decorators");
class VidyoRenderer extends RendererBase_1.RendererBase {
    constructor(vidyoCore) {
        super(vidyoCore);
        this._previewLoad = false;
        this._showViewControls = true;
        this._viewLabel = true;
        this._viewMeters = true;
        this._onResize = () => {
            setTimeout(() => void this._onUpdate(undefined));
        };
    }
    CreateView(viewId) {
        super.CreateView(viewId);
        window.addEventListener('resize', this._onResize);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher.CompositeRenderListeners);
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.Update, EventDispatcher.CompositeRenderListeners, (payload) => this._onUpdate(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateSource, EventDispatcher.CompositeRenderListeners, (streamId) => this._updateStreamSource(streamId));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.GridLayoutChanged, EventDispatcher.CompositeRenderListeners, () => this._updateGridLayouts());
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateCompositeRenderer, EventDispatcher.CompositeRenderListeners, (payload) => this._updateView(payload));
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnecting, EventDispatcher.CompositeRenderListeners, () => this._onDisconnecting());
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateViewLabel, EventDispatcher.CompositeRenderListeners, (payload) => this._updateViewLabel(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateAudioMeters, EventDispatcher.CompositeRenderListeners, (payload) => this._updateAudioMeters(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateVideoTileControls, EventDispatcher.CompositeRenderListeners, (payload) => this._updateVideoTileControls(payload));
    }
    Destroy() {
        super.Destroy();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher.CompositeRenderListeners);
        this._removeAllElements();
        window.removeEventListener('resize', this._onResize);
    }
    _createParent(viewId) {
        if (viewId) {
            let parentElement = document.getElementById(viewId);
            if (parentElement) {
                return parentElement;
            }
        }
        let error = new Error(StringUtils_1.default.Format(Messages.TheElementIdDoesntExist, { id: viewId }));
        this._vidyoCore.Controllers.LogController.LogError(error);
        throw (error);
    }
    _isAudioMeterDisabled() {
        return !this._viewMeters;
    }
    _onRecheckEachVideoSize() {
        let container = new VideoResolution_1.BasicVideoResolution();
        if (this._parent) {
            container.Width = this._parent.clientWidth;
            container.Height = this._parent.clientHeight;
        }
        let videos = [];
        this._eachVideoElement((element) => {
            let containerResolution = new VideoResolution_1.BasicVideoResolution(element.clientWidth, element.clientHeight);
            let videoElement = element.getElementsByTagName('video')[0];
            let videoResolution = new VideoResolution_1.VideoResolution(element.getAttribute('data-stream-id') || '');
            videoResolution.ParticipantId = element.getAttribute('data-participant-id') || '';
            videoResolution.IsApplication = element.classList.contains('application-type');
            videoResolution.IsPinned = element.classList.contains('pinned-video');
            videoResolution.ContainerResolution = containerResolution;
            if (videoElement) {
                let resolution = this._getVideoMediaResolution(videoElement);
                videoResolution.Width = resolution.width || Constants.DefaultLocalStreamWidth;
                videoResolution.Height = resolution.height || Constants.DefaultLocalStreamHeight;
            }
            if (videoResolution.IsPinned) {
                this._updateViewLabel({ showLabel: this._viewLabel });
                this._updateAudioMeters({ showMeters: this._viewMeters });
                this._updateVideoTileControls({ showControls: this._showViewControls });
            }
            this._setAspectRatioClassToContainer(element, videoResolution);
            videos.push(videoResolution);
        });
        this._vidyoCore.Controllers.RendererController.UpdateVideoResolutions(container, videos);
    }
    _onUpdate(ids) {
        let participantLimit = this._vidyoCore.Controllers.ModerationController.IsLobbyEnabled
            ? 0
            : this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit;
        let sourcesLimit = participantLimit;
        let activeParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Active: true, IsPinned: false });
        let inactiveParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Active: false, IsPinned: false });
        let pinnedParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Active: true, IsPinned: true });
        let dynamicSourcesLimit = Math.max(sourcesLimit - pinnedParticipants.length, 0);
        inactiveParticipants = inactiveParticipants.filter((p) => {
            return !p.Sources.some((s) => s.Type === Source_1.SourceMediaType.Video);
        });
        let participants = activeParticipants.concat(inactiveParticipants).slice(0, dynamicSourcesLimit);
        let activeStreamIds = participants.map((p) => p.Id);
        if (ids) {
            activeStreamIds = ObjectUtils_1.default.Difference(activeStreamIds, ids);
        }
        let previewStream = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
        let showLocalPreview = this._vidyoCore.Controllers.RendererController.ShowLocalPreview
            && previewStream && previewStream.GetVideoTracks().length > 0;
        if (previewStream) {
            if (showLocalPreview) {
                activeStreamIds.push(previewStream.Id);
            }
        }
        Array.prototype.forEach.call(document.querySelectorAll('.video-type.video-container:not(.pinned-video)'), (videoElement) => {
            let participantId = videoElement.getAttribute('data-participant-id');
            if (participantId && !activeStreamIds.includes(participantId)) {
                this._updateContainerState();
                this._safelyRemoveVideoElement(participantId);
            }
        });
        participants.forEach((participant) => {
            let stream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantVideoStream(participant.Id);
            if (stream) {
                this._addStream(stream, participant.Id, participant.Name, false);
            }
            else {
                this._updateContainerState();
                this._safelyRemoveVideoElement(participant.Id);
            }
        });
        this._updatePreview();
        this._updateApplicationsStreams();
        this._updateContainerState();
        this._updateAudioStreams();
        this._onRecheckEachVideoSize();
    }
    _addStream(stream, id, name, isPreview) {
        let container = this._getOrCreateContainer();
        let options = {
            name: name,
            displayCropped: true,
            allowZoom: true
        };
        this._updateContainerState();
        let alreadyRendered = this._elementsVideoForParticipant(id).length > 0;
        if (!alreadyRendered) {
            let selector = '.video-grid';
            let mediaGrid = container.querySelector(selector);
            this._addVideoElement(Templates.trackTemplate, mediaGrid, options, stream, id, isPreview, false);
            this._updateViewLabel({ showLabel: this._viewLabel });
            this._updateAudioMeters({ showMeters: this._viewMeters });
            this._updateVideoTileControls({ showControls: this._showViewControls });
        }
        this._updateParticipantStaticViews(id, isPreview);
    }
    _onDisconnecting() {
        this._destroyAudioElements();
        this._removeAllElements();
        this._updatePreview();
    }
    _getOrCreateContainer() {
        let container = this._parent.querySelector('.vidyo-rendering-container');
        if (!container) {
            this._parent.innerHTML = Templates.containerTemplate;
            container = this._parent.querySelector('.vidyo-rendering-container');
            if (!container) {
                let error = new Error(StringUtils_1.default.Format(Messages.TheElementIdDoesntExist, { id: 'vidyo-rendering-container' }));
                this._vidyoCore.Controllers.LogController.LogError(error);
                throw (error);
            }
            this._updateGridLayouts();
        }
        return container;
    }
    _removeAllElements() {
        if (this._parent) {
            const videoContainers = this._parent.querySelectorAll('.video-container');
            Array.prototype.forEach.call(videoContainers, (videoElement) => {
                let streamId = videoElement.getAttribute('data-participant-id');
                if (streamId) {
                    this._safelyRemoveAllMediaElement(streamId);
                }
            });
            while (this._parent.lastChild) {
                this._parent.removeChild(this._parent.lastChild);
            }
        }
    }
    _updateApplicationsStreams() {
        const allParticipants = this._vidyoCore.Controllers.ParticipantController.GetParticipants({ Origin: Participant_1.ParticipantOrigin.Remote });
        const allParticipantsIds = allParticipants.map((participant) => participant.Id);
        Array.prototype.forEach.call(document.querySelectorAll('.application-type.video-container'), (videoElement) => {
            let participantId = videoElement.getAttribute('data-participant-id');
            const needRenderLocal = videoElement.classList.contains('local-track')
                && this._vidyoCore.Controllers.RendererController.ShowLocalSharePreview;
            if (participantId && !allParticipantsIds.includes(participantId) && !needRenderLocal) {
                this._safelyRemoveApplicationElement(participantId);
            }
        });
        allParticipants.forEach((participant) => {
            this._updateParticipantStaticViews(participant.Id, false);
        });
        if (this._vidyoCore.Controllers.RendererController.ShowLocalSharePreview) {
            const previewId = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream.Id;
            this._updateParticipantStaticViews(previewId, true);
        }
    }
    _updateAudioMeters(viewMeters) {
        let audioMeters = document.querySelectorAll(`.volume-indicator`);
        this._viewMeters = viewMeters.showMeters;
        Array.from(audioMeters).forEach((e) => e.hidden = !this._viewMeters);
    }
    _updateContainerState() {
        this._getOrCreateContainer();
    }
    _updateGridLayouts() {
        let container = this._parent.querySelector('.vidyo-rendering-container');
        if (!container) {
            return;
        }
        let style = '';
        let videoGridLayout = this._vidyoCore.Controllers.RendererController.VideoGridLayout;
        let scope = ".video-grid" || '';
        style += StringUtils_1.default.Format(Templates.compositeLayoutStyle, { scope, columns: videoGridLayout.Columns, rows: videoGridLayout.Rows });
        videoGridLayout.SpaceBefore.forEach((index) => {
            style += StringUtils_1.default.Format(Templates.compositeLayoutStyleSpaceBeforeVideo, { index, scope });
        });
        let applicationGridLayout = this._vidyoCore.Controllers.RendererController.ApplicationGridLayout;
        const applicationsPresent = applicationGridLayout.Cells > 0;
        let gridSplitStyle = "VideoOnly";
        if (applicationsPresent) {
            gridSplitStyle = this._vidyoCore.Controllers.RendererController.MediaGridSplit === 'horizontal'
                ? "HorizontalSplit"
                : "VerticalSplit";
            if (videoGridLayout.Cells === 0) {
                gridSplitStyle = "ApplicatonOnly";
            }
            scope = ".application-grid" || '';
            style += StringUtils_1.default.Format(Templates.compositeLayoutStyle, {
                scope,
                columns: applicationGridLayout.Columns,
                rows: applicationGridLayout.Rows
            });
            applicationGridLayout.SpaceBefore.forEach((index) => {
                style += StringUtils_1.default.Format(Templates.compositeLayoutStyleSpaceBeforeVideo, { index, scope });
            });
        }
        style += Templates.compositeLayoutGridSplitStyle(gridSplitStyle, videoGridLayout.Columns);
        let styleElement = container.querySelector('style');
        if (!styleElement) {
            throw (new Error('Failed to find style element in rendering container, cannot update grid layout'));
        }
        if (styleElement.innerHTML !== style) {
            styleElement.innerHTML = style;
        }
        let videoGrid = container.querySelector('.video-grid');
        if (!videoGrid) {
            throw (new Error('Failed to find video grid in rendering container, cannot update picture-in-picture settings'));
        }
        const cellCountForPictureInPictureMode = 0;
        const previewStream = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
        const showLocalPreview = this._vidyoCore.Controllers.RendererController.ShowLocalPreview && previewStream &&
            previewStream.GetVideoTracks().length > 0;
        videoGrid.classList.toggle('picture-in-picture', !applicationsPresent && showLocalPreview && videoGridLayout.Cells === cellCountForPictureInPictureMode);
        Array.prototype.forEach.call(container.querySelectorAll('.media-grid video'), (video) => {
            video.style.marginLeft = '';
            video.style.marginTop = '';
        });
    }
    _updateParticipantStaticViews(participantId, isPreview) {
        let applicationStreams = [];
        const pinnedStreams = [];
        let name = '';
        if (isPreview) {
            applicationStreams = this._vidyoCore.Controllers.RendererController.ShowLocalSharePreview ?
                this._vidyoCore.Controllers.LocalStreamController.GetApplicationStreams() : [];
            name = 'Preview share';
        }
        else {
            let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
            if (participant) {
                applicationStreams = [];
                const activeSources = this._vidyoCore.Controllers.ConferenceController.ActiveStaticSources;
                activeSources.forEach((ssrc) => {
                    let str = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantStreamBySsrc(participantId, ssrc);
                    if (str) {
                        const type = this._vidyoCore.Controllers.RemoteStreamController.GetTrackMediaType(str.Id);
                        switch (type) {
                            case TrackMetaDataProvider_1.MediaTrackType.Application:
                                applicationStreams.push(str);
                                break;
                            case TrackMetaDataProvider_1.MediaTrackType.Video:
                                pinnedStreams.push(str);
                                break;
                            default:
                                console.log("unsupported MediaTrackType " + type?.toString());
                                break;
                        }
                    }
                });
                if (participant.IsPinned && !pinnedStreams.length) {
                    this._vidyoCore.Controllers.ParticipantController.PinParticipant(participantId, false);
                }
                name = participant.Name;
            }
        }
        const container = this._getOrCreateContainer();
        let appGrid = container.querySelector('.application-grid');
        if (appGrid) {
            let options = {
                name,
                displayCropped: true,
                allowZoom: true
            };
            let appStreamsIds = applicationStreams.map((stream) => stream.Id);
            let pinnedStreamIds = pinnedStreams.map((stream) => stream.Id);
            let currentStaticViews = appGrid
                .querySelectorAll(`.vidyo-rendering-container .video-container[data-participant-id='${participantId}']`);
            for (let i = currentStaticViews.length - 1; i >= 0; --i) {
                let view = currentStaticViews[i];
                if (-1 === [...appStreamsIds, ...pinnedStreamIds].indexOf(view.getAttribute('data-stream-id'))) {
                    const parent = view.parentElement;
                    if (parent) {
                        parent.removeChild(view);
                        this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileRemoved, {
                            element: view,
                            isApplication: view.classList.contains('application-type'),
                            participantId
                        });
                    }
                }
            }
            for (let [key, value] of Object.entries(this._streamPopups)) {
                if (value.participantId === participantId && !appStreamsIds.includes(key)) {
                    this._closeStreamPopup(key);
                }
            }
            applicationStreams.forEach((appStream) => {
                if (!document.querySelector(`.vidyo-rendering-container .video-container[data-stream-id='${appStream.Id}']`)
                    && !this._streamPopups[appStream.Id]) {
                    if (appStream.Id === this._vidyoCore.Controllers.LocalStreamController.WindowShareStream.Id) {
                        options.name = this._vidyoCore.Controllers.DeviceController.GetWindowSharePreviewLabel();
                    }
                    if (appStream.Id === this._vidyoCore.Controllers.LocalStreamController.MonitorShareStream.Id) {
                        options.name = this._vidyoCore.Controllers.DeviceController.GetMonitorSharePreviewLabel();
                    }
                    this._addVideoElement(Templates.trackTemplate, appGrid, options, appStream, participantId, isPreview, true);
                }
            });
            pinnedStreams.forEach((stream) => {
                if (!document.querySelector(`.vidyo-rendering-container .video-container[data-stream-id='${stream.Id}']`)) {
                    options.displayCropped = this._vidyoCore.Controllers.AdvancedSettingsController.PinnedParticipantDisplayCropped;
                    this._addVideoElement(Templates.trackTemplate, appGrid, options, stream, participantId, isPreview, false, true);
                }
            });
        }
    }
    _updatePreview() {
        const previewStream = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
        const showLocalPreview = this._vidyoCore.Controllers.RendererController.ShowLocalPreview && previewStream?.GetVideoTracks().length > 0;
        if (previewStream && showLocalPreview) {
            const selectedCamera = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Camera;
            let previewLabel = 'Self View';
            if (typeof selectedCamera !== 'boolean') {
                previewLabel = selectedCamera.PreviewLabel;
            }
            this._addStream(previewStream, previewStream.Id, previewLabel, true);
        }
    }
    _updateVideoTileControls(options) {
        const videoTileControls = document.querySelectorAll('.video-tile-controls');
        this._showViewControls = options.showControls;
        Array.from(videoTileControls).forEach((e) => e.hidden = !this._showViewControls);
    }
    _updateStreamSource(participantId) {
        this._updateContainerState();
        let stream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantVideoStream(participantId);
        let audioStream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantAudioStream(participantId);
        let isPreview = false;
        let isRestricted = false;
        if (!stream) {
            let preview = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
            if (preview) {
                isPreview = true;
                isRestricted = this._vidyoCore.Controllers.LocalStreamController.LocalCameraStreamRestricted;
                stream = preview;
                audioStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
            }
        }
        let videoState = false;
        let audioState = false;
        let participant;
        if (!isPreview) {
            participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
            if (participant) {
                videoState = participant.HasVideoSource();
                audioState = participant.HasAudioSource() && !participant.AudioMuted();
            }
        }
        if (stream) {
            let videoEnabled = videoState
                || !!(isPreview && stream.GetVideoTracks().length && stream.GetVideoTracks()[0].IsActive());
            let audioEnabled = audioState ||
                !!(isPreview && audioStream && audioStream.GetAudioTracks().length && audioStream.GetAudioTracks()[0].IsActive()
                    && !this._vidyoCore.Controllers.DeviceController.GetAudioMuteState());
            let container = this._parent.querySelector(`[data-stream-id='${stream.Id}']`);
            if (container) {
                let videoElement = container.querySelector('video');
                if (videoElement) {
                    let mediaStream = stream.GetMediaStream();
                    if (isPreview && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsElectron() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsFirefox()) {
                        if (this._previewLoad !== audioEnabled) {
                            this._previewLoad = audioEnabled;
                        }
                        else {
                            setTimeout(() => videoElement.ended && videoElement.load());
                        }
                    }
                    if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsIOS()) {
                        try {
                            if (videoElement.ended || videoElement.paused) {
                                videoElement.play().catch(() => { });
                            }
                        }
                        catch (e) { }
                    }
                    container.classList.toggle('audio-muted', !audioEnabled);
                    container.classList.toggle('video-muted', !videoEnabled);
                    container.classList.toggle('video-restricted', isRestricted);
                    if (audioStream) {
                        const canvasContextId = isPreview ? audioStream.Id : participantId;
                        if (audioEnabled) {
                            let canvasList = container.getElementsByClassName('volume-indicator');
                            let canvas = canvasList[0];
                            if (canvas) {
                                this._createEnergyLevelCanvasContext(canvasContextId, canvas);
                            }
                        }
                        else {
                            this._deleteEnergyLevelCanvasContext(canvasContextId);
                        }
                    }
                    this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileUpdated, {
                        element: container,
                        isApplication: container.classList.contains('application-type'),
                        isLocal: isPreview,
                        isPinned: container.classList.contains('pinned-video'),
                        participantId,
                        videoEnabled,
                        audioEnabled
                    });
                }
            }
            if (isPreview || (participant && participant.IsRemote)) {
                const participantIdToUpdate = isPreview ? stream.Id : participantId;
                this._updateParticipantStaticViews(participantIdToUpdate, isPreview);
            }
            this._updateGridLayouts();
            this._onRecheckEachVideoSize();
            if (!isPreview && audioStream) {
                this._updateAudioStreamSource(audioStream);
            }
        }
    }
    _updateView(options) {
        if (document.getElementById(options.viewId)) {
            this._removeAllElements();
            this.CreateView(options.viewId);
            this._onUpdate(undefined);
        }
    }
    _updateViewLabel(viewLabel) {
        let labels = document.querySelectorAll('.video-display-name');
        this._viewLabel = viewLabel.showLabel;
        Array.from(labels).forEach((e) => e.hidden = !this._viewLabel);
    }
}
__decorate([
    (0, Decorators_1.debounce)()
], VidyoRenderer.prototype, "_updateGridLayouts", null);
exports.VidyoRenderer = VidyoRenderer;

},{"../../core/controllers/StreamController/TrackMetaDataProvider":59,"../../core/events/ConnectionEvents":66,"../../core/events/EventDispatcher":68,"../../core/events/RenderEvents":75,"../../core/models/Participant":94,"../../core/models/Source":98,"../../core/models/VideoResolution":100,"../../core/utils/Constants":138,"../../core/utils/Decorators":139,"../../core/utils/Messages":150,"../../core/utils/ObjectUtils":153,"../../core/utils/OperatingSystemInfoProvider":154,"../../core/utils/StringUtils":164,"../RendererBase":175,"../Templates":177}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomVidyoRenderer = void 0;
const EventDispatcher = require("../../core/events/EventDispatcher");
const Messages = require("../../core/utils/Messages");
const RenderEvents = require("../../core/events/RenderEvents");
const RendererBase_1 = require("../RendererBase");
const Templates_1 = require("../Templates");
const ObjectUtils_1 = require("../../core/utils/ObjectUtils");
const StringUtils_1 = require("../../core/utils/StringUtils");
const OperatingSystemInfoProvider_1 = require("../../core/utils/OperatingSystemInfoProvider");
class CustomVidyoRenderer extends RendererBase_1.RendererBase {
    constructor(vidyoCore) {
        super(vidyoCore);
        this._previewLoad = false;
        this._showAudioMeters = new Map();
        this._showViewControls = new Map();
        this._showViewLabels = new Map();
    }
    CreateView(viewId) {
        super.CreateView(viewId);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher.CustomRenderListeners);
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.Update, EventDispatcher.CustomRenderListeners, (payload) => this._onUpdate(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.Hide, EventDispatcher.RenderListeners, (payload) => this._onHide(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateSource, EventDispatcher.CustomRenderListeners, (streamId) => this._updateStreamSource(streamId));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateViewLabel, EventDispatcher.CustomRenderListeners, (payload) => this._updateViewLabel(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateAudioMeters, EventDispatcher.CustomRenderListeners, (payload) => this._updateAudioMeters(payload));
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.UpdateVideoTileControls, EventDispatcher.CustomRenderListeners, (payload) => this._updateVideoTileControls(payload));
    }
    Destroy() {
        super.Destroy();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher.CustomRenderListeners);
        Object.keys(this._vidyoCore.Controllers.RendererController.Views).reverse().forEach((key) => {
            this._vidyoCore.Controllers.RendererController.HideView({ viewId: key });
        });
    }
    _createParent() { return document.body; }
    _elementsVideoForParticipant(id) {
        const elements = document.querySelectorAll(`.vidyo-rendering-container-custom.video-type .video-container[data-participant-id='${id}']`);
        return Array.from(elements);
    }
    _elementsApplicationForParticipant(id) {
        let elements = document.querySelectorAll(`.vidyo-rendering-container-custom.application-type .video-container[data-participant-id='${id}']`);
        return Array.from(elements);
    }
    _isAudioMeterDisabled(participantId) {
        const views = this._vidyoCore.Controllers.RendererController.Views;
        for (let viewId in views) {
            if (participantId === views[viewId].participantId) {
                return this._showAudioMeters.get(viewId) === false;
            }
        }
        return false;
    }
    _onHide(payload) {
        this._hideView(payload.viewId);
    }
    _onUpdate(ids) {
        const views = this._vidyoCore.Controllers.RendererController.Views;
        let streamIds = ObjectUtils_1.default.MapObject(views, (view) => view.streamId);
        if (ids) {
            streamIds = ObjectUtils_1.default.Difference(streamIds, ids);
        }
        Object.values(views).filter((view) => !streamIds.includes(view.streamId)).forEach((view) => {
            this._hideView(view.viewId);
        });
        for (let key in views) {
            if (views.hasOwnProperty(key)) {
                const view = views[key];
                this._updateView(view);
            }
        }
        this._updateAudioStreams();
    }
    _safelyRemoveVideoElement(id) {
        this._deleteEnergyLevelCanvasContext(id);
        this._elementsVideoForParticipant(id).forEach((toRemove) => {
            this._removeVideoElements(toRemove);
            this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileRemoved, {
                element: toRemove,
                isApplication: false,
                participantId: id
            });
        });
    }
    _findElementById(id) {
        let element = document.getElementById(id);
        if (!element) {
            this._vidyoCore.Controllers.LogController.LogWarning(() => StringUtils_1.default.Format(Messages.TheElementIdDoesntExist, { id }));
        }
        return element;
    }
    _hideView(viewId) {
        let viewElement = this._findElementById(viewId);
        if (viewElement) {
            const videoContainers = viewElement.querySelectorAll('.video-container');
            Array.prototype.forEach.call(videoContainers, (videoElement) => {
                let streamId = videoElement.getAttribute('data-participant-id');
                if (streamId) {
                    if (videoElement.parentElement.classList.contains('application-type')) {
                        this._safelyRemoveApplicationElement(streamId);
                    }
                    else {
                        this._safelyRemoveVideoElement(streamId);
                    }
                }
            });
            while (viewElement.lastChild) {
                viewElement.removeChild(viewElement.lastChild);
            }
        }
        this._showAudioMeters.delete(viewId);
        this._showViewControls.delete(viewId);
        this._showViewLabels.delete(viewId);
    }
    _updateAudioMeters(viewMeters) {
        let audioMeters = document.querySelector(`#${viewMeters.viewId} .volume-indicator`);
        if (audioMeters) {
            audioMeters.hidden = !viewMeters.showMeters;
        }
        this._showAudioMeters.set(viewMeters.viewId, viewMeters.showMeters);
    }
    _updateVideoTileControls(options) {
        const videoTileControls = document.querySelector(`#${options.viewId} .video-tile-controls`);
        if (videoTileControls) {
            videoTileControls.hidden = !options.showControls;
        }
        this._showViewControls.set(options.viewId, options.showControls);
    }
    _updateStreamSource(participantId) {
        let stream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantVideoStream(participantId);
        let audioStream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantAudioStream(participantId);
        let isPreview = false;
        let isRestricted = false;
        if (!stream) {
            let preview = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
            if (preview) {
                isPreview = true;
                isRestricted = this._vidyoCore.Controllers.LocalStreamController.LocalCameraStreamRestricted;
                stream = preview;
                audioStream = this._vidyoCore.Controllers.LocalStreamController.MicrophoneAudioStrem;
            }
        }
        let videoState = false;
        let audioState = false;
        let participant;
        if (!isPreview) {
            participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participantId);
            if (participant) {
                videoState = participant.HasVideoSource();
                audioState = participant.HasAudioSource() && !participant.AudioMuted();
            }
        }
        if (stream) {
            let videoEnabled = videoState
                || (isPreview && stream.GetVideoTracks().length && stream.GetVideoTracks()[0].IsActive());
            let audioEnabled = audioState ||
                !!(isPreview && audioStream && audioStream.GetAudioTracks().length && audioStream.GetAudioTracks()[0].IsActive()
                    && !this._vidyoCore.Controllers.DeviceController.GetAudioMuteState());
            let container = this._parent.querySelector(`[data-stream-id='${stream.Id}']`);
            if (container) {
                let videoElement = container.querySelector('video');
                if (videoElement) {
                    let mediaStream = stream.GetMediaStream();
                    if (isPreview && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
                        const isRearCamera = stream.GetVideoTracks()[0]?.Settings.facingMode === 'environment';
                        videoElement.classList.toggle('flip-back-video', isRearCamera);
                    }
                    if (isPreview && OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsElectron() || OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsSafari()) {
                        if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsMobileDevice()) {
                            setTimeout(() => {
                                try {
                                    videoElement.ended && videoElement.load();
                                    videoElement.paused && videoElement.play();
                                }
                                catch (e) { }
                            }, 0);
                        }
                        else {
                            this._previewLoad !== audioEnabled ? this._previewLoad = audioEnabled : videoElement.ended && videoElement.load();
                        }
                    }
                    container.classList.toggle('audio-muted', !audioEnabled);
                    container.classList.toggle('video-restricted', isRestricted);
                    if (audioStream) {
                        const canvasContextId = isPreview ? audioStream.Id : participantId;
                        if (audioEnabled) {
                            let canvasList = container.getElementsByClassName('volume-indicator');
                            let canvas = canvasList[0];
                            if (canvas) {
                                this._createEnergyLevelCanvasContext(canvasContextId, canvas);
                            }
                        }
                        else {
                            this._deleteEnergyLevelCanvasContext(canvasContextId);
                        }
                    }
                }
                this._vidyoCore.EventDispatcher.emitAsync(RenderEvents.Events.VideoTileUpdated, {
                    element: container,
                    isApplication: container.classList.contains('application-type'),
                    isLocal: isPreview,
                    isPinned: false,
                    participantId,
                    videoEnabled,
                    audioEnabled
                });
            }
            if (!isPreview && audioStream) {
                this._updateAudioStreamSource(audioStream);
            }
        }
    }
    _updateView(view) {
        let element = this._findElementById(view.viewId);
        let stream;
        if (view.isLocal) {
            if (!view.isApplication) {
                stream = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream;
            }
            else {
                stream = this._vidyoCore.Controllers.LocalStreamController.GetApplicationStreamById(view.streamId);
            }
        }
        else {
            stream = this._vidyoCore.Controllers.RemoteStreamController.TryGetParticipantStreamBySsrc(view.participantId, view.sourceId);
        }
        let label = view.label;
        if (stream) {
            let options = {
                name: label,
                displayCropped: view.displayCropped,
                allowZoom: view.allowZoom
            };
            let participant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(view.participantId);
            let alreadyRendered = !!document
                .querySelector(`.vidyo-rendering-container-custom .video-container[data-stream-id='${stream.Id}']`);
            if (!alreadyRendered && stream.GetVideoTracks().length) {
                if (view.isLocal || (participant && participant.IsRemote)) {
                    let id = participant && participant.Id || stream.Id;
                    this._addVideoElement(Templates_1.customTrackTemplate, element, options, stream, id, view.isLocal, view.isApplication);
                    if (this._showViewLabels.has(view.viewId)) {
                        this._updateViewLabel({
                            viewId: view.viewId,
                            showLabel: this._showViewLabels.get(view.viewId)
                        });
                    }
                    if (this._showAudioMeters.has(view.viewId)) {
                        this._updateAudioMeters({
                            viewId: view.viewId,
                            showMeters: this._showAudioMeters.get(view.viewId)
                        });
                    }
                    if (this._showViewControls.has(view.viewId)) {
                        this._updateVideoTileControls({
                            viewId: view.viewId,
                            showControls: this._showViewControls.get(view.viewId)
                        });
                    }
                }
            }
        }
    }
    _updateViewLabel(viewLabel) {
        let label = document.querySelector(`#${viewLabel.viewId} .video-display-name`);
        if (label) {
            label.hidden = !viewLabel.showLabel;
        }
        this._showViewLabels.set(viewLabel.viewId, viewLabel.showLabel);
    }
}
exports.CustomVidyoRenderer = CustomVidyoRenderer;

},{"../../core/events/EventDispatcher":68,"../../core/events/RenderEvents":75,"../../core/utils/Messages":150,"../../core/utils/ObjectUtils":153,"../../core/utils/OperatingSystemInfoProvider":154,"../../core/utils/StringUtils":164,"../RendererBase":175,"../Templates":177}],181:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var VidyoConnector_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoConnector = exports.VidyoConnectorAnalyticServiceType = exports.VidyoConnectorFailReason = exports.VidyoConnectorDisconnectReason = exports.VidyoConnectorState = void 0;
const SimpleApi = require("../vidyo_simple_api/VidyoSimple");
const ConferenceEvents = require("../core/events/ConferenceEvents");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
const PromiseHelper_1 = require("../core/utils/PromiseHelper");
const UUID = require("uuid");
const Constants_1 = require("../core/utils/Constants");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const StringUtils_1 = require("../core/utils/StringUtils");
const SyncronizedQueue_1 = require("../core/utils/SyncronizedQueue");
const Messages = require("../core/utils/Messages");
const GoogleAnalytics_1 = require("../core/utils/GoogleAnalytics");
const UserMediaProvider_1 = require("../core/utils/UserMediaProvider");
const LocationProvider_1 = require("../core/utils/LocationProvider");
const APITypes_1 = require("../core/models/APITypes");
const JSValidation_1 = require("../core/utils/JSValidation");
const ObjectUtils_1 = require("../core/utils/ObjectUtils");
const Decorators_1 = require("../core/utils/Decorators");
const noop = () => { };
var VidyoConnectorState;
(function (VidyoConnectorState) {
    VidyoConnectorState["Idle"] = "VIDYO_CONNECTORSTATE_Idle";
    VidyoConnectorState["Ready"] = "VIDYO_CONNECTORSTATE_Ready";
    VidyoConnectorState["EstablishingConnection"] = "VIDYO_CONNECTORSTATE_EstablishingConnection";
    VidyoConnectorState["FindingResource"] = "VIDYO_CONNECTORSTATE_FindingResource";
    VidyoConnectorState["ConnectingToResource"] = "VIDYO_CONNECTORSTATE_ConnectingToResource";
    VidyoConnectorState["EnablingMedia"] = "VIDYO_CONNECTORSTATE_EnablingMedia";
    VidyoConnectorState["Disconecting"] = "VIDYO_CONNECTORSTATE_Disconecting";
    VidyoConnectorState["Connected"] = "VIDYO_CONNECTORSTATE_Connected";
})(VidyoConnectorState = exports.VidyoConnectorState || (exports.VidyoConnectorState = {}));
var VidyoConnectorDisconnectReason;
(function (VidyoConnectorDisconnectReason) {
    VidyoConnectorDisconnectReason["BrowserOffline"] = "VIDYO_CONNECTORDISCONNECTREASON_BrowserOffLine";
    VidyoConnectorDisconnectReason["Disconnected"] = "VIDYO_CONNECTORDISCONNECTREASON_Disconnected";
    VidyoConnectorDisconnectReason["ConnectionLost"] = "VIDYO_CONNECTORDISCONNECTREASON_ConnectionLost";
    VidyoConnectorDisconnectReason["ConnectionTimeout"] = "VIDYO_CONNECTORDISCONNECTREASON_ConnectionTimeout";
    VidyoConnectorDisconnectReason["NoResponse"] = "VIDYO_CONNECTORDISCONNECTREASON_NoResponse";
    VidyoConnectorDisconnectReason["Terminated"] = "VIDYO_CONNECTORDISCONNECTREASON_Terminated";
    VidyoConnectorDisconnectReason["MiscLocalError"] = "VIDYO_CONNECTORDISCONNECTREASON_MiscLocalError";
    VidyoConnectorDisconnectReason["MiscRemoteError"] = "VIDYO_CONNECTORDISCONNECTREASON_MiscRemoteError";
    VidyoConnectorDisconnectReason["MiscError"] = "VIDYO_CONNECTORDISCONNECTREASON_MiscError";
    VidyoConnectorDisconnectReason["Booted"] = "VIDYO_CONNECTORDISCONNECTREASON_Booted";
    VidyoConnectorDisconnectReason["ConferenceDestroyed"] = "VIDYO_CONNECTORDISCONNECTREASON_ConferenceDestroyed";
    VidyoConnectorDisconnectReason["ServerShuttingDown"] = "VIDYO_CONNECTORDISCONNECTREASON_ServerShuttingDown";
})(VidyoConnectorDisconnectReason = exports.VidyoConnectorDisconnectReason || (exports.VidyoConnectorDisconnectReason = {}));
var VidyoConnectorFailReason;
(function (VidyoConnectorFailReason) {
    VidyoConnectorFailReason["BrowserOffline"] = "VIDYO_CONNECTORFAILREASON_BrowserOffLine";
    VidyoConnectorFailReason["ConnectionFailed"] = "VIDYO_CONNECTORFAILREASON_ConnectionFailed";
    VidyoConnectorFailReason["ConnectionLost"] = "VIDYO_CONNECTORFAILREASON_ConnectionLost";
    VidyoConnectorFailReason["ConnectionTimeout"] = "VIDYO_CONNECTORFAILREASON_ConnectionTimeout";
    VidyoConnectorFailReason["NoResponse"] = "VIDYO_CONNECTORFAILREASON_NoResponse";
    VidyoConnectorFailReason["Terminated"] = "VIDYO_CONNECTORFAILREASON_Terminated";
    VidyoConnectorFailReason["InvalidToken"] = "VIDYO_CONNECTORFAILREASON_InvalidToken";
    VidyoConnectorFailReason["InvalidDisplayNameLength"] = "VIDYO_CONNECTORFAILREASON_InvalidDisplayNameLength";
    VidyoConnectorFailReason["BrowserVersionNotSupported"] = "VIDYO_CONNECTORFAILREASON_BrowserVersionNotSupported";
    VidyoConnectorFailReason["UnableToCreateResource"] = "VIDYO_CONNECTORFAILREASON_UnableToCreateResource";
    VidyoConnectorFailReason["NoResponseFromResource"] = "VIDYO_CONNECTORFAILREASON_NoResponseFromResource";
    VidyoConnectorFailReason["InvalidResourceId"] = "VIDYO_CONNECTORFAILREASON_InvalidResourceId";
    VidyoConnectorFailReason["ResourceFull"] = "VIDYO_CONNECTORFAILREASON_ResourceFull";
    VidyoConnectorFailReason["NotMember"] = "VIDYO_CONNECTORFAILREASON_NotMember";
    VidyoConnectorFailReason["Banned"] = "VIDYO_CONNECTORFAILREASON_Banned";
    VidyoConnectorFailReason["MediaNotEnabled"] = "VIDYO_CONNECTORFAILREASON_MediaNotEnabled";
    VidyoConnectorFailReason["MediaFailed"] = "VIDYO_CONNECTORFAILREASON_MediaFailed";
    VidyoConnectorFailReason["MiscLocalError"] = "VIDYO_CONNECTORFAILREASON_MiscLocalError";
    VidyoConnectorFailReason["MiscRemoteError"] = "VIDYO_CONNECTORFAILREASON_MiscRemoteError";
    VidyoConnectorFailReason["MiscError"] = "VIDYO_CONNECTORFAILREASON_MiscError";
    VidyoConnectorFailReason["NotSupported"] = "VIDYO_CONNECTORFAILREASON_NotSupported";
    VidyoConnectorFailReason["RoomLocked"] = "VIDYO_CONNECTORFAILREASON_RoomLocked";
    VidyoConnectorFailReason["RoomDisabled"] = "VIDYO_CONNECTORFAILREASON_RoomDisabled";
    VidyoConnectorFailReason["AllLinesInUse"] = "VIDYO_CONNECTORFAILREASON_AllLinesInUse";
    VidyoConnectorFailReason["SeatLicenseExpired"] = "VIDYO_CONNECTORFAILREASON_SeatLicenseExpired";
    VidyoConnectorFailReason["NotLicensed"] = "VIDYO_CONNECTORFAILREASON_NotLicensed";
    VidyoConnectorFailReason["Rejected"] = "VIDYO_CONNECTORFAILREASON_Rejected";
})(VidyoConnectorFailReason = exports.VidyoConnectorFailReason || (exports.VidyoConnectorFailReason = {}));
var VidyoConnectorAnalyticServiceType;
(function (VidyoConnectorAnalyticServiceType) {
    VidyoConnectorAnalyticServiceType["VIDYO_CONNECTORANALYTICSSERVICETYPE_Google"] = "VIDYO_CONNECTORANALYTICSSERVICETYPE_Google";
})(VidyoConnectorAnalyticServiceType = exports.VidyoConnectorAnalyticServiceType || (exports.VidyoConnectorAnalyticServiceType = {}));
class VidyoConnectorHiddenMembers {
    constructor() {
        this.AbortLogin = null;
        this.State = VidyoConnectorState.Idle;
        this.VidyoParticipantCallbacks = {};
        this.RecorderInCallCallbacks = {};
        this.VidyoModerationCallbacks = {
            onModerationCommandReceived: noop
        };
        this.VidyoConferenceModeCallbacks = {
            conferenceModeChanged: noop
        };
        this.VidyoLectureModeCallbacks = {
            presenterChanged: noop,
            handRaised: noop
        };
        this.VidyoUnprocessedAudioCallbacks = {
            onUnprocessedAudioSupportChanged: noop,
            onUnprocessedAudioStarted: noop
        };
    }
}
let VidyoConnector = VidyoConnector_1 = class VidyoConnector {
    constructor() {
        this.objType = 'VidyoConnector';
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_hidden', new VidyoConnectorHiddenMembers());
        this._hidden.VidyoSimple = new SimpleApi.VidyoSimple();
        this.objId = UUID.v4();
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.VidyoConnector, __filename);
    }
    AddMessageClass(msgClass) {
        return this._hidden.VidyoEndpoint.AddMessageClass(msgClass);
    }
    AnalyticsControlEventAction(options) {
        return this._hidden.VidyoEndpoint.AnalyticsControlEventAction(options);
    }
    AnalyticsStart(options) {
        return this._hidden.VidyoEndpoint.AnalyticsStart(options);
    }
    AnalyticsStop() {
        return this._hidden.VidyoEndpoint.AnalyticsStop();
    }
    AssignViewToCompositeRenderer(options) {
        return this._hidden.VidyoEndpoint.AssignViewToCompositeRenderer(options);
    }
    AssignViewToLocalCamera(options) {
        return this._hidden.VidyoEndpoint.AssignViewToLocalCamera(options);
    }
    AssignViewToLocalMonitor(options) {
        return this._hidden.VidyoEndpoint.AssignViewToLocalMonitor(options);
    }
    AssignViewToLocalWindowShare(options) {
        return this._hidden.VidyoEndpoint.AssignViewToLocalWindowShare(options);
    }
    AssignViewToRemoteCamera(options) {
        return this._hidden.VidyoEndpoint.AssignViewToRemoteCamera(options);
    }
    AssignViewToRemoteWindowShare(options) {
        return this._hidden.VidyoEndpoint.AssignViewToRemoteWindowShare(options);
    }
    Connect(options) {
        return Promise.resolve(true);
    }
    ConnectToRoomAsGuest(options) {
        const { roomKey, onSuccess, onFailure, onDisconnected, roomPin } = options;
        const host = options.host.replace(/^https?:\/\//, '');
        const displayName = StringUtils_1.default.toSecureString(options.displayName);
        if (this._hidden.State !== VidyoConnectorState.Ready) {
            return Promise.reject(new Error(StringUtils_1.default.Format(Messages.ErrorWhileConnecting, { state: this._hidden.State })));
        }
        this._hidden.VidyoUser.SetDisplayName({ displayName });
        let { promise: loginPromise, resolve: afterLogin, reject: abortLogin } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        this._hidden.AbortLogin = abortLogin;
        let { promise: disconnectionPromise, resolve: localOnDisconnected } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        this._hidden.DisconnectionPromise = disconnectionPromise;
        this._hidden.DisconnectionPromise.then((reason) => {
            this._changeState(VidyoConnectorState.Ready);
            if (!reason || !reason.reasonCode) {
                setTimeout(() => onFailure(window.navigator.onLine === false ? VidyoConnectorFailReason.BrowserOffline : VidyoConnectorFailReason.MiscError), 0);
            }
            else if (ObjectUtils_1.default.existValueInEnum(VidyoConnectorDisconnectReason, reason.reasonCode)) {
                setTimeout(() => onDisconnected(window.navigator.onLine === false ? VidyoConnectorDisconnectReason.BrowserOffline : reason.reasonCode), 0);
            }
            else {
                setTimeout(() => onFailure(window.navigator.onLine === false ? VidyoConnectorFailReason.BrowserOffline : reason.reasonCode), 0);
            }
            this._hidden.VidyoRoom = null;
        });
        let { promise: roomCreatePromise, resolve: afterRoomCreate } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        let { promise: roomEnterPromise, resolve: afterRoomEntered } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        let { promise: mediaEnablePromise, resolve: afterMediaEnabled } = (0, PromiseHelper_1.MakePromiseWithCallback)();
        this._changeState(VidyoConnectorState.EstablishingConnection);
        return this._hidden.VidyoUser.LoginAsGuestWithRoomKey(roomKey, displayName, host, roomPin, undefined, 'hunter', afterLogin, localOnDisconnected, () => { }).then(() => {
            return loginPromise;
        }).then(() => {
            this._changeState(VidyoConnectorState.FindingResource);
            let resourceId = ``;
            return this._hidden.VidyoUser.CreateRoomFromId(resourceId, roomKey, afterRoomCreate).then(() => roomCreatePromise);
        }).then((room) => {
            this._hidden.VidyoRoom = room;
            this._changeState(VidyoConnectorState.ConnectingToResource);
            return room.Enter(afterRoomEntered, () => { }).then(() => roomEnterPromise);
        }).then(() => {
            this._hidden.VidyoRoom.RegisterParticipantEventListener(this._hidden.VidyoParticipantCallbacks.onJoined || noop, this._hidden.VidyoParticipantCallbacks.onLeft || noop, this._hidden.VidyoParticipantCallbacks.onDynamicChanged || noop, this._hidden.VidyoParticipantCallbacks.onLoudestChanged || noop);
            this._hidden.VidyoRoom.RegisterRecorderInCallEventListener(this._hidden.RecorderInCallCallbacks.onRecorderInCallChanged || noop);
            if (this._hidden.VidyoMessagesCallbacks) {
                this._hidden.VidyoRoom.RegisterMessageEventListener({
                    onMessageAcknowledged: this._hidden.VidyoMessagesCallbacks.onChatMessageAcknowledged || noop,
                    onMessageRead: () => { },
                    onMessageReceived: this._hidden.VidyoMessagesCallbacks.onChatMessageReceived,
                    onMessageTypingIndication: () => { }
                });
            }
            this._hidden.VidyoRoom.RegisterConferenceModeEventListener(this._hidden.VidyoConferenceModeCallbacks);
            this._hidden.VidyoRoom.RegisterLectureModeEventListener(this._hidden.VidyoLectureModeCallbacks);
            this._hidden.VidyoRoom.RegisterModerationCommandEventListener(this._hidden.VidyoModerationCallbacks);
            this._hidden.VidyoRoom.RegisterUnprocessedAudioEventListener(this._hidden.VidyoUnprocessedAudioCallbacks);
            this._changeState(VidyoConnectorState.EnablingMedia);
            return this._hidden.VidyoRoom.EnableMedia(afterMediaEnabled, onFailure, () => { }).then(() => mediaEnablePromise);
        }).then(() => {
            this._hidden.VidyoSimple.EventDispatcher.once(ConferenceEvents.Events.ConferenceJoined, () => {
                this._hidden.AbortLogin = null;
                this._changeState(VidyoConnectorState.Connected);
                onSuccess();
            });
            return true;
        }).catch((e) => {
            console.error(`exception caught: ${e}`);
            let reason = (e === VidyoConnectorDisconnectReason.Terminated ||
                e === VidyoConnectorFailReason.InvalidDisplayNameLength ||
                e === VidyoConnectorFailReason.BrowserVersionNotSupported) ? e : VidyoConnectorDisconnectReason.MiscError;
            this._changeState(VidyoConnectorState.Ready);
            if (ObjectUtils_1.default.existValueInEnum(VidyoConnectorDisconnectReason, reason)) {
                setTimeout(() => onDisconnected(window.navigator.onLine === false ? VidyoConnectorDisconnectReason.BrowserOffline : reason), 0);
            }
            else {
                onFailure(window.navigator.onLine === false ? VidyoConnectorFailReason.BrowserOffline : reason);
            }
            return false;
        });
    }
    CycleCamera() {
        this._hidden.VidyoEndpoint.CycleCamera();
        return Promise.resolve(true);
    }
    CycleMicrophone() {
        this._hidden.VidyoEndpoint.CycleMicrophone();
        return Promise.resolve(true);
    }
    CycleSpeaker() {
        this._hidden.VidyoEndpoint.CycleSpeaker();
        return Promise.resolve(true);
    }
    Destruct() {
        return this.Disable();
    }
    Disable() {
        return this._hidden.VidyoSimple.Disable().then((result) => {
            this._changeState(VidyoConnectorState.Idle);
            return result;
        });
    }
    Disconnect() {
        if (this._hidden.State !== VidyoConnectorState.Connected) {
            if (this._hidden.AbortLogin) {
                this._hidden.AbortLogin(VidyoConnectorDisconnectReason.Terminated);
                this._hidden.AbortLogin = null;
            }
            else {
                return Promise.reject(undefined);
            }
        }
        this._changeState(VidyoConnectorState.Disconecting);
        this._hidden.VidyoUser.Logout();
        return this._hidden.DisconnectionPromise;
    }
    DisableDebug() {
        this._hidden.VidyoEndpoint.DisableDebug();
    }
    EnableDebug(options) {
        return this._hidden.VidyoEndpoint.EnableDebug(options);
    }
    GetAnalyticsEventTable(options) {
        return this._hidden.VidyoEndpoint.GetAnalyticsEventTable(options);
    }
    GetConnectionProperties() {
        let properties = [];
        properties.push({ name: 'Room.displayName', value: this._hidden.VidyoRoom?.RoomDisplayName });
        properties.push({ name: 'Room.conferenceIdNumber', value: this._hidden.VidyoRoom?.RoomIdNumber });
        return Promise.resolve(properties);
    }
    GetState() {
        return Promise.resolve(this._hidden.State);
    }
    GetStatsJson() {
        return this._hidden.VidyoEndpoint.GetStatsJson();
    }
    GetWebRTCStats() {
        return this._hidden.VidyoEndpoint.GetWebRTCStats();
    }
    GetVersion() { return Promise.resolve(`${Constants_1.LibVersion}.${Constants_1.LibBuild}`); }
    GetVersionWithoutBuildNumber() { return Promise.resolve(Constants_1.LibVersion); }
    HideView(options) {
        return this._hidden.VidyoEndpoint.HideView(options);
    }
    PinParticipant(options) {
        return this._hidden.VidyoEndpoint.PinParticipant(options);
    }
    RaiseHand(options) {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.RaiseHand(options);
        }
        return Promise.resolve(false);
    }
    RegisterConferenceModeEventListener(callbacks) {
        this._hidden.VidyoConferenceModeCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.RegisterConferenceModeEventListener(this._hidden.VidyoConferenceModeCallbacks);
        }
        return Promise.resolve(false);
    }
    RegisterLectureModeEventListener(callbacks) {
        this._hidden.VidyoLectureModeCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.RegisterLectureModeEventListener(this._hidden.VidyoLectureModeCallbacks);
        }
        return Promise.resolve(false);
    }
    RegisterLocalCameraEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterLocalCameraEventListener(options);
    }
    RegisterLocalCameraStreamInterceptor(interceptor) {
        return this._hidden.VidyoEndpoint.RegisterLocalCameraStreamInterceptor(interceptor);
    }
    RegisterLocalMicrophoneEnergyListener(energyLevelInfo) {
        return this._hidden.VidyoEndpoint.RegisterLocalMicrophoneEnergyListener(energyLevelInfo);
    }
    RegisterLocalMicrophoneEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterLocalMicrophoneEventListener(options);
    }
    RegisterLocalMonitorEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterLocalMonitorEventListener(options);
    }
    RegisterLocalSpeakerEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterLocalSpeakerEventListener(options);
    }
    RegisterLocalWindowShareEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterLocalWindowShareEventListener(options);
    }
    RegisterMessageEventListener(callbacks) {
        this._hidden.VidyoMessagesCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            this._hidden.VidyoRoom.RegisterMessageEventListener({
                onMessageAcknowledged: callbacks.onChatMessageAcknowledged || noop,
                onMessageRead: () => { },
                onMessageReceived: callbacks.onChatMessageReceived,
                onMessageTypingIndication: () => { }
            });
        }
        return Promise.resolve(true);
    }
    RegisterModerationCommandEventListener(callbacks) {
        let promise = Promise.resolve(true);
        this._hidden.VidyoModerationCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            promise = this._hidden.VidyoRoom.RegisterModerationCommandEventListener(this._hidden.VidyoModerationCallbacks);
        }
        return promise;
    }
    RegisterLogEventListener(onLogListener) {
        return this._hidden.VidyoEndpoint.RegisterLogEventListener(onLogListener);
    }
    RegisterParticipantEventListener(callbacks) {
        let promise = Promise.resolve(true);
        this._hidden.VidyoParticipantCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            promise = this._hidden.VidyoRoom.RegisterParticipantEventListener(this._hidden.VidyoParticipantCallbacks.onJoined || noop, this._hidden.VidyoParticipantCallbacks.onLeft || noop, this._hidden.VidyoParticipantCallbacks.onDynamicChanged || noop, this._hidden.VidyoParticipantCallbacks.onLoudestChanged || noop);
        }
        return promise;
    }
    RegisterPermissionEventListener(options) {
        return this._hidden.VidyoPermission.RegisterPermissionEventListener(options);
    }
    RegisterReconnectEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterReconnectEventListener(options);
    }
    RegisterRecorderInCallEventListener(callbacks) {
        let promise = Promise.resolve(true);
        this._hidden.RecorderInCallCallbacks = callbacks;
        if (this._hidden.VidyoRoom) {
            promise = this._hidden.VidyoRoom.RegisterRecorderInCallEventListener(this._hidden.RecorderInCallCallbacks.onRecorderInCallChanged || noop);
        }
        return promise;
    }
    RegisterRemoteCameraEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterRemoteCameraEventListener(options);
    }
    RegisterRemoteMicrophoneEnergyListener(energyLevelInfo) {
        return this._hidden.VidyoEndpoint.RegisterRemoteMicrophoneEnergyListener(energyLevelInfo);
    }
    RegisterRemoteMicrophoneEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterRemoteMicrophoneEventListener(options);
    }
    RegisterRemoteSpeakerEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterRemoteSpeakerEventListener(options);
    }
    RegisterRemoteWindowShareEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterRemoteWindowShareEventListener(options);
    }
    RegisterResourceManagerEventListener(resourceManagerCallbacks) {
        return this._hidden.VidyoEndpoint.RegisterResourceManagerEventListener(resourceManagerCallbacks);
    }
    RegisterUnprocessedAudioEventListener(options) {
        this._hidden.VidyoUnprocessedAudioCallbacks = options;
        if (this._hidden.VidyoRoom) {
            this._hidden.VidyoRoom.RegisterUnprocessedAudioEventListener(options);
        }
        return Promise.resolve(true);
    }
    RegisterVideoTileEventListener(options) {
        return this._hidden.VidyoEndpoint.RegisterVideoTileEventListener(options);
    }
    ReportLocalParticipantOnJoined(reportLocalParticipant) {
        this._hidden.VidyoEndpoint.ReportLocalParticipantOnJoined(reportLocalParticipant);
        return Promise.resolve(true);
    }
    SelectAudioContentShare(options) {
        return this._hidden.VidyoEndpoint.SelectAudioContentShare(options);
    }
    SelectDefaultCamera() {
        this._hidden.VidyoEndpoint.SelectDefaultCamera();
        return Promise.resolve(true);
    }
    SelectDefaultMicrophone() {
        this._hidden.VidyoEndpoint.SelectDefaultMicrophone();
        return Promise.resolve(true);
    }
    SelectDefaultSpeaker() {
        this._hidden.VidyoEndpoint.SelectDefaultSpeaker();
        return Promise.resolve(true);
    }
    SelectLocalCamera({ localCamera }) {
        this._hidden.VidyoEndpoint.SelectCamera({ camera: localCamera });
        return Promise.resolve(true);
    }
    SelectLocalMicrophone({ localMicrophone }) {
        this._hidden.VidyoEndpoint.SelectMicrophone({ microphone: localMicrophone });
        return Promise.resolve(true);
    }
    SelectLocalMonitor(options) {
        return this._hidden.VidyoEndpoint.SelectLocalMonitor(options);
    }
    SelectLocalSpeaker({ localSpeaker }) {
        this._hidden.VidyoEndpoint.SelectSpeaker({ speaker: localSpeaker });
        return Promise.resolve(true);
    }
    SelectLocalWindowShare(options) {
        return this._hidden.VidyoEndpoint.SelectLocalWindowShare(options);
    }
    SelectVideoContentShare(options) {
        return this._hidden.VidyoEndpoint.SelectVideoContentShare(options);
    }
    SendChatMessage(options) {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.SendMessage(options);
        }
        return Promise.resolve(false);
    }
    SendPrivateChatMessage(options) {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.SendPrivateMessage(options);
        }
        return Promise.resolve(false);
    }
    SetAdvancedConfiguration(values) {
        this._hidden.VidyoEndpoint.SetAdvancedConfiguration(values);
    }
    SetOptions(options) {
        this._hidden.VidyoEndpoint.SetOptions(options);
    }
    SetCameraPrivacy(state) {
        return this._hidden.VidyoEndpoint.SetCameraPrivacy(state);
    }
    SetConsoleLoggerFilter(options) {
        this._hidden.VidyoEndpoint.SetConsoleLoggerFilter(options);
    }
    SetFileLoggerFilter(options) {
        this._hidden.VidyoEndpoint.SetFileLoggerFilter(options);
    }
    SetLocation(location) {
        return this._hidden.VidyoEndpoint.SetLocation(location);
    }
    SetMaxReceiveBitRate(options) {
        return this._hidden.VidyoEndpoint.SetMaxReceiveBitRate(options);
    }
    SetMaxSendBitRate(options) {
        return this._hidden.VidyoEndpoint.SetMaxSendBitRate(options);
    }
    SetMicrophonePrivacy(state) {
        return this._hidden.VidyoEndpoint.SetMicrophonePrivacy(state);
    }
    SetPool(options) {
        return this._hidden.VidyoEndpoint.SetPool(options);
    }
    SetTCPTransport(param) {
        return this._hidden.VidyoUser.SetTCPTransport(param);
    }
    SetUDPTransport(param) {
        return this._hidden.VidyoUser.SetUDPTransport(param);
    }
    SetSpeakerPrivacy(state) {
        return this._hidden.VidyoEndpoint.SetSpeakerPrivacy(state);
    }
    ShowAudioMeters(options) {
        return this._hidden.VidyoEndpoint.ShowAudioMeters(options);
    }
    ShowPreview(options) {
        return this._hidden.VidyoEndpoint.ShowPreview(options);
    }
    ShowVideoTileControls(options) {
        return this._hidden.VidyoEndpoint.ShowVideoTileControls(options);
    }
    ShowViewAt(options) {
        return this._hidden.VidyoEndpoint.ShowViewAt(options);
    }
    ShowViewLabel(options) {
        return this._hidden.VidyoEndpoint.ShowViewLabel(options);
    }
    ShowWindowSharePreview(options) {
        this._hidden.VidyoEndpoint.ShowWindowSharePreview(options);
        return Promise.resolve(true);
    }
    UnraiseHand(options) {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnraiseHand(options);
        }
        return Promise.resolve(false);
    }
    UnregisterConferenceModeEventListener() {
        this._hidden.VidyoConferenceModeCallbacks = {
            conferenceModeChanged: noop
        };
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnregisterConferenceModeEventListener();
        }
        return Promise.resolve(true);
    }
    UnregisterLectureModeEventListener() {
        this._hidden.VidyoLectureModeCallbacks = {
            presenterChanged: noop,
            handRaised: noop
        };
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnregisterLectureModeEventListener();
        }
        return Promise.resolve(true);
    }
    UnregisterModerationCommandEventListener() {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnregisterModerationCommandEventListener();
        }
        this._hidden.VidyoModerationCallbacks = { onModerationCommandReceived: noop };
        return Promise.resolve(true);
    }
    UnregisterLocalCameraEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalCameraEventListener();
    }
    UnregisterLocalCameraStreamInterceptor() {
        return this._hidden.VidyoEndpoint.UnregisterLocalCameraStreamInterceptor();
    }
    UnregisterLocalMicrophoneEnergyListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalMicrophoneEnergyListener();
    }
    UnregisterLocalMicrophoneEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalMicrophoneEventListener();
    }
    UnregisterLocalMonitorEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalMonitorEventListener();
    }
    UnregisterLocalSpeakerEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalSpeakerEventListener();
    }
    UnregisterLocalWindowShareEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLocalWindowShareEventListener();
    }
    UnregisterLogEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterLogEventListener();
    }
    UnregisterMessageEventListener() {
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnregisterMessageEventListener();
        }
        if (this._hidden.VidyoMessagesCallbacks) {
            this._hidden.VidyoMessagesCallbacks = undefined;
        }
        return Promise.resolve(true);
    }
    UnregisterParticipantEventListener() {
        if (this._hidden.VidyoRoom) {
            this._hidden.VidyoRoom.UnregisterParticipantEventListener();
            return Promise.resolve(true);
        }
        this._hidden.VidyoParticipantCallbacks = {};
        return Promise.resolve(true);
    }
    UnregisterPermissionEventListener() {
        return this._hidden.VidyoPermission.UnregisterPermissionEventListener();
    }
    UnregisterRemoteCameraEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterRemoteCameraEventListener();
    }
    UnregisterRemoteMicrophoneEnergyListener() {
        return this._hidden.VidyoEndpoint.UnregisterRemoteMicrophoneEnergyListener();
    }
    UnregisterRemoteMicrophoneEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterRemoteMicrophoneEventListener();
    }
    UnregisterRemoteSpeakerEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterRemoteSpeakerEventListener();
    }
    UnregisterRemoteWindowShareEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterRemoteWindowShareEventListener();
    }
    UnregisterResourceManagerEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterResourceManagerEventListener();
    }
    UnregisterUnprocessedAudioEventListener() {
        this._hidden.VidyoUnprocessedAudioCallbacks = {
            onUnprocessedAudioSupportChanged: noop,
            onUnprocessedAudioStarted: noop
        };
        if (this._hidden.VidyoRoom) {
            return this._hidden.VidyoRoom.UnregisterUnprocessedAudioEventListener();
        }
        return Promise.resolve(true);
    }
    UnregisterVideoTileEventListener() {
        return this._hidden.VidyoEndpoint.UnregisterVideoTileEventListener();
    }
    _changeState(state) {
        this._hidden.State = state;
    }
    _initialize(viewId, viewStyle, remoteParticipants, logFileFilter, logFileName, userData) {
        return this._hidden.VidyoSimple.Initialize().then(() => {
            this._hidden.VidyoEndpoint = this._hidden.VidyoSimple.CreateVidyoEndpoint(viewId, viewStyle, remoteParticipants, logFileFilter, logFileFilter, logFileName);
            this._hidden.VidyoUser = this._hidden.VidyoSimple.CreateVidyoUser(this._hidden.VidyoEndpoint);
            this._hidden.VidyoPermission = this._hidden.VidyoSimple.CreateVidyoPermission();
            this._changeState(VidyoConnectorState.Ready);
            return true;
        });
    }
    _noopPromise() {
        console.warn('Not Implemented');
        console.trace();
        return new Promise(() => false);
    }
    _registerAdvancedSettingsEventListener({ onDisableStatsChanged, onEnableAudioOnlyModeChanged, onEnableAutoReconnectChanged, onEnableCompositorFixedParticipants, onEnableFixedEncoderBitRate, onEnableSimpleAPILoggingChanged, onEnableScreenShareSimulcastChanged, onEnableTransportCcChanged, onEnableVideoSimulcastChanged, onEnableVidyoConnectorAPILoggingChanged, onMaxReconnectAttemptsChanged, onParticipantLimitChanged, onPinnedParticipantDisplayCroppedChanged, onReconnectBackoffChanged, onLogCategoryChanged, onShowStatisticsOverlayChanged, onStatisticsRefreshIntervalChanged, onCameraContentHintChanged, onWindowShareContentHintChanged }) {
        this._hidden.VidyoEndpoint.RegisterAdvancedSettingsEventListener({ onDisableStatsChanged,
            onEnableAudioOnlyModeChanged,
            onEnableAutoReconnectChanged,
            onEnableCompositorFixedParticipants,
            onEnableFixedEncoderBitRate,
            onEnableScreenShareSimulcastChanged,
            onEnableTransportCcChanged,
            onEnableVideoSimulcastChanged,
            onEnableVidyoConnectorAPILoggingChanged,
            onMaxReconnectAttemptsChanged,
            onParticipantLimitChanged,
            onPinnedParticipantDisplayCroppedChanged,
            onReconnectBackoffChanged,
            onShowStatisticsOverlayChanged,
            onStatisticsRefreshIntervalChanged,
            onEnableSimpleAPILoggingChanged,
            onLogCategoryChanged,
            onCameraContentHintChanged,
            onWindowShareContentHintChanged });
    }
    static CreateVidyoConnector(options) {
        let { viewId, viewStyle, remoteParticipants, logFileFilter, logFileName, userData, constraints } = options;
        let vidyoConnector = new VidyoConnector_1();
        if (constraints !== undefined) {
            if (constraints.disableGoogleAnalytics) {
                GoogleAnalytics_1.GoogleAnalyticsProvider.isDisabled = true;
            }
            if (constraints.mediaConstraints) {
                UserMediaProvider_1.UserMediaProvider.SetAudioAndVideoConstraints(constraints.mediaConstraints);
            }
            if (constraints.location) {
                LocationProvider_1.LocationProvider.SetDefaultLocationStatus(constraints.location);
            }
        }
        return vidyoConnector._initialize(viewId, viewStyle, remoteParticipants, logFileFilter, logFileName, userData).then(() => {
            window['vidyoConnector'] = vidyoConnector;
            return vidyoConnector;
        });
    }
};
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "AssignViewToLocalCamera", null);
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "AssignViewToLocalMonitor", null);
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "AssignViewToLocalWindowShare", null);
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "AssignViewToRemoteCamera", null);
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "AssignViewToRemoteWindowShare", null);
__decorate([
    Decorators_1.notImplemented
], VidyoConnector.prototype, "Connect", null);
__decorate([
    (0, SyncronizedQueue_1.synchronized)('custom-layout')
], VidyoConnector.prototype, "HideView", null);
VidyoConnector = VidyoConnector_1 = __decorate([
    JSValidation_1.default
], VidyoConnector);
exports.VidyoConnector = VidyoConnector;

}).call(this)}).call(this,"/src/vidyo_connector_api/VidyoConnector.ts")
},{"../core/events/ConferenceEvents":65,"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/Constants":138,"../core/utils/Decorators":139,"../core/utils/GoogleAnalytics":144,"../core/utils/JSValidation":145,"../core/utils/LocationProvider":147,"../core/utils/Messages":150,"../core/utils/ObjectUtils":153,"../core/utils/PromiseHelper":157,"../core/utils/StringUtils":164,"../core/utils/SyncronizedQueue":165,"../core/utils/UserMediaProvider":168,"../core/utils/VidyoDebugger":170,"../vidyo_simple_api/VidyoSimple":192,"uuid":11}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseModel = void 0;
class BaseModel {
    constructor(id, name, objId, origin, objectType) {
        this.id = id;
        this.name = name;
        this.objId = objId;
        this.objType = `Vidyo${origin}${objectType}`;
    }
}
exports.BaseModel = BaseModel;

},{}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatMessage = exports.VidyoChatMessageType = exports.VidyoChatMessageSenderType = void 0;
var VidyoChatMessageSenderType;
(function (VidyoChatMessageSenderType) {
    VidyoChatMessageSenderType["User"] = "VIDYO_CHATMESSAGESENDERTYPE_User";
    VidyoChatMessageSenderType["Room"] = "VIDYO_CHATMESSAGESENDERTYPE_Room";
    VidyoChatMessageSenderType["System"] = "VIDYO_CHATMESSAGESENDERTYPE_System";
    VidyoChatMessageSenderType["None"] = "VIDYO_CHATMESSAGESENDERTYPE_None";
})(VidyoChatMessageSenderType = exports.VidyoChatMessageSenderType || (exports.VidyoChatMessageSenderType = {}));
var VidyoChatMessageType;
(function (VidyoChatMessageType) {
    VidyoChatMessageType["Chat"] = "VIDYO_CHATMESSAGETYPE_Chat";
    VidyoChatMessageType["MediaStart"] = "VIDYO_CHATMESSAGETYPE_MediaStart";
    VidyoChatMessageType["MediaStop"] = "VIDYO_CHATMESSAGETYPE_MediaStop";
    VidyoChatMessageType["PrivateChat"] = "VIDYO_CHATMESSAGETYPE_PrivateChat";
})(VidyoChatMessageType = exports.VidyoChatMessageType || (exports.VidyoChatMessageType = {}));
const CoreToVidyoChatMessageSenderTypeMap = {
    user: VidyoChatMessageSenderType.User,
    room: VidyoChatMessageSenderType.Room
};
const CoreToVidyoChatMessageTypeMap = {
    chat: VidyoChatMessageType.Chat,
    mediastart: VidyoChatMessageType.MediaStart,
    mediastop: VidyoChatMessageType.MediaStop,
    privatechat: VidyoChatMessageType.PrivateChat
};
class ChatMessage {
    constructor(coreMessage) {
        this.objType = 'VidyoChatMessage';
        this.objId = coreMessage.objId;
        this.timestamp = coreMessage.timestamp;
        this.userId = coreMessage.userId;
        this.body = coreMessage.body;
        this.id = coreMessage.id;
        this.senderType = CoreToVidyoChatMessageSenderTypeMap[coreMessage.senderType] || VidyoChatMessageSenderType.None;
        this.type = CoreToVidyoChatMessageTypeMap[coreMessage.type] || VidyoChatMessageType.Chat;
    }
}
exports.ChatMessage = ChatMessage;

},{}],184:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoRemoteMicrophoneMode = exports.VidyoDeviceAudioSignalType = exports.VidyoDeviceType = exports.VidyoDeviceState = exports.RemoteWindowShare = exports.RemoteMicrophone = exports.RemoteCamera = exports.VidyoCameraControlDirection = exports.RemoteSpeaker = exports.Speaker = exports.Microphone = exports.Camera = exports.Device = void 0;
const BaseModel_1 = require("./BaseModel");
const NotImplemented_1 = require("../core/utils/NotImplemented");
const Origin_1 = require("./Origin");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
class Device extends BaseModel_1.BaseModel {
    constructor(vidyoCore, device, origin = Origin_1.Origin.Local) {
        super(device.Id, device.Name, device.ObjId, origin, device.Type);
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
    }
    GetId() {
        return Promise.resolve(this.id);
    }
    GetName() {
        return Promise.resolve(this.name);
    }
    GetType() {
        return Promise.resolve(this.objType);
    }
}
exports.Device = Device;
class Camera extends Device {
    AllowRemoteCameraControl(options) {
        return this._vidyoCore.Controllers.DeviceController.AllowRemoteCameraControl(this.id, options.allow);
    }
    GetPosition() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetPreviewLabel() {
        const label = this._vidyoCore.Controllers.DeviceController.GetPreviewLabel(this.id);
        return Promise.resolve(label);
    }
    IsControllable() {
        return this._vidyoCore.Controllers.DeviceController.IsLocalCameraControllable(this.id);
    }
    IsSuspended() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SetAspectRatioConstraint({ aspectRatioWidth, aspectRatioHeight }) {
        this._vidyoCore.Controllers.DeviceController.SetAspectRatioConstraint(this.id, aspectRatioWidth, aspectRatioHeight);
        return Promise.resolve(true);
    }
    SetMaxConstraint(constraints) {
        this._vidyoCore.Controllers.DeviceController.SetMaxConstraint(constraints, this.id);
        return Promise.resolve(true);
    }
    SetPreviewLabel(options) {
        this._vidyoCore.Controllers.DeviceController.SetPreviewLabel(options.previewLabel, this.id);
        return Promise.resolve(true);
    }
}
exports.Camera = Camera;
class Microphone extends Device {
    AddToRemoteSpeaker({ remoteSpeaker }) {
        this._vidyoCore.Controllers.DeviceController.AddToRemoteSpeaker(this.id, remoteSpeaker.id);
        return Promise.resolve(true);
    }
    GetSignalType() {
        const mediaProperties = this._vidyoCore.Controllers.DeviceController.GetMicrophoneMediaProperties(this.id);
        if (mediaProperties) {
            return Promise.resolve(mediaProperties.signalType);
        }
    }
    RemoveFromRemoteSpeaker({ remoteSpeaker }) {
        this._vidyoCore.Controllers.DeviceController.RemoveFromRemoteSpeaker(this.id, remoteSpeaker.id);
        return Promise.resolve(true);
    }
    SetSignalType({ signalType }) {
        return this._vidyoCore.Controllers.DeviceController.SetMicrophoneSignalType(this.id, signalType);
    }
}
exports.Microphone = Microphone;
class Speaker extends Device {
}
exports.Speaker = Speaker;
class RemoteSpeaker extends Device {
}
exports.RemoteSpeaker = RemoteSpeaker;
var VidyoCameraControlDirection;
(function (VidyoCameraControlDirection) {
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_PanLeft"] = "VIDYO_CAMERACONTROLDIRECTION_PanLeft";
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_PanRight"] = "VIDYO_CAMERACONTROLDIRECTION_PanRight";
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_TiltUp"] = "VIDYO_CAMERACONTROLDIRECTION_TiltUp";
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_TiltDown"] = "VIDYO_CAMERACONTROLDIRECTION_TiltDown";
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_ZoomIn"] = "VIDYO_CAMERACONTROLDIRECTION_ZoomIn";
    VidyoCameraControlDirection["VIDYO_CAMERACONTROLDIRECTION_ZoomOut"] = "VIDYO_CAMERACONTROLDIRECTION_ZoomOut";
})(VidyoCameraControlDirection = exports.VidyoCameraControlDirection || (exports.VidyoCameraControlDirection = {}));
class RemoteCamera extends Device {
    ControlPTZStart(options) {
        return this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZStart(this.id, options);
    }
    ControlPTZStop() {
        return this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZStop(this.id);
    }
    ControlPTZNudge(options) {
        return this._vidyoCore.Controllers.DeviceController.ControlRemoteCameraPTZNudge(this.id, options);
    }
    GetControlCapabilities() {
        return this._vidyoCore.Controllers.DeviceController.GetCameraControlCapabilities(this.id).then((coreCapabilities) => {
            return Promise.resolve({
                panTiltHasRubberBand: false,
                panTiltHasContinuousMove: coreCapabilities.panTiltHasContinuousMove,
                panTiltHasNudge: coreCapabilities.panTiltHasNudge,
                zoomHasRubberBand: false,
                zoomHasContinuousMove: coreCapabilities.zoomHasContinuousMove,
                zoomHasNudge: coreCapabilities.zoomHasNudge,
                hasPhotoCapture: false
            });
        });
    }
    GetPosition() {
        (0, NotImplemented_1.NotImplemented)();
    }
    HasPanAndTilt() {
        return this._vidyoCore.Controllers.DeviceController.RemoteCameraHasPanAndTilt(this.id);
    }
    HasZoom() {
        return this._vidyoCore.Controllers.DeviceController.RemoteCameraHasZoom(this.id);
    }
    IsControllable() {
        return this._vidyoCore.Controllers.DeviceController.IsRemoteCameraControllable(this.id);
    }
    IsSuspended() {
        (0, NotImplemented_1.NotImplemented)();
    }
    ShowCameraControl(options) {
        return this._vidyoCore.Controllers.DeviceController.ShowCameraControl(this.id, options.show);
    }
}
exports.RemoteCamera = RemoteCamera;
class RemoteMicrophone extends Device {
    AddToLocalSpeaker({ mode }) {
        if (typeof mode !== 'string' || mode !== VidyoRemoteMicrophoneMode[mode]) {
            return Promise.reject(new Error(`Unexpected microphone mode: "${mode}"`));
        }
        return this._vidyoCore.Controllers.DeviceController.AddRemoteMicrophoneToLocalSpeaker(this.id, mode);
    }
    GetSignalType() {
        const signalType = this._vidyoCore.Controllers.DeviceController.GetRemoteMicrophoneSignalType(this.id);
        return Promise.resolve(signalType);
    }
    RemoveFromLocalSpeaker() {
        return this._vidyoCore.Controllers.DeviceController.RemoveRemoteMicrophoneFromLocalSpeaker(this.id);
    }
}
exports.RemoteMicrophone = RemoteMicrophone;
class RemoteWindowShare extends Device {
}
exports.RemoteWindowShare = RemoteWindowShare;
var VidyoDeviceState;
(function (VidyoDeviceState) {
    VidyoDeviceState["Added"] = "VIDYO_DEVICESTATE_Added";
    VidyoDeviceState["Removed"] = "VIDYO_DEVICESTATE_Removed";
    VidyoDeviceState["Started"] = "VIDYO_DEVICESTATE_Started";
    VidyoDeviceState["Stopped"] = "VIDYO_DEVICESTATE_Stopped";
    VidyoDeviceState["Suspended"] = "VIDYO_DEVICESTATE_Suspended";
    VidyoDeviceState["Unsuspended"] = "VIDYO_DEVICESTATE_Unsuspended";
    VidyoDeviceState["InUse"] = "VIDYO_DEVICESTATE_InUse";
    VidyoDeviceState["Available"] = "VIDYO_DEVICESTATE_Available";
    VidyoDeviceState["Paused"] = "VIDYO_DEVICESTATE_Paused";
    VidyoDeviceState["Resumed"] = "VIDYO_DEVICESTATE_Resumed";
    VidyoDeviceState["Controllable"] = "VIDYO_DEVICESTATE_Controllable";
    VidyoDeviceState["NotControllable"] = "VIDYO_DEVICESTATE_NotControllable";
    VidyoDeviceState["DefaultChanged"] = "VIDYO_DEVICESTATE_DefaultChanged";
    VidyoDeviceState["ConfigureSuccess"] = "VIDYO_DEVICESTATE_ConfigureSuccess";
    VidyoDeviceState["ConfigureError"] = "VIDYO_DEVICESTATE_ConfigureError";
    VidyoDeviceState["Error"] = "VIDYO_DEVICESTATE_Error";
})(VidyoDeviceState = exports.VidyoDeviceState || (exports.VidyoDeviceState = {}));
var VidyoDeviceType;
(function (VidyoDeviceType) {
    VidyoDeviceType["LocalCamera"] = "VIDYO_DEVICETYPE_LocalCamera";
    VidyoDeviceType["LocalMicrophone"] = "VIDYO_DEVICETYPE_LocalMicrophone";
    VidyoDeviceType["LocalMonitor"] = "VIDYO_DEVICETYPE_LocalMonitor";
    VidyoDeviceType["LocalWindowShare"] = "VIDYO_DEVICETYPE_LocalWindowShare";
    VidyoDeviceType["LocalSpeaker"] = "VIDYO_DEVICETYPE_LocalSpeaker";
    VidyoDeviceType["LocalRenderer"] = "VIDYO_DEVICETYPE_LocalRenderer";
    VidyoDeviceType["RemoteCamera"] = "VIDYO_DEVICETYPE_RemoteCamera";
    VidyoDeviceType["RemoteMicrophone"] = "VIDYO_DEVICETYPE_RemoteMicrophone";
    VidyoDeviceType["RemoteWindowShare"] = "VIDYO_DEVICETYPE_RemoteWindowShare";
    VidyoDeviceType["RemoteSpeaker"] = "VIDYO_DEVICETYPE_RemoteSpeaker";
    VidyoDeviceType["RemoteRenderer"] = "VIDYO_DEVICETYPE_RemoteRenderer";
    VidyoDeviceType["VirtualVideoSource"] = "VIDYO_DEVICETYPE_VirtualVideoSource";
})(VidyoDeviceType = exports.VidyoDeviceType || (exports.VidyoDeviceType = {}));
var VidyoDeviceAudioSignalType;
(function (VidyoDeviceAudioSignalType) {
    VidyoDeviceAudioSignalType["VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed"] = "VIDYO_DEVICEAUDIOSIGNALTYPE_Unprocessed";
    VidyoDeviceAudioSignalType["VIDYO_DEVICEAUDIOSIGNALTYPE_Voice"] = "VIDYO_DEVICEAUDIOSIGNALTYPE_Voice";
})(VidyoDeviceAudioSignalType = exports.VidyoDeviceAudioSignalType || (exports.VidyoDeviceAudioSignalType = {}));
var VidyoRemoteMicrophoneMode;
(function (VidyoRemoteMicrophoneMode) {
    VidyoRemoteMicrophoneMode["VIDYO_REMOTEMICROPHONEMODE_Dynamic"] = "VIDYO_REMOTEMICROPHONEMODE_Dynamic";
    VidyoRemoteMicrophoneMode["VIDYO_REMOTEMICROPHONEMODE_Static"] = "VIDYO_REMOTEMICROPHONEMODE_Static";
})(VidyoRemoteMicrophoneMode = exports.VidyoRemoteMicrophoneMode || (exports.VidyoRemoteMicrophoneMode = {}));

}).call(this)}).call(this,"/src/vidyo_simple_api/Devices.ts")
},{"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/NotImplemented":152,"../core/utils/VidyoDebugger":170,"./BaseModel":182,"./Origin":187}],185:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndPoint = void 0;
const AdvancedSettingsEvents = require("../core/events/AdvancedSettingsEvents");
const ConnectionEvents = require("../core/events/ConnectionEvents");
const DeviceEvents = require("../core/events/DeviceEvents");
const RenderEvents = require("../core/events/RenderEvents");
const StreamEvents = require("../core/events/StreamEvents");
const UUID = require("uuid");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
const Camera_1 = require("../core/models/device/Camera");
const Devices_1 = require("./Devices");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const Microphone_1 = require("../core/models/device/Microphone");
const LocationProvider_1 = require("../core/utils/LocationProvider");
const OperatingSystemInfoProvider_1 = require("../core/utils/OperatingSystemInfoProvider");
const NotImplemented_1 = require("../core/utils/NotImplemented");
const Participant_1 = require("../vidyo_simple_api/Participant");
const Speaker_1 = require("../core/models/device/Speaker");
const LocalStorageProvider_1 = require("../core/utils/LocalStorageProvider");
const EventDispatcher_1 = require("../core/events/EventDispatcher");
const Stats_1 = require("./stats/Stats");
const WindowShare_1 = require("./WindowShare");
const Monitor_1 = require("./Monitor");
const Origin_1 = require("./Origin");
const LogEvents_1 = require("../core/events/LogEvents");
const APITypes_1 = require("../core/models/APITypes");
const JSValidation_1 = require("../core/utils/JSValidation");
const RendererTypes_1 = require("../core/models/RendererTypes");
const VidyoConnector_1 = require("../vidyo_connector_api/VidyoConnector");
const AnalyticsController_1 = require("../core/controllers/AnalyticsController/AnalyticsController");
let EndPoint = class EndPoint {
    constructor(vidyoCore) {
        this.objType = 'VidyoEndpoint';
        this._useDefaultCamera = true;
        this._useDefaultMicrophone = true;
        this._useDefaultSpeaker = true;
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
        this._vidyoCore.Controllers.CallStateController.EnableMedia();
        this.objId = this._createEndpointID();
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
        if (this._vidyoCore.Controllers.RendererController.RenderMode === RendererTypes_1.RenderMode.Composite) {
            this._registerLocalCameraPlugInOutManager();
            this._registerLocalMicrophonePlugInOutManager();
            this._registerLocalSpeakerPlugInOutManager();
        }
    }
    AddMessageClass(msgClass) {
        this._vidyoCore.Controllers.MessageController.AddMessageClass(msgClass);
        return Promise.resolve(true);
    }
    AnalyticsControlEventAction(options) {
        return this._vidyoCore.Controllers.AnalyticsController.ControlEventAction(options.eventCategory, options.eventAction, options.enable);
    }
    AnalyticsStart(options) {
        let coreServiceType = null;
        switch (options.serviceType) {
            case VidyoConnector_1.VidyoConnectorAnalyticServiceType.VIDYO_CONNECTORANALYTICSSERVICETYPE_Google:
                coreServiceType = AnalyticsController_1.AnalyticServiceType.VIDYO_COREANALYTICSSERVICETYPE_Google;
                break;
            default:
                this._vidyoCore.Controllers.LogController.LogInfo(() => `Unexpected analytics service type: ${options.serviceType}`);
                return Promise.resolve(false);
        }
        return this._vidyoCore.Controllers.AnalyticsController.Start(coreServiceType, options.serverUrl, options.trackingID);
    }
    AnalyticsStop() {
        return this._vidyoCore.Controllers.AnalyticsController.Stop();
    }
    AssignViewToCompositeRenderer(options) {
        this._vidyoCore.Controllers.RendererController.AssignViewToCompositeRenderer(options);
        return Promise.resolve(true);
    }
    AssignViewToLocalCamera({ viewId, localCamera, displayCropped, allowZoom }) {
        const streamId = this._vidyoCore.Controllers.LocalStreamController.CameraVideoStream.Id;
        return this._vidyoCore.Controllers.RendererController.AssignViewToLocalSource({
            viewId: viewId,
            sourceId: localCamera.id,
            displayCropped: displayCropped,
            allowZoom: allowZoom,
            isApplication: false,
            streamId: streamId
        });
    }
    AssignViewToLocalMonitor({ allowZoom, displayCropped, localMonitor, viewId }) {
        const streamId = this._vidyoCore.Controllers.LocalStreamController.MonitorShareStream.Id;
        return this._vidyoCore.Controllers.RendererController.AssignViewToLocalSource({
            viewId: viewId,
            sourceId: localMonitor.id,
            displayCropped: displayCropped,
            allowZoom: allowZoom,
            isApplication: true,
            streamId: streamId
        });
    }
    AssignViewToLocalWindowShare({ allowZoom, displayCropped, viewId, localWindowShare }) {
        const streamId = this._vidyoCore.Controllers.LocalStreamController.WindowShareStream.Id;
        return this._vidyoCore.Controllers.RendererController.AssignViewToLocalSource({
            viewId: viewId,
            sourceId: localWindowShare.id,
            displayCropped: displayCropped,
            allowZoom: allowZoom,
            isApplication: true,
            streamId: streamId
        });
    }
    AssignViewToRemoteCamera({ allowZoom, displayCropped, remoteCamera, viewId }) {
        return this._vidyoCore.Controllers.RendererController.AssignViewToRemoteSource({
            viewId: viewId,
            sourceId: remoteCamera.id,
            isApplication: false,
            displayCropped: displayCropped,
            allowZoom: allowZoom
        });
    }
    AssignViewToRemoteWindowShare({ allowZoom, displayCropped, remoteWindowShare, viewId }) {
        return this._vidyoCore.Controllers.RendererController.AssignViewToRemoteSource({
            viewId: viewId,
            sourceId: remoteWindowShare.id,
            isApplication: true,
            displayCropped: displayCropped,
            allowZoom: allowZoom
        });
    }
    CycleCamera() {
        this._vidyoCore.Controllers.DeviceController.CycleCamera();
    }
    CycleMicrophone() {
        this._vidyoCore.Controllers.DeviceController.CycleMicrophone();
    }
    CycleSpeaker() {
        this._vidyoCore.Controllers.DeviceController.CycleSpeaker();
    }
    Disable() {
        (0, NotImplemented_1.NotImplemented)();
    }
    DisableDebug() {
        this._vidyoCore.Controllers.LogController.LogInfo(() => `DisableDebug is called`);
        this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL = '';
        this._vidyoCore.Controllers.LogController.DisableDebug();
    }
    EnableDebug({ port, logFilter }) {
        if (this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL) {
            this._vidyoCore.Controllers.LogController.LogWarning(() => `Port ${port} is ignored. Debug logs will be posted to ${this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL}`);
        }
        else {
            this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL = `https://127.0.0.1:${port}`;
            this._vidyoCore.Controllers.LogController.LogWarning(() => `Debug logs will be posted to ${this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL}`);
        }
        return this._vidyoCore.Controllers.LogController.EnableDebug(logFilter);
    }
    EnableFileLogger() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetAnalyticsEventTable(options) {
        options?.onGetAnalyticsEventTableCallback?.(this._vidyoCore.Controllers.AnalyticsController.GetAnalyticsEventTable());
        return Promise.resolve(true);
    }
    GetId() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetStats() {
        let endpointStatistics = this._vidyoCore.Controllers.StatisticsController.GetEndpointStatistics();
        let endpointStats = new Stats_1.EndpointStats(endpointStatistics);
        return endpointStats;
    }
    GetStatsJson() {
        return Promise.resolve(JSON.stringify(this.GetStats()));
    }
    GetWebRTCStats() {
        return this._vidyoCore.HunterProvider.GetStats();
    }
    HideView(options) {
        return this._vidyoCore.Controllers.RendererController.HideView(options);
    }
    PinParticipant({ participant, pin }) {
        return this._vidyoCore.Controllers.ParticipantController.PinParticipant(participant.id, pin);
    }
    RegisterAdvancedSettingsEventListener({ onDisableStatsChanged, onDisableDynamicAudioSources, onEnableAudioOnlyModeChanged, onEnableAutoReconnectChanged, onEnableCompositorFixedParticipants, onEnableFixedEncoderBitRate, onEnableSimpleAPILoggingChanged, onEnableScreenShareSimulcastChanged, onEnableTransportCcChanged, onEnableVideoSimulcastChanged, onEnableVidyoConnectorAPILoggingChanged, onExtDataChanged, onExtDataTypeChanged, onMaxReconnectAttemptsChanged, onParticipantLimitChanged, onPinnedParticipantDisplayCroppedChanged, onReconnectBackoffChanged, onLogCategoryChanged, onShowStatisticsOverlayChanged, onStatisticsRefreshIntervalChanged, onCameraContentHintChanged, onWindowShareContentHintChanged }) {
        if (onLogCategoryChanged) {
            onLogCategoryChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ShowLogCategory);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.LogCategoryChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onLogCategoryChanged);
        }
        if (onDisableDynamicAudioSources) {
            onDisableDynamicAudioSources(this._vidyoCore.Controllers.AdvancedSettingsController.DisableDynamicAudioSources);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.DisableDynamicAudioSourcesChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onDisableDynamicAudioSources);
        }
        if (onDisableStatsChanged) {
            onDisableStatsChanged(this._vidyoCore.Controllers.AdvancedSettingsController.DisableStats);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.DisableStatsChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onDisableStatsChanged);
        }
        if (onEnableAudioOnlyModeChanged) {
            onEnableAudioOnlyModeChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableAudioOnlyMode);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableAudioOnlyModeChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableAudioOnlyModeChanged);
        }
        if (onEnableCompositorFixedParticipants) {
            onEnableCompositorFixedParticipants(this._vidyoCore.Controllers.AdvancedSettingsController.EnableCompositorFixedParticipants);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableCompositorFixedParticipantsChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableCompositorFixedParticipants);
        }
        if (onEnableFixedEncoderBitRate) {
            onEnableFixedEncoderBitRate(this._vidyoCore.Controllers.AdvancedSettingsController.EnableFixedEncoderBitRate);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableFixedEncoderBitRateChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableFixedEncoderBitRate);
        }
        if (onEnableScreenShareSimulcastChanged) {
            onEnableScreenShareSimulcastChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableScreenShareSimulcastChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableScreenShareSimulcastChanged);
        }
        if (onEnableVideoSimulcastChanged) {
            onEnableVideoSimulcastChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableVideoSimulcastChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableVideoSimulcastChanged);
        }
        if (onEnableTransportCcChanged) {
            onEnableTransportCcChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableTransportCc);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableTransportCcChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableTransportCcChanged);
        }
        if (onParticipantLimitChanged) {
            onParticipantLimitChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ParticipantLimitChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onParticipantLimitChanged);
        }
        if (onShowStatisticsOverlayChanged) {
            onShowStatisticsOverlayChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ShowStatisticsOverlay);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ShowStatisticsOverlayChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onShowStatisticsOverlayChanged);
        }
        if (onStatisticsRefreshIntervalChanged) {
            onStatisticsRefreshIntervalChanged(this._vidyoCore.Controllers.AdvancedSettingsController.StatisticsRefreshInterval);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.StatisticsRefreshIntervalChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onStatisticsRefreshIntervalChanged);
        }
        if (onExtDataChanged) {
            onShowStatisticsOverlayChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ExtData);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ExtDataChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onExtDataChanged);
        }
        if (onExtDataTypeChanged) {
            onShowStatisticsOverlayChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ExtDataType);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ExtDataTypeChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onExtDataTypeChanged);
        }
        if (onEnableSimpleAPILoggingChanged) {
            onEnableSimpleAPILoggingChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableSimpleAPILogging);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableSimpleAPILoggingChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableSimpleAPILoggingChanged);
        }
        if (onEnableVidyoConnectorAPILoggingChanged) {
            onEnableVidyoConnectorAPILoggingChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableVidyoConnectorAPILogging);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableVidyoConnectorAPILoggingChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableVidyoConnectorAPILoggingChanged);
        }
        if (onEnableAutoReconnectChanged) {
            onEnableAutoReconnectChanged(this._vidyoCore.Controllers.AdvancedSettingsController.EnableAutoReconnect);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.EnableAutoReconnectChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onEnableAutoReconnectChanged);
        }
        if (onMaxReconnectAttemptsChanged) {
            onMaxReconnectAttemptsChanged(this._vidyoCore.Controllers.AdvancedSettingsController.MaxReconnectAttempts);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.MaxReconnectAttemptsChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onMaxReconnectAttemptsChanged);
        }
        if (onPinnedParticipantDisplayCroppedChanged) {
            onPinnedParticipantDisplayCroppedChanged(this._vidyoCore.Controllers.AdvancedSettingsController.PinnedParticipantDisplayCropped);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.PinnedParticipantDisplayCroppedChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onPinnedParticipantDisplayCroppedChanged);
        }
        if (onReconnectBackoffChanged) {
            onReconnectBackoffChanged(this._vidyoCore.Controllers.AdvancedSettingsController.ReconnectBackoff);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.ReconnectBackoffChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onReconnectBackoffChanged);
        }
        if (onCameraContentHintChanged) {
            onCameraContentHintChanged(this._vidyoCore.Controllers.AdvancedSettingsController.CameraContentHint);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.CameraContentHintChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onCameraContentHintChanged);
        }
        if (onWindowShareContentHintChanged) {
            onWindowShareContentHintChanged(this._vidyoCore.Controllers.AdvancedSettingsController.WindowShareContentHint);
            this._vidyoCore.EventDispatcher.on(AdvancedSettingsEvents.Events.WindowShareContentHintChanged, EventDispatcher_1.VidyoAdvancedSettingsEventListeners, onWindowShareContentHintChanged);
        }
    }
    RegisterLocalCameraEventListener({ onAdded, onRemoved, onSelected, onStateUpdated }) {
        let localOnAdded = (payload) => { onAdded(new Devices_1.Camera(this._vidyoCore, payload.camera)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraAdded, EventDispatcher_1.VidyoLocalCameraEventListeners, localOnAdded);
        let localOnRemoved = (payload) => { onRemoved(new Devices_1.Camera(this._vidyoCore, payload.camera)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraRemoved, EventDispatcher_1.VidyoLocalCameraEventListeners, localOnRemoved);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraUnplugged, EventDispatcher_1.VidyoLocalCameraEventListeners, localOnRemoved);
        let localOnSelected = (payload) => {
            const camera = payload ? new Devices_1.Camera(this._vidyoCore, payload.camera) : null;
            onSelected(camera);
        };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraSelected, EventDispatcher_1.VidyoLocalCameraEventListeners, localOnSelected);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraStateUpdated, EventDispatcher_1.VidyoLocalCameraEventListeners, (payload) => onStateUpdated(new Devices_1.Camera(this._vidyoCore, payload.camera), payload.state));
        let deviceDetectionPromise;
        let needEmitOnSelect = false;
        if (this._vidyoCore.Controllers.DeviceController.DevicesAreBeingDetected) {
            this._vidyoCore.Controllers.DeviceController.GetCameraList().forEach((camera) => localOnAdded({ camera }));
            needEmitOnSelect = true;
        }
        deviceDetectionPromise = this._vidyoCore.Controllers.DeviceController.StartDeviceDetection();
        return deviceDetectionPromise.then(() => {
            if (this._vidyoCore.Controllers.DeviceController.IsCameraSelected()) {
                if (needEmitOnSelect) {
                    let camera = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Camera;
                    if (typeof camera !== 'boolean') {
                        localOnSelected({ camera });
                    }
                }
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SelectDefaultCamera();
            }
            return true;
        }).catch(() => {
            return false;
        });
    }
    RegisterLocalCameraStreamInterceptor(interceptor) {
        return this._vidyoCore.Controllers.LocalStreamController.RegisterLocalCameraStreamInterceptor(interceptor);
    }
    RegisterLocalMicrophoneEnergyListener(energyLevelInfo) {
        return this._vidyoCore.Controllers.MicrophoneEnergyLevelController.RegisterLocalMicrophoneEnergyListener(energyLevelInfo);
    }
    RegisterLocalMicrophoneEventListener({ onAdded, onRemoved, onSelected, onStateUpdated }) {
        let localOnAdded = (payload) => { onAdded(new Devices_1.Microphone(this._vidyoCore, payload.microphone)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneAdded, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, localOnAdded);
        let localOnRemoved = (payload) => { onRemoved(new Devices_1.Microphone(this._vidyoCore, payload.microphone)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneRemoved, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, localOnRemoved);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneUnplugged, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, localOnRemoved);
        const localOnSelected = (payload) => {
            const microphone = payload ? new Devices_1.Microphone(this._vidyoCore, payload.microphone) : null;
            onSelected(microphone);
        };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneSelected, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, localOnSelected);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneStateUpdated, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, (payload) => onStateUpdated(new Devices_1.Microphone(this._vidyoCore, payload.microphone), payload.state));
        let deviceDetectionPromise;
        let needEmitOnSelect = false;
        if (this._vidyoCore.Controllers.DeviceController.DevicesAreBeingDetected) {
            this._vidyoCore.Controllers.DeviceController.GetMicrophoneList().forEach((microphone) => localOnAdded({ microphone }));
            needEmitOnSelect = true;
        }
        deviceDetectionPromise = this._vidyoCore.Controllers.DeviceController.StartDeviceDetection();
        return deviceDetectionPromise.then(() => {
            if (this._vidyoCore.Controllers.DeviceController.IsMicrophoneSelected()) {
                if (needEmitOnSelect) {
                    let microphone = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Microphone;
                    if (typeof microphone !== 'boolean') {
                        localOnSelected({ microphone });
                    }
                }
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SelectDefaultMicrophone();
            }
            return true;
        }).catch(() => {
            return false;
        });
    }
    RegisterLocalMonitorEventListener({ onAdded, onRemoved, onSelected, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalMonitorEventListeners);
        let dummyMonitorShare = new Monitor_1.Monitor(this._vidyoCore, 'Select Monitor');
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalMonitorAdded, EventDispatcher_1.VidyoLocalMonitorEventListeners, () => onAdded(dummyMonitorShare));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalMonitorSelected, EventDispatcher_1.VidyoLocalMonitorEventListeners, () => onSelected(dummyMonitorShare));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalMonitorDeselected, EventDispatcher_1.VidyoLocalMonitorEventListeners, () => onSelected(undefined));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalMonitorRemoved, EventDispatcher_1.VidyoLocalMonitorEventListeners, () => onRemoved(dummyMonitorShare));
        onAdded(dummyMonitorShare);
        return Promise.resolve(true);
    }
    RegisterLocalSpeakerEventListener({ onAdded, onRemoved, onSelected, onStateUpdated }) {
        let localOnAdded = (payload) => { onAdded(new Devices_1.Speaker(this._vidyoCore, payload.speaker)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerAdded, EventDispatcher_1.VidyoLocalSpeakerEventListeners, localOnAdded);
        let localOnRemoved = (payload) => { onRemoved(new Devices_1.Speaker(this._vidyoCore, payload.speaker)); };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerRemoved, EventDispatcher_1.VidyoLocalSpeakerEventListeners, localOnRemoved);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerUnplugged, EventDispatcher_1.VidyoLocalSpeakerEventListeners, localOnRemoved);
        const localOnSelected = (payload) => {
            const speaker = payload ? new Devices_1.Speaker(this._vidyoCore, payload.speaker) : null;
            onSelected(speaker);
        };
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerSelected, EventDispatcher_1.VidyoLocalSpeakerEventListeners, localOnSelected);
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerStateUpdated, EventDispatcher_1.VidyoLocalSpeakerEventListeners, (payload) => onStateUpdated(new Devices_1.Speaker(this._vidyoCore, payload.speaker), payload.state));
        let deviceDetectionPromise;
        let needEmitOnSelect = false;
        if (this._vidyoCore.Controllers.DeviceController.DevicesAreBeingDetected) {
            this._vidyoCore.Controllers.DeviceController.GetSpeakerList().forEach((speaker) => localOnAdded({ speaker }));
            needEmitOnSelect = true;
        }
        deviceDetectionPromise = this._vidyoCore.Controllers.DeviceController.StartDeviceDetection();
        return deviceDetectionPromise.then(() => {
            if (this._vidyoCore.Controllers.DeviceController.IsSpeakerSelected()) {
                if (needEmitOnSelect) {
                    let speaker = this._vidyoCore.Controllers.DeviceController.GetSelectedDevices().Speaker;
                    if (typeof speaker !== 'boolean') {
                        localOnSelected({ speaker });
                    }
                }
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SelectDefaultSpeaker();
            }
            return true;
        }).catch(() => {
            return false;
        });
    }
    RegisterLocalWindowShareEventListener({ onAdded, onRemoved, onSelected, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalWindowShareEventListeners);
        let dummyWindowShare = new WindowShare_1.WindowShare(this._vidyoCore, 'Select Share', Origin_1.Origin.Local, 'Application');
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalWindowShareAdded, EventDispatcher_1.VidyoLocalWindowShareEventListeners, () => onAdded(dummyWindowShare));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalWindowShareSelected, EventDispatcher_1.VidyoLocalWindowShareEventListeners, () => onSelected(dummyWindowShare));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalWindowShareDeselected, EventDispatcher_1.VidyoLocalWindowShareEventListeners, () => onSelected(null));
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.LocalWindowShareRemoved, EventDispatcher_1.VidyoLocalWindowShareEventListeners, () => onRemoved(dummyWindowShare));
        onAdded(dummyWindowShare);
        return Promise.resolve(true);
    }
    RegisterLogEventListener(onLogListener) {
        this._vidyoCore.Controllers.LogController.SetLogLevelApp(onLogListener.filter);
        this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventApp, EventDispatcher_1.VidyoCustomLoggingEventListeners, onLogListener.onLog);
        return Promise.resolve(true);
    }
    RegisterReconnectEventListener({ onReconnecting, onReconnected, onConferenceLost }) {
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnecting, EventDispatcher_1.VidyoReconnectEventListeners, (payload) => {
            onReconnecting(payload.attempt, payload.attemptTimeout, payload.lastReason);
        });
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.ConferenceLost, EventDispatcher_1.VidyoReconnectEventListeners, (payload) => {
            onConferenceLost(payload.lastReason);
        });
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Reconnected, EventDispatcher_1.VidyoReconnectEventListeners, () => {
            onReconnected();
        });
        return Promise.resolve(true);
    }
    RegisterRemoteCameraEventListener({ onAdded, onRemoved, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteCameraAdded, EventDispatcher_1.VidyoRemoteCameraEventListeners, (payload) => {
            onAdded(new Devices_1.RemoteCamera(this._vidyoCore, payload.camera, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteCameraRemoved, EventDispatcher_1.VidyoRemoteCameraEventListeners, (payload) => {
            onRemoved(new Devices_1.RemoteCamera(this._vidyoCore, payload.camera, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteCameraStateUpdated, EventDispatcher_1.VidyoRemoteCameraEventListeners, (payload) => {
            onStateUpdated(new Devices_1.RemoteCamera(this._vidyoCore, payload.camera, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        return Promise.resolve(true);
    }
    RegisterRemoteMicrophoneEnergyListener(energyLevelInfo) {
        return this._vidyoCore.Controllers.MicrophoneEnergyLevelController.RegisterRemoteMicrophoneEnergyListener(energyLevelInfo);
    }
    RegisterRemoteMicrophoneEventListener({ onAdded, onRemoved, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteMicrophoneAdded, EventDispatcher_1.VidyoRemoteMicrophoneEventListeners, (payload) => {
            onAdded(new Devices_1.RemoteMicrophone(this._vidyoCore, payload.microphone, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteMicrophoneRemoved, EventDispatcher_1.VidyoRemoteMicrophoneEventListeners, (payload) => {
            onRemoved(new Devices_1.RemoteMicrophone(this._vidyoCore, payload.microphone, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteMicrophoneStateUpdated, EventDispatcher_1.VidyoRemoteMicrophoneEventListeners, (payload) => {
            onStateUpdated(new Devices_1.RemoteMicrophone(this._vidyoCore, payload.microphone, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant), payload.state);
        });
        return Promise.resolve(true);
    }
    RegisterRemoteSpeakerEventListener({ onAdded, onRemoved, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.RemoteSpeakerAdded, EventDispatcher_1.VidyoRemoteSpeakerEventListeners, (payload) => {
            onAdded(new Devices_1.RemoteSpeaker(this._vidyoCore, payload.speaker, Origin_1.Origin.Remote));
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.RemoteSpeakerRemoved, EventDispatcher_1.VidyoRemoteSpeakerEventListeners, (payload) => {
            onRemoved(new Devices_1.RemoteSpeaker(this._vidyoCore, payload.speaker, Origin_1.Origin.Remote));
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.RemoteSpeakerStateUpdated, EventDispatcher_1.VidyoRemoteSpeakerEventListeners, (payload) => {
            onStateUpdated(new Devices_1.RemoteSpeaker(this._vidyoCore, payload.speaker, Origin_1.Origin.Remote), payload.state);
        });
        const coreRemoteSpeaker = this._vidyoCore.Controllers.DeviceController.RemoteSpeaker;
        if (coreRemoteSpeaker) {
            const vidyoRemoteSpeaker = new Devices_1.RemoteSpeaker(this._vidyoCore, coreRemoteSpeaker, Origin_1.Origin.Remote);
            onAdded(vidyoRemoteSpeaker);
            onStateUpdated(vidyoRemoteSpeaker, Devices_1.VidyoDeviceState.Resumed);
        }
        return Promise.resolve(true);
    }
    RegisterRemoteWindowShareEventListener({ onAdded, onRemoved, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteWindowShareAdded, EventDispatcher_1.VidyoRemoteWindowShareEventListeners, (payload) => {
            onAdded(new Devices_1.RemoteWindowShare(this._vidyoCore, payload.windowShare, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteWindowShareRemoved, EventDispatcher_1.VidyoRemoteWindowShareEventListeners, (payload) => {
            onRemoved(new Devices_1.RemoteWindowShare(this._vidyoCore, payload.windowShare, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(StreamEvents.Events.RemoteWindowShareStateUpdated, EventDispatcher_1.VidyoRemoteWindowShareEventListeners, (payload) => {
            onStateUpdated(new Devices_1.RemoteWindowShare(this._vidyoCore, payload.windowShare, Origin_1.Origin.Remote), new Participant_1.Participant(payload.participant));
        });
        return Promise.resolve(true);
    }
    RegisterResourceManagerEventListener(resourceManagerCallbacks) {
        return this._vidyoCore.Controllers.ResourcesManager.RegisterResourceManagerEventListener(resourceManagerCallbacks);
    }
    RegisterVideoTileEventListener({ onAdded, onRemoved, onStateUpdated }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRenderVideoTileEventListener);
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.VideoTileAdded, EventDispatcher_1.VidyoRenderVideoTileEventListener, (payload) => {
            onAdded(payload);
        });
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.VideoTileRemoved, EventDispatcher_1.VidyoRenderVideoTileEventListener, (payload) => {
            onRemoved(payload);
        });
        this._vidyoCore.EventDispatcher.on(RenderEvents.Events.VideoTileUpdated, EventDispatcher_1.VidyoRenderVideoTileEventListener, (payload) => {
            onStateUpdated(payload);
        });
        return Promise.resolve(true);
    }
    ReportLocalParticipantOnJoined(reportLocalParticipant) {
        this._vidyoCore.Controllers.ParticipantController.ReportLocalParticipant(reportLocalParticipant);
    }
    SelectAudioContentShare({ localMicrophone }) {
        if (localMicrophone) {
            const microphoneList = this._vidyoCore.Controllers.DeviceController.GetMicrophoneList();
            const coreMicrophone = microphoneList.find((coreMicrophone) => coreMicrophone.Id === localMicrophone.id);
            if (coreMicrophone) {
                this._vidyoCore.Controllers.DeviceController.SelectAudioContentShareDevice(coreMicrophone);
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SelectAudioContentShareDevice(new Microphone_1.Microphone(localMicrophone.name, localMicrophone.id, localMicrophone.objId));
            }
        }
        else {
            this._vidyoCore.Controllers.DeviceController.SelectAudioContentShareDevice();
        }
        return Promise.resolve(true);
    }
    SelectCamera({ camera }) {
        if (camera) {
            this._vidyoCore.Controllers.DeviceController.SelectCamera(new Camera_1.Camera(camera.name, camera.id, camera.objId));
        }
        else {
            this._vidyoCore.Controllers.DeviceController.SelectCamera();
        }
        this._useDefaultCamera = false;
    }
    SelectDefaultCamera() {
        this._vidyoCore.Controllers.DeviceController.SelectDefaultCamera();
        this._useDefaultCamera = true;
    }
    SelectDefaultMicrophone() {
        this._vidyoCore.Controllers.DeviceController.SelectDefaultMicrophone();
        this._useDefaultMicrophone = true;
    }
    SelectDefaultSpeaker() {
        this._vidyoCore.Controllers.DeviceController.SelectDefaultSpeaker();
        this._useDefaultSpeaker = true;
    }
    SelectLocalMicrophone() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SelectLocalMonitor(options) {
        return this._vidyoCore.Controllers.DeviceController.SelectMonitor(options.localMonitor)
            .then((result) => result);
    }
    SelectLocalSpeaker() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SelectLocalWindowShare(options) {
        return this._vidyoCore.Controllers.DeviceController.SelectWindowShare(options.localWindowShare)
            .then((result) => result);
    }
    SelectMicrophone({ microphone }) {
        if (microphone) {
            const microphoneList = this._vidyoCore.Controllers.DeviceController.GetMicrophoneList();
            const coreMicrophone = microphoneList.find((coreMicrophone) => coreMicrophone.Id === microphone.id);
            if (coreMicrophone) {
                this._vidyoCore.Controllers.DeviceController.SelectMicrophone(coreMicrophone);
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SelectMicrophone(new Microphone_1.Microphone(microphone.name, microphone.id, microphone.objId));
            }
        }
        else {
            this._vidyoCore.Controllers.DeviceController.SelectMicrophone();
        }
        this._useDefaultMicrophone = false;
    }
    SelectSpeaker({ speaker }) {
        let coreSpeaker = speaker ? new Speaker_1.Speaker(speaker.name, speaker.id, speaker.objId)
            : new Speaker_1.Speaker('', '', '');
        this._vidyoCore.Controllers.DeviceController.SelectSpeaker(coreSpeaker);
        this._useDefaultSpeaker = false;
    }
    SelectVideoContentShare({ localCamera }) {
        const videoContent = localCamera
            ? new Camera_1.Camera(localCamera.name, localCamera.id, localCamera.objId)
            : undefined;
        return this._vidyoCore.Controllers.DeviceController.SelectVideoContentShareDevice(videoContent);
    }
    SetAdvancedConfiguration(values) {
        if (typeof values.addLogCategory !== 'undefined') {
            this._vidyoCore.Controllers.LogController.SetLogLevelSDK(values.addLogCategory);
            this._vidyoCore.Controllers.AdvancedSettingsController.ShowLogCategory = values.addLogCategory;
        }
        if (typeof values.disableAudioEnergyMonitor !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.DisableAudioEnergyMonitor = values.disableAudioEnergyMonitor;
        }
        if (typeof values.disableDynamicAudioSources !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.DisableDynamicAudioSources = values.disableDynamicAudioSources;
        }
        if (typeof values.disableStats !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.DisableStats = values.disableStats;
        }
        if (typeof values.dynamicAudioSources !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.DynamicAudioSources = +values.dynamicAudioSources;
        }
        if (typeof values.enableAudioOnlyMode !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableAudioOnlyMode = values.enableAudioOnlyMode;
        }
        if (typeof values.enableCompositorFixedParticipants !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableCompositorFixedParticipants = values.enableCompositorFixedParticipants;
        }
        if (typeof values.enableScreenShareSimulcast !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableScreenShareSimulcast = values.enableScreenShareSimulcast;
        }
        if (typeof values.enableVideoSimulcast !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableVideoSimulcast = values.enableVideoSimulcast;
        }
        if (typeof values.enableTransportCc !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableTransportCc = values.enableTransportCc;
        }
        if (typeof values.loggerURL !== 'undefined' && values.loggerURL !== '') {
            this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL = values.loggerURL;
        }
        if (typeof values.participantLimit !== 'undefined') {
            if (+values.participantLimit >= 0) {
                this._vidyoCore.Controllers.AdvancedSettingsController.ParticipantLimit = +values.participantLimit;
            }
            else {
                this._vidyoCore.Controllers.LogController.LogWarning(() => `Ignore invalid participantLimit: ${values.participantLimit}`);
            }
        }
        if (typeof values.showStatisticsOverlay !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.ShowStatisticsOverlay = values.showStatisticsOverlay;
        }
        if (typeof values.enableSimpleAPILogging !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableSimpleAPILogging = values.enableSimpleAPILogging;
        }
        if (typeof values.enableVidyoConnectorAPILogging !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableVidyoConnectorAPILogging = values.enableVidyoConnectorAPILogging;
        }
        if (typeof values.extData !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.ExtData = values.extData;
        }
        if (typeof values.extDataType !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.ExtDataType = values.extDataType;
        }
        if (typeof values.enableAutoReconnect !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.EnableAutoReconnect = values.enableAutoReconnect;
        }
        if (typeof values.maxReconnectAttempts !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.MaxReconnectAttempts = +values.maxReconnectAttempts;
        }
        if (typeof values.reconnectBackoff !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.ReconnectBackoff = +values.reconnectBackoff;
        }
        if (typeof values.statisticsRefreshInterval !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.StatisticsRefreshInterval = +values.statisticsRefreshInterval;
        }
        if (typeof values.onAnalyticsEventSent === 'function' || values.onAnalyticsEventSent === null) {
            this._vidyoCore.Controllers.AdvancedSettingsController.OnAnalyticsEventSent = values.onAnalyticsEventSent;
        }
        if (typeof values.pinnedParticipantDisplayCropped !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.PinnedParticipantDisplayCropped = values.pinnedParticipantDisplayCropped;
        }
        if (typeof values.cameraContentHint !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.CameraContentHint = values.cameraContentHint;
        }
        if (typeof values.windowShareContentHint !== 'undefined') {
            this._vidyoCore.Controllers.AdvancedSettingsController.WindowShareContentHint = values.windowShareContentHint;
        }
    }
    SetOptions(options) {
        if (typeof options.pushLogs === 'object' && typeof options.pushLogs.enabled === 'boolean') {
            this._vidyoCore.Controllers.LogController.SetPushOptions(options.pushLogs);
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    SetCameraPrivacy(state) {
        if (state && typeof state.privacy === 'boolean') {
            return this._vidyoCore.Controllers.DeviceController.SetVideoMuteState(state.privacy);
        }
        return Promise.resolve(false);
    }
    SetConsoleLoggerFilter(options) {
        this._vidyoCore.Controllers.LogController.SetLogLevelSDK(options.consoleLogFilter);
    }
    SetFileLoggerFilter(options) {
        this.SetConsoleLoggerFilter({ consoleLogFilter: options.fileLogFilter });
    }
    SetLocation(location) {
        if (typeof location.latitude === 'number' && typeof location.longitude === 'number') {
            LocationProvider_1.LocationProvider.SetLocation(location);
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    SetMaxReceiveBitRate({ bitRate }) {
        this._vidyoCore.Controllers.TransmittedStreamController.MaxReceiveBandwidth = bitRate;
        return Promise.resolve(true);
    }
    SetMaxSendBitRate(options) {
        this._vidyoCore.Controllers.LocalStreamController.SetMaxSendBitRate(options.bitRate);
        return Promise.resolve(true);
    }
    SetMicrophonePrivacy(state) {
        if (state && typeof state.privacy === 'boolean') {
            return this._vidyoCore.Controllers.DeviceController.SetAudioMuteState(state.privacy);
        }
        return Promise.resolve(false);
    }
    SetMode() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SetPool(options) {
        this._vidyoCore.Controllers.ConnectionController.ReflectorsPoolName = options.name;
        return Promise.resolve(true);
    }
    SetPreview(options) {
        this._vidyoCore.Controllers.RendererController.SetPreview(options);
    }
    SetSpeakerPrivacy(state) {
        if (state && typeof state.privacy === 'boolean') {
            this._vidyoCore.Controllers.DeviceController.SetSpeakerMuteState(state.privacy);
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    SetViewAnimationSpeed({ viewId, speedPercentage }) {
        (0, NotImplemented_1.NotImplemented)();
    }
    SetViewBackgroundColor({ viewId, red, green, blue }) {
        (0, NotImplemented_1.NotImplemented)();
    }
    ShowAudioMeters(options) {
        return this._vidyoCore.Controllers.RendererController.ShowAudioMeters(options);
    }
    ShowPreview({ preview }) {
        this._vidyoCore.Controllers.RendererController.ShowLocalPreview = preview;
        return Promise.resolve(true);
    }
    ShowVideoTileControls(options) {
        return this._vidyoCore.Controllers.RendererController.ShowVideoTileControls(options);
    }
    ShowViewAt({ viewId, x, y, width, height }) {
        return this._vidyoCore.Controllers.RendererController.ShowViewAt({ viewId, width, height, x, y })
            .then(() => {
            const sourceId = this._vidyoCore.Controllers.RendererController.Views[viewId].sourceId;
            if (sourceId) {
                const participant = this._vidyoCore.Controllers.ParticipantController.GetParticipantBySsrc(sourceId);
                if (participant) {
                    this._vidyoCore.Controllers.ConferenceController.ActivateParticipantSource(participant, sourceId);
                }
            }
            return true;
        });
    }
    ShowViewLabel(options) {
        return this._vidyoCore.Controllers.RendererController.ShowViewLabel(options);
    }
    ShowWindowSharePreview(options) {
        this._vidyoCore.Controllers.RendererController.ShowLocalShare(options.preview);
    }
    StartDeviceDetection() {
        return this._vidyoCore.Controllers.DeviceController.StartDeviceDetection();
    }
    StartLocationDetection() {
        (0, NotImplemented_1.NotImplemented)();
    }
    StartShareDetection() {
        (0, NotImplemented_1.NotImplemented)();
    }
    StopDeviceDetection() {
        (0, NotImplemented_1.NotImplemented)();
    }
    StopLocationDetection() {
        (0, NotImplemented_1.NotImplemented)();
    }
    StopShareDetection() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterLocalCameraEventListener() {
        this._vidyoCore.Controllers.DeviceController.ClearLocalCameras();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalCameraEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLocalCameraStreamInterceptor() {
        return this._vidyoCore.Controllers.LocalStreamController.UnregisterLocalCameraStreamInterceptor();
    }
    UnregisterLocalMicrophoneEnergyListener() {
        return this._vidyoCore.Controllers.MicrophoneEnergyLevelController.UnregisterLocalMicrophoneEnergyListener();
    }
    UnregisterLocalMicrophoneEventListener() {
        this._vidyoCore.Controllers.DeviceController.ClearLocalMicrophones();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalMicrophoneEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLocalMonitorEventListener() {
        this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalMonitorRemoved);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalMonitorEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLocalRendererEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterLocalSpeakerEventListener() {
        this._vidyoCore.Controllers.DeviceController.ClearLocalSpeakers();
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalSpeakerEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLocalWindowShareEventListener() {
        this._vidyoCore.EventDispatcher.emit(StreamEvents.Events.LocalWindowShareRemoved);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLocalWindowShareEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLogEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoCustomLoggingEventListeners);
        return Promise.resolve(true);
    }
    UnregisterRemoteCameraEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRemoteCameraEventListeners);
        return Promise.resolve(true);
    }
    UnregisterRemoteMicrophoneEnergyListener() {
        return this._vidyoCore.Controllers.MicrophoneEnergyLevelController.UnregisterRemoteMicrophoneEnergyListener();
    }
    UnregisterRemoteMicrophoneEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRemoteMicrophoneEventListeners);
        return Promise.resolve(true);
    }
    UnregisterRemoteRendererEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterRemoteSpeakerEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRemoteSpeakerEventListeners);
        return Promise.resolve(true);
    }
    UnregisterRemoteWindowShareEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRemoteWindowShareEventListeners);
        return Promise.resolve(true);
    }
    UnregisterResourceManagerEventListener() {
        return this._vidyoCore.Controllers.ResourcesManager.UnregisterResourceManagerEventListener();
    }
    UnregisterVideoTileEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRenderVideoTileEventListener);
        return Promise.resolve(true);
    }
    _createEndpointID() {
        const endpointIDKey = 'VidyoCore::EndpointID';
        let endpointID = LocalStorageProvider_1.LocalStorageProvider.Get(endpointIDKey);
        if (!endpointID) {
            endpointID = UUID.v4();
            LocalStorageProvider_1.LocalStorageProvider.Set(endpointIDKey, endpointID);
        }
        return endpointID;
    }
    _onLocalCameraAdded(cameraPayload) {
        if (this._useDefaultCamera) {
            let camera = new Devices_1.Camera(this._vidyoCore, cameraPayload.camera);
            this._setDefaultCamera(camera);
            setTimeout(() => this._vidyoCore.Controllers.DeviceController.SelectDefaultCamera(), 0);
        }
    }
    _onLocalCameraRemoved(cameraPayload) {
        if (this._vidyoCore.Controllers.DeviceController.IsDefaultCamera(cameraPayload.camera)) {
            this._setDefaultCamera(null);
        }
    }
    _onLocalCameraUnplugged(cameraPayload) {
        const deviceController = this._vidyoCore.Controllers.DeviceController;
        this._onLocalCameraRemoved(cameraPayload);
        if (deviceController.IsCameraSelected() && deviceController.GetSelectedDevices().Camera['Id'] == cameraPayload.camera.Id) {
            deviceController.SelectDefaultCamera();
            this._useDefaultCamera = true;
        }
    }
    _onLocalMicrophoneAdded(microphonePayload) {
        if (this._useDefaultMicrophone) {
            let microphone = new Devices_1.Microphone(this._vidyoCore, microphonePayload.microphone);
            if (OperatingSystemInfoProvider_1.OperatingSystemInfoProvider.IsAndroid()) {
                let defaultMic = this._vidyoCore.Controllers.DeviceController.DefaultMicrophone;
                if (defaultMic === false || !microphonePayload.microphone.Name.toLowerCase().includes('earpiece')) {
                    this._setDefaultMicrophone(microphone);
                }
            }
            else {
                this._setDefaultMicrophone(microphone);
            }
            setTimeout(() => this._vidyoCore.Controllers.DeviceController.SelectDefaultMicrophone(), 0);
        }
    }
    _onLocalMicrophoneRemoved(microphonePayload) {
        if (this._vidyoCore.Controllers.DeviceController.IsDefaultMicrophone(microphonePayload.microphone)) {
            this._setDefaultMicrophone(null);
        }
    }
    _onLocalMicrophoneUnplugged(microphonePayload) {
        const deviceController = this._vidyoCore.Controllers.DeviceController;
        this._onLocalMicrophoneRemoved(microphonePayload);
        if (deviceController.IsMicrophoneSelected() && deviceController.GetSelectedDevices().Microphone['Id'] == microphonePayload.microphone.Id) {
            deviceController.SelectDefaultMicrophone();
            this._useDefaultMicrophone = true;
        }
    }
    _onLocalSpeakerAdded(speakerPayload) {
        const deviceController = this._vidyoCore.Controllers.DeviceController;
        if (this._useDefaultSpeaker && deviceController.GetSelectedDevices().Speaker['Id'] !== '') {
            let speaker = new Devices_1.Speaker(this._vidyoCore, speakerPayload.speaker);
            this._setDefaultSpeaker(speaker);
            setTimeout(() => this._vidyoCore.Controllers.DeviceController.SelectDefaultSpeaker(), 0);
        }
    }
    _onLocalSpeakerRemoved(speakerPayload) {
        if (this._vidyoCore.Controllers.DeviceController.IsDefaultSpeaker(speakerPayload.speaker)) {
            this._setDefaultSpeaker(null);
        }
    }
    _onLocalSpeakerUnplugged(speakerPayload) {
        const deviceController = this._vidyoCore.Controllers.DeviceController;
        this._onLocalSpeakerRemoved(speakerPayload);
        if (deviceController.IsSpeakerSelected() && deviceController.GetSelectedDevices().Speaker['Id'] == speakerPayload.speaker.Id) {
            deviceController.SelectDefaultSpeaker();
            this._useDefaultSpeaker = true;
        }
    }
    _registerLocalCameraPlugInOutManager() {
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraAdded, EventDispatcher_1.VidyoLocalCameraEventListeners, (cameraPayload) => {
            this._onLocalCameraAdded(cameraPayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraRemoved, EventDispatcher_1.VidyoLocalCameraEventListeners, (cameraPayload) => {
            this._onLocalCameraRemoved(cameraPayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.CameraUnplugged, EventDispatcher_1.VidyoLocalCameraEventListeners, (cameraPayload) => {
            this._onLocalCameraUnplugged(cameraPayload);
        });
    }
    _registerLocalMicrophonePlugInOutManager() {
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneAdded, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, (microphonePayload) => {
            this._onLocalMicrophoneAdded(microphonePayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneRemoved, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, (microphonePayload) => {
            this._onLocalMicrophoneRemoved(microphonePayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.MicrophoneUnplugged, EventDispatcher_1.VidyoLocalMicrophoneEventListeners, (microphonePayload) => {
            this._onLocalMicrophoneUnplugged(microphonePayload);
        });
    }
    _registerLocalSpeakerPlugInOutManager() {
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerAdded, EventDispatcher_1.VidyoLocalSpeakerEventListeners, (speakerPayload) => {
            this._onLocalSpeakerAdded(speakerPayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerRemoved, EventDispatcher_1.VidyoLocalSpeakerEventListeners, (speakerPayload) => {
            this._onLocalSpeakerRemoved(speakerPayload);
        });
        this._vidyoCore.EventDispatcher.on(DeviceEvents.Events.SpeakerUnplugged, EventDispatcher_1.VidyoLocalSpeakerEventListeners, (speakerPayload) => {
            this._onLocalSpeakerUnplugged(speakerPayload);
        });
    }
    _setDefaultCamera(camera) {
        this._vidyoCore.Controllers.DeviceController
            .SetDefaultCamera(camera !== null ? new Camera_1.Camera(camera.name, camera.id, camera.objId) : null);
    }
    _setDefaultMicrophone(microphone) {
        if (microphone !== null) {
            const microphoneList = this._vidyoCore.Controllers.DeviceController.GetMicrophoneList();
            const coreMicrophone = microphoneList.find((coreMicrophone) => coreMicrophone.Id === microphone.id);
            if (coreMicrophone) {
                this._vidyoCore.Controllers.DeviceController.SetDefaultMicrophone(coreMicrophone);
            }
            else {
                this._vidyoCore.Controllers.DeviceController.SetDefaultMicrophone(new Microphone_1.Microphone(microphone.name, microphone.id, microphone.objId));
            }
        }
        else {
            this._vidyoCore.Controllers.DeviceController.SetDefaultMicrophone(null);
        }
    }
    _setDefaultSpeaker(speaker) {
        this._vidyoCore.Controllers.DeviceController
            .SetDefaultSpeaker(speaker !== null ? new Speaker_1.Speaker(speaker.name, speaker.id, speaker.objId) : null);
    }
};
EndPoint = __decorate([
    JSValidation_1.default
], EndPoint);
exports.EndPoint = EndPoint;

}).call(this)}).call(this,"/src/vidyo_simple_api/EndPoint.ts")
},{"../core/controllers/AnalyticsController/AnalyticsController":33,"../core/events/AdvancedSettingsEvents":62,"../core/events/ConnectionEvents":66,"../core/events/DeviceEvents":67,"../core/events/EventDispatcher":68,"../core/events/LogEvents":69,"../core/events/RenderEvents":75,"../core/events/StreamEvents":79,"../core/models/APITypes":90,"../core/models/RendererTypes":96,"../core/models/device/Camera":101,"../core/models/device/Microphone":105,"../core/models/device/Speaker":106,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/JSValidation":145,"../core/utils/LocalStorageProvider":146,"../core/utils/LocationProvider":147,"../core/utils/NotImplemented":152,"../core/utils/OperatingSystemInfoProvider":154,"../core/utils/VidyoDebugger":170,"../vidyo_connector_api/VidyoConnector":181,"../vidyo_simple_api/Participant":188,"./Devices":184,"./Monitor":186,"./Origin":187,"./WindowShare":193,"./stats/Stats":216,"uuid":11}],186:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Monitor = void 0;
const UUID = require("uuid");
const Origin_1 = require("./Origin");
const BaseModel_1 = require("./BaseModel");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
class Monitor extends BaseModel_1.BaseModel {
    constructor(vidyoCore, name, origin = Origin_1.Origin.Local) {
        super(UUID.v4(), name, UUID.v4(), origin, 'Monitor');
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
    }
    GetId() { return this.id; }
    GetName() { return this.name; }
    GetPreviewLabel() {
        const label = this._vidyoCore.Controllers.DeviceController.GetMonitorSharePreviewLabel();
        return Promise.resolve(label);
    }
    SetFrameInterval(interval) { }
    SetPreviewLabel(options) {
        this._vidyoCore.Controllers.DeviceController.SetMonitorSharePreviewLabel(options.previewLabel);
        return Promise.resolve(true);
    }
}
exports.Monitor = Monitor;

}).call(this)}).call(this,"/src/vidyo_simple_api/Monitor.ts")
},{"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/VidyoDebugger":170,"./BaseModel":182,"./Origin":187,"uuid":11}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromCoreOrigin = exports.Origin = void 0;
const Participant_1 = require("../core/models/Participant");
var Origin;
(function (Origin) {
    Origin.Local = 'Local';
    Origin.Remote = 'Remote';
})(Origin = exports.Origin || (exports.Origin = {}));
function FromCoreOrigin(coreOrigin) {
    switch (coreOrigin) {
        case Participant_1.ParticipantOrigin.Local:
            return Origin.Local;
        case Participant_1.ParticipantOrigin.Remote:
            return Origin.Remote;
        default:
            console.log("unsupported coreOrigin");
            break;
    }
}
exports.FromCoreOrigin = FromCoreOrigin;

},{"../core/models/Participant":94}],188:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoParticipantHandState = exports.Participant = void 0;
const BaseModel_1 = require("./BaseModel");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
class Participant extends BaseModel_1.BaseModel {
    constructor(participant) {
        super(participant.Id, participant.Name, participant.ObjId, '', 'Participant');
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
        this.userId = participant.UserId;
        this.isLocal = participant.IsLocal;
        this.AppType = participant.AppType;
        this.trust = () => Promise.resolve(participant.Trust);
        this.isHidden = () => Promise.resolve(participant.IsHidden);
        this.isSelectable = () => Promise.resolve(participant.IsSelectable);
        this.isRecording = () => Promise.resolve(participant.IsRecording);
    }
    GetId() {
        return Promise.resolve(this.id);
    }
    GetName() {
        return Promise.resolve(this.name);
    }
    GetUserId() {
        return Promise.resolve(this.userId);
    }
    GetApplicationType() {
        return Promise.resolve(this.AppType);
    }
    GetTrust() {
        return this.trust();
    }
    IsLocal() {
        return Promise.resolve(this.isLocal);
    }
    IsHidden() {
        return this.isHidden();
    }
    IsRecording() {
        return this.isRecording();
    }
    IsSelectable() {
        return this.isSelectable();
    }
}
exports.Participant = Participant;
var VidyoParticipantHandState;
(function (VidyoParticipantHandState) {
    VidyoParticipantHandState["VIDYO_PARTICIPANTHANDSTATE_APPROVED"] = "VIDYO_PARTICIPANTHANDSTATE_APPROVED";
    VidyoParticipantHandState["VIDYO_PARTICIPANTHANDSTATE_DISMISSED"] = "VIDYO_PARTICIPANTHANDSTATE_DISMISSED";
    VidyoParticipantHandState["VIDYO_PARTICIPANTHANDSTATE_RAISED"] = "VIDYO_PARTICIPANTHANDSTATE_RAISED";
    VidyoParticipantHandState["VIDYO_PARTICIPANTHANDSTATE_UNRAISED"] = "VIDYO_PARTICIPANTHANDSTATE_UNRAISED";
})(VidyoParticipantHandState = exports.VidyoParticipantHandState || (exports.VidyoParticipantHandState = {}));

}).call(this)}).call(this,"/src/vidyo_simple_api/Participant.ts")
},{"../core/models/APITypes":90,"../core/utils/VidyoDebugger":170,"./BaseModel":182}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permission = exports.PermissionType = void 0;
const EventDispatcher_1 = require("../core/events/EventDispatcher");
const PermissionEvents = require("../core/events/PermissionEvents");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
var Permission_1 = require("../core/models/Permission");
Object.defineProperty(exports, "PermissionType", { enumerable: true, get: function () { return Permission_1.PermissionType; } });
class Permission {
    constructor(vidyoCore) {
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
    }
    RegisterPermissionEventListener({ onPermissionUpdated }) {
        this._vidyoCore.EventDispatcher.on(PermissionEvents.Events.PermissionUpdated, EventDispatcher_1.VidyoPermissionEventListeners, (payload) => onPermissionUpdated(payload.permission, payload.granted));
        this._vidyoCore.EventDispatcher.emit(PermissionEvents.Events.PermissionListenerRegistered);
        return Promise.resolve(true);
    }
    UnregisterPermissionEventListener() {
        this._vidyoCore.EventDispatcher.emit(PermissionEvents.Events.PermissionListenerUnregistered);
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoPermissionEventListeners);
        return Promise.resolve(true);
    }
}
exports.Permission = Permission;

},{"../core/events/EventDispatcher":68,"../core/events/PermissionEvents":74,"../core/models/Permission":95,"../core/utils/AssignHiddenPropertyValue":135}],190:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VidyoRoomConferenceMode = exports.VidyoRoomModerationType = exports.Room = void 0;
const ParticipantEvents = require("../core/events/ParticipantEvents");
const MessageEvents = require("../core/events/MessageEvents");
const ModerationEvents = require("../core/events/ModerationEvents");
const UUID = require("uuid");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
const EventDispatcher_1 = require("../core/events/EventDispatcher");
const RoomEvents_1 = require("../core/events/RoomEvents");
const StreamEvents_1 = require("../core/events/StreamEvents");
const NotImplemented_1 = require("../core/utils/NotImplemented");
const Participant_1 = require("../vidyo_simple_api/Participant");
const ChatMessage_1 = require("../vidyo_simple_api/ChatMessage");
const EventDispatcher_2 = require("../core/events/EventDispatcher");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const Constants_1 = require("../core/utils/Constants");
class Room {
    constructor(vidyoCore, coreRoom) {
        this.objType = 'VidyoRoom';
        this.objId = UUID.v4();
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_coreRoom', coreRoom);
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
    }
    get RoomDisplayName() {
        return this._coreRoom?.DisplayName;
    }
    get RoomIdNumber() {
        return this._coreRoom?.RoomId;
    }
    AcceptIncoming() {
        (0, NotImplemented_1.NotImplemented)();
    }
    Delete() {
        (0, NotImplemented_1.NotImplemented)();
    }
    DisableMedia() {
        (0, NotImplemented_1.NotImplemented)();
    }
    EnableMedia(onMediaEnabled, onMediaFailed, onMediaDisabled) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoEnableMediaRoomListeners);
        this._vidyoCore.EventDispatcher.once(StreamEvents_1.Events.MediaFailed, EventDispatcher_2.VidyoEnableMediaRoomListeners, function (payload) {
            onMediaFailed(payload.reason);
        });
        this._vidyoCore.EventDispatcher.once(StreamEvents_1.Events.MediaDisabled, EventDispatcher_2.VidyoEnableMediaRoomListeners, function (payload) {
            onMediaDisabled(payload.reason);
        });
        this._vidyoCore.EventDispatcher.once(StreamEvents_1.Events.MediaEnabled, EventDispatcher_2.VidyoEnableMediaRoomListeners, function (payload) {
            onMediaEnabled();
        });
        this._vidyoCore.Controllers.ConnectionController.StartMediaExchange();
        return Promise.resolve(true);
    }
    Enter(onEntered, onExited) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoEnterRoomListeners);
        this._vidyoCore.EventDispatcher.once(RoomEvents_1.Events.Entered, EventDispatcher_2.VidyoEnterRoomListeners, function (payload) {
            onEntered();
        });
        this._vidyoCore.EventDispatcher.once(RoomEvents_1.Events.Left, EventDispatcher_2.VidyoEnterRoomListeners, function (payload) {
            onExited();
        });
        this._vidyoCore.Controllers.RoomController.Enter(this._coreRoom);
        return Promise.resolve(true);
    }
    GetHistory() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetHistoryById() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetHistoryByTime() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetId() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetRoomProperties() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetType() {
        (0, NotImplemented_1.NotImplemented)();
    }
    Invite() {
        (0, NotImplemented_1.NotImplemented)();
    }
    InviteN() {
        (0, NotImplemented_1.NotImplemented)();
    }
    Leave() {
        this._vidyoCore.Controllers.RoomController.Leave(this._coreRoom);
        return true;
    }
    MessageSearch() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RaiseHand({ raiseHandResponse = () => { }, requestId }) {
        this._vidyoCore.EventDispatcher.once(ModerationEvents.Events.RaiseHandResponse, EventDispatcher_1.VidyoRaiseHandEventListeners, (payload) => {
            raiseHandResponse(payload.handState);
        });
        return this._vidyoCore.Controllers.ModerationController.RaiseHand();
    }
    RegisterConferenceModeEventListener({ conferenceModeChanged = () => { } }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoConferenceModeEventListeners);
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.ConferenceModeChanged, EventDispatcher_1.VidyoConferenceModeEventListeners, (payload) => {
            conferenceModeChanged(payload.mode);
        });
        return Promise.resolve(true);
    }
    RegisterLectureModeEventListener({ presenterChanged = () => { }, handRaised = () => { } }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLectureModeEventListeners);
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.PresenterChanged, EventDispatcher_1.VidyoLectureModeEventListeners, (payload) => {
            presenterChanged(payload.participant ? new Participant_1.Participant(payload.participant) : undefined);
        });
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.HandRaised, EventDispatcher_1.VidyoLectureModeEventListeners, (payload) => {
            handRaised(payload.participants.map((participant) => new Participant_1.Participant(participant)));
        });
        return Promise.resolve(true);
    }
    RegisterModerationCommandEventListener({ onModerationCommandReceived = () => { } }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoModerationEventListeners);
        this._vidyoCore.EventDispatcher.on(ModerationEvents.Events.OnModerationCommandReceived, EventDispatcher_1.VidyoModerationEventListeners, (payload) => {
            onModerationCommandReceived(payload.deviceType, payload.moderationType, payload.state);
        });
        return Promise.resolve(true);
    }
    RegisterMessageEventListener({ onMessageReceived, onMessageAcknowledged, onMessageRead, onMessageTypingIndication }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoMessageEventListeners);
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.OnMessage, EventDispatcher_2.VidyoMessageEventListeners, (payload) => {
            onMessageReceived(new Participant_1.Participant(payload.participant), new ChatMessage_1.ChatMessage(payload.message));
        });
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.OnMessageAcknowledged, EventDispatcher_2.VidyoMessageEventListeners, (payload) => {
            onMessageAcknowledged(new ChatMessage_1.ChatMessage(payload.message));
        });
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.OnMessageRead, EventDispatcher_2.VidyoMessageEventListeners, (payload) => {
            onMessageRead(new Participant_1.Participant(payload.participant), +payload.messageId);
        });
        this._vidyoCore.EventDispatcher.on(MessageEvents.Events.OnMessageChatState, EventDispatcher_2.VidyoMessageEventListeners, (payload) => {
            onMessageTypingIndication(new Participant_1.Participant(payload.participant), payload.state);
        });
        return Promise.resolve(true);
    }
    RegisterParticipantEventListener(onParticipantJoined, onParticipantLeft, onDynamicParticipantChanged, onLoudestParticipantChanged) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoRoomParticipantEventListeners);
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.ParticipantJoined, EventDispatcher_2.VidyoRoomParticipantEventListeners, (payload) => {
            onParticipantJoined(new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.ParticipantLeft, EventDispatcher_2.VidyoRoomParticipantEventListeners, (payload) => {
            onParticipantLeft(new Participant_1.Participant(payload.participant));
        });
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.DynamicParticipantChanged, EventDispatcher_2.VidyoRoomParticipantEventListeners, (payload) => {
            onDynamicParticipantChanged(payload.participants.map((p) => new Participant_1.Participant(p)));
        });
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.LoudestParticipantChanged, EventDispatcher_2.VidyoRoomParticipantEventListeners, (payload) => {
            onLoudestParticipantChanged(new Participant_1.Participant(payload.participant), undefined);
        });
        return Promise.resolve(true);
    }
    RegisterRecorderInCallEventListener(onRecorderInCallChanged) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoRoomRecorderInCallEventListeners);
        this._vidyoCore.EventDispatcher.on(ParticipantEvents.Events.RecorderInCallChanged, EventDispatcher_2.VidyoRoomRecorderInCallEventListeners, (payload) => {
            onRecorderInCallChanged(payload.hasRecorder, payload.isPaused, payload.isWebcasting);
        });
        return Promise.resolve(true);
    }
    RegisterResourceManagerEventListener(resourceManagerCallbacks) {
        return this._vidyoCore.Controllers.ResourcesManager.RegisterResourceManagerEventListener(resourceManagerCallbacks);
    }
    RegisterRoomPropertiesEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RegisterSubjectEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RegisterUnprocessedAudioEventListener({ onUnprocessedAudioSupportChanged, onUnprocessedAudioStarted }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoRoomUnprocessedAudioEventListeners);
        this._vidyoCore.EventDispatcher.on(RoomEvents_1.Events.UnprocessedAudioSupportChanged, EventDispatcher_2.VidyoRoomUnprocessedAudioEventListeners, (payload) => {
            onUnprocessedAudioSupportChanged(payload.supported);
        });
        this._vidyoCore.EventDispatcher.on(RoomEvents_1.Events.UnprocessedAudioStarted, EventDispatcher_2.VidyoRoomUnprocessedAudioEventListeners, (payload) => {
            onUnprocessedAudioStarted(payload.started);
        });
        return Promise.resolve(true);
    }
    RejectIncoming() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SendMessage({ message }) {
        const capped_message = message.substr(0, Constants_1.ChatMessageSizeLimit);
        const result = this._vidyoCore.Controllers.MessageController.SendMessage(capped_message);
        return Promise.resolve(result);
    }
    SendMessageAcknowledged({ messageId }) {
        return this._vidyoCore.Controllers.MessageController.SendMessageAcknowledged(messageId);
    }
    SendMessageTypingIndication({ typingIndication }) {
        return this._vidyoCore.Controllers.MessageController.SendMessageTypingIndication(typingIndication);
    }
    SendPrivateMessage({ participant, message }) {
        const coreParticipant = this._vidyoCore.Controllers.ParticipantController.TryGetParticipant(participant.id);
        if (!coreParticipant) {
            this._vidyoCore.Controllers.LogController.LogInfo(() => 'Could not find the participant');
            return Promise.resolve(false);
        }
        const capped_message = message.substr(0, Constants_1.ChatMessageSizeLimit);
        const result = this._vidyoCore.Controllers.MessageController.SendPrivateMessage(participant.id, capped_message);
        return Promise.resolve(result);
    }
    SetRoomProperties() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SetSubject() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnraiseHand({ requestId }) {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoRaiseHandEventListeners);
        return this._vidyoCore.Controllers.ModerationController.UnraiseHand();
    }
    UnregisterMessageEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoMessageEventListeners);
        return Promise.resolve(true);
    }
    UnregisterConferenceModeEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoConferenceModeEventListeners);
        return Promise.resolve(true);
    }
    UnregisterLectureModeEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoLectureModeEventListeners);
        return Promise.resolve(true);
    }
    UnregisterModerationCommandEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoModerationEventListeners);
        return Promise.resolve(true);
    }
    UnregisterParticipantEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoRoomParticipantEventListeners);
    }
    UnregisterResourceManagerEventListener() {
        return this._vidyoCore.Controllers.ResourcesManager.UnregisterResourceManagerEventListener();
    }
    UnregisterRoomPropertiesEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterSubjectEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RegisterRecoderInCallEventListener() {
        return Promise.resolve(true);
    }
    UnregisterRecoderInCallEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterUnprocessedAudioEventListener() {
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_2.VidyoRoomUnprocessedAudioEventListeners);
        return Promise.resolve(true);
    }
}
exports.Room = Room;
var VidyoRoomModerationType;
(function (VidyoRoomModerationType) {
    VidyoRoomModerationType["SoftMute"] = "VIDYO_ROOMMODERATIONTYPE_SoftMute";
    VidyoRoomModerationType["HardMute"] = "VIDYO_ROOMMODERATIONTYPE_HardMute";
})(VidyoRoomModerationType = exports.VidyoRoomModerationType || (exports.VidyoRoomModerationType = {}));
var VidyoRoomConferenceMode;
(function (VidyoRoomConferenceMode) {
    VidyoRoomConferenceMode["Lobby"] = "VIDYO_ROOMCONFERENCEMODE_LOBBY";
    VidyoRoomConferenceMode["Lecture"] = "VIDYO_ROOMCONFERENCEMODE_LECTURE";
    VidyoRoomConferenceMode["Group"] = "VIDYO_ROOMCONFERENCEMODE_GROUP";
})(VidyoRoomConferenceMode = exports.VidyoRoomConferenceMode || (exports.VidyoRoomConferenceMode = {}));

}).call(this)}).call(this,"/src/vidyo_simple_api/Room.ts")
},{"../core/events/EventDispatcher":68,"../core/events/MessageEvents":70,"../core/events/ModerationEvents":72,"../core/events/ParticipantEvents":73,"../core/events/RoomEvents":77,"../core/events/StreamEvents":79,"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/Constants":138,"../core/utils/NotImplemented":152,"../core/utils/VidyoDebugger":170,"../vidyo_simple_api/ChatMessage":183,"../vidyo_simple_api/Participant":188,"uuid":11}],191:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const ConnectionEvents = require("../core/events/ConnectionEvents");
const UUID = require("uuid");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
const RoomEvents_1 = require("../core/events/RoomEvents");
const NotImplemented_1 = require("../core/utils/NotImplemented");
const EventDispatcher_1 = require("../core/events/EventDispatcher");
const Stats_1 = require("./stats/Stats");
const VidyoConnector_1 = require("../vidyo_connector_api/VidyoConnector");
const ConnectionEvents_1 = require("../core/events/ConnectionEvents");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const Decorators_1 = require("../core/utils/Decorators");
class User {
    constructor(vidyoCore) {
        this.objType = 'VidyoUser';
        this._enableTCPTransport = true;
        this._enableUDPTransport = true;
        this.objId = UUID.v4();
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
    }
    AddRosterContact() {
        (0, NotImplemented_1.NotImplemented)();
    }
    CreateRoomFromId(resourceId, createToken, onRoomCreated) {
        this._vidyoCore.EventDispatcher.once(RoomEvents_1.Events.Created, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onRoomCreated(payload.room, payload.result, payload.token);
        });
        this._vidyoCore.Controllers.RoomController.CreateRoom({
            token: createToken,
            resourceId: resourceId
        });
        return Promise.resolve(true);
    }
    CreateRoomWithId(resourceId, createToken, onRoomCreated) {
        this._vidyoCore.EventDispatcher.once(RoomEvents_1.Events.Created, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onRoomCreated(payload.room, payload.result, payload.token);
        });
        this._vidyoCore.Controllers.RoomController.CreateRoom({
            token: createToken,
            isNewRoom: true,
            resourceId: resourceId
        });
        return true;
    }
    CreateTopicRoom(resourceId, description, createToken, onRoomCreated) {
        this._vidyoCore.EventDispatcher.once(RoomEvents_1.Events.Created, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onRoomCreated(payload.room, payload.result, payload.token);
        });
        this._vidyoCore.Controllers.RoomController.CreateRoom({
            token: createToken,
            isNewRoom: true,
            subject: description,
            resourceId: resourceId
        });
        return true;
    }
    GetContact() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetConversationRoom() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetId() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetRecentRooms() {
        (0, NotImplemented_1.NotImplemented)();
    }
    GetStats() {
        let userStatistic = this._vidyoCore.Controllers.StatisticsController.GetUserStatistics();
        let userStats = new Stats_1.UserStats(userStatistic);
        return userStats;
    }
    Login(username, password, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials) {
        return true;
    }
    LoginAsGuest(displayName, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials) {
        return true;
    }
    LoginWithAccessToken(accessToken, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials) {
        return this.LoginWithTenantToken(accessToken, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials);
    }
    LoginWithRefreshToken(refreshToken, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials) {
        return this.LoginWithTenantToken(refreshToken, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials);
    }
    LoginWithTenantToken(provisionToken, host, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged, onTokenReceived, onGetWebProxyCredentials) {
        return Promise.resolve(true);
    }
    LoginAsGuestWithRoomKey(roomKey, displayName, host, roomPin, port, serviceType, onLoginComplete, onLoggedOut, onConnectionStatusChanged) {
        if (serviceType != "hunter") {
            return Promise.reject(VidyoConnector_1.VidyoConnectorFailReason.NotSupported);
        }
        this._vidyoCore.EventDispatcher.releaseGroup(EventDispatcher_1.VidyoUserListeners);
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Connected, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onLoginComplete(payload.result, payload.isSecure);
        });
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.Disconnected, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onLoggedOut(payload);
        });
        this._vidyoCore.EventDispatcher.on(ConnectionEvents.Events.ConnectionStatusChanged, EventDispatcher_1.VidyoUserListeners, function (payload) {
            onConnectionStatusChanged(payload.reason);
        });
        return this._vidyoCore.Controllers.ConnectionController.CreateHunterConnection({
            roomKey: roomKey,
            displayName: displayName,
            host: host,
            roomPin: roomPin,
            port: port,
            serviceType: serviceType,
            enableTCPTransport: this._enableTCPTransport,
            enableUDPTransport: this._enableUDPTransport
        }).then(() => {
            this._vidyoCore.Controllers.ConnectionController.Connect();
        }).catch((error) => {
            if (error === VidyoConnector_1.VidyoConnectorFailReason.InvalidDisplayNameLength) {
                this._vidyoCore.Controllers.LogController.LogError(() => 'Display Name is too long');
            }
            return Promise.reject(error);
        });
    }
    Logout() {
        this._vidyoCore.Controllers.ConnectionController.Disconnect(ConnectionEvents_1.ConnectionEventsInfo.Disconnecting);
        return true;
    }
    RegisterContactEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RegisterRoomEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    RemoveRosterContact() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchConversationRooms() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchRooms() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchRoomsWithName() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchRoomsWithOwner() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchRoomsWithSubject() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchTopicRooms() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SearchUsers() {
        (0, NotImplemented_1.NotImplemented)();
    }
    SetDisplayName({ displayName }) {
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_displayName', displayName);
    }
    SetTCPTransport(param) {
        this._enableTCPTransport = param.enable;
        return Promise.resolve(true);
    }
    SetUDPTransport(param) {
        this._enableUDPTransport = param.enable;
        return Promise.resolve(true);
    }
    SetWebProxyAddressCredentials() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterCallEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterContactEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterLicenseEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UnregisterRoomEventListener() {
        (0, NotImplemented_1.NotImplemented)();
    }
    UpdatePresence() {
        (0, NotImplemented_1.NotImplemented)();
    }
}
__decorate([
    Decorators_1.notImplemented
], User.prototype, "Login", null);
__decorate([
    Decorators_1.notImplemented
], User.prototype, "LoginAsGuest", null);
__decorate([
    Decorators_1.notImplemented
], User.prototype, "LoginWithTenantToken", null);
exports.User = User;

}).call(this)}).call(this,"/src/vidyo_simple_api/User.ts")
},{"../core/events/ConnectionEvents":66,"../core/events/EventDispatcher":68,"../core/events/RoomEvents":77,"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/Decorators":139,"../core/utils/NotImplemented":152,"../core/utils/VidyoDebugger":170,"../vidyo_connector_api/VidyoConnector":181,"./stats/Stats":216,"uuid":11}],192:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Property = exports.VidyoEndpoint = exports.VidyoPermissionType = exports.VidyoPermision = exports.VidyoParticipant = exports.VidyoUser = exports.VidyoRoom = exports.VidyoChatMessage = exports.VidyoDeviceState = exports.VidyoRemoteWindowShare = exports.VidyoRemoteSpeaker = exports.VidyoRemoteMicrophone = exports.VidyoRemoteCamera = exports.VidyoSpeaker = exports.VidyoMicrophone = exports.VidyoCamera = exports.VidyoSimple = void 0;
const UUID = require("uuid");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
const LogEvents_1 = require("../core/events/LogEvents");
const VidyoCore_1 = require("../core/VidyoCore");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const LogController_1 = require("../core/controllers/LogController/LogController");
class VidyoSimple {
    constructor() {
        this.objType = 'VidyoSimple';
        this.objId = UUID.v4();
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', new VidyoCore_1.VidyoCore());
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
    }
    get EventDispatcher() {
        return this._vidyoCore.EventDispatcher;
    }
    CreateVidyoEndpoint(viewId, viewStyle, remoteParticipants, consoleLogFilter, fileLogFilter, fileLogName) {
        return this._vidyoCore.CreateEndpoint(viewId, viewStyle, remoteParticipants, consoleLogFilter, fileLogFilter, fileLogName);
    }
    CreateVidyoPermission() {
        return this._vidyoCore.CreatePermission();
    }
    CreateVidyoUser(endPoint) {
        return this._vidyoCore.CreateUser(endPoint);
    }
    Disable() {
        return this._vidyoCore.Disable();
    }
    Initialize() {
        return this._vidyoCore.Initialize().then(() => {
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.fatal, (logRecord) => {
                console.error('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : '#dd0000'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.error, (logRecord) => {
                console.error('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : '#dd0000'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.warning, (logRecord) => {
                console.warn('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : '#774400'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.info, (logRecord) => {
                console.log('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : 'black'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.debug, (logRecord) => {
                console.debug('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : '#202020'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.sent, (logRecord) => {
                console.debug('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : 'darkgreen'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.received, (logRecord) => {
                console.debug('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : 'darkblue'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.enter, (logRecord) => {
                console.log('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : 'darkslateblue'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventsSDK.leave, (logRecord) => {
                console.log('%c' + LogController_1.LogRecord.toLogString(logRecord), 'color: ' + (logRecord.categoryName === LogEvents_1.VidyoLogCategory.VidyoDevelopment ? 'darkviolet' : 'darkmagenta'));
            });
            this._vidyoCore.EventDispatcher.on(LogEvents_1.LogEventDebug, (logRecord) => {
                if (this._vidyoCore && this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL
                    && this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL !== '') {
                    try {
                        const response = fetch(this._vidyoCore.Controllers.AdvancedSettingsController.LoggerURL, {
                            method: 'post',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(logRecord)
                        });
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            });
            return true;
        });
    }
}
exports.VidyoSimple = VidyoSimple;
var Devices_1 = require("./Devices");
Object.defineProperty(exports, "VidyoCamera", { enumerable: true, get: function () { return Devices_1.Camera; } });
Object.defineProperty(exports, "VidyoMicrophone", { enumerable: true, get: function () { return Devices_1.Microphone; } });
Object.defineProperty(exports, "VidyoSpeaker", { enumerable: true, get: function () { return Devices_1.Speaker; } });
Object.defineProperty(exports, "VidyoRemoteCamera", { enumerable: true, get: function () { return Devices_1.RemoteCamera; } });
Object.defineProperty(exports, "VidyoRemoteMicrophone", { enumerable: true, get: function () { return Devices_1.RemoteMicrophone; } });
Object.defineProperty(exports, "VidyoRemoteSpeaker", { enumerable: true, get: function () { return Devices_1.RemoteSpeaker; } });
Object.defineProperty(exports, "VidyoRemoteWindowShare", { enumerable: true, get: function () { return Devices_1.RemoteWindowShare; } });
Object.defineProperty(exports, "VidyoDeviceState", { enumerable: true, get: function () { return Devices_1.VidyoDeviceState; } });
var ChatMessage_1 = require("./ChatMessage");
Object.defineProperty(exports, "VidyoChatMessage", { enumerable: true, get: function () { return ChatMessage_1.ChatMessage; } });
var Room_1 = require("./Room");
Object.defineProperty(exports, "VidyoRoom", { enumerable: true, get: function () { return Room_1.Room; } });
var User_1 = require("./User");
Object.defineProperty(exports, "VidyoUser", { enumerable: true, get: function () { return User_1.User; } });
var Participant_1 = require("./Participant");
Object.defineProperty(exports, "VidyoParticipant", { enumerable: true, get: function () { return Participant_1.Participant; } });
var Permission_1 = require("./Permission");
Object.defineProperty(exports, "VidyoPermision", { enumerable: true, get: function () { return Permission_1.Permission; } });
Object.defineProperty(exports, "VidyoPermissionType", { enumerable: true, get: function () { return Permission_1.PermissionType; } });
var EndPoint_1 = require("./EndPoint");
Object.defineProperty(exports, "VidyoEndpoint", { enumerable: true, get: function () { return EndPoint_1.EndPoint; } });
class Property {
}
exports.Property = Property;

}).call(this)}).call(this,"/src/vidyo_simple_api/VidyoSimple.ts")
},{"../core/VidyoCore":31,"../core/controllers/LogController/LogController":44,"../core/events/LogEvents":69,"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/VidyoDebugger":170,"./ChatMessage":183,"./Devices":184,"./EndPoint":185,"./Participant":188,"./Permission":189,"./Room":190,"./User":191,"uuid":11}],193:[function(require,module,exports){
(function (__filename){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowShare = void 0;
const UUID = require("uuid");
const Origin_1 = require("./Origin");
const BaseModel_1 = require("./BaseModel");
const VidyoDebugger_1 = require("../core/utils/VidyoDebugger");
const APITypes_1 = require("../core/models/APITypes");
const AssignHiddenPropertyValue_1 = require("../core/utils/AssignHiddenPropertyValue");
class WindowShare extends BaseModel_1.BaseModel {
    constructor(vidyoCore, name, origin = Origin_1.Origin.Local, applicationName, processId) {
        super(UUID.v4(), name, UUID.v4(), origin, 'WindowShare');
        this.applicationName = applicationName;
        this.processId = processId;
        VidyoDebugger_1.VidyoDebugger.Debug(this, APITypes_1.API.Simple, __filename);
        (0, AssignHiddenPropertyValue_1.AssignHiddenPropertyValue)(this, '_vidyoCore', vidyoCore);
    }
    GetApplicationName() { return this.applicationName; }
    GetId() { return this.id; }
    GetName() { return this.name; }
    GetPreviewLabel() {
        const label = this._vidyoCore.Controllers.DeviceController.GetWindowSharePreviewLabel();
        return Promise.resolve(label);
    }
    GetProcessId() { return this.processId; }
    IsApplicationNameSet() { return !!this.applicationName; }
    IsNameSet() { return !!this.name; }
    SetFrameInterval(interval) { }
    SetPreviewLabel(options) {
        this._vidyoCore.Controllers.DeviceController.SetWindowSharePreviewLabel(options.previewLabel);
        return Promise.resolve(true);
    }
}
exports.WindowShare = WindowShare;

}).call(this)}).call(this,"/src/vidyo_simple_api/WindowShare.ts")
},{"../core/models/APITypes":90,"../core/utils/AssignHiddenPropertyValue":135,"../core/utils/VidyoDebugger":170,"./BaseModel":182,"./Origin":187,"uuid":11}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BandwidthSummaryStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class BandwidthSummaryStats {
    constructor(coreBSStatistics = new Statistics_1.BandwidthSummaryStatistics()) {
        this.actualEncoderBitRate = coreBSStatistics.ActualEncoderBitRate;
        this.availableBandwidth = coreBSStatistics.AvailableBandwidth;
        this.leakyBucketDelay = coreBSStatistics.LeakyBucketDelay;
        this.retransmitBitRate = coreBSStatistics.RetransmitBitRate;
        this.targetEncoderBitRate = coreBSStatistics.TargetEncoderBitRate;
        this.totalTransmitBitRate = coreBSStatistics.TotalTransmitBitRate;
    }
}
exports.BandwidthSummaryStats = BandwidthSummaryStats;

},{"../../core/models/statistics/Statistics":131}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class EndpointStats {
    constructor(coreEndpointStatistics = new Statistics_1.EndpointStatistics()) {
        this.applicationTag = coreEndpointStatistics.ApplicationTag;
        this.buildTag = coreEndpointStatistics.BuildTag;
        this.bytesReceivedTcp = coreEndpointStatistics.BytesReceivedTcp;
        this.bytesReceivedUdp = coreEndpointStatistics.BytesReceivedUdp;
        this.bytesSentTcp = coreEndpointStatistics.BytesSentTcp;
        this.bytesSentUdp = coreEndpointStatistics.BytesSentUdp;
        this.connectTime = coreEndpointStatistics.ConnectTime;
        this.id = coreEndpointStatistics.Id;
        this.libraryVersion = coreEndpointStatistics.LibraryVersion;
        this.localCameraStats = coreEndpointStatistics.LocalCameraStats
            .map((obj) => new Stats_1.LocalVideoSourceStats(obj));
        this.localMicrophoneStats = coreEndpointStatistics.LocalMicrophoneStats
            .map((obj) => new Stats_1.LocalMicrophoneStats(obj));
        this.localMonitorStats = coreEndpointStatistics.LocalMonitorStats
            .map((obj) => new Stats_1.LocalVideoSourceStats(obj));
        this.localRendererStats = coreEndpointStatistics.LocalRendererStats
            .map((obj) => new Stats_1.LocalRendererStats(obj));
        this.localSpeakerStats = coreEndpointStatistics.LocalSpeakerStats
            .map((obj) => new Stats_1.LocalSpeakerStats(obj));
        this.localWindowShareStats = coreEndpointStatistics.LocalWindowShareStats
            .map((obj) => new Stats_1.LocalVideoSourceStats(obj));
        this.loginTimeConsumedMs = coreEndpointStatistics.LoginTimeConsumedMs;
        this.logStats = new Stats_1.LogStats(coreEndpointStatistics.LogStats);
        this.maxBitRate = coreEndpointStatistics.MaxBitRate;
        this.maxEncodePixelRateInitial = coreEndpointStatistics.MaxEncodePixelRateInitial;
        this.mediaEnableTimeConsumedMs = coreEndpointStatistics.MediaEnableTimeConsumedMs;
        this.mediaRouteAcquireTimeConsumedMs = coreEndpointStatistics.MediaRouteAcquireTimeConsumedMs;
        this.networkInterfaceStats = coreEndpointStatistics.NetworkInterfaceStats
            .map((obj) => new Stats_1.NetworkInterfaceStats(obj));
        this.osName = coreEndpointStatistics.OsName;
        this.osVersion = coreEndpointStatistics.OsVersion;
        this.processorBrand = coreEndpointStatistics.ProcessorBrand;
        this.processorLogicalCores = coreEndpointStatistics.ProcessorLogicalCores;
        this.processorModel = coreEndpointStatistics.ProcessorModel;
        this.processorPhysicalCores = coreEndpointStatistics.ProcessorPhysicalCores;
        this.processorSpeed = coreEndpointStatistics.ProcessorSpeed;
        this.roomEnterTimeConsumedMs = coreEndpointStatistics.RoomEnterTimeConsumedMs;
        this.timeStamp = coreEndpointStatistics.TimeStamp;
        this.userAgent = coreEndpointStatistics.UserAgent;
        this.userStats = coreEndpointStatistics.UserStats
            .map((obj) => new Stats_1.UserStats(obj));
    }
}
exports.EndpointStats = EndpointStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestDataStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LatencyTestDataStats {
    constructor(coreLatencyTestDataStatistics = new Statistics_1.LatencyTestDataStatistics()) {
        this.address = coreLatencyTestDataStatistics.Address;
        this.latencyMs = coreLatencyTestDataStatistics.LatencyMs;
        this.latitude = coreLatencyTestDataStatistics.Latitude;
        this.longitude = coreLatencyTestDataStatistics.Longitude;
        this.name = coreLatencyTestDataStatistics.Name;
        this.responseReceived = coreLatencyTestDataStatistics.ResponseReceived;
    }
}
exports.LatencyTestDataStats = LatencyTestDataStats;

},{"../../core/models/statistics/Statistics":131}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class LatencyTestStats {
    constructor(coreLatencyTestStats = new Statistics_1.LatencyTestStatistics()) {
        this.latencyTestDataStats = coreLatencyTestStats.LatencyTestDataStats
            .map((obj) => new Stats_1.LatencyTestDataStats(obj));
    }
}
exports.LatencyTestStats = LatencyTestStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalMicrophoneStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class LocalMicrophoneStats {
    constructor(coreLMStatistics = new Statistics_1.LocalMicrophoneStatistics()) {
        this.aecEchoCoupling = coreLMStatistics.AecEchoCoupling;
        this.agcAverageGain = coreLMStatistics.AgcAverageGain;
        this.bitsPerSample = coreLMStatistics.BitsPerSample;
        this.format = coreLMStatistics.Format;
        this.id = coreLMStatistics.Id;
        this.localSpeakerStreams = coreLMStatistics.LocalSpeakerStreams
            .map((obj) => new Stats_1.LocalSpeakerStreamStats(obj));
        this.name = coreLMStatistics.Name;
        this.noiseSuppressionSnr = coreLMStatistics.NoiseSuppressionSnr;
        this.numberOfChannels = coreLMStatistics.NumberOfChannels;
        this.remoteSpeakerStreams = coreLMStatistics.RemoteSpeakerStreams
            .map((obj) => new Stats_1.RemoteSpeakerStreamStats(obj));
        this.sampleRateMeasured = coreLMStatistics.SampleRateMeasured;
        this.sampleRateSet = coreLMStatistics.SampleRateSet;
    }
}
exports.LocalMicrophoneStats = LocalMicrophoneStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalRendererStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LocalRendererStats {
    constructor(coreLRStatistics = new Statistics_1.LocalRendererStatistics()) {
        this.format = coreLRStatistics.Format;
        this.frameIntervalMeasured = coreLRStatistics.FrameIntervalMeasured;
        this.frameIntervalSet = coreLRStatistics.FrameIntervalSet;
        this.height = coreLRStatistics.Height;
        this.id = coreLRStatistics.Id;
        this.name = coreLRStatistics.Name;
        this.totalFrames = coreLRStatistics.TotalFrames;
        this.totalPixels = coreLRStatistics.TotalPixels;
        this.width = coreLRStatistics.Width;
    }
}
exports.LocalRendererStats = LocalRendererStats;

},{"../../core/models/statistics/Statistics":131}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalRendererStreamStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LocalRendererStreamStats {
    constructor(coreLRSStatistics = new Statistics_1.LocalRendererStreamStatistics()) {
        this.bufferDropped = coreLRSStatistics.BufferDropped;
        this.bufferSize = coreLRSStatistics.BufferSize;
        this.height = coreLRSStatistics.Height;
        this.id = coreLRSStatistics.Id;
        this.name = coreLRSStatistics.Name;
        this.width = coreLRSStatistics.Width;
    }
}
exports.LocalRendererStreamStats = LocalRendererStreamStats;

},{"../../core/models/statistics/Statistics":131}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSpeakerStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LocalSpeakerStats {
    constructor(coreLSStatistics = new Statistics_1.LocalSpeakerStatistics()) {
        this.bitsPerSample = coreLSStatistics.BitsPerSample;
        this.format = coreLSStatistics.Format;
        this.id = coreLSStatistics.Id;
        this.name = coreLSStatistics.Name;
        this.numberOfChannels = coreLSStatistics.NumberOfChannels;
        this.sampleRateMeasured = coreLSStatistics.SampleRateMeasured;
        this.sampleRateSet = coreLSStatistics.SampleRateSet;
    }
}
exports.LocalSpeakerStats = LocalSpeakerStats;

},{"../../core/models/statistics/Statistics":131}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSpeakerStreamStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LocalSpeakerStreamStats {
    constructor(coreLSStatistics = new Statistics_1.LocalSpeakerStreamStatistics()) {
        this.bitsPerSample = coreLSStatistics.BitsPerSample;
        this.delay = coreLSStatistics.Delay;
        this.format = coreLSStatistics.Format;
        this.highestThreshold = coreLSStatistics.HighestThreshold;
        this.highThreshold = coreLSStatistics.HighThreshold;
        this.isActive = coreLSStatistics.IsActive;
        this.lastEnergy = coreLSStatistics.LastEnergy;
        this.lastPlayed = coreLSStatistics.LastPlayed;
        this.lowestThreshold = coreLSStatistics.LowestThreshold;
        this.lowThreshold = coreLSStatistics.LowThreshold;
        this.maxThreshold = coreLSStatistics.MaxThreshold;
        this.name = coreLSStatistics.Name;
        this.numberOfChannels = coreLSStatistics.NumberOfChannels;
        this.overrun = coreLSStatistics.Overrun;
        this.played = coreLSStatistics.Played;
        this.sampleRate = coreLSStatistics.SampleRate;
        this.underrun = coreLSStatistics.Underrun;
    }
}
exports.LocalSpeakerStreamStats = LocalSpeakerStreamStats;

},{"../../core/models/statistics/Statistics":131}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalVideoSourceStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class LocalVideoSourceStats {
    constructor(coreLVSStatistics = new Statistics_1.LocalVideoSourceStatistics()) {
        this.format = '';
        this.qualityLimitationReason = '';
        this.runnels = [];
        this.format = coreLVSStatistics.Format;
        this.frameIntervalMeasured = coreLVSStatistics.FrameIntervalMeasured;
        this.frameIntervalSet = coreLVSStatistics.FrameIntervalSet;
        this.height = coreLVSStatistics.Height;
        this.id = coreLVSStatistics.Id;
        this.localRendererStreams = coreLVSStatistics.LocalRendererStreams
            .map((obj) => new Stats_1.LocalRendererStreamStats(obj));
        this.name = coreLVSStatistics.Name;
        this.qualityLimitationReason = coreLVSStatistics.QualityLimitationReason;
        this.remoteRendererStreams = coreLVSStatistics.RemoteRendererStreams
            .map((obj) => new Stats_1.RemoteRendererStreamStats(obj));
        this.runnels = coreLVSStatistics.Runnels.map((obj) => ({ ...obj }));
        this.totalFrames = coreLVSStatistics.TotalFrames;
        this.width = coreLVSStatistics.Width;
    }
}
exports.LocalVideoSourceStats = LocalVideoSourceStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogDataStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class LogDataStats {
    constructor(coreLogDataStatistics = new Statistics_1.LogDataStatistics()) {
        this.name = '';
        this.occurances = 0;
        this.name = coreLogDataStatistics.Name;
        this.occurances = coreLogDataStatistics.Occurances;
    }
}
exports.LogDataStats = LogDataStats;

},{"../../core/models/statistics/Statistics":131}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class LogStats {
    constructor(coreLogStatistics = new Statistics_1.LogStatistics()) {
        this.logErrorDataStats = coreLogStatistics.LogErrorDataStats
            .map((obj) => new Stats_1.LogDataStats(obj));
        this.logWarningDataStats = coreLogStatistics.LogWarningDataStats
            .map((obj) => new Stats_1.LogDataStats(obj));
    }
}
exports.LogStats = LogStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaConnectionTransportInfo = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class MediaConnectionTransportInfo {
    constructor(coreMCTInfo = new Statistics_1.MediaConnectionTransportInformation()) {
        this.addressType = coreMCTInfo.AddressType;
        this.componentType = coreMCTInfo.ComponentType;
        this.connectionId = coreMCTInfo.ConnectionId;
        this.connectionType = coreMCTInfo.ConnectionType;
        this.externalLocalAddr = coreMCTInfo.ExternalLocalAddr;
        this.externalRemoteAddr = coreMCTInfo.ExternalRemoteAddr;
        this.interfaceName = coreMCTInfo.InterfaceName;
        this.interfaceType = coreMCTInfo.InterfaceType;
        this.internalLocalAddr = coreMCTInfo.InternalLocalAddr;
        this.internalRemoteAddr = coreMCTInfo.InternalRemoteAddr;
        this.totalRoundTripTime = coreMCTInfo.TotalRoundTripTime;
        this.transportPlugIn = coreMCTInfo.TransportPlugIn;
    }
}
exports.MediaConnectionTransportInfo = MediaConnectionTransportInfo;

},{"../../core/models/statistics/Statistics":131}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkInterfaceStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class NetworkInterfaceStats {
    constructor(coreNIStatistics = new Statistics_1.NetworkInterfaceStatistics()) {
        this.isUp = coreNIStatistics.IsUp;
        this.name = coreNIStatistics.Name;
        this.type = coreNIStatistics.Type;
    }
}
exports.NetworkInterfaceStats = NetworkInterfaceStats;

},{"../../core/models/statistics/Statistics":131}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticipantGenerationStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class ParticipantGenerationStats {
    constructor(corePGStatistics = new Statistics_1.ParticipantGenerationStatistics()) {
        this.id = '';
        this.name = '';
        this.cameraId = corePGStatistics.CameraId;
        this.cameraName = corePGStatistics.CameraName;
        this.enabled = corePGStatistics.Enabled;
        this.frameInterval = corePGStatistics.FrameInterval;
        this.height = corePGStatistics.Height;
        this.id = corePGStatistics.Id;
        this.name = corePGStatistics.Name;
        this.pixelRate = corePGStatistics.PixelRate;
        this.width = corePGStatistics.Width;
    }
}
exports.ParticipantGenerationStats = ParticipantGenerationStats;

},{"../../core/models/statistics/Statistics":131}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticipantStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class ParticipantStats {
    constructor(corePStatistics = new Statistics_1.ParticipantStatistic()) {
        this.id = corePStatistics.Id;
        this.name = corePStatistics.Name;
        this.remoteCameraStats = corePStatistics.RemoteCameraStats
            .map((obj) => new Stats_1.RemoteVideoSourceStats(obj));
        this.remoteMicrophoneStats = corePStatistics.RemoteMicrophoneStats
            .map((obj) => new Stats_1.RemoteMicrophoneStats(obj));
        this.remoteWindowShareStats = corePStatistics.RemoteWindowShareStats
            .map((obj) => new Stats_1.RemoteVideoSourceStats(obj));
        this.userId = corePStatistics.UserId;
    }
}
exports.ParticipantStats = ParticipantStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateShaperStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class RateShaperStats {
    constructor(coreRSStatistics = new Statistics_1.RateShaperStatistics()) {
        this.delayNormal = coreRSStatistics.DelayNormal;
        this.delayRetransmit = coreRSStatistics.DelayRetransmit;
        this.dropNormal = coreRSStatistics.DropNormal;
        this.packetsNormal = coreRSStatistics.PacketsNormal;
        this.packetsRetransmit = coreRSStatistics.PacketsRetransmit;
    }
}
exports.RateShaperStats = RateShaperStats;

},{"../../core/models/statistics/Statistics":131}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteMicrophoneStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class RemoteMicrophoneStats {
    constructor(coreRMStatistics = new Statistics_1.RemoteMicrophoneStatistics()) {
        this.bitsPerSample = coreRMStatistics.BitsPerSample;
        this.codecDtx = coreRMStatistics.CodecDtx;
        this.codecName = coreRMStatistics.CodecName;
        this.codecQualitySetting = coreRMStatistics.CodecQualitySetting;
        this.id = coreRMStatistics.Id;
        this.lastFrameMs = coreRMStatistics.LastFrameMs;
        this.localSpeakerStreams = coreRMStatistics.LocalSpeakerStreams
            .map((obj) => new Stats_1.LocalSpeakerStreamStats(obj));
        this.name = coreRMStatistics.Name;
        this.numberOfChannels = coreRMStatistics.NumberOfChannels;
        this.receiveNetworkBitRate = coreRMStatistics.ReceiveNetworkBitRate;
        this.receiveNetworkDelay = coreRMStatistics.ReceiveNetworkDelay;
        this.receiveNetworkDroppedPackets = coreRMStatistics.ReceiveNetworkDroppedPackets;
        this.receiveNetworkJitter = coreRMStatistics.ReceiveNetworkJitter;
        this.receiveNetworkPacketsConcealed = coreRMStatistics.ReceiveNetworkPacketsConcealed;
        this.receiveNetworkPacketsLost = coreRMStatistics.ReceiveNetworkPacketsLost;
        this.sampleRateMeasured = coreRMStatistics.SampleRateMeasured;
        this.sampleRateSet = coreRMStatistics.SampleRateSet;
    }
}
exports.RemoteMicrophoneStats = RemoteMicrophoneStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteRendererStreamStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class RemoteRendererStreamStats {
    constructor(coreRRSStatistics = new Statistics_1.RemoteRendererStreamStatistics()) {
        this.bitRateRequested = coreRRSStatistics.BitRateRequested;
        this.codecFir = coreRRSStatistics.CodecFir;
        this.codecIFrames = coreRRSStatistics.CodecIFrames;
        this.codecLayers = coreRRSStatistics.CodecLayers;
        this.codecNacks = coreRRSStatistics.CodecNacks;
        this.codecName = coreRRSStatistics.CodecName;
        this.codecPli = coreRRSStatistics.PlisReceived;
        this.fps = coreRRSStatistics.Fps;
        this.fpsRequested = coreRRSStatistics.FpsRequested;
        this.fpsInput = coreRRSStatistics.FpsInput;
        this.fpsSent = coreRRSStatistics.FpsSent;
        this.framesDropped = coreRRSStatistics.FramesDropped;
        this.height = coreRRSStatistics.Height;
        this.heightRequested = coreRRSStatistics.HeightRequested;
        this.lastHeight = coreRRSStatistics.LastHeight;
        this.lastWidth = coreRRSStatistics.LastWidth;
        this.name = coreRRSStatistics.Name;
        this.sendNetworkBitRate = coreRRSStatistics.SendNetworkBitRate;
        this.sendNetworkRtt = coreRRSStatistics.SendNetworkRtt;
        this.width = coreRRSStatistics.Width;
        this.widthRequested = coreRRSStatistics.WidthRequested;
    }
}
exports.RemoteRendererStreamStats = RemoteRendererStreamStats;

},{"../../core/models/statistics/Statistics":131}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSpeakerStreamStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
class RemoteSpeakerStreamStats {
    constructor(coreRSStatistics = new Statistics_1.RemoteSpeakerStreamStatistics()) {
        this.bitsPerSample = coreRSStatistics.BitsPerSample;
        this.codecDtx = coreRSStatistics.CodecDtx;
        this.codecName = coreRSStatistics.CodecName;
        this.codecQualitySetting = coreRSStatistics.CodecQualitySetting;
        this.name = coreRSStatistics.Name;
        this.numberOfChannels = coreRSStatistics.NumberOfChannels;
        this.sampleRate = coreRSStatistics.SampleRate;
        this.sendNetworkBitRate = coreRSStatistics.SendNetworkBitRate;
        this.sendNetworkRtt = coreRSStatistics.SendNetworkRtt;
    }
}
exports.RemoteSpeakerStreamStats = RemoteSpeakerStreamStats;

},{"../../core/models/statistics/Statistics":131}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteVideoSourceStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class RemoteVideoSourceStats {
    constructor(coreRVSStatistics = new Statistics_1.RemoteVideoSourceStatistics()) {
        this.codecFir = coreRVSStatistics.CodecFir;
        this.codecPli = coreRVSStatistics.PlisSent;
        this.codecIFrames = coreRVSStatistics.CodecIFrames;
        this.codecLayers = coreRVSStatistics.CodecLayers;
        this.codecNacks = coreRVSStatistics.CodecNacks;
        this.codecName = coreRVSStatistics.CodecName;
        this.fpsDecoded = coreRVSStatistics.FpsDecoded;
        this.fpsDecoderInput = coreRVSStatistics.FpsDecoderInput;
        this.fpsRendered = coreRVSStatistics.FpsRendered;
        this.height = coreRVSStatistics.Height;
        this.id = coreRVSStatistics.Id;
        this.localRendererStreams = coreRVSStatistics.LocalRendererStreams
            .map((obj) => new Stats_1.LocalRendererStreamStats(obj));
        this.maxStreamFrameRate = coreRVSStatistics.MaxStreamFrameRate;
        this.maxStreamHeight = coreRVSStatistics.MaxStreamHeight;
        this.maxStreamWidth = coreRVSStatistics.MaxStreamWidth;
        this.name = coreRVSStatistics.Name;
        this.receiveNetworkBitRate = coreRVSStatistics.ReceiveNetworkBitRate;
        this.receiveNetworkPacketsConcealed = coreRVSStatistics.ReceiveNetworkPacketsConcealed;
        this.receiveNetworkPacketsLost = coreRVSStatistics.ReceiveNetworkPacketsLost;
        this.receiveNetworkPacketsReordered = coreRVSStatistics.ReceiveNetworkPacketsReordered;
        this.receiveNetworkRecoveredWithFec = coreRVSStatistics.ReceiveNetworkRecoveredWithFec;
        this.showFrameRate = coreRVSStatistics.ShowFrameRate;
        this.showHeight = coreRVSStatistics.ShowHeight;
        this.showPixelRate = coreRVSStatistics.ShowPixelRate;
        this.showState = coreRVSStatistics.ShowState;
        this.showWidth = coreRVSStatistics.ShowWidth;
        this.width = coreRVSStatistics.Width;
    }
}
exports.RemoteVideoSourceStats = RemoteVideoSourceStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
const RateShaperStats_1 = require("./RateShaperStats");
const BandwidthSummaryStats_1 = require("./BandwidthSummaryStats");
class RoomStats {
    constructor(coreRoomStatistics = new Statistics_1.RoomStatistics()) {
        this.availableDecodeCpuPercent = coreRoomStatistics.AvailableDecodeCpuPercent;
        this.availableEncodeCpuPercent = coreRoomStatistics.AvailableEncodeCpuPercent;
        this.availableDecodeBwPercent = coreRoomStatistics.AvailableDecodeBwPercent;
        this.availableEncodeBwPercent = coreRoomStatistics.AvailableEncodeBwPercent;
        this.bandwidthApp = new BandwidthSummaryStats_1.BandwidthSummaryStats(coreRoomStatistics.BandwidthApp);
        this.bandwidthAudio = new BandwidthSummaryStats_1.BandwidthSummaryStats(coreRoomStatistics.BandwidthAudio);
        this.bandwidthVideo = new BandwidthSummaryStats_1.BandwidthSummaryStats(coreRoomStatistics.BandwidthVideo);
        this.conferenceId = coreRoomStatistics.ConferenceId;
        this.cpuUsage = coreRoomStatistics.CpuUsage;
        this.callId = coreRoomStatistics.CallId;
        this.currentBandwidthDecodePixelRate = coreRoomStatistics.CurrentBandwidthDecodePixelRate;
        this.currentBandwidthEncodePixelRate = coreRoomStatistics.CurrentBandwidthEncodePixelRate;
        this.currentCpuDecodePixelRate = coreRoomStatistics.CurrentCpuDecodePixelRate;
        this.currentCpuEncodePixelRate = coreRoomStatistics.CurrentCpuEncodePixelRate;
        this.id = coreRoomStatistics.Id;
        this.maxDecodePixelRate = coreRoomStatistics.MaxDecodePixelRate;
        this.maxEncodePixelRate = coreRoomStatistics.MaxEncodePixelRate;
        this.maxVideoSources = coreRoomStatistics.MaxVideoSources;
        this.participantGenerationStats = coreRoomStatistics.ParticipantGenerationStats
            .map((obj) => new Stats_1.ParticipantGenerationStats(obj));
        this.participantStats = coreRoomStatistics.ParticipantStats
            .map((obj) => new Stats_1.ParticipantStats(obj));
        this.rateShaperApp = new RateShaperStats_1.RateShaperStats(coreRoomStatistics.RateShaperApp);
        this.rateShaperAudio = new RateShaperStats_1.RateShaperStats(coreRoomStatistics.RateShaperAudio);
        this.rateShaperVideo = new RateShaperStats_1.RateShaperStats(coreRoomStatistics.RateShaperVideo);
        this.receiveBitRateAvailable = coreRoomStatistics.ReceiveBitRateAvailable;
        this.receiveBitRateTotal = coreRoomStatistics.ReceiveBitRateTotal;
        this.reflectorId = coreRoomStatistics.ReflectorId;
        this.sendBitRateAvailable = coreRoomStatistics.SendBitRateAvailable;
        this.sendBitRateTotal = coreRoomStatistics.SendBitRateTotal;
        this.staticSources = coreRoomStatistics.StaticSources;
        this.transportInformation = coreRoomStatistics.TransportInformation
            .map((obj) => new Stats_1.MediaConnectionTransportInfo(obj));
    }
}
exports.RoomStats = RoomStats;

},{"../../core/models/statistics/Statistics":131,"./BandwidthSummaryStats":194,"./RateShaperStats":210,"./Stats":216}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatencyTestStats = exports.LatencyTestDataStats = exports.LogStats = exports.LogDataStats = exports.UserStats = exports.RoomStats = exports.RemoteVideoSourceStats = exports.RemoteSpeakerStreamStats = exports.RemoteRendererStreamStats = exports.RemoteMicrophoneStats = exports.RateShaperStats = exports.ParticipantStats = exports.ParticipantGenerationStats = exports.NetworkInterfaceStats = exports.MediaConnectionTransportInfo = exports.LocalVideoSourceStats = exports.LocalSpeakerStreamStats = exports.LocalSpeakerStats = exports.LocalRendererStreamStats = exports.LocalRendererStats = exports.LocalMicrophoneStats = exports.EndpointStats = exports.BandwidthSummaryStats = void 0;
var BandwidthSummaryStats_1 = require("./BandwidthSummaryStats");
Object.defineProperty(exports, "BandwidthSummaryStats", { enumerable: true, get: function () { return BandwidthSummaryStats_1.BandwidthSummaryStats; } });
var EndpointStats_1 = require("./EndpointStats");
Object.defineProperty(exports, "EndpointStats", { enumerable: true, get: function () { return EndpointStats_1.EndpointStats; } });
var LocalMicrophoneStats_1 = require("./LocalMicrophoneStats");
Object.defineProperty(exports, "LocalMicrophoneStats", { enumerable: true, get: function () { return LocalMicrophoneStats_1.LocalMicrophoneStats; } });
var LocalRendererStats_1 = require("./LocalRendererStats");
Object.defineProperty(exports, "LocalRendererStats", { enumerable: true, get: function () { return LocalRendererStats_1.LocalRendererStats; } });
var LocalRendererStreamStats_1 = require("./LocalRendererStreamStats");
Object.defineProperty(exports, "LocalRendererStreamStats", { enumerable: true, get: function () { return LocalRendererStreamStats_1.LocalRendererStreamStats; } });
var LocalSpeakerStats_1 = require("./LocalSpeakerStats");
Object.defineProperty(exports, "LocalSpeakerStats", { enumerable: true, get: function () { return LocalSpeakerStats_1.LocalSpeakerStats; } });
var LocalSpeakerStreamStats_1 = require("./LocalSpeakerStreamStats");
Object.defineProperty(exports, "LocalSpeakerStreamStats", { enumerable: true, get: function () { return LocalSpeakerStreamStats_1.LocalSpeakerStreamStats; } });
var LocalVideoSourceStats_1 = require("./LocalVideoSourceStats");
Object.defineProperty(exports, "LocalVideoSourceStats", { enumerable: true, get: function () { return LocalVideoSourceStats_1.LocalVideoSourceStats; } });
var MediaConnectionTransportInfo_1 = require("./MediaConnectionTransportInfo");
Object.defineProperty(exports, "MediaConnectionTransportInfo", { enumerable: true, get: function () { return MediaConnectionTransportInfo_1.MediaConnectionTransportInfo; } });
var NetworkInterfaceStats_1 = require("./NetworkInterfaceStats");
Object.defineProperty(exports, "NetworkInterfaceStats", { enumerable: true, get: function () { return NetworkInterfaceStats_1.NetworkInterfaceStats; } });
var ParticipantGenerationStats_1 = require("./ParticipantGenerationStats");
Object.defineProperty(exports, "ParticipantGenerationStats", { enumerable: true, get: function () { return ParticipantGenerationStats_1.ParticipantGenerationStats; } });
var ParticipantStats_1 = require("./ParticipantStats");
Object.defineProperty(exports, "ParticipantStats", { enumerable: true, get: function () { return ParticipantStats_1.ParticipantStats; } });
var RateShaperStats_1 = require("./RateShaperStats");
Object.defineProperty(exports, "RateShaperStats", { enumerable: true, get: function () { return RateShaperStats_1.RateShaperStats; } });
var RemoteMicrophoneStats_1 = require("./RemoteMicrophoneStats");
Object.defineProperty(exports, "RemoteMicrophoneStats", { enumerable: true, get: function () { return RemoteMicrophoneStats_1.RemoteMicrophoneStats; } });
var RemoteRendererStreamStats_1 = require("./RemoteRendererStreamStats");
Object.defineProperty(exports, "RemoteRendererStreamStats", { enumerable: true, get: function () { return RemoteRendererStreamStats_1.RemoteRendererStreamStats; } });
var RemoteSpeakerStreamStats_1 = require("./RemoteSpeakerStreamStats");
Object.defineProperty(exports, "RemoteSpeakerStreamStats", { enumerable: true, get: function () { return RemoteSpeakerStreamStats_1.RemoteSpeakerStreamStats; } });
var RemoteVideoSourceStats_1 = require("./RemoteVideoSourceStats");
Object.defineProperty(exports, "RemoteVideoSourceStats", { enumerable: true, get: function () { return RemoteVideoSourceStats_1.RemoteVideoSourceStats; } });
var RoomStats_1 = require("./RoomStats");
Object.defineProperty(exports, "RoomStats", { enumerable: true, get: function () { return RoomStats_1.RoomStats; } });
var UserStats_1 = require("./UserStats");
Object.defineProperty(exports, "UserStats", { enumerable: true, get: function () { return UserStats_1.UserStats; } });
var LogDataStats_1 = require("./LogDataStats");
Object.defineProperty(exports, "LogDataStats", { enumerable: true, get: function () { return LogDataStats_1.LogDataStats; } });
var LogStats_1 = require("./LogStats");
Object.defineProperty(exports, "LogStats", { enumerable: true, get: function () { return LogStats_1.LogStats; } });
var LatencyTestDataStats_1 = require("./LatencyTestDataStats");
Object.defineProperty(exports, "LatencyTestDataStats", { enumerable: true, get: function () { return LatencyTestDataStats_1.LatencyTestDataStats; } });
var LatencyTestStats_1 = require("./LatencyTestStats");
Object.defineProperty(exports, "LatencyTestStats", { enumerable: true, get: function () { return LatencyTestStats_1.LatencyTestStats; } });

},{"./BandwidthSummaryStats":194,"./EndpointStats":195,"./LatencyTestDataStats":196,"./LatencyTestStats":197,"./LocalMicrophoneStats":198,"./LocalRendererStats":199,"./LocalRendererStreamStats":200,"./LocalSpeakerStats":201,"./LocalSpeakerStreamStats":202,"./LocalVideoSourceStats":203,"./LogDataStats":204,"./LogStats":205,"./MediaConnectionTransportInfo":206,"./NetworkInterfaceStats":207,"./ParticipantGenerationStats":208,"./ParticipantStats":209,"./RateShaperStats":210,"./RemoteMicrophoneStats":211,"./RemoteRendererStreamStats":212,"./RemoteSpeakerStreamStats":213,"./RemoteVideoSourceStats":214,"./RoomStats":215,"./UserStats":217}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserStats = void 0;
const Statistics_1 = require("../../core/models/statistics/Statistics");
const Stats_1 = require("./Stats");
class UserStats {
    constructor(coreUserStatistics = new Statistics_1.UserStatistics()) {
        this.host = coreUserStatistics.Host;
        this.latencyTestStats = new Stats_1.LatencyTestStats(coreUserStatistics.LatencyTestStats);
        this.id = coreUserStatistics.Id;
        this.port = coreUserStatistics.Port;
        this.roomStats = coreUserStatistics.RoomStats
            .map((obj) => new Stats_1.RoomStats(obj));
        this.serviceType = coreUserStatistics.ServiceType;
    }
}
exports.UserStats = UserStats;

},{"../../core/models/statistics/Statistics":131,"./Stats":216}]},{},[174]);
